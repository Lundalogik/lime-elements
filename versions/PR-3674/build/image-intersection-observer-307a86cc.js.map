{"version":3,"names":["ImageIntersectionObserver","constructor","containerElement","this","handleIntersection","entries","entry","isIntersecting","img","target","dataSrc","dataset","src","setAttribute","observer","unobserve","IntersectionObserver","images","shadowRoot","querySelectorAll","observe","disconnect"],"sources":["./src/components/markdown/image-intersection-observer.ts"],"sourcesContent":["export class ImageIntersectionObserver {\n    private observer: IntersectionObserver;\n\n    /**\n     * @param containerElement - The element containing images to observe.\n     */\n    public constructor(containerElement: HTMLElement) {\n        this.observer = new IntersectionObserver(this.handleIntersection);\n\n        const images = containerElement.shadowRoot.querySelectorAll('img');\n\n        for (const img of images) {\n            this.observer.observe(img);\n        }\n    }\n\n    public disconnect() {\n        this.observer.disconnect();\n    }\n\n    private readonly handleIntersection = (\n        entries: IntersectionObserverEntry[]\n    ) => {\n        for (const entry of entries) {\n            if (entry.isIntersecting) {\n                const img = entry.target as HTMLImageElement;\n                const dataSrc = img.dataset.src;\n\n                if (dataSrc) {\n                    img.setAttribute('src', dataSrc);\n                    delete img.dataset.src;\n                }\n\n                this.observer.unobserve(img);\n            }\n        }\n    };\n}\n"],"mappings":"MAAaA,EAMTC,YAAmBC,GAcFC,KAAAC,mBACbC,IAEA,IAAK,MAAMC,KAASD,EAAS,CACzB,GAAIC,EAAMC,eAAgB,CACtB,MAAMC,EAAMF,EAAMG,OAClB,MAAMC,EAAUF,EAAIG,QAAQC,IAE5B,GAAIF,EAAS,CACTF,EAAIK,aAAa,MAAOH,UACjBF,EAAIG,QAAQC,G,CAGvBT,KAAKW,SAASC,UAAUP,E,IA1BhCL,KAAKW,SAAW,IAAIE,qBAAqBb,KAAKC,oBAE9C,MAAMa,EAASf,EAAiBgB,WAAWC,iBAAiB,OAE5D,IAAK,MAAMX,KAAOS,EAAQ,CACtBd,KAAKW,SAASM,QAAQZ,E,EAIvBa,aACHlB,KAAKW,SAASO,Y"}