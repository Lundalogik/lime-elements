{"version":3,"names":["SelectWithEmptyOptionExample","constructor","hostRef","this","required","optionsWithUnlabeledEmpty","text","value","optionsWithLabeledEmpty","handleChange1","event","value1","detail","handleChange2","value2","setRequired","stopPropagation","render","h","key","label","options","onChange"],"sources":["src/components/select/examples/select-with-empty-option.tsx"],"sourcesContent":["import { LimelSelectCustomEvent, Option } from '@limetech/lime-elements';\nimport { Component, h, State } from '@stencil/core';\n\n/**\n * With Empty Option\n *\n * Adding an empty option makes it possible for the user to \"unset\"\n * any chosen value.\n *\n * This example demonstrates two different approaches to empty options in select components:\n *\n * **1. Unlabeled empty option**:\n * A select with a completely empty option (both `text` and `value` are empty).\n *\n * Provides a way to clear a selection without any visible text.\n * This works well when the select's purpose is clear from context\n * and \"no selection\" feels intuitive.\n *\n * **2. Labeled empty option**:\n * A select with a labeled empty option (using a label as `text`,\n * but with an empty `value`).\n *\n * This approach uses descriptive labels like \"All\", \"None\", while still\n * having an empty `value`. When good labels are used in the right context,\n * this improves clarity for users by explicitly communicating what an empty\n * selection means in this specific context.\n *\n * Try selecting a value below, and then selecting the empty\n * option again. Notice how the select's UI resets to an empty default state,\n * if no `text` is provided to label the empty option.\n *\n * :::important\n * If the component is set as `required`, and the empty option is unlabeled,\n * it will be removed from the list.\n * This is to ensure that if users open the required dropdown,\n * and close it without selecting anything, the component can make set\n * itself to `invalid`, forcing the user to choose a choice,\n * before being able to continue.\n *\n * However, when the empty option is labeled, it will remain in the list,\n * even if the component is set as `required`. This can be confusing for users,\n * as they may not understand why the empty option is still available and selectable,\n * but once selected, the component becomes `invalid`.\n * :::\n */\n@Component({\n    shadow: true,\n    tag: 'limel-example-select-with-empty-option',\n})\nexport class SelectWithEmptyOptionExample {\n    @State()\n    public value1: Option;\n\n    @State()\n    public value2: Option;\n\n    @State()\n    public required = false;\n\n    private optionsWithUnlabeledEmpty: Option[] = [\n        { text: '', value: '' },\n        { text: 'Luke Skywalker', value: 'luke' },\n        { text: 'Han Solo', value: 'han' },\n        { text: 'Leia Organa', value: 'leia' },\n        { text: 'Obi-Wan Kenobi', value: 'obi-wan' },\n    ];\n\n    private optionsWithLabeledEmpty: Option[] = [\n        { text: 'None', value: '' },\n        { text: 'Luke Skywalker', value: 'luke' },\n        { text: 'Han Solo', value: 'han' },\n        { text: 'Leia Organa', value: 'leia' },\n        { text: 'Obi-Wan Kenobi', value: 'obi-wan' },\n    ];\n\n    public render() {\n        return (\n            <section>\n                <h4>Unlabeled Empty Option</h4>\n                <limel-select\n                    label=\"Select a character\"\n                    value={this.value1}\n                    options={this.optionsWithUnlabeledEmpty}\n                    required={this.required}\n                    onChange={this.handleChange1}\n                />\n                <limel-example-value value={this.value1} />\n\n                <h4>Labeled Empty Option</h4>\n                <limel-select\n                    label=\"Select a character\"\n                    value={this.value2}\n                    options={this.optionsWithLabeledEmpty}\n                    required={this.required}\n                    onChange={this.handleChange2}\n                />\n                <limel-example-value value={this.value2} />\n\n                <limel-example-controls>\n                    <limel-switch\n                        value={this.required}\n                        label=\"Required\"\n                        onChange={this.setRequired}\n                    />\n                </limel-example-controls>\n            </section>\n        );\n    }\n\n    private handleChange1 = (event: LimelSelectCustomEvent<Option<string>>) => {\n        this.value1 = event.detail;\n    };\n\n    private handleChange2 = (event: LimelSelectCustomEvent<Option<string>>) => {\n        this.value2 = event.detail;\n    };\n\n    private setRequired = (event: CustomEvent<boolean>) => {\n        event.stopPropagation();\n        this.required = event.detail;\n    };\n}\n"],"mappings":"qDAiDaA,EAA4B,MAJzC,WAAAC,CAAAC,G,UAYWC,KAAQC,SAAG,MAEVD,KAAAE,0BAAsC,CAC1C,CAAEC,KAAM,GAAIC,MAAO,IACnB,CAAED,KAAM,iBAAkBC,MAAO,QACjC,CAAED,KAAM,WAAYC,MAAO,OAC3B,CAAED,KAAM,cAAeC,MAAO,QAC9B,CAAED,KAAM,iBAAkBC,MAAO,YAG7BJ,KAAAK,wBAAoC,CACxC,CAAEF,KAAM,OAAQC,MAAO,IACvB,CAAED,KAAM,iBAAkBC,MAAO,QACjC,CAAED,KAAM,WAAYC,MAAO,OAC3B,CAAED,KAAM,cAAeC,MAAO,QAC9B,CAAED,KAAM,iBAAkBC,MAAO,YAqC7BJ,KAAAM,cAAiBC,IACrBP,KAAKQ,OAASD,EAAME,MAAM,EAGtBT,KAAAU,cAAiBH,IACrBP,KAAKW,OAASJ,EAAME,MAAM,EAGtBT,KAAAY,YAAeL,IACnBA,EAAMM,kBACNb,KAAKC,SAAWM,EAAME,MAAM,CAEnC,CA9CU,MAAAK,GACH,OACIC,EAAA,WAAAC,IAAA,4CACID,EAA+B,MAAAC,IAAA,sEAC/BD,EACI,gBAAAC,IAAA,2CAAAC,MAAM,qBACNb,MAAOJ,KAAKQ,OACZU,QAASlB,KAAKE,0BACdD,SAAUD,KAAKC,SACfkB,SAAUnB,KAAKM,gBAEnBS,EAAA,uBAAAC,IAAA,2CAAqBZ,MAAOJ,KAAKQ,SAEjCO,EAA6B,MAAAC,IAAA,oEAC7BD,EACI,gBAAAC,IAAA,2CAAAC,MAAM,qBACNb,MAAOJ,KAAKW,OACZO,QAASlB,KAAKK,wBACdJ,SAAUD,KAAKC,SACfkB,SAAUnB,KAAKU,gBAEnBK,EAAA,uBAAAC,IAAA,2CAAqBZ,MAAOJ,KAAKW,SAEjCI,EAAA,0BAAAC,IAAA,4CACID,EAAA,gBAAAC,IAAA,2CACIZ,MAAOJ,KAAKC,SACZgB,MAAM,WACNE,SAAUnB,KAAKY,e","ignoreList":[]}