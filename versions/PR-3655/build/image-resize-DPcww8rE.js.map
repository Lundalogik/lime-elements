{"version":3,"file":"image-resize-DPcww8rE.js","sources":["src/util/image-resize.ts"],"sourcesContent":["/**\n * Image resize utilities\n *\n * Overview\n * --------\n * This module provides a small, dependency-free utility to resize images on the client\n * (in the browser) before uploading. It works by decoding an input `File` to an\n * `ImageBitmap` (or falling back to an `HTMLImageElement`), drawing it onto a\n * `Canvas`/`OffscreenCanvas` with the requested strategy (cover/contain), and\n * then exporting the result to a new `File` with your preferred MIME type and\n * quality.\n *\n * Why resize client-side?\n * - Faster perceived uploads and lower bandwidth usage\n * - Consistent avatar sizes and formats (e.g., JPEG 400x400)\n * - No server-side transformation required for common cases\n *\n * Fit strategies\n * - `cover` (default): The image is scaled to cover the target rectangle, and\n *   the excess parts are center-cropped. Good for avatars.\n * - `contain`: The image is scaled to fit entirely within the target rectangle\n *   without cropping, letterboxing if needed. Good when you must preserve the\n *   entire image.\n *\n * Decoding & EXIF orientation\n * EXIF orientation is a piece of metadata stored inside image files\n * (usually JPEGs) that tells image renderer software how the image should be displayed\n * i.e., whether it should be rotated or flipped. This meta data is normally added\n * to photos by digital cameras and phones.\n * - When available, `createImageBitmap(file, { imageOrientation: 'from-image' })`\n *   is used to automatically respect EXIF orientation.\n * - If not available or it fails (e.g., unsupported format), we fall back to\n *   decoding via an `HTMLImageElement`.\n *\n * OffscreenCanvas\n * - If the environment supports `OffscreenCanvas`, it will be used for the draw\n *   and encode operations for better performance in some cases. Otherwise, a\n *   regular `HTMLCanvasElement` is used.\n *\n * HEIC/HEIF notes\n * - All major browsers except Safari lack native HEIC/HEIF decoding.\n *   In such cases the `resizeImage` function will throw when decoding fails.\n *   The caller should catch and fall back\n *   to using the original file or handle conversion on the server.\n * - If we need guaranteed client-side HEIC->JPEG conversion, we must add a small\n *   library or WASM module; this utility intentionally avoids extra dependencies.\n *\n * Output type & quality\n * - Default output is `image/jpeg` with `quality=0.85`, which is typically\n *   appropriate for avatars. You can switch to `image/png` to preserve\n *   transparency.\n * - The output filename extension is adjusted to match the chosen MIME type by\n *   default (e.g., `.jpg` or `.png`). You can override naming via the `rename`\n *   option.\n *\n * Error handling\n * - Throws if canvas/context cannot be created or if canvas->blob conversion fails.\n * - Decoding failures (unsupported type) will throw; caller can try/catch and\n *   fall back to the original file.\n *\n * Performance tips\n * - Keep target sizes reasonable (e.g., 256–1024 px) to avoid long processing\n *   times on modest devices.\n * - JPEG with quality 0.8–0.9 often strikes a good balance between size and\n *   perceived quality for photos/avatars.\n *\n * Usage examples\n * --------------\n * Basic usage:\n * ```ts\n * import { resizeImage } from '@limetech/lime-elements/util/image-resize';\n *\n * const processed = await resizeImage(file, {\n *   width: 400,\n *   height: 400,\n *   fit: 'cover',         // default; center-crops\n *   type: 'image/jpeg',   // default\n *   quality: 0.85,        // default\n * });\n * // Upload `processed` instead of the original file\n * ```\n *\n * With custom naming:\n * ```ts\n * const processed = await resizeImage(file, {\n *   width: 800,\n *   height: 800,\n *   fit: 'contain',\n *   type: 'image/png',\n *   rename: (name) => name.replace(/\\.[^.]+$/, '') + '_resized.png',\n * });\n * ```\n *\n * In a Stencil component (simplified):\n * ```tsx\n * private async handleFilesSelected(file: File) {\n *   try {\n *     const resized = await resizeImage(file, { width: 400, height: 400 });\n *     // build your FileInfo and emit\n *   } catch {\n *     // fall back to original\n *   }\n * }\n * ```\n */\n// (Removed exported ResizeFit to avoid forcing a public symbol.)\n\n/**\n * Options for client-side image resizing.\n * @beta\n */\nexport type ResizeOptions = {\n    /** Target width in CSS pixels. */\n    width: number;\n    /** Target height in CSS pixels. */\n    height: number;\n    /** Fit strategy; defaults to 'cover'. */\n    fit?: 'cover' | 'contain';\n    /** Output MIME type; 'image/jpeg' by default. */\n    type?: 'image/jpeg' | 'image/png';\n    /** JPEG quality (0..1); used only for 'image/jpeg'. Defaults to 0.85. */\n    quality?: number;\n    /** Optional renaming function. Defaults to changing extension to match MIME. */\n    rename?: (originalName: string) => string;\n};\n\ntype SourceLike = ImageBitmap | HTMLImageElement;\n\n/**\n * Resize an image file on the client using Canvas/OffscreenCanvas.\n * Returns a new File with the requested format and dimensions.\n *\n * Contract\n * - Input: image `File`\n * - Output: resized image as a new `File` with updated `type`, name, and size\n * - Errors: may throw on decode failure or canvas export failure\n *\n * @beta\n * @param file - The image file to resize.\n * @param options - Configuration for the resize operation.\n */\nexport async function resizeImage(\n    file: File,\n    options: ResizeOptions\n): Promise<File> {\n    const {\n        width,\n        height,\n        fit = 'cover',\n        type = 'image/jpeg',\n        quality = 0.85,\n        rename = (name: string) => renameWithType(name, type),\n    } = options;\n\n    const source = await loadSource(file);\n    const { sx, sy, sw, sh, dx, dy, dw, dh } = computeRects(\n        source.width as number,\n        source.height as number,\n        width,\n        height,\n        fit\n    );\n\n    const canvas = createCanvas(width, height);\n    const ctx = get2dContext(canvas);\n    ctx.clearRect(0, 0, width, height);\n    ctx.drawImage(source, sx, sy, sw, sh, dx, dy, dw, dh);\n\n    const blob = await canvasToBlob(canvas, type, quality);\n    const name = rename(file.name);\n    return new File([blob], name, { type });\n}\n\n/** Whether OffscreenCanvas is available in the current environment. */\nfunction supportsOffscreen(): boolean {\n    try {\n        return typeof (globalThis as any).OffscreenCanvas === 'function';\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Create either an OffscreenCanvas or a regular canvas for drawing.\n * @param width - Target width\n * @param height - Target height\n */\nfunction createCanvas(\n    width: number,\n    height: number\n): HTMLCanvasElement | OffscreenCanvas {\n    if (supportsOffscreen()) {\n        return new (globalThis as any).OffscreenCanvas(width, height);\n    }\n\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n}\n\n/**\n * Get the 2D rendering context, throwing a descriptive error if unavailable.\n * @param canvas - The canvas to get context from\n */\nfunction get2dContext(canvas: HTMLCanvasElement | OffscreenCanvas) {\n    const ctx = (canvas as any).getContext('2d', { alpha: true });\n    if (!ctx) {\n        throw new Error('2D canvas context not available');\n    }\n\n    return ctx as CanvasRenderingContext2D;\n}\n\n/**\n * Convert the canvas content to a Blob, supporting both canvas types.\n * @param canvas - The source canvas\n * @param type - Output MIME type\n * @param quality - JPEG quality (0..1)\n */\nfunction canvasToBlob(\n    canvas: HTMLCanvasElement | OffscreenCanvas,\n    type: string,\n    quality: number\n): Promise<Blob> {\n    if ('convertToBlob' in canvas) {\n        return (canvas as OffscreenCanvas).convertToBlob({ type, quality });\n    }\n\n    return new Promise((resolve, reject) => {\n        (canvas as HTMLCanvasElement).toBlob(\n            (blob) => {\n                if (!blob) {\n                    reject(new Error('Failed to create blob from canvas'));\n                    return;\n                }\n                resolve(blob);\n            },\n            type,\n            quality\n        );\n    });\n}\n\n/**\n * Load the image into a decodable source (ImageBitmap preferred).\n * @param file - The input file to decode\n */\n\nasync function loadSource(file: File): Promise<SourceLike> {\n    if (typeof (globalThis as any).createImageBitmap === 'function') {\n        try {\n            return await (globalThis as any).createImageBitmap(file, {\n                imageOrientation: 'from-image',\n            } as any);\n        } catch (error) {\n            // Log for debugging in development, but continue with fallback\n            const isDev =\n                (globalThis as any).process?.env?.NODE_ENV !== 'production';\n\n            if (\n                isDev &&\n                typeof console !== 'undefined' &&\n                typeof console.debug === 'function'\n            ) {\n                console.debug(\n                    'createImageBitmap failed, falling back to HTMLImageElement:',\n                    error\n                );\n            }\n        }\n    }\n\n    return await loadImageElement(file);\n}\n\n/**\n * Decode an image file via HTMLImageElement when ImageBitmap is unavailable.\n * @param file - The input file to decode\n */\nasync function loadImageElement(file: File): Promise<HTMLImageElement> {\n    const url = URL.createObjectURL(file);\n    try {\n        const img = new Image();\n        img.decoding = 'sync';\n        img.src = url;\n        await img.decode?.().catch(() => undefined);\n        if (!img.complete) {\n            await new Promise<void>((resolve, reject) => {\n                const cleanup = () => {\n                    img.removeEventListener('load', onLoad);\n                    img.removeEventListener('error', onError);\n                };\n\n                const onLoad = () => {\n                    cleanup();\n                    resolve();\n                };\n                const onError = (e: Event) => {\n                    cleanup();\n                    reject(e);\n                };\n\n                img.addEventListener('load', onLoad);\n                img.addEventListener('error', onError);\n            });\n        }\n        return img;\n    } finally {\n        URL.revokeObjectURL(url);\n    }\n}\n\n/**\n * Compute source and destination rectangles for drawImage based on the fit mode.\n *\n * Returns sx, sy, sw, sh for the source crop/area and dx, dy, dw, dh for the\n * destination rectangle on the target canvas.\n *\n * @param sw - Source width\n * @param sh - Source height\n * @param tw - Target width\n * @param th - Target height\n * @param fit - Fit mode (cover/contain)\n */\nfunction computeRects(\n    sw: number,\n    sh: number,\n    tw: number,\n    th: number,\n    fit: 'cover' | 'contain'\n) {\n    const sRatio = sw / sh;\n    const tRatio = tw / th;\n\n    if (fit === 'cover') {\n        // scale source to cover target, then center-crop\n        let cropW: number;\n        let cropH: number;\n        if (sRatio > tRatio) {\n            // source is wider than target: crop width\n            cropH = sh;\n            cropW = sh * tRatio;\n        } else {\n            // source is taller than target: crop height\n            cropW = sw;\n            cropH = sw / tRatio;\n        }\n        const sx = (sw - cropW) / 2;\n        const sy = (sh - cropH) / 2;\n        return { sx, sy, sw: cropW, sh: cropH, dx: 0, dy: 0, dw: tw, dh: th };\n    }\n\n    // contain: fit inside, letterbox if needed\n    let drawW: number;\n    let drawH: number;\n    if (sRatio > tRatio) {\n        drawW = tw;\n        drawH = tw / sRatio;\n    } else {\n        drawH = th;\n        drawW = th * sRatio;\n    }\n    const dx = (tw - drawW) / 2;\n    const dy = (th - drawH) / 2;\n\n    return { sx: 0, sy: 0, sw, sh, dx, dy, dw: drawW, dh: drawH };\n}\n\n/**\n * Update filename extension to match the desired MIME type.\n * @param name - Original filename\n * @param type - Output MIME type\n */\nfunction renameWithType(name: string, type: string): string {\n    const ext = type === 'image/png' ? 'png' : 'jpg';\n    const idx = name.lastIndexOf('.');\n    const base = idx > 0 ? name.slice(0, idx) : name;\n    return `${base}.${ext}`;\n}\n"],"names":[],"mappings":"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"}