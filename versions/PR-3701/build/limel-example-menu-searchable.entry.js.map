{"version":3,"names":["SearchMenuItems","searchValue","menuItems","toLowerCase","flattenedItems","flattenMenuItems","results","filter","i","_a","text","includes","map","item","secondaryText","ancestors","getAncestorChain","length","visibleAncestors","slice","Object","assign","join","parent","flatten","menuItem","parentItem","cloned","push","Array","isArray","items","subItem","chain","current","unshift","CascadingMenuItems","icon","name","color","separator","MenuSubItemsExample","this","from","_value","index","handleSearch","async","queryString","handleSelect","event","lastSelectedItem","detail","render","h","searcher","onSelect","emptyResultMessage","title","slot","label","value","_b"],"sources":["./src/components/menu/examples/subitems-search.ts","./src/components/menu/examples/nested-item-constants.ts","./src/components/menu/examples/menu-searchable.tsx"],"sourcesContent":["import { MenuItem, ListSeparator } from '@limetech/lime-elements';\n\n/**\n * Client-side helper used as a `searcher` for `<limel-menu>`.\n *\n * WHAT IT DOES\n * - Performs a case-insensitive substring match against the `text` property of\n *   every (non-separator) menu item in the whole tree.\n * - Flattens the tree so that deep descendants can surface in the search\n *   result list.\n * - Adds hierarchical context for each match by *generating* a `secondaryText`\n *   showing up to the two closest ancestors (truncated with an ellipsis if the\n *   depth is greater):\n *     depth 1: (no secondaryText)\n *     depth 2: `Parent`\n *     depth 3: `Grandparent › Parent`\n *     depth ≥4: `… › ParentLevel2 › Parent`\n * - Never overwrites an existing `secondaryText` defined on an item.\n * - Avoids mutating your original item objects: it creates shallow clones and\n *   attaches an internal `parentItem` reference only to those clones.\n *\n * WHEN TO USE\n * Use this helper if your menu data is already available client-side, and you\n * want a simple, fast search without hitting a server. For remote or paged\n * searches you should implement your own function that returns a Promise of\n * items (still adhering to the same `MenuSearcher` signature).\n *\n * LIMITATIONS / DESIGN CHOICES\n * - Only the `text` field is searched (not `secondaryText`, `commandText`, or\n *   other metadata). Extend the filter logic if you need more fields.\n * - Returned items are *flat*; selecting one acts exactly like selecting a\n *   normal item (no automatic reconstruction of its parent path).\n * - Uses a Unicode ellipsis `…` and a breadcrumb separator `›` for compactness;\n *   change these if your design language differs.\n * - Relies on the internal `parentItem` property (`MenuItem.parentItem`) for\n *   temporary chaining. That property is documented as internal; here it is\n *   only added to the cloned objects this function returns.\n *\n * PERFORMANCE NOTES\n * For very large trees you may want to:\n *  - Debounce calls (the `limel-menu` will call the searcher on each keypress).\n *  - Precompute a cached flattened array shared across invocations.\n *  - Switch to a more advanced search algorithm (e.g., Fuse.js) if fuzzy\n *    matching is required.\n *\n * CUSTOMIZING THE CONTEXT PATH\n * If you prefer another format (e.g., `Parent: Office`, or full root path),\n * adjust the section that builds `visibleAncestors` below. You can also expose\n * a configuration argument if you wrap this helper.\n *\n * EXAMPLE USAGE\n * ```tsx\n * <limel-menu\n *   items={items}\n *   searcher={(query) => Promise.resolve(SearchMenuItems(query, items))}\n * />\n * ```\n *\n * @param searchValue - The raw query string from the `limel-menu` search field.\n * @param menuItems   - The root menu items (can include nested `items`).\n * @returns An array of matching `MenuItem`s enriched with contextual\n *          `secondaryText` where appropriate.\n */\nexport function SearchMenuItems(\n    searchValue: string,\n    menuItems: Array<MenuItem | ListSeparator>\n): MenuItem[] {\n    if (!searchValue) {\n        return [];\n    }\n\n    searchValue = searchValue?.toLowerCase();\n    const flattenedItems = flattenMenuItems(menuItems);\n\n    const results = flattenedItems.filter(\n        (i) =>\n            !('separator' in i) && i.text?.toLowerCase().includes(searchValue)\n    );\n\n    return results.map((item) => {\n        // Respect any pre-defined secondaryText\n        if (item.secondaryText) {\n            return item;\n        }\n\n        const ancestors = getAncestorChain(item); // root ... immediate parent (excluding the item itself)\n        if (ancestors.length === 0) {\n            return item;\n        }\n\n        let visibleAncestors: string[];\n        if (ancestors.length <= 2) {\n            visibleAncestors = ancestors;\n        } else {\n            // Truncate: show only the last two ancestors with leading ellipsis\n            visibleAncestors = ['…', ...ancestors.slice(-2)];\n        }\n\n        return {\n            ...item,\n            secondaryText: visibleAncestors.join(' › '),\n        } as MenuItem;\n    });\n}\n\nfunction flattenMenuItems(\n    menuItems: Array<MenuItem | ListSeparator>,\n    parent?: MenuItem\n): MenuItem[] {\n    const flattenedItems: MenuItem[] = [];\n\n    function flatten(menuItem: MenuItem, parentItem?: MenuItem) {\n        const cloned: MenuItem = { ...menuItem };\n        if (parentItem) {\n            cloned.parentItem = parentItem;\n        }\n        flattenedItems.push(cloned);\n\n        if (Array.isArray(menuItem.items)) {\n            for (const subItem of menuItem.items) {\n                if (!('separator' in subItem)) {\n                    flatten(subItem as MenuItem, cloned);\n                }\n            }\n        }\n    }\n\n    for (const menuItem of menuItems) {\n        if (!('separator' in menuItem)) {\n            flatten(menuItem as MenuItem, parent);\n        }\n    }\n\n    return flattenedItems;\n}\n\nfunction getAncestorChain(item: MenuItem): string[] {\n    const chain: string[] = [];\n    let current = item.parentItem;\n    while (current) {\n        if (current.text) {\n            chain.unshift(current.text);\n        }\n        current = current.parentItem;\n    }\n    return chain;\n}\n","import { MenuItem } from '@limetech/lime-elements';\n\nexport const CascadingMenuItems: MenuItem[] = [\n    {\n        text: 'Responsible',\n        icon: {\n            name: 'user',\n            color: 'rgb(var(--color-orange-light))',\n        },\n        items: [\n            {\n                text: 'Name',\n            },\n            {\n                text: 'Email',\n            },\n            {\n                text: 'Phone',\n            },\n            {\n                separator: true,\n                text: 'Relations',\n            },\n            {\n                text: 'Office',\n                icon: {\n                    name: 'exterior',\n                    color: 'rgb(var(--color-green-light))',\n                },\n                items: [\n                    {\n                        text: 'Name',\n                    },\n                    {\n                        text: 'Phone',\n                    },\n                    {\n                        text: 'Fax',\n                    },\n                    {\n                        text: 'Address',\n                    },\n                    {\n                        text: 'City',\n                    },\n                    {\n                        text: 'Homepage',\n                    },\n                    {\n                        separator: true,\n                        text: 'Relations',\n                    },\n                    {\n                        text: 'Manager',\n                        icon: {\n                            name: 'manager',\n                            color: 'rgb(var(--color-purple-darker))',\n                        },\n                        items: [\n                            {\n                                text: 'Name',\n                            },\n                            {\n                                text: 'Email',\n                            },\n                            {\n                                text: 'Phone',\n                            },\n                        ],\n                    },\n                ],\n            },\n        ],\n    },\n    {\n        text: 'Deal',\n        icon: {\n            name: 'money',\n            color: 'rgb(var(--color-green-default))',\n        },\n        items: [\n            {\n                text: 'Name',\n            },\n            {\n                text: 'Value',\n            },\n            {\n                text: 'Weighted value',\n            },\n            {\n                text: 'Department',\n            },\n            {\n                text: 'Probability',\n            },\n            {\n                text: 'Won/Lost reason',\n            },\n            {\n                text: 'Quote sent',\n            },\n            {\n                text: 'Expected order',\n            },\n        ],\n    },\n    {\n        text: 'Document',\n        icon: {\n            name: 'document',\n            color: 'rgb(var(--color-gray-default))',\n        },\n        items: [\n            {\n                text: 'Name',\n            },\n            {\n                text: 'Type',\n            },\n        ],\n    },\n];\n","import {\n    MenuItem,\n    ListSeparator,\n    LimelMenuCustomEvent,\n} from '@limetech/lime-elements';\nimport { Component, State, h } from '@stencil/core';\nimport { SearchMenuItems } from './subitems-search';\nimport { CascadingMenuItems } from './nested-item-constants';\n\n/**\n * Searchable items\n *\n * Unlike some other components like `limel-picker` or `limel-select` that\n * have internal fallback search (filtering) logic, this component has no built-in\n * “default local filter”.\n *\n * This example showcases a purely consumer-side pattern, demonstrating how to\n * implement and attach a searcher to the component.\n *\n * ### What the searcher must return\n * - An array of `MenuItem` | `ListSeparator`.\n * - These items are rendered flat (no automatic parent–child reconstruction).\n *\n * :::tip\n * It is great to show the end user the hierarchical breadcrumbs for search results.\n * A keyword might be found in several sub-menus, and that can make it confusing\n * for the user to see the exact same keyword listed several times in the search results.\n * Therefore—as we did in this example—by populating `secondaryText` or other fields,\n * you can visualize the context of the found item.\n *\n * To give it a try, test searching for \"Phone\", in this example.\n *\n * **How the searcher works:**\n * See `subitems-search.ts`\n * - For each search match (in `SearchMenuItems`), we build an ancestor chain\n * using the internally cloned `parentItem` links.\n * - We generate `secondaryText` only if the item didn’t already define one.\n * - Formatting rules:\n *   - 0 ancestors: no `secondaryText`.\n *   - 1 ancestor: `Parent`\n *   - 2 ancestors: `Grandparent` › `Parent`\n *   - 3+ ancestors: … › `SecondToLast` › `Parent`\n * - We have used a › character to be consistent with `limel-breadcrumb`'s default design.\n * - For the ellipsis, we have used the typographic … (single character) to\n *  indicate truncation.\n * :::\n *\n * @sourceFile nested-item-constants.ts\n * @sourceFile subitems-search.ts\n */\n@Component({\n    tag: 'limel-example-menu-searchable',\n    shadow: true,\n})\nexport class MenuSubItemsExample {\n    private items: Array<MenuItem | ListSeparator> = [\n        {\n            text: 'Company name',\n            icon: {\n                name: '-lime-filter',\n                color: 'rgb(var(--contrast-800))',\n            },\n        },\n        {\n            text: 'Buying status',\n            icon: {\n                name: '-lime-filter',\n                color: 'rgb(var(--contrast-800))',\n            },\n        },\n        {\n            text: 'Telephone',\n            icon: {\n                name: '-lime-filter',\n                color: 'rgb(var(--contrast-800))',\n            },\n        },\n        {\n            text: 'Classification',\n            icon: {\n                name: '-lime-filter',\n                color: 'rgb(var(--contrast-800))',\n            },\n        },\n        {\n            text: 'Responsible',\n            icon: {\n                name: '-lime-filter',\n                color: 'rgb(var(--contrast-800))',\n            },\n        },\n        {\n            text: 'Classification',\n            icon: {\n                name: '-lime-filter',\n                color: 'rgb(var(--contrast-800))',\n            },\n        },\n        {\n            text: 'City',\n            icon: {\n                name: '-lime-filter',\n                color: 'rgb(var(--contrast-800))',\n            },\n        },\n        {\n            separator: true,\n            text: 'Relations',\n        },\n        ...CascadingMenuItems,\n        {\n            text: 'Long sub list',\n            icon: 'ellipsis',\n            items: Array.from(Array.from({ length: 50 }), (_value, index) => {\n                return {\n                    text: `Item ${index + 1}`,\n                };\n            }),\n        },\n    ];\n\n    @State()\n    private lastSelectedItem: MenuItem;\n\n    public render() {\n        return [\n            <limel-menu\n                items={this.items}\n                searcher={this.handleSearch}\n                onSelect={this.handleSelect}\n                emptyResultMessage=\"No items found\"\n            >\n                <limel-chip\n                    text=\"Filter\"\n                    icon={{\n                        name: 'plus_math',\n                        color: 'rgb(var(--contrast-800))',\n                        title: 'Add',\n                    }}\n                    slot=\"trigger\"\n                />\n            </limel-menu>,\n            <limel-example-value\n                label=\"Last selected item\"\n                value={this.lastSelectedItem?.text ?? ''}\n            />,\n        ];\n    }\n\n    private handleSearch = async (queryString: string) => {\n        return SearchMenuItems(queryString, this.items);\n    };\n\n    private handleSelect = (event: LimelMenuCustomEvent<MenuItem>) => {\n        this.lastSelectedItem = event.detail;\n    };\n}\n"],"mappings":"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"}