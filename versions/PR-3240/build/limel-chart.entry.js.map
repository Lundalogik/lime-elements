{"version":3,"names":["chartCss","PERCENT","DEFAULT_AXIS_INCREMENT","Chart","this","cachedRange","componentWillLoad","recalculateRangeData","render","h","style","items","length","toString","renderCaption","renderTableHeader","renderAxises","class","renderItems","accessibleLabel","scope","accessibleItemsLabel","translate","get","language","includes","type","minRange","maxRange","rangeData","lines","adjustedMinRange","Math","floor","axisIncrement","adjustedMaxRange","ceil","value","push","role","totalRange","cumulativeOffset","map","item","index","itemId","createRandomString","size","offset","calculateSizeAndOffset","nextItemSize","getNextItemSize","nextItemOffset","getNextItemOffset","getItemStyle","getItemClass","key","id","tabIndex","getItemText","getFormattedValue","renderTooltip","startValue","prefix","suffix","nextItem","nextNormalizedEnd","nextNormalizedStart","_a","color","undefined","normalizedStart","normalizedEnd","noStartValue","withStartValue","text","PERCENT_DECIMAL","formattedValue","tooltipProps","label","helperLabel","elementId","toFixed","Object","assign","openDirection","orientation","calculateRange","min","concat","max","totalSum","reduce","sum","finalMaxRange","maxValue","visualMaxRange","visualMinRange","handleChange"],"sources":["./src/components/chart/chart.scss?tag=limel-chart&encapsulation=shadow","./src/components/chart/chart.tsx"],"sourcesContent":["@use '../../style/mixins';\n$min-item-size: 0.5rem;\n\n/**\n* @prop --chart-background-color: Defines the background color of the chart. Defaults to `transparent` for _most_ chart types.\n* @prop --chart-axis-line-color: Defines color of the axis lines. Defaults to `--contrast-900`. Note that lines have opacity as well, and get opaque on hover.\n* @prop --chart-item-border-radius: Defines the roundness of corners of items in a chart. Defaults to different values depending on the chart type. Does not have any effect on `pie` and `doughnut` types.\n* @prop --chart-stacked-item-divider-color: Defines the color that visually separates stacked chart items, for example for a `stacked-bar` chart. Defaults to `rgb(var(--color-white), 0.6)`.\n*/\n\n:host(limel-chart) {\n    --chart-axis-line-color: var(\n        --limel-chart-axis-line-color,\n        rgb(var(--contrast-900))\n    );\n    box-sizing: border-box;\n    isolation: isolate;\n\n    display: flex;\n    width: 100%;\n    height: 100%;\n    min-width: 0;\n    min-height: 0;\n    padding: var(--limel-chart-padding);\n}\n\ntable {\n    // Since these are mainly \"resets\", no styles should be before them.\n    all: unset;\n    border-collapse: collapse;\n    border-spacing: 0;\n    empty-cells: show;\n\n    position: relative;\n    display: flex;\n    width: 100%;\n    height: 100%;\n    min-width: 0;\n    min-height: 0;\n\n    colgroup,\n    thead,\n    tbody,\n    tr,\n    th,\n    td {\n        all: unset;\n    }\n\n    caption,\n    colgroup,\n    thead,\n    tfoot,\n    th,\n    td {\n        @include mixins.visually-hidden;\n    }\n}\n\n*,\n*:before,\n*:after {\n    box-sizing: border-box;\n}\n\n.chart {\n    position: relative;\n    flex-grow: 1;\n    width: 100%;\n    height: 100%;\n    min-height: 0;\n    min-width: 0;\n\n    &:has(.item:hover),\n    &:has(.item:focus-visible) {\n        .item {\n            opacity: 0.4;\n        }\n    }\n}\n\n.item {\n    transition:\n        background-color 0.2s ease,\n        filter 0.2s ease,\n        opacity 0.4s ease;\n    cursor: help;\n\n    &:focus-visible,\n    &:hover {\n        opacity: 1 !important;\n    }\n}\n\n@mixin line(\n    $direction: vertical,\n    $color: rgb(var(--contrast-800), 0.4),\n    $position: center\n) {\n    @if $direction == vertical {\n        background: linear-gradient(to bottom, $color 0%, $color 100%)\n            $position/1px\n            100%\n            no-repeat;\n    } @else if $direction == horizontal {\n        background: linear-gradient(to right, $color 0%, $color 100%)\n            $position/100%\n            1px\n            no-repeat;\n    }\n}\n\n@import './partial-styles/_layout-for-charts-with-x-y-axises';\n@import './partial-styles/_layout-for-charts-with-circular-shape';\n@import './partial-styles/_bar-gantt-scatter';\n@import './partial-styles/_area_line';\n@import './partial-styles/_pie-doughnut';\n@import './partial-styles/_ring';\n@import './partial-styles/_stacked-bar';\n@import './partial-styles/_axises';\n","import { Component, h, Prop, Watch } from '@stencil/core';\nimport { Languages } from '../date-picker/date.types';\nimport translate from '../../global/translations';\nimport { createRandomString } from '../../util/random-string';\nimport { ChartItem } from './chart.types';\n\nconst PERCENT = 100;\nconst DEFAULT_AXIS_INCREMENT = 10;\n\n/**\n * A chart is a graphical representation of data, in which\n * visual symbols such as such bars, dots, lines, or slices, represent\n * each data point, in comparison to others.\n *\n * @exampleComponent limel-example-chart-stacked-bar\n * @exampleComponent limel-example-chart-orientation\n * @exampleComponent limel-example-chart-max-value\n * @exampleComponent limel-example-chart-type-bar\n * @exampleComponent limel-example-chart-type-scatter\n * @exampleComponent limel-example-chart-type-area\n * @exampleComponent limel-example-chart-type-line\n * @exampleComponent limel-example-chart-type-pie\n * @exampleComponent limel-example-chart-type-doughnut\n * @exampleComponent limel-example-chart-type-ring\n * @exampleComponent limel-example-chart-type-gantt\n * @exampleComponent limel-example-chart-multi-axis\n * @exampleComponent limel-example-chart-multi-axis-with-negative-start-values\n * @exampleComponent limel-example-chart-multi-axis-area-with-negative-start-values\n * @exampleComponent limel-example-chart-axis-increment\n * @exampleComponent limel-example-chart-accessibility\n * @exampleComponent limel-example-chart-styling\n * @exampleComponent limel-example-chart-creative-styling\n * @Beta\n */\n\n@Component({\n    tag: 'limel-chart',\n    shadow: true,\n    styleUrl: 'chart.scss',\n})\nexport class Chart {\n    /**\n     * Defines the language for translations.\n     * Will translate the translatable strings on the components.\n     */\n    @Prop({ reflect: true })\n    public language: Languages = 'en';\n\n    /**\n     * Helps users of assistive technologies to understand\n     * the context of the chart, and what is being displayed.\n     */\n    @Prop({ reflect: true })\n    public accessibleLabel?: string;\n\n    /**\n     * Helps users of assistive technologies to understand\n     * what the items in the chart represent.\n     */\n    @Prop({ reflect: true })\n    public accessibleItemsLabel?: string;\n\n    /**\n     * List of items in the chart,\n     * each representing a data point.\n     */\n    @Prop()\n    public items!: ChartItem[];\n\n    /**\n     * Defines how items are visualized in the chart.\n     */\n    @Prop({ reflect: true })\n    public type?:\n        | 'area'\n        | 'bar'\n        | 'doughnut'\n        | 'line'\n        | 'pie'\n        | 'ring'\n        | 'scatter'\n        | 'stacked-bar' = 'stacked-bar';\n\n    /**\n     * Defines whether the chart is intended to be displayed wide or tall.\n     * Does not have any effect on chart types which generate circular forms.\n     */\n    @Prop({ reflect: true })\n    public orientation?: 'landscape' | 'portrait' = 'landscape';\n\n    /**\n     * Specifies the range that items' values could be in.\n     * This is used in calculation of the size of the items in the chart.\n     * When not provided, the sum of all values in the items will be considered as the range.\n     */\n    @Prop({ reflect: true })\n    public maxValue?: number;\n\n    /**\n     * Specifies the increment for the axis lines.\n     */\n    @Prop({ reflect: true })\n    public axisIncrement?: number = DEFAULT_AXIS_INCREMENT;\n\n    private rangeData: {\n        minRange: number;\n        maxRange: number;\n        totalRange: number;\n    };\n\n    private cachedRange: {\n        minRange: number;\n        maxRange: number;\n        totalRange: number;\n    } | null = null;\n\n    public componentWillLoad() {\n        this.recalculateRangeData();\n    }\n\n    public render() {\n        return (\n            <table\n                style={{\n                    '--limel-chart-number-of-items':\n                        this.items.length.toString(),\n                }}\n            >\n                {this.renderCaption()}\n                {this.renderTableHeader()}\n                {this.renderAxises()}\n                <tbody class=\"chart\">{this.renderItems()}</tbody>\n            </table>\n        );\n    }\n\n    private renderCaption() {\n        if (!this.accessibleLabel) {\n            return;\n        }\n\n        return <caption>{this.accessibleLabel}</caption>;\n    }\n\n    private renderTableHeader() {\n        return (\n            <thead>\n                <tr>\n                    <th scope=\"col\">{this.accessibleItemsLabel}</th>\n                    <th scope=\"col\">{translate.get('value', this.language)}</th>\n                </tr>\n            </thead>\n        );\n    }\n\n    private renderAxises() {\n        if (!['bar', 'scatter', 'area', 'line'].includes(this.type)) {\n            return;\n        }\n\n        const { minRange, maxRange } = this.rangeData;\n\n        const lines = [];\n\n        const adjustedMinRange =\n            Math.floor(minRange / this.axisIncrement) * this.axisIncrement;\n        const adjustedMaxRange =\n            Math.ceil(maxRange / this.axisIncrement) * this.axisIncrement;\n\n        for (\n            let value = adjustedMinRange;\n            value <= adjustedMaxRange;\n            value += this.axisIncrement\n        ) {\n            lines.push(\n                <div\n                    class={{\n                        'axis-line': true,\n                        'zero-line': value === 0,\n                    }}\n                    role=\"presentation\"\n                >\n                    <span>{value}</span>\n                </div>,\n            );\n        }\n\n        return (\n            <div class=\"axises\" role=\"presentation\">\n                {lines}\n            </div>\n        );\n    }\n\n    private renderItems() {\n        if (!this.items || this.items.length === 0) {\n            return;\n        }\n\n        const { minRange, totalRange } = this.rangeData;\n\n        let cumulativeOffset = 0;\n\n        return this.items.map((item, index) => {\n            const itemId = createRandomString();\n            const { size, offset } = this.calculateSizeAndOffset(\n                item,\n                cumulativeOffset,\n            );\n\n            if (this.type === 'pie' || this.type === 'doughnut') {\n                cumulativeOffset += size;\n            }\n\n            const nextItemSize = this.getNextItemSize(\n                index,\n                minRange,\n                totalRange,\n            );\n            const nextItemOffset = this.getNextItemOffset(\n                index,\n                cumulativeOffset,\n            );\n\n            return (\n                <tr\n                    style={this.getItemStyle(\n                        item,\n                        index,\n                        size,\n                        offset,\n                        nextItemSize,\n                        nextItemOffset,\n                    )}\n                    class={this.getItemClass(item)}\n                    key={itemId}\n                    id={itemId}\n                    tabIndex={0}\n                >\n                    <th>{this.getItemText(item)}</th>\n                    <td>{this.getFormattedValue(item)}</td>\n                    {this.renderTooltip(\n                        itemId,\n                        this.getItemText(item),\n                        item.value,\n                        size,\n                        item.startValue,\n                        item.prefix,\n                        item.suffix,\n                    )}\n                </tr>\n            );\n        });\n    }\n\n    private getNextItemSize(\n        index: number,\n        minRange: number,\n        totalRange: number,\n    ): number {\n        const nextItem = this.items[index + 1];\n        if (!nextItem) {\n            return 0;\n        }\n\n        const nextNormalizedEnd =\n            ((nextItem.value - minRange) / totalRange) * PERCENT;\n        const nextNormalizedStart =\n            (((nextItem.startValue ?? 0) - minRange) / totalRange) * PERCENT;\n\n        return nextNormalizedEnd - nextNormalizedStart;\n    }\n\n    private getNextItemOffset(index: number, cumulativeOffset: number): number {\n        const nextItem = this.items[index + 1];\n        if (!nextItem) {\n            return 0;\n        }\n\n        if (this.type === 'pie' || this.type === 'doughnut') {\n            return cumulativeOffset;\n        }\n\n        const { minRange, totalRange } = this.rangeData;\n\n        const nextNormalizedStart =\n            (((nextItem.startValue ?? 0) - minRange) / totalRange) * PERCENT;\n\n        return nextNormalizedStart;\n    }\n\n    private getItemStyle(\n        item: ChartItem,\n        index: number,\n        size: number,\n        offset: number,\n        nextItemSize: number,\n        nextItemOffset: number,\n    ) {\n        const style: { [key: string]: string } = {\n            '--limel-chart-item-color': item.color,\n            '--limel-chart-item-offset': `${offset}`,\n            '--limel-chart-item-size': `${size}`,\n            '--limel-chart-item-index': `${index}`,\n        };\n\n        if (this.type === 'line' || this.type === 'area') {\n            style['--limel-chart-next-item-size'] = `${nextItemSize}`;\n            style['--limel-chart-next-item-offset'] = `${nextItemOffset}`;\n        }\n\n        return style;\n    }\n\n    private getItemClass(item: ChartItem) {\n        return {\n            item: true,\n            'has-start-value': item.startValue !== undefined,\n            'has-negative-value-only': item.value < 0 && !item.startValue,\n        };\n    }\n\n    private calculateSizeAndOffset(item: ChartItem, cumulativeOffset: number) {\n        const { minRange, totalRange } = this.rangeData;\n\n        const normalizedStart =\n            (((item.startValue ?? 0) - minRange) / totalRange) * PERCENT;\n        const normalizedEnd = ((item.value - minRange) / totalRange) * PERCENT;\n        const size = normalizedEnd - normalizedStart;\n\n        let offset = normalizedStart;\n        if (this.type === 'pie' || this.type === 'doughnut') {\n            offset = cumulativeOffset;\n        }\n\n        return { size: size, offset: offset };\n    }\n\n    private getFormattedValue({\n        value,\n        startValue,\n        prefix = '',\n        suffix = '',\n    }: {\n        value: number;\n        startValue?: number;\n        prefix?: string;\n        suffix?: string;\n    }): string {\n        const noStartValue = `${prefix}${value}${suffix}`;\n        const withStartValue = `${prefix}${startValue}${suffix} — ${prefix}${value}${suffix}`;\n\n        return startValue !== undefined ? withStartValue : noStartValue;\n    }\n\n    private getItemText(item: ChartItem): string {\n        return item.text;\n    }\n\n    private renderTooltip(\n        itemId: string,\n        text: string,\n        value: number,\n        size: number,\n        startValue?: number,\n        prefix: string = '',\n        suffix: string = '',\n    ) {\n        const PERCENT_DECIMAL = 2;\n        const formattedValue = this.getFormattedValue({\n            value: value,\n            startValue: startValue,\n            prefix: prefix,\n            suffix: suffix,\n        });\n\n        const tooltipProps: any = {\n            label: text,\n            helperLabel: formattedValue,\n            elementId: itemId,\n        };\n\n        if (this.type !== 'bar' && this.type !== 'scatter') {\n            tooltipProps.label = `${text} (${size.toFixed(PERCENT_DECIMAL)}%)`;\n        }\n\n        return (\n            <limel-tooltip\n                {...tooltipProps}\n                openDirection={\n                    this.orientation === 'portrait' ? 'right' : 'top'\n                }\n            />\n        );\n    }\n\n    private calculateRange() {\n        if (this.cachedRange) {\n            return this.cachedRange;\n        }\n\n        const minRange = Math.min(\n            ...[].concat(\n                ...this.items.map((item) => [item.startValue ?? 0, item.value]),\n            ),\n        );\n        const maxRange = Math.max(\n            ...[].concat(\n                ...this.items.map((item) => [item.startValue ?? 0, item.value]),\n            ),\n        );\n\n        const totalSum = this.items.reduce((sum, item) => sum + item.value, 0);\n\n        let finalMaxRange = this.maxValue ?? maxRange;\n        if (\n            (this.type === 'pie' || this.type === 'doughnut') &&\n            !this.maxValue\n        ) {\n            finalMaxRange = totalSum;\n        }\n\n        const visualMaxRange =\n            Math.ceil(finalMaxRange / this.axisIncrement) * this.axisIncrement;\n        const visualMinRange =\n            Math.floor(minRange / this.axisIncrement) * this.axisIncrement;\n\n        const totalRange = visualMaxRange - visualMinRange;\n\n        this.cachedRange = {\n            minRange: visualMinRange,\n            maxRange: visualMaxRange,\n            totalRange: totalRange,\n        };\n\n        return this.cachedRange;\n    }\n\n    @Watch('items')\n    @Watch('axisIncrement')\n    @Watch('maxValue')\n    handleChange() {\n        this.cachedRange = null;\n        this.recalculateRangeData();\n    }\n\n    private recalculateRangeData() {\n        this.rangeData = this.calculateRange();\n    }\n}\n"],"mappings":"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"}