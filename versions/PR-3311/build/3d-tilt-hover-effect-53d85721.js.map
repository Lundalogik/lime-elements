{"version":3,"names":["MOUSE_SCALE_FACTOR","SCALING_BASE","ROTATION_DEGREE_MULTIPLIER","GLOW_POSITION_MULTIPLIER","CENTER_DIVISOR","tiltFollowingTheCursor","e","the3dElementBounds","element","mouseX","clientX","mouseY","clientY","leftX","x","topY","y","center","width","height","distance","Math","sqrt","scalingFactor","min","rotate3d","log","style","setProperty","glowPosition","handleMouseEnter","selector","setBounds","tiltCallback","the3dElement","shadowRoot","querySelector","bounds","getBoundingClientRect","document","addEventListener","handleMouseLeave","removeEventListener","removeProperty"],"sources":["./src/util/3d-tilt-hover-effect.ts"],"sourcesContent":["/**\n * Utility functions for creating a 3D tilt hover effect.\n *\n * This module provides functions that enables consumer components to display a nice 3D effect,\n * when being hovered; enabling them to follow the cursor's position and tilt towards it.\n *\n * ## What you need, to make this work\n * ### Typescript\n * 1. Import the functions:\n *\n * ```tsx\n * import {\n *     tiltFollowingTheCursor,\n *     handleMouseEnter,\n *     handleMouseLeave,\n * } from './path/to/3d-tilt-hover-effect';\n * ```\n *\n * 2. In your component, define the necessary properties.\n * For example, if your 3D element is a `section` element:\n *\n * ```tsx\n * @Element() private element: HTMLElement;\n * private the3dElementBounds: DOMRect;\n *\n * public componentDidLoad() {\n *     const the3dElement = this.element.shadowRoot.querySelector('section');\n *     the3dElement.addEventListener('mouseenter', this.handleMouseEnter);\n *     the3dElement.addEventListener('mouseleave', this.handleMouseLeave);\n * }\n *\n * public disconnectedCallback() {\n *     const the3dElement = this.element.shadowRoot.querySelector('section');\n *     if (the3dElement) {\n *         the3dElement.removeEventListener(\n *             'mouseenter',\n *             this.handleMouseEnter,\n *         );\n *         the3dElement.removeEventListener(\n *             'mouseleave',\n *             this.handleMouseLeave,\n *         );\n *     }\n * }\n * ```\n *\n * 3. If your component does not already have event handlers,\n * implement them using the imported functions from this file:\n *\n * ```tsx\n * private handleMouseEnter = () => {\n *     handleMouseEnter(this.element, 'section', (bounds) => {\n *         this.the3dElementBounds = bounds;\n *     }, this.tiltFollowingTheCursor);\n * };\n *\n * private handleMouseLeave = () => {\n *     handleMouseLeave(this.element, this.tiltFollowingTheCursor);\n * };\n *\n * private tiltFollowingTheCursor = (e: MouseEvent) => {\n *     tiltFollowingTheCursor(e, this.the3dElementBounds, this.element);\n * };\n * ```\n *\n * 4. Attach the event handlers to the relevant elements in your render method:\n *\n * ```tsx\n * public render() {\n *     return (\n *         <section\n *             onMouseEnter={this.handleMouseEnter}\n *             onMouseLeave={this.handleMouseLeave}\n *         >\n *             Your content here\n *         </section>\n *     );\n * }\n * ```\n *\n * :::note\n * - Ensure that the `element` and `the3dElementBounds` properties are properly\n * defined in your component.\n * - The `selector` parameter in `handleMouseEnter` should match the selector\n * of the element you want to apply the 3D effect to.\n * - The `tiltFollowingTheCursor` function calculates the 3D rotation and glow\n * position based on the cursor's position relative to the element's bounds.\n * :::\n *\n * ### HTML elements + CSS\n * 1. Add a `<div class=\"limel-3d-hover-effect-glow\" />` element to your component's template,\n * inside the element you want to apply the 3D effect to, and preferably at the bottom of all\n * other elements within that element (to avoid the need to specifying `z-index`es).\n * 2. Add the following `mixin` to your component's SCSS file:\n * `limel-3d-hover-effect-glow($the3dElement, $border-radius);`\n *\n * and don't forget to define the `$the3dElement` variables for the mixin to work\n * (and optionally the `$border-radius`).\n * 3. Keep in mind that the `<div class=\"limel-3d-hover-effect-glow\" />` will be\n * absolutely positioned inside the parent element, so make sure the parent element\n * has `position` set.\n * 4. Add the following `mixin` to the host element: `parent-of-the-3d-element`.\n * 5. Add the following `mixin` to the 3D element: `the-3d-element`.\n * 6. And if your element is supposed to be clickable, add this `mixin` as well: `the-3d-element--clickable`.\n *\n */\n\nexport const MOUSE_SCALE_FACTOR = 100;\nexport const SCALING_BASE = 50;\nexport const ROTATION_DEGREE_MULTIPLIER = 1.6;\nexport const GLOW_POSITION_MULTIPLIER = 2;\nexport const CENTER_DIVISOR = 2;\n\nexport function tiltFollowingTheCursor(\n    e: MouseEvent,\n    the3dElementBounds: DOMRect,\n    element: HTMLElement,\n) {\n    const mouseX = e.clientX;\n    const mouseY = e.clientY;\n    const leftX = mouseX - the3dElementBounds.x;\n    const topY = mouseY - the3dElementBounds.y;\n    const center = {\n        x: leftX - the3dElementBounds.width / CENTER_DIVISOR,\n        y: topY - the3dElementBounds.height / CENTER_DIVISOR,\n    };\n    const distance = Math.sqrt(\n        center.x ** CENTER_DIVISOR + center.y ** CENTER_DIVISOR,\n    );\n\n    const scalingFactor = Math.sqrt(\n        Math.min(the3dElementBounds.width, the3dElementBounds.height) /\n            SCALING_BASE,\n    );\n\n    const rotate3d = `\n        ${center.y / (MOUSE_SCALE_FACTOR * scalingFactor)},\n        ${-center.x / (MOUSE_SCALE_FACTOR * scalingFactor)},\n        0,\n        ${(Math.log(distance) * ROTATION_DEGREE_MULTIPLIER) / scalingFactor}deg\n    `;\n    element.style.setProperty('--limel-3d-hover-effect-rotate3d', rotate3d);\n\n    const glowPosition = `\n        ${center.x * GLOW_POSITION_MULTIPLIER + the3dElementBounds.width / CENTER_DIVISOR}px\n        ${center.y * GLOW_POSITION_MULTIPLIER + the3dElementBounds.height / CENTER_DIVISOR}px\n    `;\n    element.style.setProperty(\n        '--limel-3d-hover-effect-glow-position',\n        glowPosition,\n    );\n}\n\nexport function handleMouseEnter(\n    element: HTMLElement,\n    selector: string,\n    setBounds: (bounds: DOMRect) => void,\n    tiltCallback: (e: MouseEvent) => void,\n) {\n    const the3dElement = element.shadowRoot.querySelector(\n        selector,\n    ) as HTMLElement;\n    const bounds = the3dElement.getBoundingClientRect();\n    setBounds(bounds);\n    document.addEventListener('mousemove', tiltCallback);\n}\n\nexport function handleMouseLeave(\n    element: HTMLElement,\n    selector: string,\n    tiltCallback: (e: MouseEvent) => void,\n) {\n    const the3dElement = element.shadowRoot.querySelector(\n        selector,\n    ) as HTMLElement;\n    document.removeEventListener('mousemove', tiltCallback);\n    the3dElement.style.removeProperty('--limel-3d-hover-effect-rotate3d');\n    the3dElement.style.removeProperty('--limel-3d-hover-effect-glow-position');\n}\n"],"mappings":"AA2GO,MAAMA,EAAqB,IAC3B,MAAMC,EAAe,GACrB,MAAMC,EAA6B,IACnC,MAAMC,EAA2B,EACjC,MAAMC,EAAiB,E,SAEdC,EACZC,EACAC,EACAC,GAEA,MAAMC,EAASH,EAAEI,QACjB,MAAMC,EAASL,EAAEM,QACjB,MAAMC,EAAQJ,EAASF,EAAmBO,EAC1C,MAAMC,EAAOJ,EAASJ,EAAmBS,EACzC,MAAMC,EAAS,CACXH,EAAGD,EAAQN,EAAmBW,MAAQd,EACtCY,EAAGD,EAAOR,EAAmBY,OAASf,GAE1C,MAAMgB,EAAWC,KAAKC,KAClBL,EAAOH,GAAKV,EAAiBa,EAAOD,GAAKZ,GAG7C,MAAMmB,EAAgBF,KAAKC,KACvBD,KAAKG,IAAIjB,EAAmBW,MAAOX,EAAmBY,QAClDlB,GAGR,MAAMwB,EAAW,aACXR,EAAOD,GAAKhB,EAAqBuB,iBAChCN,EAAOH,GAAKd,EAAqBuB,4BAEjCF,KAAKK,IAAIN,GAAYlB,EAA8BqB,aAE1Df,EAAQmB,MAAMC,YAAY,mCAAoCH,GAE9D,MAAMI,EAAe,aACfZ,EAAOH,EAAIX,EAA2BI,EAAmBW,MAAQd,gBACjEa,EAAOD,EAAIb,EAA2BI,EAAmBY,OAASf,YAExEI,EAAQmB,MAAMC,YACV,wCACAC,EAER,C,SAEgBC,EACZtB,EACAuB,EACAC,EACAC,GAEA,MAAMC,EAAe1B,EAAQ2B,WAAWC,cACpCL,GAEJ,MAAMM,EAASH,EAAaI,wBAC5BN,EAAUK,GACVE,SAASC,iBAAiB,YAAaP,EAC3C,C,SAEgBQ,EACZjC,EACAuB,EACAE,GAEA,MAAMC,EAAe1B,EAAQ2B,WAAWC,cACpCL,GAEJQ,SAASG,oBAAoB,YAAaT,GAC1CC,EAAaP,MAAMgB,eAAe,oCAClCT,EAAaP,MAAMgB,eAAe,wCACtC,Q"}