{"version":3,"names":["ImageIntersectionObserver","constructor","containerElement","this","handleIntersection","entries","entry","isIntersecting","img","target","dataSrc","dataset","src","setAttribute","observer","unobserve","IntersectionObserver","images","querySelectorAll","observe","disconnect","markdownCss","Markdown","imageIntersectionObserver","globalConfig","markdownWhitelist","async","cleanupImageIntersectionObserver","html","markdownToHTML","value","forceHardLineBreaks","whitelist","_a","lazyLoadImages","rootElement","innerHTML","setupImageIntersectionObserver","setupTaskListHandlers","error","console","textChanged","disconnectedCallback","render","h","id","ref","el","checkboxes","lines","split","taskListIndex","checkbox","inputElement","currentTaskIndex","addEventListener","taskCounter","i","length","line","taskListRegex","taskListMatch","exec","indent","newState","checked","text","updatedMarkdown","join","taskListChange","emit"],"sources":["./src/components/markdown/image-intersection-observer.ts","./src/components/markdown/markdown.scss?tag=limel-markdown&encapsulation=shadow","./src/components/markdown/markdown.tsx"],"sourcesContent":["export class ImageIntersectionObserver {\n    private observer: IntersectionObserver;\n\n    /**\n     * @param containerElement - The element containing images to observe.\n     */\n    public constructor(containerElement: HTMLElement) {\n        this.observer = new IntersectionObserver(this.handleIntersection);\n\n        const images = containerElement.querySelectorAll('img');\n        for (const img of images) {\n            this.observer.observe(img);\n        }\n    }\n\n    public disconnect() {\n        this.observer.disconnect();\n    }\n\n    private readonly handleIntersection = (\n        entries: IntersectionObserverEntry[]\n    ) => {\n        for (const entry of entries) {\n            if (entry.isIntersecting) {\n                const img = entry.target as HTMLImageElement;\n                const dataSrc = img.dataset.src;\n\n                if (dataSrc) {\n                    img.setAttribute('src', dataSrc);\n                    delete img.dataset.src;\n                }\n\n                this.observer.unobserve(img);\n            }\n        }\n    };\n}\n","/**\n* @prop --markdown-hyperlink-color: color of text for hyperlinks. Defaults to `--color-blue-dark`;\n* @prop --markdown-hyperlink-color--hovered: color of text for hyperlinks when hovered. Defaults to `--color-blue-default`;\n*/\n\n@forward './partial-styles/pre-code';\n@forward './partial-styles/headings';\n@forward './partial-styles/body-text';\n@forward './partial-styles/lists';\n@forward './partial-styles/tables';\n@forward './partial-styles/blockquotes';\n@forward './partial-styles/definition-lists';\n@forward './partial-styles/img';\n@forward './partial-styles/kbd';\n@forward './partial-styles/_adjust-for-table-cell';\n\n*,\n*::before,\n*::after {\n    box-sizing: border-box;\n\n    & :where(:not(img, video, svg, canvas, iframe)) {\n        min-width: 0;\n        min-height: 0;\n    }\n}\n\n// body-text\nhr {\n    border-top: 1px solid rgb(var(--contrast-700));\n}\n\n.MsoNormal {\n    margin: 0;\n}\n","import { Component, h, Prop, Watch, Event, EventEmitter } from '@stencil/core';\nimport { markdownToHTML } from './markdown-parser';\nimport { globalConfig } from '../../global/config';\nimport { CustomElementDefinition } from '../../global/shared-types/custom-element.types';\nimport { ImageIntersectionObserver } from './image-intersection-observer';\n\n/**\n * The Markdown component receives markdown syntax\n * and renders it as HTML.\n *\n * @exampleComponent limel-example-markdown-headings\n * @exampleComponent limel-example-markdown-emphasis\n * @exampleComponent limel-example-markdown-lists\n * @exampleComponent limel-example-markdown-links\n * @exampleComponent limel-example-markdown-images\n * @exampleComponent limel-example-markdown-code\n * @exampleComponent limel-example-markdown-footnotes\n * @exampleComponent limel-example-markdown-tables\n * @exampleComponent limel-example-markdown-html\n * @exampleComponent limel-example-markdown-keys\n * @exampleComponent limel-example-markdown-blockquotes\n * @exampleComponent limel-example-markdown-horizontal-rule\n * @exampleComponent limel-example-markdown-composite\n * @exampleComponent limel-example-markdown-custom-component\n */\n@Component({\n    tag: 'limel-markdown',\n    styleUrl: 'markdown.scss',\n    shadow: true,\n})\nexport class Markdown {\n    /**\n     * The input text. Treated as GitHub Flavored Markdown, with the addition\n     * that any included HTML will be parsed and rendered as HTML, rather than\n     * as text.\n     */\n    @Prop()\n    public value: string = '';\n\n    /**\n     * Whitelisted html elements.\n     *\n     * Any custom element added here will not be sanitized and thus rendered.\n     * Can also be set via `limel-config`. Setting this property will override\n     * the global config.\n     * @alpha\n     */\n    @Prop()\n    public whitelist?: CustomElementDefinition[] =\n        globalConfig.markdownWhitelist;\n\n    /**\n     * Enable lazy loading for images\n     */\n    @Prop()\n    public lazyLoadImages = false;\n\n    /**\n     * Emitted when a task list checkbox is clicked.\n     * The event detail contains the updated markdown text.\n     */\n    @Event()\n    public taskListChange: EventEmitter<string>;\n\n    @Watch('value')\n    public async textChanged() {\n        try {\n            this.cleanupImageIntersectionObserver();\n\n            const html = await markdownToHTML(this.value, {\n                forceHardLineBreaks: true,\n                whitelist: this.whitelist ?? [],\n                lazyLoadImages: this.lazyLoadImages,\n            });\n\n            this.rootElement.innerHTML = html;\n\n            this.setupImageIntersectionObserver();\n            this.setupTaskListHandlers();\n        } catch (error) {\n            console.error(error);\n        }\n    }\n\n    private rootElement: HTMLDivElement;\n    private imageIntersectionObserver: ImageIntersectionObserver | null = null;\n\n    public async componentDidLoad() {\n        this.textChanged();\n    }\n\n    public disconnectedCallback() {\n        this.cleanupImageIntersectionObserver();\n    }\n\n    public render() {\n        return <div id=\"markdown\" ref={(el) => (this.rootElement = el)} />;\n    }\n\n    private setupTaskListHandlers() {\n        // Make task list checkboxes interactive and sync back to markdown\n        const checkboxes = this.rootElement.querySelectorAll(\n            '.task-list-item input[type=\"checkbox\"]'\n        );\n\n        // Parse the current markdown to find task list items\n        const lines = this.value.split('\\n');\n        let taskListIndex = 0;\n\n        for (const checkbox of checkboxes) {\n            const inputElement = checkbox as HTMLInputElement;\n            const currentTaskIndex = taskListIndex++;\n\n            inputElement.addEventListener('change', () => {\n                // Find the corresponding line in the markdown\n                let taskCounter = 0;\n\n                for (let i = 0; i < lines.length; i++) {\n                    const line = lines[i];\n                    // Match both checked and unchecked task list items\n                    // Using a more specific regex to avoid backtracking issues\n                    const taskListRegex = /^(\\s*)- \\[([x ])\\] (.+)$/;\n                    const taskListMatch = taskListRegex.exec(line);\n\n                    if (taskListMatch) {\n                        if (taskCounter === currentTaskIndex) {\n                            // Update this line\n                            const indent = taskListMatch[1];\n                            const newState = inputElement.checked ? 'x' : ' ';\n                            const text = taskListMatch[3];\n                            lines[i] = `${indent}- [${newState}] ${text}`;\n\n                            // Emit the updated markdown\n                            const updatedMarkdown = lines.join('\\n');\n                            this.taskListChange.emit(updatedMarkdown);\n                            break;\n                        }\n                        taskCounter++;\n                    }\n                }\n            });\n        }\n    }\n\n    private setupImageIntersectionObserver() {\n        if (this.lazyLoadImages) {\n            this.imageIntersectionObserver = new ImageIntersectionObserver(\n                this.rootElement\n            );\n        }\n    }\n\n    private cleanupImageIntersectionObserver() {\n        if (this.imageIntersectionObserver) {\n            this.imageIntersectionObserver.disconnect();\n            this.imageIntersectionObserver = null;\n        }\n    }\n}\n"],"mappings":"2OAAaA,EAMTC,YAAmBC,GAaFC,KAAAC,mBACbC,IAEA,IAAK,MAAMC,KAASD,EAAS,CACzB,GAAIC,EAAMC,eAAgB,CACtB,MAAMC,EAAMF,EAAMG,OAClB,MAAMC,EAAUF,EAAIG,QAAQC,IAE5B,GAAIF,EAAS,CACTF,EAAIK,aAAa,MAAOH,UACjBF,EAAIG,QAAQC,G,CAGvBT,KAAKW,SAASC,UAAUP,E,IAzBhCL,KAAKW,SAAW,IAAIE,qBAAqBb,KAAKC,oBAE9C,MAAMa,EAASf,EAAiBgB,iBAAiB,OACjD,IAAK,MAAMV,KAAOS,EAAQ,CACtBd,KAAKW,SAASK,QAAQX,E,EAIvBY,aACHjB,KAAKW,SAASM,Y,EChBtB,MAAMC,EAAc,87R,MC8BPC,EAAQ,M,wEAuDTnB,KAAAoB,0BAA8D,K,WAhD/C,G,eAYnBC,EAAaC,kB,oBAMO,K,CAUjBC,oB,MACH,IACIvB,KAAKwB,mCAEL,MAAMC,QAAaC,EAAe1B,KAAK2B,MAAO,CAC1CC,oBAAqB,KACrBC,WAAWC,EAAA9B,KAAK6B,aAAS,MAAAC,SAAA,EAAAA,EAAI,GAC7BC,eAAgB/B,KAAK+B,iBAGzB/B,KAAKgC,YAAYC,UAAYR,EAE7BzB,KAAKkC,iCACLlC,KAAKmC,uB,CACP,MAAOC,GACLC,QAAQD,MAAMA,E,EAOfb,yBACHvB,KAAKsC,a,CAGFC,uBACHvC,KAAKwB,kC,CAGFgB,SACH,OAAOC,EAAA,OAAKC,GAAG,WAAWC,IAAMC,GAAQ5C,KAAKgC,YAAcY,G,CAGvDT,wBAEJ,MAAMU,EAAa7C,KAAKgC,YAAYjB,iBAChC,0CAIJ,MAAM+B,EAAQ9C,KAAK2B,MAAMoB,MAAM,MAC/B,IAAIC,EAAgB,EAEpB,IAAK,MAAMC,KAAYJ,EAAY,CAC/B,MAAMK,EAAeD,EACrB,MAAME,EAAmBH,IAEzBE,EAAaE,iBAAiB,UAAU,KAEpC,IAAIC,EAAc,EAElB,IAAK,IAAIC,EAAI,EAAGA,EAAIR,EAAMS,OAAQD,IAAK,CACnC,MAAME,EAAOV,EAAMQ,GAGnB,MAAMG,EAAgB,2BACtB,MAAMC,EAAgBD,EAAcE,KAAKH,GAEzC,GAAIE,EAAe,CACf,GAAIL,IAAgBF,EAAkB,CAElC,MAAMS,EAASF,EAAc,GAC7B,MAAMG,EAAWX,EAAaY,QAAU,IAAM,IAC9C,MAAMC,EAAOL,EAAc,GAC3BZ,EAAMQ,GAAK,GAAGM,OAAYC,MAAaE,IAGvC,MAAMC,EAAkBlB,EAAMmB,KAAK,MACnCjE,KAAKkE,eAAeC,KAAKH,GACzB,K,CAEJX,G,OAOZnB,iCACJ,GAAIlC,KAAK+B,eAAgB,CACrB/B,KAAKoB,0BAA4B,IAAIvB,EACjCG,KAAKgC,Y,EAKTR,mCACJ,GAAIxB,KAAKoB,0BAA2B,CAChCpB,KAAKoB,0BAA0BH,aAC/BjB,KAAKoB,0BAA4B,I"}