{"version":3,"names":["FormLayoutType","ColumnAggregatorType"],"sources":["./src/components/form/form.types.ts","./src/components/table/table.types.ts"],"sourcesContent":["import { JSONSchema7 } from 'json-schema';\nimport { Help } from '../help/help.types';\nimport { EventEmitter } from '@stencil/core';\n\n/**\n * EventEmitter from `@stencil/core`.\n *\n * @public\n */\nexport { EventEmitter } from '@stencil/core';\n\ndeclare module 'json-schema' {\n    interface JSONSchema7 {\n        /**\n         * @internal\n         * Unique identifier for the schema\n         */\n        id?: string;\n\n        /**\n         * Lime elements specific options that can be specified in a schema\n         */\n        lime?: Omit<LimeSchemaOptions, 'layout'> & {\n            layout?: Partial<LimeLayoutOptions>;\n        };\n    }\n}\n\n/**\n * @public\n */\nexport interface ValidationStatus {\n    /**\n     * True if the form is valid, false otherwise\n     *\n     * If the form is invalid, any errors can be found on the `errors` property\n     */\n    valid: boolean;\n\n    /**\n     * List of validation errors\n     */\n    errors?: FormError[];\n}\n\n/**\n * @public\n */\nexport interface FormError {\n    /**\n     * Name of the error\n     */\n    name: string;\n\n    /**\n     * Params of the error\n     */\n    params?: unknown;\n\n    /**\n     * Name of the invalid property\n     */\n    property: string;\n\n    /**\n     * Path to the property within the schema\n     */\n    schemaPath: string;\n\n    /**\n     * String describing the error\n     */\n    message: string;\n}\n\n/**\n * @public\n */\nexport type ValidationError = {\n    /**\n     * Name of the field the error belongs to\n     */\n    [key: string]: string[] | ValidationError;\n};\n\n/**\n * @public\n */\nexport interface FormComponent<T = any> {\n    /**\n     * The value of the current property\n     */\n    value: T;\n\n    /**\n     * Whether or not the current property is required\n     */\n    required?: boolean;\n\n    /**\n     * Whether or not the current property is readonly\n     */\n    readonly?: boolean;\n\n    /**\n     * Whether or not the current property is disabled\n     */\n    disabled?: boolean;\n\n    /**\n     * The label of the current property\n     */\n    label?: string;\n\n    /**\n     * The helper text for the current property\n     */\n    helperText?: string;\n\n    /**\n     * Additional contextual information about the form\n     */\n    formInfo?: FormInfo;\n\n    /**\n     * The event to emit when the value of the current property has changed\n     */\n    change: EventEmitter<T>;\n}\n\n/**\n * @public\n */\nexport interface FormInfo {\n    /**\n     * The schema of the current property\n     */\n    schema?: FormSchema;\n\n    /**\n     * The schema of the whole form\n     */\n    rootSchema?: FormSchema;\n\n    /**\n     * A tree of errors for this property and its children\n     */\n    errorSchema?: object;\n\n    /**\n     * The value of the whole form\n     */\n    rootValue?: any;\n\n    /**\n     * The name of the current property\n     */\n    name?: string;\n\n    /**\n     * Path to the property within the schema\n     */\n    schemaPath?: string[];\n}\n\n/**\n * Lime elements specific options that can be specified under the `lime` key in\n * a schema, e.g.\n *\n * ```ts\n * const schema = {\n *     type: 'object',\n *     lime: {\n *         collapsible: true,\n *     },\n * };\n * ```\n *\n * @public\n */\nexport interface LimeSchemaOptions {\n    /**\n     * When specified on an object it will render all sub components inside a\n     * collapsible section\n     */\n    collapsible?: boolean;\n\n    /**\n     * When `collapsible` is `true`, set this to `false` to make the\n     * collapsible section load in the open state.\n     * Defaults to `true`.\n     */\n    collapsed?: boolean;\n\n    /**\n     * Will render the field using the specified component. The component\n     * should implement the `FormComponent` interface\n     */\n    component?: FormComponentOptions;\n\n    /**\n     * When specified on an object it will render the sub components with the\n     * specified layout\n     */\n    layout?: LimeLayoutOptions;\n\n    /**\n     * Mark the field as disabled\n     */\n    disabled?: boolean;\n\n    help?: string | Partial<Help>;\n}\n\n/**\n * Options for a layout to be used in a form\n * @public\n */\nexport type LimeLayoutOptions = GridLayoutOptions & RowLayoutOptions;\n\n/**\n * Options for a component to be rendered inside a form\n *\n * @public\n */\nexport interface FormComponentOptions {\n    /**\n     * Name of the component\n     */\n    name?: string;\n\n    /**\n     * Extra properties to give the component in addition to the properties\n     * specified on the `FormComponent` interface\n     */\n    props?: Record<string, any>;\n}\n\n/**\n * @public\n */\nexport interface FormLayoutOptions<\n    T extends FormLayoutType | `${FormLayoutType}` = FormLayoutType.Default,\n> {\n    /**\n     * The type of layout to use\n     */\n    type: T;\n}\n\n/**\n * Layout options for a grid layout\n * @public\n */\nexport interface GridLayoutOptions\n    extends FormLayoutOptions<FormLayoutType | `${FormLayoutType}`> {\n    /**\n     * When specified on a component within the grid, the component will take\n     * up the the specified number of columns in the form\n     */\n    // eslint-disable-next-line no-magic-numbers\n    colSpan?: 1 | 2 | 3 | 4 | 5 | 'all';\n\n    /**\n     * When specified on a component within the grid, the component will take\n     * up the the specified number of rows in the form\n     */\n    rowSpan?: number;\n\n    /**\n     * Number of columns to use in the layout\n     */\n    // eslint-disable-next-line no-magic-numbers\n    columns?: 1 | 2 | 3 | 4 | 5;\n\n    /**\n     * Attempts to fill in holes earlier in the grid, if smaller items come up\n     * later. This may cause items to appear out-of-order, when doing so would\n     * fill holes left by larger items. Defaults to `true`.\n     */\n    dense?: boolean;\n}\n\n/**\n * Layout options for a row layout\n * @public\n */\nexport interface RowLayoutOptions\n    extends FormLayoutOptions<FormLayoutType | `${FormLayoutType}`> {\n    /**\n     * When specified on a field, the chosen icon will be displayed\n     * on the left side of the row, beside the title.\n     */\n    icon?: string;\n}\n\n/**\n * Represents the layout types for a form.\n * @public\n */\nexport enum FormLayoutType {\n    /**\n     * The default layout\n     */\n    Default = 'default',\n\n    /**\n     * Render the form fields using a responsive grid layout\n     */\n    Grid = 'grid',\n\n    /**\n     * Render the form fields in full-width rows.\n     * Each row can have a leading `icon`, and a field.\n     * `title` and `description` provided by the schema will be placed\n     * on the row itself, and not on the field.\n     * This layout is good for creating UIs for user settings pages.\n     */\n    Row = 'row',\n}\n\n/**\n * Represents the JSON schema with Lime specific options\n * @public\n */\nexport interface FormSchema<T extends Record<string, any> = any>\n    extends JSONSchema7 {\n    /**\n     * The value of \"items\" MUST be either a valid JSON Schema or an array\n     * of valid JSON Schemas.\n     *\n     * This keyword determines how child instances validate for arrays, and\n     * does not directly validate the immediate instance itself.\n     *\n     * If \"items\" is a schema, validation succeeds if all elements in the\n     * array successfully validate against that schema.\n     *\n     * If \"items\" is an array of schemas, validation succeeds if each\n     * element of the instance validates against the schema at the same\n     * position, if any.\n     *\n     * Omitting this keyword has the same behavior as an empty schema.\n     *\n     * @see https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-6.4.1\n     */\n    items?: FormSchemaArrayItem<T> | Array<FormSchemaArrayItem<T>>;\n\n    /**\n     * The value of \"items\" MUST be either a valid JSON Schema or an array\n     * of valid JSON Schemas.\n     *\n     * This keyword determines how child instances validate for arrays, and\n     * does not directly validate the immediate instance itself.\n     *\n     * If \"items\" is a schema, validation succeeds if all elements in the\n     * array successfully validate against that schema.\n     *\n     * If \"items\" is an array of schemas, validation succeeds if each\n     * element of the instance validates against the schema at the same\n     * position, if any.\n     *\n     * Omitting this keyword has the same behavior as an empty schema.\n     *\n     * @see https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-6.4.2\n     */\n    additionalItems?: FormSchemaArrayItem<T>;\n\n    /**\n     * The value of this keyword MUST be a valid JSON Schema.\n     *\n     * An array instance is valid against \"contains\" if at least one of its\n     * elements is valid against the given schema.\n     *\n     * @see https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-6.4.6\n     */\n    contains?: FormSchemaArrayItem<T>;\n\n    /**\n     * The value of this keyword MUST be an array.  Elements of this array,\n     * if any, MUST be strings, and MUST be unique.\n     *\n     * An object instance is valid against this keyword if every item in the\n     * array is the name of a property in the instance.\n     *\n     * Omitting this keyword has the same behavior as an empty array.\n     *\n     * @see https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-6.5.3\n     */\n    required?: Array<ReplaceObjectType<T, Extract<keyof T, string>, string>>;\n\n    /**\n     * The value of \"properties\" MUST be an object.  Each value of this\n     * object MUST be a valid JSON Schema.\n     *\n     * This keyword determines how child instances validate for objects, and\n     * does not directly validate the immediate instance itself.\n     *\n     * Validation succeeds if, for each name that appears in both the\n     * instance and as a name within this keyword's value, the child\n     * instance for that name successfully validates against the\n     * corresponding schema.\n     *\n     * Omitting this keyword has the same behavior as an empty object.\n     *\n     * @see https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-6.5.4\n     */\n    properties?: ReplaceObjectType<\n        T,\n        FormSubKeySchema<T>,\n        Record<string, FormSchema>\n    >;\n\n    /**\n     * This keyword's value MUST be a non-empty array.  Each item of the\n     * array MUST be a valid JSON Schema.\n     *\n     * An instance validates successfully against this keyword if it\n     * validates successfully against all schemas defined by this keyword's\n     * value.\n     *\n     * @see https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-6.7.1\n     */\n    allOf?: Array<FormSchemaArrayItem<T>>;\n\n    /**\n     * This keyword's value MUST be a non-empty array.  Each item of the\n     * array MUST be a valid JSON Schema.\n     *\n     * An instance validates successfully against this keyword if it\n     * validates successfully against at least one schema defined by this\n     * keyword's value.\n     *\n     * @see https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-6.7.2\n     */\n    anyOf?: Array<FormSchemaArrayItem<T>>;\n\n    /**\n     * This keyword's value MUST be a non-empty array.  Each item of the\n     * array MUST be a valid JSON Schema.\n     *\n     * An instance validates successfully against this keyword if it\n     * validates successfully against exactly one schema defined by this\n     * keyword's value.\n     * @see https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-6.7.3\n     */\n    oneOf?: Array<FormSchemaArrayItem<T>>;\n\n    /**\n     * The value of \"patternProperties\" MUST be an object.  Each property\n     * name of this object SHOULD be a valid regular expression, according\n     * to the ECMA 262 regular expression dialect.  Each property value of\n     * this object MUST be a valid JSON Schema.\n     *\n     * This keyword determines how child instances validate for objects, and\n     * does not directly validate the immediate instance itself.  Validation\n     * of the primitive instance type against this keyword always succeeds.\n     *\n     * Validation succeeds if, for each instance name that matches any\n     * regular expressions that appear as a property name in this keyword's\n     * value, the child instance for that name successfully validates\n     * against each schema that corresponds to a matching regular\n     * expression.\n     *\n     * Omitting this keyword has the same behavior as an empty object.\n     *\n     * @see https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-6.5.5\n     */\n    patternProperties?: Record<string, FormSchema>;\n\n    /**\n     * The value of \"additionalProperties\" MUST be a valid JSON Schema.\n     *\n     * This keyword determines how child instances validate for objects, and\n     * does not directly validate the immediate instance itself.\n     *\n     * Validation with \"additionalProperties\" applies only to the child\n     * values of instance names that do not match any names in \"properties\",\n     * and do not match any regular expression in \"patternProperties\".\n     *\n     * For all such properties, validation succeeds if the child instance\n     * validates against the \"additionalProperties\" schema.\n     *\n     * Omitting this keyword has the same behavior as an empty schema.\n     *\n     * @see https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-6.5.6\n     */\n    additionalProperties?: FormSchema | boolean;\n\n    /**\n     * This keyword specifies rules that are evaluated if the instance is an\n     * object and contains a certain property.\n     *\n     * This keyword's value MUST be an object.  Each property specifies a\n     * dependency.  Each dependency value MUST be an array or a valid JSON\n     * Schema.\n     *\n     * If the dependency value is a subschema, and the dependency key is a\n     * property in the instance, the entire instance must validate against\n     * the dependency value.\n     *\n     * If the dependency value is an array, each element in the array, if\n     * any, MUST be a string, and MUST be unique.  If the dependency key is\n     * a property in the instance, each of the items in the dependency value\n     * must be a property that exists in the instance.\n     *\n     * Omitting this keyword has the same behavior as an empty object.\n     *\n     * @see https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-6.5.7\n     */\n    dependencies?: Record<string, FormSchema | string[]>;\n\n    /**\n     * The value of \"propertyNames\" MUST be a valid JSON Schema.\n     *\n     * If the instance is an object, this keyword validates if every\n     * property name in the instance validates against the provided schema.\n     * Note the property name that the schema is testing will always be a\n     * string.\n     *\n     * Omitting this keyword has the same behavior as an empty schema.\n     *\n     * @see https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-6.5.8\n     */\n    propertyNames?: FormSchema;\n\n    /**\n     * This keyword's value MUST be a valid JSON Schema.\n     *\n     * This validation outcome of this keyword's subschema has no direct\n     * effect on the overall validation result.  Rather, it controls which\n     * of the \"then\" or \"else\" keywords are evaluated.\n     *\n     * Instances that successfully validate against this keyword's subschema\n     * MUST also be valid against the subschema value of the \"then\" keyword,\n     * if present.\n     *\n     * Instances that fail to validate against this keyword's subschema MUST\n     * also be valid against the subschema value of the \"else\" keyword, if\n     * present.\n     *\n     * If annotations (Section 3.3) are being collected, they are collected\n     * from this keyword's subschema in the usual way, including when the\n     * keyword is present without either \"then\" or \"else\".\n     *\n     * @see https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-6.6.1\n     */\n    if?: FormSchema;\n\n    /**\n     * This keyword's value MUST be a valid JSON Schema.\n     *\n     * This validation outcome of this keyword's subschema has no direct\n     * effect on the overall validation result.  Rather, it controls which\n     * of the \"then\" or \"else\" keywords are evaluated.\n     *\n     * Instances that successfully validate against this keyword's subschema\n     * MUST also be valid against the subschema value of the \"then\" keyword,\n     * if present.\n     *\n     * Instances that fail to validate against this keyword's subschema MUST\n     * also be valid against the subschema value of the \"else\" keyword, if\n     * present.\n     *\n     * If annotations (Section 3.3) are being collected, they are collected\n     * from this keyword's subschema in the usual way, including when the\n     * keyword is present without either \"then\" or \"else\".\n     *\n     * @see https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-6.6.2\n     */\n    then?: FormSchema;\n\n    /**\n     * This keyword's value MUST be a valid JSON Schema.\n     *\n     * When \"if\" is present, and the instance fails to validate against its\n     * subschema, then valiation succeeds against this keyword if the\n     * instance successfully validates against this keyword's subschema.\n     *\n     * This keyword has no effect when \"if\" is absent, or when the instance\n     * successfully validates against its subschema.  Implementations MUST\n     * NOT evaluate the instance against this keyword, for either validation\n     * or annotation collection purposes, in such cases.\n     *\n     * @see https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-6.6.3\n     */\n    else?: FormSchema;\n\n    /**\n     * This keyword's value MUST be a valid JSON Schema.\n     *\n     * An instance is valid against this keyword if it fails to validate\n     * successfully against the schema defined by this keyword.\n     *\n     * @see https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-6.7.4\n     */\n    not?: FormSchema;\n\n    /**\n     * The \"$defs\" keywords provides a standardized location for\n     * schema authors to inline re-usable JSON Schemas into a more general\n     * schema.  The keyword does not directly affect the validation result.\n     *\n     * This keyword's value MUST be an object.  Each member value of this\n     * object MUST be a valid JSON Schema.\n     *\n     * As an example, here is a schema describing an array of positive\n     * integers, where the positive integer constraint is a subschema in\n     * \"definitions\":\n     * ```\n     * {\n     *     \"type\": \"array\",\n     *     \"items\": { \"$ref\": \"#/definitions/positiveInteger\" },\n     *     \"definitions\": {\n     *         \"positiveInteger\": {\n     *             \"type\": \"integer\",\n     *             \"exclusiveMinimum\": 0\n     *         }\n     *     }\n     * }\n     * ```\n     *\n     * $defs is the newer keyword introduced in the JSON Schema Draft 2019-09, while definitions is from the older drafts.\n     *\n     * The main difference is that definitions is no longer an official keyword in the latest JSON Schema specification (Draft 2019-09 and later),\n     * but it is still widely supported for backward compatibility.\n     *\n     * @see https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-9\n     */\n    $defs?: Record<string, FormSchema>;\n\n    /**\n     * The \"definitions\" keywords provides a standardized location for\n     * schema authors to inline re-usable JSON Schemas into a more general\n     * schema.  The keyword does not directly affect the validation result.\n     *\n     * This keyword's value MUST be an object.  Each member value of this\n     * object MUST be a valid JSON Schema.\n     *\n     * As an example, here is a schema describing an array of positive\n     * integers, where the positive integer constraint is a subschema in\n     * \"definitions\":\n     * ```\n     * {\n     *     \"type\": \"array\",\n     *     \"items\": { \"$ref\": \"#/definitions/positiveInteger\" },\n     *     \"definitions\": {\n     *         \"positiveInteger\": {\n     *             \"type\": \"integer\",\n     *             \"exclusiveMinimum\": 0\n     *         }\n     *     }\n     * }\n     * ```\n     *\n     * $defs is the newer keyword introduced in the JSON Schema Draft 2019-09, while definitions is from the older drafts.\n     *\n     * The main difference is that definitions is no longer an official keyword in the latest JSON Schema specification (Draft 2019-09 and later),\n     * but it is still widely supported for backward compatibility.\n     *\n     * @see https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-9\n     */\n    definitions?: Record<string, FormSchema>;\n}\n\n/**\n * Utility type for replacing object types with a specified type\n * @public\n */\nexport type ReplaceObjectType<T, AllowedType, ElseType> = T extends any[]\n    ? ElseType\n    : T extends Record<string, any>\n      ? AllowedType\n      : ElseType;\n\n/**\n * Utility type for supporting nested sub items in arrays\n * @public\n */\nexport type FormSchemaArrayItem<T> = T extends any[]\n    ? FormSchema<T[Extract<keyof T, number>]>\n    : FormSchema;\n\n/**\n * Utility type for recursive properties in a schema\n * @public\n */\nexport type FormSubKeySchema<TObj> = Partial<{\n    [Key in Extract<keyof TObj, any>]: FormSchema<TObj[Key]>;\n}>;\n","/**\n * Defines the data for a table\n * @public\n */\nexport interface Column<T extends object = any> {\n    /**\n     * Column title to be displayed\n     */\n    title: string;\n\n    /**\n     * Name of the field in the data\n     */\n    field: keyof T;\n\n    /**\n     * Function to format the value before rendering\n     */\n    formatter?: TableFormatter;\n\n    /**\n     * Component used to render the field value\n     */\n    component?: TableComponentDefinition;\n\n    /**\n     * Type of aggregator to use for the column\n     */\n    aggregator?: ColumnAggregatorType | ColumnAggregatorFunction<T>;\n\n    /**\n     * A component used to render inside the column header\n     */\n    headerComponent?: TableComponentDefinition;\n\n    /**\n     * Sets the horizontal text alignment for the column\n     */\n    horizontalAlign?: 'left' | 'center' | 'right';\n\n    /**\n     * Defines whether end-user can sort a column\n     */\n    headerSort?: boolean;\n}\n\n/**\n * Definition for a formatter function\n * @param value - The value to be formatted\n * @param data - The data for the current row\n * @returns The formatted value\n * @public\n */\nexport type TableFormatter = (value: any, data?: object) => string;\n\n/**\n * The `component` key in the schema uses this interface to define a\n * component to be rendered inside a cell in the table.\n *\n * @note The table will display the component as `inline-block` in order\n * to give the column the correct size. If the component should have the\n * full width of the column, this might have to be overridden by setting\n * the display mode to `block`, e.g.\n *\n * ```css\n * :host(*) {\n *     display: block !important;\n * }\n * ```\n * @public\n */\nexport interface TableComponentDefinition {\n    /**\n     * Name of the component\n     */\n    name: string;\n\n    /**\n     * Properties to send to the component\n     */\n    props?: Record<string, any>;\n\n    /**\n     * Factory for creating properties dynamically for a custom component.\n     *\n     * The properties returned from this function will be merged with the\n     * `props` properties when the component is created.\n     *\n     * When the propsFactory is used for header components there will be no data available.\n     *\n     * @param data - The data for the current row\n     * @returns Properties for the component\n     */\n    propsFactory?: (data: object) => Record<string, any>;\n}\n\n/**\n * Interface for custom components rendered inside a `limel-table`.\n * @public\n */\nexport interface TableComponent<T extends object = any> {\n    /**\n     * Name of the field being rendered\n     */\n    field?: string;\n\n    /**\n     * Value being rendered\n     */\n    value?: any;\n\n    /**\n     * Data for the current row of the table\n     */\n    data?: T;\n}\n\n/**\n * Indicates whether the specified column is sorted ascending or descending.\n * @public\n */\nexport interface ColumnSorter {\n    /**\n     * The column being sorted\n     */\n    column: Column;\n\n    /**\n     * The direction to sort on\n     */\n    direction: 'ASC' | 'DESC';\n}\n\n/**\n * Specifies the current page, and which columns the table is currently sorted on.\n * @public\n */\nexport interface TableParams {\n    /**\n     * The current page being set\n     */\n    page: number;\n\n    /**\n     * Sorters applied to the current page\n     */\n    sorters?: ColumnSorter[];\n}\n\n/**\n * The built-in aggregators available for columns\n * @public\n */\nexport enum ColumnAggregatorType {\n    /**\n     * Calculates the average value of all numerical cells in the column\n     */\n    Average = 'avg',\n\n    /**\n     * Displays the maximum value from all numerical cells in the column\n     */\n    Maximum = 'max',\n\n    /**\n     * Displays the minimum value from all numerical cells in the column\n     */\n    Minimum = 'min',\n\n    /**\n     * Displays the sum of all numerical cells in the column\n     */\n    Sum = 'sum',\n\n    /**\n     * Counts the number of non empty cells in the column\n     */\n    Count = 'count',\n}\n\n/**\n * Instead of using one of the built-in aggregators, it is possible to\n * define a custom aggregator function.\n *\n * @param column - the configuration for the column\n * @param values - list of all values to be aggregated\n * @param data - list of all objects to be aggregated\n * @returns the aggregated data\n *\n * @public\n */\nexport type ColumnAggregatorFunction<T = object> = (\n    column?: Column,\n    values?: any[],\n    data?: T[],\n) => any;\n\n/**\n * Defines aggregate values for columns\n * @public\n */\nexport interface ColumnAggregate {\n    /**\n     * The name of the `Column` field\n     */\n    field: string;\n    /**\n     * The aggregate value\n     */\n    value: any;\n}\n\n/**\n * Data for identifying a row of the table\n * @public\n */\nexport type RowData = {\n    id?: string | number;\n};\n"],"mappings":"IA4SYA,GAAZ,SAAYA,GAIRA,EAAA,qBAKAA,EAAA,eASAA,EAAA,YACH,EAnBD,CAAYA,MAAc,K,ICnJdC,GAAZ,SAAYA,GAIRA,EAAA,iBAKAA,EAAA,iBAKAA,EAAA,iBAKAA,EAAA,aAKAA,EAAA,gBACH,EAzBD,CAAYA,MAAoB,Y"}