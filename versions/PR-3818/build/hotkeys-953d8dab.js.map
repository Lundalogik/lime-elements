{"version":3,"names":["NORMALIZED_HOTKEY_SEPARATOR","normalizeKey","key","normalized","trim","toLowerCase","keyAliases","cmd","command","win","windows","option","esc","return","del","backspace","up","down","left","right","spacebar","test","normalizeModifiersAndKey","input","normalizedKey","includes","parts","meta","push","ctrl","alt","shift","join","normalizeHotkeyString","hotkey","tokens","split","map","token","filter","Boolean","normalizeEventKey","event","code","slice","hotkeyFromKeyboardEvent","altKey","ctrlKey","metaKey","shiftKey","isKeyboardEventFromTextInput","path","composedPath","node","Element","isContentEditable","tagName","_a","getAttribute","call"],"sources":["./src/util/hotkeys.ts"],"sourcesContent":["/**\n * These helpers provide a consistent way to:\n * - Normalize user-defined hotkey strings (e.g. \"cmd+k\", \"ctrl+shift+p\")\n * - Normalize `KeyboardEvent`s into the same canonical hotkey format\n * - Detect when a keyboard event likely originated from a text-input context\n *\n * **Canonical format**\n * - Modifiers are ordered: `meta`, `ctrl`, `alt`, `shift`\n * - Tokens are joined with `+`\n * - The final token is the non-modifier key\n *\n * Examples:\n * - `\"cmd+k\"` → `\"meta+k\"`\n * - `\"return\"` → `\"enter\"`\n * - `\"backspace\"` → `\"delete\"`\n * - `\"alt+shift+l\"` → `\"alt+shift+l\"`\n */\nconst NORMALIZED_HOTKEY_SEPARATOR = '+';\n\nconst normalizeKey = (key: string): string | null => {\n    const normalized = key.trim().toLowerCase();\n    if (!normalized) {\n        return null;\n    }\n\n    const keyAliases: Record<string, string> = {\n        cmd: 'meta',\n        command: 'meta',\n        win: 'meta',\n        windows: 'meta',\n        option: 'alt',\n        esc: 'escape',\n        return: 'enter',\n        del: 'delete',\n        backspace: 'delete',\n        up: 'arrowup',\n        down: 'arrowdown',\n        left: 'arrowleft',\n        right: 'arrowright',\n        spacebar: 'space',\n    };\n\n    if (keyAliases[normalized]) {\n        return keyAliases[normalized];\n    }\n\n    if (/^f\\d{1,2}$/.test(normalized)) {\n        return normalized;\n    }\n\n    return normalized;\n};\n\nconst normalizeModifiersAndKey = (input: {\n    key: string;\n    alt: boolean;\n    ctrl: boolean;\n    meta: boolean;\n    shift: boolean;\n}): string | null => {\n    const normalizedKey = normalizeKey(input.key);\n    if (!normalizedKey) {\n        return null;\n    }\n\n    // Ignore pure modifier presses\n    if (['shift', 'alt', 'control', 'ctrl', 'meta'].includes(normalizedKey)) {\n        return null;\n    }\n\n    const parts: string[] = [];\n\n    if (input.meta) {\n        parts.push('meta');\n    }\n    if (input.ctrl) {\n        parts.push('ctrl');\n    }\n    if (input.alt) {\n        parts.push('alt');\n    }\n    if (input.shift) {\n        parts.push('shift');\n    }\n\n    parts.push(normalizedKey);\n\n    return parts.join(NORMALIZED_HOTKEY_SEPARATOR);\n};\n\n/**\n * Normalize a user-defined hotkey string to the canonical format.\n *\n * Returns `null` for empty/invalid inputs or if the string only contains\n * modifiers (e.g. `\"ctrl+shift\"`).\n *\n * @param hotkey - User-provided hotkey string.\n */\nexport const normalizeHotkeyString = (hotkey: string): string | null => {\n    if (!hotkey) {\n        return null;\n    }\n\n    const tokens = hotkey\n        .split(/\\+/)\n        .map((token) => token.trim())\n        .filter(Boolean);\n\n    let alt = false;\n    let ctrl = false;\n    let meta = false;\n    let shift = false;\n    let key: string | null = null;\n\n    for (const token of tokens) {\n        const normalized = normalizeKey(token);\n        if (!normalized) {\n            continue;\n        }\n\n        if (normalized === 'alt') {\n            alt = true;\n            continue;\n        }\n        if (normalized === 'ctrl' || normalized === 'control') {\n            ctrl = true;\n            continue;\n        }\n        if (normalized === 'meta') {\n            meta = true;\n            continue;\n        }\n        if (normalized === 'shift') {\n            shift = true;\n            continue;\n        }\n\n        // Last non-modifier wins\n        key = normalized;\n    }\n\n    if (!key) {\n        return null;\n    }\n\n    return normalizeModifiersAndKey({ key, alt, ctrl, meta, shift });\n};\n\nconst normalizeEventKey = (event: KeyboardEvent): string | null => {\n    const code = (event.code || '').trim();\n    if (/^Key[A-Z]$/.test(code)) {\n        return code.slice(3).toLowerCase();\n    }\n\n    if (/^Digit\\d$/.test(code)) {\n        return code.slice(5);\n    }\n\n    const key = event.key;\n\n    if (key === ' ') {\n        return 'space';\n    }\n\n    return normalizeKey(key);\n};\n\n/**\n * Convert a `KeyboardEvent` into a canonical hotkey string.\n *\n * Uses `event.code` when possible for letter/digit keys to avoid\n * layout-dependent results.\n *\n * @param event - Keyboard event to normalize.\n */\nexport const hotkeyFromKeyboardEvent = (\n    event: KeyboardEvent\n): string | null => {\n    const key = normalizeEventKey(event);\n    if (!key) {\n        return null;\n    }\n\n    return normalizeModifiersAndKey({\n        key,\n        alt: event.altKey,\n        ctrl: event.ctrlKey,\n        meta: event.metaKey,\n        shift: event.shiftKey,\n    });\n};\n\n/**\n * Check whether a `KeyboardEvent` likely originated from a typing context.\n *\n * Returns `true` for events coming from:\n * - `input`, `textarea`, `select`\n * - `contenteditable` elements\n * - elements with `role=\"textbox\"`\n *\n * @param event - Keyboard event to inspect.\n */\nexport const isKeyboardEventFromTextInput = (event: KeyboardEvent): boolean => {\n    const path =\n        typeof event.composedPath === 'function' ? event.composedPath() : [];\n\n    for (const node of path) {\n        if (!(node instanceof Element)) {\n            continue;\n        }\n\n        if ((node as HTMLElement).isContentEditable) {\n            return true;\n        }\n\n        const tagName = node.tagName;\n        if (\n            tagName === 'INPUT' ||\n            tagName === 'TEXTAREA' ||\n            tagName === 'SELECT'\n        ) {\n            return true;\n        }\n\n        // Common pattern: elements with role=textbox\n        if (node.getAttribute?.('role') === 'textbox') {\n            return true;\n        }\n    }\n\n    return false;\n};\n"],"mappings":"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"}