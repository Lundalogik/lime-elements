{"version":3,"names":["NORMALIZED_HOTKEY_SEPARATOR","tokenizeHotkeyString","hotkey","raw","trim","tokens","current","index","length","char","nextChar","token","push","tail","normalizeKey","key","normalized","toLowerCase","keyAliases","cmd","command","win","windows","option","esc","return","del","backspace","up","down","left","right","spacebar","test","normalizeModifiersAndKey","input","normalizedKey","includes","parts","meta","ctrl","alt","shift","join","normalizeHotkeyString","normalizeEventKey","event","code","slice","hotkeyFromKeyboardEvent","shiftKey","altKey","ctrlKey","metaKey","hotkeysMatch","expected","pressed","options","treatExpectedMetaAsCtrl","expectedTokens","keyToken","at","modifierTokens","hasMeta","hasCtrl","mappedModifierTokens","map","ctrlEquivalent","isKeyboardEventFromTextInput","path","composedPath","node","Element","isContentEditable","tagName","_a","getAttribute","call"],"sources":["./src/util/hotkeys.ts"],"sourcesContent":["/**\n * These helpers provide a consistent way to:\n * - Normalize user-defined hotkey strings (e.g. \"cmd+k\", \"ctrl+shift+p\")\n * - Normalize `KeyboardEvent`s into the same canonical hotkey format\n * - Detect when a keyboard event likely originated from a text-input context\n *\n * **Canonical format**\n * - Modifiers are ordered: `meta`, `ctrl`, `alt`, `shift`\n * - Tokens are joined with `+`\n * - The final token is the non-modifier key\n *\n * Examples:\n * - `\"cmd+k\"` → `\"meta+k\"`\n * - `\"return\"` → `\"enter\"`\n * - `\"backspace\"` → `\"delete\"`\n * - `\"alt+shift+l\"` → `\"alt+shift+l\"`\n */\nconst NORMALIZED_HOTKEY_SEPARATOR = '+';\n\nexport const tokenizeHotkeyString = (hotkey: string): string[] => {\n    const raw = (hotkey ?? '').trim();\n    if (!raw) {\n        return [];\n    }\n\n    // Allow `+` as a hotkey.\n    if (raw === '+') {\n        return ['+'];\n    }\n\n    // Split on `+`, but treat `++` as the `+` key.\n    const tokens: string[] = [];\n    let current = '';\n    let index = 0;\n\n    while (index < raw.length) {\n        const char = raw[index];\n        if (char !== '+') {\n            current += char;\n            index++;\n            continue;\n        }\n\n        const nextChar = raw[index + 1];\n        if (nextChar === '+') {\n            const token = current.trim();\n            if (token) {\n                tokens.push(token);\n            }\n            tokens.push('+');\n            current = '';\n            index += 2;\n            continue;\n        }\n\n        const token = current.trim();\n        if (token) {\n            tokens.push(token);\n        }\n        current = '';\n        index++;\n    }\n\n    const tail = current.trim();\n    if (tail) {\n        tokens.push(tail);\n    }\n\n    return tokens;\n};\n\nconst normalizeKey = (key: string): string | null => {\n    const normalized = key.trim().toLowerCase();\n    if (!normalized) {\n        return null;\n    }\n\n    const keyAliases: Record<string, string> = {\n        cmd: 'meta',\n        command: 'meta',\n        win: 'meta',\n        windows: 'meta',\n        option: 'alt',\n        esc: 'escape',\n        return: 'enter',\n        del: 'delete',\n        backspace: 'delete',\n        up: 'arrowup',\n        down: 'arrowdown',\n        left: 'arrowleft',\n        right: 'arrowright',\n        spacebar: 'space',\n    };\n\n    if (keyAliases[normalized]) {\n        return keyAliases[normalized];\n    }\n\n    if (/^f\\d{1,2}$/.test(normalized)) {\n        return normalized;\n    }\n\n    return normalized;\n};\n\nconst normalizeModifiersAndKey = (input: {\n    key: string;\n    alt: boolean;\n    ctrl: boolean;\n    meta: boolean;\n    shift: boolean;\n}): string | null => {\n    const normalizedKey = normalizeKey(input.key);\n    if (!normalizedKey) {\n        return null;\n    }\n\n    // Ignore pure modifier presses\n    if (['shift', 'alt', 'control', 'ctrl', 'meta'].includes(normalizedKey)) {\n        return null;\n    }\n\n    const parts: string[] = [];\n\n    if (input.meta) {\n        parts.push('meta');\n    }\n    if (input.ctrl) {\n        parts.push('ctrl');\n    }\n    if (input.alt) {\n        parts.push('alt');\n    }\n    if (input.shift) {\n        parts.push('shift');\n    }\n\n    parts.push(normalizedKey);\n\n    return parts.join(NORMALIZED_HOTKEY_SEPARATOR);\n};\n\n/**\n * Normalize a user-defined hotkey string to the canonical format.\n *\n * Returns `null` for empty/invalid inputs or if the string only contains\n * modifiers (e.g. `\"ctrl+shift\"`).\n *\n * @param hotkey - User-provided hotkey string.\n */\nexport const normalizeHotkeyString = (hotkey: string): string | null => {\n    if (!hotkey) {\n        return null;\n    }\n\n    const tokens = tokenizeHotkeyString(hotkey);\n    if (tokens.length === 0) {\n        return null;\n    }\n\n    let alt = false;\n    let ctrl = false;\n    let meta = false;\n    let shift = false;\n    let key: string | null = null;\n\n    for (const token of tokens) {\n        const normalized = normalizeKey(token);\n        if (!normalized) {\n            continue;\n        }\n\n        if (normalized === 'alt') {\n            alt = true;\n            continue;\n        }\n        if (normalized === 'ctrl' || normalized === 'control') {\n            ctrl = true;\n            continue;\n        }\n        if (normalized === 'meta') {\n            meta = true;\n            continue;\n        }\n        if (normalized === 'shift') {\n            shift = true;\n            continue;\n        }\n\n        // Last non-modifier wins\n        key = normalized;\n    }\n\n    if (!key) {\n        return null;\n    }\n\n    return normalizeModifiersAndKey({ key, alt, ctrl, meta, shift });\n};\n\nconst normalizeEventKey = (event: KeyboardEvent): string | null => {\n    const code = (event.code || '').trim();\n    if (/^Key[A-Z]$/.test(code)) {\n        return code.slice(3).toLowerCase();\n    }\n\n    if (/^Digit\\d$/.test(code)) {\n        return code.slice(5);\n    }\n\n    const key = event.key;\n\n    if (key === ' ') {\n        return 'space';\n    }\n\n    return normalizeKey(key);\n};\n\n/**\n * Convert a `KeyboardEvent` into a canonical hotkey string.\n *\n * Uses `event.code` when possible for letter/digit keys to avoid\n * layout-dependent results.\n *\n * @param event - Keyboard event to normalize.\n */\nexport const hotkeyFromKeyboardEvent = (\n    event: KeyboardEvent\n): string | null => {\n    const key = normalizeEventKey(event);\n    if (!key) {\n        return null;\n    }\n\n    // `+` typically requires Shift on many keyboard layouts, but users expect to\n    // write hotkeys like `meta++` (⌘+) without explicitly adding `shift`.\n    const shift = key === '+' ? false : event.shiftKey;\n\n    return normalizeModifiersAndKey({\n        key,\n        alt: event.altKey,\n        ctrl: event.ctrlKey,\n        meta: event.metaKey,\n        shift,\n    });\n};\n\nexport const hotkeysMatch = (\n    expected: string,\n    pressed: string,\n    options?: {\n        /**\n         * Treat a configured `meta+…` hotkey as `ctrl+…` when matching.\n         *\n         * This is useful on non-Apple platforms, where the Meta/Win key is\n         * often reserved by the OS and not practical for web-app hotkeys.\n         */\n        treatExpectedMetaAsCtrl?: boolean;\n    }\n): boolean => {\n    if (!expected || !pressed) {\n        return false;\n    }\n\n    if (expected === pressed) {\n        return true;\n    }\n\n    if (!options?.treatExpectedMetaAsCtrl) {\n        return false;\n    }\n\n    const expectedTokens = tokenizeHotkeyString(expected);\n    if (expectedTokens.length <= 1) {\n        return false;\n    }\n\n    const keyToken = expectedTokens.at(-1);\n    if (!keyToken) {\n        return false;\n    }\n    const modifierTokens = expectedTokens.slice(0, -1);\n    const hasMeta = modifierTokens.includes('meta');\n    const hasCtrl = modifierTokens.includes('ctrl');\n    if (!hasMeta || hasCtrl) {\n        return false;\n    }\n\n    const mappedModifierTokens = modifierTokens.map((token) =>\n        token === 'meta' ? 'ctrl' : token\n    );\n    const ctrlEquivalent = [...mappedModifierTokens, keyToken].join(\n        NORMALIZED_HOTKEY_SEPARATOR\n    );\n\n    return ctrlEquivalent === pressed;\n};\n\n/**\n * Check whether a `KeyboardEvent` likely originated from a typing context.\n *\n * Returns `true` for events coming from:\n * - `input`, `textarea`, `select`\n * - `contenteditable` elements\n * - elements with `role=\"textbox\"`\n *\n * @param event - Keyboard event to inspect.\n */\nexport const isKeyboardEventFromTextInput = (event: KeyboardEvent): boolean => {\n    const path =\n        typeof event.composedPath === 'function' ? event.composedPath() : [];\n\n    for (const node of path) {\n        if (!(node instanceof Element)) {\n            continue;\n        }\n\n        if ((node as HTMLElement).isContentEditable) {\n            return true;\n        }\n\n        const tagName = node.tagName;\n        if (\n            tagName === 'INPUT' ||\n            tagName === 'TEXTAREA' ||\n            tagName === 'SELECT'\n        ) {\n            return true;\n        }\n\n        // Common pattern: elements with role=textbox\n        if (node.getAttribute?.('role') === 'textbox') {\n            return true;\n        }\n    }\n\n    return false;\n};\n"],"mappings":"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"}