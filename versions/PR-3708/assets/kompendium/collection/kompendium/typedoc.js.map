{"version":3,"file":"typedoc.js","sourceRoot":"","sources":["../../src/kompendium/typedoc.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n    Application,\n    Reflection,\n    ReflectionKind,\n    DeclarationReflection,\n    TypeDocOptions,\n    CommentTag,\n    TypeDocReader,\n    TSConfigReader,\n} from 'typedoc';\nimport { JsonDocsTag, JsonDocsProp } from '@stencil/core/internal';\nimport {\n    InterfaceDescription,\n    AliasDescription,\n    EnumDescription,\n    EnumMember,\n    TypeDescription,\n    MethodDescription,\n    ParameterDescription,\n    ClassDescription,\n    DecoratorDescription,\n} from '../types';\nimport { existsSync, readFileSync } from 'fs';\nimport * as ts from 'typescript';\n\nexport function parseFile(\n    filename: string,\n    tsconfig?: string,\n): TypeDescription[] {\n    if (!existsSync(filename)) {\n        // eslint-disable-next-line no-console\n        console.warn('typeRoot file does not exist', filename);\n\n        return [];\n    }\n\n    // TypeDoc 0.23 still uses the synchronous API with new Application()\n    const app = new Application();\n\n    const options: Partial<TypeDocOptions> = {\n        entryPoints: [filename],\n        skipErrorChecking: true,\n    };\n\n    if (tsconfig) {\n        options.tsconfig = tsconfig;\n    }\n\n    if (filename.endsWith('.d.ts')) {\n        // TypeDoc 0.23+ handles .d.ts files automatically\n        options.exclude = ['**/+(*test*|node_modules)/**'];\n    }\n\n    app.options.addReader(new TypeDocReader());\n    app.options.addReader(new TSConfigReader());\n    app.bootstrap(options);\n\n    const project = app.convert();\n    if (!project) {\n        // eslint-disable-next-line no-console\n        console.warn('Could not find any type information');\n\n        return [];\n    }\n\n    const data: TypeDescription[] = [];\n    project.traverse(traverseCallback(data));\n\n    return data;\n}\n\nconst fns = {\n    [ReflectionKind.Interface]: addInterface,\n    [ReflectionKind.Class]: addClass,\n    [ReflectionKind.TypeAlias]: addType,\n    [ReflectionKind.Enum]: addEnum,\n    [ReflectionKind.EnumMember]: addEnumMember,\n};\n\nconst traverseCallback = (data: any) => (reflection: Reflection) => {\n    const fn = fns[reflection.kind];\n    if (fn) {\n        fn(reflection, data);\n    } else {\n        reflection.traverse(traverseCallback(data));\n    }\n};\n\nfunction addInterface(\n    reflection: DeclarationReflection,\n    data: InterfaceDescription[],\n) {\n    // TypeDoc 0.23+ handles exports differently, removed isExported check\n\n    data.push({\n        type: 'interface',\n        name: reflection.name,\n        typeParams: getTypeParams(reflection),\n        docs: getDocs(reflection),\n        docsTags: getDocsTags(reflection),\n        props: reflection.children?.filter(isProperty).map(getProperty) || [],\n        methods: reflection.children?.filter(isMethod).map(getMethod) || [],\n        sources: getSources(reflection),\n    });\n}\n\nfunction addClass(reflection: DeclarationReflection, data: ClassDescription[]) {\n    // TypeDoc 0.23+ handles exports differently, removed isExported check\n\n    // Get decorators from AST if available, otherwise return empty array\n    const decorators = getDecorators(reflection);\n\n    // Get implemented interfaces for @inheritDoc resolution\n    const implementedInterfaces = getImplementedInterfaces(reflection);\n\n    data.push({\n        type: 'class',\n        name: reflection.name,\n        typeParams: getTypeParams(reflection),\n        docs: getDocs(reflection),\n        docsTags: getDocsTags(reflection),\n        props:\n            reflection.children\n                ?.filter(isProperty)\n                .map((prop) =>\n                    getPropertyWithInheritDoc(prop, implementedInterfaces),\n                ) || [],\n        methods:\n            reflection.children\n                ?.filter(isMethod)\n                .map((method) =>\n                    getMethodWithInheritDoc(method, implementedInterfaces),\n                ) || [],\n        sources: getSources(reflection),\n        decorators: decorators,\n    });\n}\n\nfunction addType(reflection: DeclarationReflection, data: AliasDescription[]) {\n    // TypeDoc 0.23+ handles exports differently, removed isExported check\n\n    data.push({\n        type: 'alias',\n        name: reflection.name,\n        docs: getDocs(reflection),\n        docsTags: getDocsTags(reflection),\n        alias: reflection.type.toString(),\n        sources: getSources(reflection),\n    });\n}\n\nfunction addEnum(reflection: DeclarationReflection, data: EnumDescription[]) {\n    // TypeDoc 0.23+ handles exports differently, removed isExported check\n\n    const members = [];\n    reflection.traverse(traverseCallback(members));\n\n    data.push({\n        type: 'enum',\n        name: reflection.name,\n        docs: getDocs(reflection),\n        docsTags: getDocsTags(reflection),\n        members: members,\n        sources: getSources(reflection),\n    });\n}\n\nfunction addEnumMember(reflection: DeclarationReflection, data: EnumMember[]) {\n    // TypeDoc 0.23+ stores enum values in type.value instead of defaultValue\n    let value: string;\n    // TypeDoc 0.23 types don't include 'type' and 'value' properties on reflection types\n    // These properties exist at runtime for literal types but aren't in TypeScript definitions\n    if (reflection.type && (reflection.type as any).type === 'literal') {\n        const literalValue = (reflection.type as any).value;\n        if (typeof literalValue === 'string') {\n            value = `\"${literalValue}\"`;\n        } else {\n            value = String(literalValue);\n        }\n    } else {\n        value = reflection.defaultValue;\n    }\n\n    data.push({\n        name: reflection.name,\n        docs: getDocs(reflection),\n        docsTags: getDocsTags(reflection),\n        value: value,\n    });\n}\n\nfunction getDocs(reflection: Reflection): string {\n    if (!reflection.comment) {\n        return '';\n    }\n\n    // TypeDoc 0.23+ uses summary instead of shortText/text\n    const text =\n        reflection.comment.summary\n            ?.map((part: any) => part.text)\n            .join('')\n            .trim() || '';\n\n    // Normalize multiple newlines to single newlines\n    return text.replace(/\\n\\n+/g, '\\n');\n}\n\nfunction getDocsTags(reflection: DeclarationReflection) {\n    // TypeDoc 0.23+ uses blockTags instead of tags\n    return reflection.comment?.blockTags?.map(getTag) || [];\n}\n\nfunction getTag(tag: CommentTag): JsonDocsTag {\n    // TypeDoc 0.23+ uses tag and content instead of tagName and text\n    // tag already has @ prefix in TypeDoc 0.23, so remove it\n    const tagName = (tag.tag as string).replace(/^@+/, '');\n\n    return {\n        name: tagName,\n        text:\n            tag.content\n                ?.map((part: any) => part.text)\n                .join('')\n                .trim() || '',\n    };\n}\n\nfunction isProperty(reflection: DeclarationReflection): boolean {\n    // TypeDoc 0.23+ uses ReflectionType with signatures for functions\n    if (reflection.kind !== ReflectionKind.Property) {\n        return false;\n    }\n\n    // TypeDoc types don't expose 'type' and 'declaration' properties on reflection.type\n    // These exist at runtime but require type assertion to access\n    const type = reflection.type as any;\n\n    return !(\n        type &&\n        type.type === 'reflection' &&\n        type.declaration?.signatures\n    );\n}\n\nfunction isMethod(reflection: DeclarationReflection): boolean {\n    // TypeDoc 0.23+ uses ReflectionType with signatures for functions\n    if (reflection.kind !== ReflectionKind.Property) {\n        return false;\n    }\n\n    // TypeDoc types don't expose 'type' and 'declaration' properties on reflection.type\n    // These exist at runtime but require type assertion to access\n    const type = reflection.type as any;\n\n    return type && type.type === 'reflection' && type.declaration?.signatures;\n}\n\nfunction getProperty(reflection: DeclarationReflection): Partial<JsonDocsProp> {\n    return {\n        name: reflection.name,\n        type: reflection.type.toString(),\n        docs: getDocs(reflection),\n        docsTags: getDocsTags(reflection),\n        default: reflection.defaultValue,\n        optional: reflection.flags.isOptional,\n    };\n}\n\nfunction getMethod(reflection: DeclarationReflection): MethodDescription {\n    // TypeDoc 0.23+ stores method signatures in type.declaration.signatures\n    // TypeDoc types don't expose declaration property, but it exists at runtime\n    const type = reflection.type as any;\n    const signature = type?.declaration?.signatures?.[0];\n\n    if (!signature) {\n        return {\n            name: reflection.name,\n            docs: getDocs(reflection),\n            docsTags: [],\n            parameters: [],\n            returns: { type: 'void', docs: '' },\n        };\n    }\n\n    // Get docs from signature, not from the property\n    let docs =\n        signature.comment?.summary\n            ?.map((part: any) => part.text)\n            .join('')\n            .trim() || '';\n    // Normalize multiple newlines to single newlines\n    docs = docs.replace(/\\n\\n+/g, '\\n');\n\n    // Get parameters\n    const parameters: ParameterDescription[] =\n        signature.parameters?.map((param: any) => ({\n            name: param.name,\n            type: param.type?.toString() || 'any',\n            docs:\n                param.comment?.summary\n                    ?.map((part: any) => part.text)\n                    .join('')\n                    .trim() || '',\n            default: param.defaultValue,\n            optional: param.flags?.isOptional || false,\n        })) || [];\n\n    // Get return type\n    const returnsTag = signature.comment?.blockTags?.find(\n        (tag: any) => tag.tag === '@returns',\n    );\n    const returnsText =\n        returnsTag?.content\n            ?.map((part: any) => part.text)\n            .join('')\n            .trim() || '';\n\n    const returns = {\n        type: signature.type?.toString() || 'void',\n        docs: returnsText,\n    };\n\n    // Get other tags (excluding @param and @returns)\n    const docsTags =\n        signature.comment?.blockTags\n            ?.filter(\n                (tag: any) => tag.tag !== '@param' && tag.tag !== '@returns',\n            )\n            .map(getTag) || [];\n\n    return {\n        name: reflection.name,\n        docs: docs,\n        docsTags: docsTags,\n        parameters: parameters,\n        returns: returns,\n    };\n}\n\nfunction getImplementedInterfaces(\n    reflection: DeclarationReflection,\n): DeclarationReflection[] {\n    const interfaces: DeclarationReflection[] = [];\n\n    // Check if class implements any interfaces\n    // implementedTypes exists on DeclarationReflection at runtime but not in type definitions\n    const implemented = (reflection as any).implementedTypes;\n    if (implemented) {\n        implemented.forEach((type: any) => {\n            if (type.reflection) {\n                interfaces.push(type.reflection);\n            }\n        });\n    }\n\n    return interfaces;\n}\n\nfunction getPropertyWithInheritDoc(\n    reflection: DeclarationReflection,\n    interfaces: DeclarationReflection[],\n): Partial<JsonDocsProp> {\n    const prop = getProperty(reflection);\n\n    // Check for @inheritDoc tag in blockTags\n    const hasInheritDoc = reflection.comment?.blockTags?.some(\n        (tag: any) => tag.tag.toLowerCase() === '@inheritdoc',\n    );\n\n    if (hasInheritDoc && interfaces.length > 0) {\n        // Try to find the property in implemented interfaces\n        for (const iface of interfaces) {\n            const interfaceProp = iface.children?.find(\n                (child) => child.name === reflection.name,\n            );\n            if (interfaceProp) {\n                return {\n                    ...prop,\n                    docs: getDocs(interfaceProp),\n                    docsTags: getDocsTags(interfaceProp),\n                };\n            }\n        }\n    }\n\n    return prop;\n}\n\nfunction getMethodWithInheritDoc(\n    reflection: DeclarationReflection,\n    interfaces: DeclarationReflection[],\n): MethodDescription {\n    // Check for @inheritDoc in the method signature blockTags\n    // TypeDoc types don't expose declaration property, but it exists at runtime\n    const type = reflection.type as any;\n    const signature = type?.declaration?.signatures?.[0];\n    const hasInheritDoc = signature?.comment?.blockTags?.some(\n        (tag: any) => tag.tag.toLowerCase() === '@inheritdoc',\n    );\n\n    if (hasInheritDoc && interfaces.length > 0) {\n        // Try to find the method in implemented interfaces and return its parsed version\n        for (const iface of interfaces) {\n            const interfaceMethod = iface.children?.find(\n                (child) => child.name === reflection.name,\n            );\n            if (interfaceMethod) {\n                return getMethod(interfaceMethod);\n            }\n        }\n    }\n\n    // If no inheritDoc or interface not found, return the method as-is\n    return getMethod(reflection);\n}\n\n/**\n * Extract decorator information from TypeScript source code using AST parsing\n *\n * TypeDoc 0.23 removed the decorators property from DeclarationReflection,\n * which was present in 0.17. This function works around that limitation by\n * parsing the original TypeScript source files to extract decorator information.\n * @param {DeclarationReflection} reflection - The TypeDoc reflection to extract decorators from\n * @returns {DecoratorDescription[]} Array of decorator descriptions with names and arguments\n * @remarks\n * This is a workaround for incomplete TypeDoc 0.23 API. TypeDoc removed\n * decorator information from their reflection model, but decorators are\n * essential for documenting Stencil components (e.g., @Component, @Prop).\n *\n * Performance considerations:\n * - Reads and parses source files on demand (I/O + parsing overhead)\n * - Caches nothing - each call re-parses the file\n * - For large codebases, consider caching parsed source files\n *\n * Known limitations:\n * - Only extracts class-level decorators, not property/method decorators\n * - Decorator arguments are captured as raw text, not parsed\n * - Fails silently if source file is unavailable or parsing fails\n * - Depends on TypeScript AST structure (may break with TS version changes)\n * @example\n * ```typescript\n * // For a class like:\n * @Component({ tag: 'my-component' })\n * class MyComponent { }\n *\n * // Returns:\n * [{\n *   name: 'Component',\n *   arguments: { _config: \"{ tag: 'my-component' }\" }\n * }]\n * ```\n */\nfunction getDecorators(\n    reflection: DeclarationReflection,\n): DecoratorDescription[] {\n    // TypeDoc 0.23+ removed the decorators property\n    // We need to parse decorators from the TypeScript AST\n    if (!reflection.sources || reflection.sources.length === 0) {\n        return [];\n    }\n\n    const source = reflection.sources[0];\n    const fileName = source.fullFileName || source.fileName;\n\n    if (!existsSync(fileName)) {\n        return [];\n    }\n\n    try {\n        const sourceFile = ts.createSourceFile(\n            fileName,\n            readFileSync(fileName, 'utf8'),\n            ts.ScriptTarget.Latest,\n            true,\n        );\n\n        let decorators: DecoratorDescription[] = [];\n\n        const visit = (node: ts.Node): void => {\n            if (\n                ts.isClassDeclaration(node) &&\n                node.name?.getText() === reflection.name\n            ) {\n                // TypeScript 4.x decorators property exists at runtime but varies across TS versions\n                // Using 'as any' because decorator API changed between TS 4.x and 5.x\n                const nodeDecorators = (node as any).decorators;\n                if (nodeDecorators) {\n                    decorators = nodeDecorators.map((decorator: any) => {\n                        const expression = decorator.expression;\n                        let name = '';\n                        let args: any = {};\n\n                        if (ts.isCallExpression(expression)) {\n                            name = expression.expression.getText();\n                            if (expression.arguments.length > 0) {\n                                args = {\n                                    _config: expression.arguments[0].getText(),\n                                };\n                            }\n                        } else {\n                            name = expression.getText();\n                        }\n\n                        return { name: name, arguments: args };\n                    });\n                }\n            }\n\n            ts.forEachChild(node, visit);\n        };\n\n        visit(sourceFile);\n\n        return decorators;\n    } catch (error) {\n        // eslint-disable-next-line no-console\n        console.warn('Failed to parse decorators:', error);\n\n        return [];\n    }\n}\n\nfunction getTypeParams(reflection: DeclarationReflection) {\n    return (\n        reflection.typeParameters?.map((param) => ({\n            name: param.name,\n        })) || []\n    );\n}\n\nfunction getSources(reflection: DeclarationReflection) {\n    // TypeDoc 0.23+ has both fileName (short) and fullFileName (full path)\n    // Convert to relative path from project root\n    return (\n        reflection.sources?.map((source) => {\n            const fullPath = source.fullFileName || source.fileName;\n\n            // WORKAROUND: TypeDoc 0.23 sometimes includes duplicate path prefixes\n            // in fullFileName, e.g., \"src/kompendium/src/kompendium/file.ts\"\n            // This appears to happen when TypeDoc resolves paths through symlinks\n            // or when the project structure has nested TypeScript configs.\n            //\n            // The regex matches paths starting with 'src/kompendium/' and optionally\n            // captures a duplicate 'src/kompendium/' prefix that we then remove.\n            //\n            // Examples:\n            //   \"src/kompendium/src/kompendium/file.ts\" → \"src/kompendium/file.ts\"\n            //   \"src/kompendium/file.ts\" → \"src/kompendium/file.ts\" (unchanged)\n            //\n            // FRAGILE: Hard-codes project structure assumptions. If the project\n            // is renamed or restructured, this regex will need updating.\n            const match = fullPath.match(\n                /src\\/kompendium\\/(?:src\\/kompendium\\/)?.+$/,\n            );\n            if (match) {\n                // Remove duplicate prefix if present\n                return match[0].replace(\n                    /^src\\/kompendium\\/src\\/kompendium\\//,\n                    'src/kompendium/',\n                );\n            }\n\n            return source.fileName;\n        }) || []\n    );\n}\n"]}