import { r as registerInstance, h, a as getElement } from './index-DOaZxWLP.js';
import { a as getAugmentedNamespace, g as getDefaultExportFromCjs } from './_commonjsHelpers-E-ZsRS8r.js';
import { g as getTypes } from './markdown-types-Ajsawr_9.js';

var bail_1;
var hasRequiredBail;

function requireBail () {
	if (hasRequiredBail) return bail_1;
	hasRequiredBail = 1;

	bail_1 = bail;

	function bail(err) {
	  if (err) {
	    throw err
	  }
	}
	return bail_1;
}

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

var isBuffer$1;
var hasRequiredIsBuffer$1;

function requireIsBuffer$1 () {
	if (hasRequiredIsBuffer$1) return isBuffer$1;
	hasRequiredIsBuffer$1 = 1;
	isBuffer$1 = function isBuffer (obj) {
	  return obj != null && obj.constructor != null &&
	    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	};
	return isBuffer$1;
}

var extend;
var hasRequiredExtend;

function requireExtend () {
	if (hasRequiredExtend) return extend;
	hasRequiredExtend = 1;

	var hasOwn = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var defineProperty = Object.defineProperty;
	var gOPD = Object.getOwnPropertyDescriptor;

	var isArray = function isArray(arr) {
		if (typeof Array.isArray === 'function') {
			return Array.isArray(arr);
		}

		return toStr.call(arr) === '[object Array]';
	};

	var isPlainObject = function isPlainObject(obj) {
		if (!obj || toStr.call(obj) !== '[object Object]') {
			return false;
		}

		var hasOwnConstructor = hasOwn.call(obj, 'constructor');
		var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
		// Not own constructor property must be Object
		if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
		var key;
		for (key in obj) { /**/ }

		return typeof key === 'undefined' || hasOwn.call(obj, key);
	};

	// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
	var setProperty = function setProperty(target, options) {
		if (defineProperty && options.name === '__proto__') {
			defineProperty(target, options.name, {
				enumerable: true,
				configurable: true,
				value: options.newValue,
				writable: true
			});
		} else {
			target[options.name] = options.newValue;
		}
	};

	// Return undefined instead of __proto__ if '__proto__' is not an own property
	var getProperty = function getProperty(obj, name) {
		if (name === '__proto__') {
			if (!hasOwn.call(obj, name)) {
				return void 0;
			} else if (gOPD) {
				// In early versions of node, obj['__proto__'] is buggy when obj has
				// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
				return gOPD(obj, name).value;
			}
		}

		return obj[name];
	};

	extend = function extend() {
		var options, name, src, copy, copyIsArray, clone;
		var target = arguments[0];
		var i = 1;
		var length = arguments.length;
		var deep = false;

		// Handle a deep copy situation
		if (typeof target === 'boolean') {
			deep = target;
			target = arguments[1] || {};
			// skip the boolean and the target
			i = 2;
		}
		if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
			target = {};
		}

		for (; i < length; ++i) {
			options = arguments[i];
			// Only deal with non-null/undefined values
			if (options != null) {
				// Extend the base object
				for (name in options) {
					src = getProperty(target, name);
					copy = getProperty(options, name);

					// Prevent never-ending loop
					if (target !== copy) {
						// Recurse if we're merging plain objects or arrays
						if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
							if (copyIsArray) {
								copyIsArray = false;
								clone = src && isArray(src) ? src : [];
							} else {
								clone = src && isPlainObject(src) ? src : {};
							}

							// Never move original objects, clone them
							setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

						// Don't bring in undefined values
						} else if (typeof copy !== 'undefined') {
							setProperty(target, { name: name, newValue: copy });
						}
					}
				}
			}
		}

		// Return the modified object
		return target;
	};
	return extend;
}

var isPlainObj;
var hasRequiredIsPlainObj;

function requireIsPlainObj () {
	if (hasRequiredIsPlainObj) return isPlainObj;
	hasRequiredIsPlainObj = 1;

	isPlainObj = value => {
		if (Object.prototype.toString.call(value) !== '[object Object]') {
			return false;
		}

		const prototype = Object.getPrototypeOf(value);
		return prototype === null || prototype === Object.prototype;
	};
	return isPlainObj;
}

var wrap_1$1;
var hasRequiredWrap$1;

function requireWrap$1 () {
	if (hasRequiredWrap$1) return wrap_1$1;
	hasRequiredWrap$1 = 1;

	var slice = [].slice;

	wrap_1$1 = wrap;

	// Wrap `fn`.
	// Can be sync or async; return a promise, receive a completion handler, return
	// new values and errors.
	function wrap(fn, callback) {
	  var invoked;

	  return wrapped

	  function wrapped() {
	    var params = slice.call(arguments, 0);
	    var callback = fn.length > params.length;
	    var result;

	    if (callback) {
	      params.push(done);
	    }

	    try {
	      result = fn.apply(null, params);
	    } catch (error) {
	      // Well, this is quite the pickle.
	      // `fn` received a callback and invoked it (thus continuing the pipeline),
	      // but later also threw an error.
	      // We’re not about to restart the pipeline again, so the only thing left
	      // to do is to throw the thing instead.
	      if (callback && invoked) {
	        throw error
	      }

	      return done(error)
	    }

	    if (!callback) {
	      if (result && typeof result.then === 'function') {
	        result.then(then, done);
	      } else if (result instanceof Error) {
	        done(result);
	      } else {
	        then(result);
	      }
	    }
	  }

	  // Invoke `next`, only once.
	  function done() {
	    if (!invoked) {
	      invoked = true;

	      callback.apply(null, arguments);
	    }
	  }

	  // Invoke `done` with one value.
	  // Tracks if an error is passed, too.
	  function then(value) {
	    done(null, value);
	  }
	}
	return wrap_1$1;
}

var trough_1;
var hasRequiredTrough;

function requireTrough () {
	if (hasRequiredTrough) return trough_1;
	hasRequiredTrough = 1;

	var wrap = requireWrap$1();

	trough_1 = trough;

	trough.wrap = wrap;

	var slice = [].slice;

	// Create new middleware.
	function trough() {
	  var fns = [];
	  var middleware = {};

	  middleware.run = run;
	  middleware.use = use;

	  return middleware

	  // Run `fns`.  Last argument must be a completion handler.
	  function run() {
	    var index = -1;
	    var input = slice.call(arguments, 0, -1);
	    var done = arguments[arguments.length - 1];

	    if (typeof done !== 'function') {
	      throw new Error('Expected function as last argument, not ' + done)
	    }

	    next.apply(null, [null].concat(input));

	    // Run the next `fn`, if any.
	    function next(err) {
	      var fn = fns[++index];
	      var params = slice.call(arguments, 0);
	      var values = params.slice(1);
	      var length = input.length;
	      var pos = -1;

	      if (err) {
	        done(err);
	        return
	      }

	      // Copy non-nully input into values.
	      while (++pos < length) {
	        if (values[pos] === null || values[pos] === undefined) {
	          values[pos] = input[pos];
	        }
	      }

	      input = values;

	      // Next or done.
	      if (fn) {
	        wrap(fn, next).apply(null, input);
	      } else {
	        done.apply(null, [null].concat(input));
	      }
	    }
	  }

	  // Add `fn` to the list.
	  function use(fn) {
	    if (typeof fn !== 'function') {
	      throw new Error('Expected `fn` to be a function, not ' + fn)
	    }

	    fns.push(fn);

	    return middleware
	  }
	}
	return trough_1;
}

var unistUtilStringifyPosition;
var hasRequiredUnistUtilStringifyPosition;

function requireUnistUtilStringifyPosition () {
	if (hasRequiredUnistUtilStringifyPosition) return unistUtilStringifyPosition;
	hasRequiredUnistUtilStringifyPosition = 1;

	var own = {}.hasOwnProperty;

	unistUtilStringifyPosition = stringify;

	function stringify(value) {
	  // Nothing.
	  if (!value || typeof value !== 'object') {
	    return ''
	  }

	  // Node.
	  if (own.call(value, 'position') || own.call(value, 'type')) {
	    return position(value.position)
	  }

	  // Position.
	  if (own.call(value, 'start') || own.call(value, 'end')) {
	    return position(value)
	  }

	  // Point.
	  if (own.call(value, 'line') || own.call(value, 'column')) {
	    return point(value)
	  }

	  // ?
	  return ''
	}

	function point(point) {
	  if (!point || typeof point !== 'object') {
	    point = {};
	  }

	  return index(point.line) + ':' + index(point.column)
	}

	function position(pos) {
	  if (!pos || typeof pos !== 'object') {
	    pos = {};
	  }

	  return point(pos.start) + '-' + point(pos.end)
	}

	function index(value) {
	  return value && typeof value === 'number' ? value : 1
	}
	return unistUtilStringifyPosition;
}

var vfileMessage;
var hasRequiredVfileMessage;

function requireVfileMessage () {
	if (hasRequiredVfileMessage) return vfileMessage;
	hasRequiredVfileMessage = 1;

	var stringify = requireUnistUtilStringifyPosition();

	vfileMessage = VMessage;

	// Inherit from `Error#`.
	function VMessagePrototype() {}
	VMessagePrototype.prototype = Error.prototype;
	VMessage.prototype = new VMessagePrototype();

	// Message properties.
	var proto = VMessage.prototype;

	proto.file = '';
	proto.name = '';
	proto.reason = '';
	proto.message = '';
	proto.stack = '';
	proto.fatal = null;
	proto.column = null;
	proto.line = null;

	// Construct a new VMessage.
	//
	// Note: We cannot invoke `Error` on the created context, as that adds readonly
	// `line` and `column` attributes on Safari 9, thus throwing and failing the
	// data.
	function VMessage(reason, position, origin) {
	  var parts;
	  var range;
	  var location;

	  if (typeof position === 'string') {
	    origin = position;
	    position = null;
	  }

	  parts = parseOrigin(origin);
	  range = stringify(position) || '1:1';

	  location = {
	    start: {line: null, column: null},
	    end: {line: null, column: null}
	  };

	  // Node.
	  if (position && position.position) {
	    position = position.position;
	  }

	  if (position) {
	    // Position.
	    if (position.start) {
	      location = position;
	      position = position.start;
	    } else {
	      // Point.
	      location.start = position;
	    }
	  }

	  if (reason.stack) {
	    this.stack = reason.stack;
	    reason = reason.message;
	  }

	  this.message = reason;
	  this.name = range;
	  this.reason = reason;
	  this.line = position ? position.line : null;
	  this.column = position ? position.column : null;
	  this.location = location;
	  this.source = parts[0];
	  this.ruleId = parts[1];
	}

	function parseOrigin(origin) {
	  var result = [null, null];
	  var index;

	  if (typeof origin === 'string') {
	    index = origin.indexOf(':');

	    if (index === -1) {
	      result[1] = origin;
	    } else {
	      result[0] = origin.slice(0, index);
	      result[1] = origin.slice(index + 1);
	    }
	  }

	  return result
	}
	return vfileMessage;
}

var global$1 = (typeof global !== "undefined" ? global :
  typeof self !== "undefined" ? self :
  typeof window !== "undefined" ? window : {});

// shim for using process in browser
// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === 'function') {
    cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === 'function') {
    cachedClearTimeout = clearTimeout;
}

function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
}
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
var title = 'browser';
var platform = 'browser';
var browser = true;
var env = {};
var argv = [];
var version = ''; // empty string to avoid regexp issues
var versions = {};
var release = {};
var config = {};

function noop() {}

var on = noop;
var addListener = noop;
var once = noop;
var off = noop;
var removeListener = noop;
var removeAllListeners = noop;
var emit = noop;

function binding(name) {
    throw new Error('process.binding is not supported');
}

function cwd () { return '/' }
function chdir (dir) {
    throw new Error('process.chdir is not supported');
}function umask() { return 0; }

// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
var performance = global$1.performance || {};
var performanceNow =
  performance.now        ||
  performance.mozNow     ||
  performance.msNow      ||
  performance.oNow       ||
  performance.webkitNow  ||
  function(){ return (new Date()).getTime() };

// generate timestamp or delta
// see http://nodejs.org/api/process.html#process_process_hrtime
function hrtime(previousTimestamp){
  var clocktime = performanceNow.call(performance)*1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor((clocktime%1)*1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds<0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds,nanoseconds]
}

var startTime = new Date();
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1000;
}

var browser$1 = {
  nextTick: nextTick,
  title: title,
  browser: browser,
  env: env,
  argv: argv,
  version: version,
  versions: versions,
  on: on,
  addListener: addListener,
  once: once,
  off: off,
  removeListener: removeListener,
  removeAllListeners: removeAllListeners,
  emit: emit,
  binding: binding,
  cwd: cwd,
  chdir: chdir,
  umask: umask,
  hrtime: hrtime,
  platform: platform,
  release: release,
  config: config,
  uptime: uptime
};

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
function resolve() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : '/';

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
}
// path.normalize(path)
// posix version
function normalize(path) {
  var isPathAbsolute = isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isPathAbsolute).join('/');

  if (!path && !isPathAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isPathAbsolute ? '/' : '') + path;
}
// posix version
function isAbsolute(path) {
  return path.charAt(0) === '/';
}

// posix version
function join() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
}


// path.relative(from, to)
// posix version
function relative(from, to) {
  from = resolve(from).substr(1);
  to = resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
}

var sep = '/';
var delimiter = ':';

function dirname(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
}

function basename(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
}


function extname(path) {
  return splitPath(path)[3];
}
var _polyfillNode_path = {
  extname: extname,
  basename: basename,
  dirname: dirname,
  sep: sep,
  delimiter: delimiter,
  relative: relative,
  join: join,
  isAbsolute: isAbsolute,
  normalize: normalize,
  resolve: resolve
};
function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b' ?
    function (str, start, len) { return str.substr(start, len) } :
    function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

var _polyfillNode_path$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  basename: basename,
  default: _polyfillNode_path,
  delimiter: delimiter,
  dirname: dirname,
  extname: extname,
  isAbsolute: isAbsolute,
  join: join,
  normalize: normalize,
  relative: relative,
  resolve: resolve,
  sep: sep
});

var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_path$1);

var replaceExt_1;
var hasRequiredReplaceExt;

function requireReplaceExt () {
	if (hasRequiredReplaceExt) return replaceExt_1;
	hasRequiredReplaceExt = 1;

	var path = require$$0$1;

	function replaceExt(npath, ext) {
	  if (typeof npath !== 'string') {
	    return npath;
	  }

	  if (npath.length === 0) {
	    return npath;
	  }

	  var nFileName = path.basename(npath, path.extname(npath)) + ext;
	  return path.join(path.dirname(npath), nFileName);
	}

	replaceExt_1 = replaceExt;
	return replaceExt_1;
}

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

var isBuffer;
var hasRequiredIsBuffer;

function requireIsBuffer () {
	if (hasRequiredIsBuffer) return isBuffer;
	hasRequiredIsBuffer = 1;
	isBuffer = function isBuffer (obj) {
	  return obj != null && obj.constructor != null &&
	    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	};
	return isBuffer;
}

var core$1;
var hasRequiredCore$1;

function requireCore$1 () {
	if (hasRequiredCore$1) return core$1;
	hasRequiredCore$1 = 1;

	var path = require$$0$1;
	var replace = requireReplaceExt();
	var buffer = requireIsBuffer();

	core$1 = VFile;

	var own = {}.hasOwnProperty;
	var proto = VFile.prototype;

	// Order of setting (least specific to most), we need this because otherwise
	// `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a
	// stem can be set.
	var order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname'];

	proto.toString = toString;

	// Access full path (`~/index.min.js`).
	Object.defineProperty(proto, 'path', {get: getPath, set: setPath});

	// Access parent path (`~`).
	Object.defineProperty(proto, 'dirname', {get: getDirname, set: setDirname});

	// Access basename (`index.min.js`).
	Object.defineProperty(proto, 'basename', {get: getBasename, set: setBasename});

	// Access extname (`.js`).
	Object.defineProperty(proto, 'extname', {get: getExtname, set: setExtname});

	// Access stem (`index.min`).
	Object.defineProperty(proto, 'stem', {get: getStem, set: setStem});

	// Construct a new file.
	function VFile(options) {
	  var prop;
	  var index;
	  var length;

	  if (!options) {
	    options = {};
	  } else if (typeof options === 'string' || buffer(options)) {
	    options = {contents: options};
	  } else if ('message' in options && 'messages' in options) {
	    return options
	  }

	  if (!(this instanceof VFile)) {
	    return new VFile(options)
	  }

	  this.data = {};
	  this.messages = [];
	  this.history = [];
	  this.cwd = browser$1.cwd();

	  // Set path related properties in the correct order.
	  index = -1;
	  length = order.length;

	  while (++index < length) {
	    prop = order[index];

	    if (own.call(options, prop)) {
	      this[prop] = options[prop];
	    }
	  }

	  // Set non-path related properties.
	  for (prop in options) {
	    if (order.indexOf(prop) === -1) {
	      this[prop] = options[prop];
	    }
	  }
	}

	function getPath() {
	  return this.history[this.history.length - 1]
	}

	function setPath(path) {
	  assertNonEmpty(path, 'path');

	  if (path !== this.path) {
	    this.history.push(path);
	  }
	}

	function getDirname() {
	  return typeof this.path === 'string' ? path.dirname(this.path) : undefined
	}

	function setDirname(dirname) {
	  assertPath(this.path, 'dirname');
	  this.path = path.join(dirname || '', this.basename);
	}

	function getBasename() {
	  return typeof this.path === 'string' ? path.basename(this.path) : undefined
	}

	function setBasename(basename) {
	  assertNonEmpty(basename, 'basename');
	  assertPart(basename, 'basename');
	  this.path = path.join(this.dirname || '', basename);
	}

	function getExtname() {
	  return typeof this.path === 'string' ? path.extname(this.path) : undefined
	}

	function setExtname(extname) {
	  var ext = extname || '';

	  assertPart(ext, 'extname');
	  assertPath(this.path, 'extname');

	  if (ext) {
	    if (ext.charAt(0) !== '.') {
	      throw new Error('`extname` must start with `.`')
	    }

	    if (ext.indexOf('.', 1) !== -1) {
	      throw new Error('`extname` cannot contain multiple dots')
	    }
	  }

	  this.path = replace(this.path, ext);
	}

	function getStem() {
	  return typeof this.path === 'string'
	    ? path.basename(this.path, this.extname)
	    : undefined
	}

	function setStem(stem) {
	  assertNonEmpty(stem, 'stem');
	  assertPart(stem, 'stem');
	  this.path = path.join(this.dirname || '', stem + (this.extname || ''));
	}

	// Get the value of the file.
	function toString(encoding) {
	  var value = this.contents || '';
	  return buffer(value) ? value.toString(encoding) : String(value)
	}

	// Assert that `part` is not a path (i.e., does not contain `path.sep`).
	function assertPart(part, name) {
	  if (part.indexOf(path.sep) !== -1) {
	    throw new Error(
	      '`' + name + '` cannot be a path: did not expect `' + path.sep + '`'
	    )
	  }
	}

	// Assert that `part` is not empty.
	function assertNonEmpty(part, name) {
	  if (!part) {
	    throw new Error('`' + name + '` cannot be empty')
	  }
	}

	// Assert `path` exists.
	function assertPath(path, name) {
	  if (!path) {
	    throw new Error('Setting `' + name + '` requires `path` to be set too')
	  }
	}
	return core$1;
}

var vfile;
var hasRequiredVfile;

function requireVfile () {
	if (hasRequiredVfile) return vfile;
	hasRequiredVfile = 1;

	var VMessage = requireVfileMessage();
	var VFile = requireCore$1();

	vfile = VFile;

	var proto = VFile.prototype;

	proto.message = message;
	proto.info = info;
	proto.fail = fail;

	// Create a message with `reason` at `position`.
	// When an error is passed in as `reason`, copies the stack.
	function message(reason, position, origin) {
	  var filePath = this.path;
	  var message = new VMessage(reason, position, origin);

	  if (filePath) {
	    message.name = filePath + ':' + message.name;
	    message.file = filePath;
	  }

	  message.fatal = false;

	  this.messages.push(message);

	  return message
	}

	// Fail: creates a vmessage, associates it with the file, and throws it.
	function fail() {
	  var message = this.message.apply(this, arguments);

	  message.fatal = true;

	  throw message
	}

	// Info: creates a vmessage, associates it with the file, and marks the fatality
	// as null.
	function info() {
	  var message = this.message.apply(this, arguments);

	  message.fatal = null;

	  return message
	}
	return vfile;
}

var unified_1$1;
var hasRequiredUnified$1;

function requireUnified$1 () {
	if (hasRequiredUnified$1) return unified_1$1;
	hasRequiredUnified$1 = 1;

	var bail = requireBail();
	var buffer = requireIsBuffer$1();
	var extend = requireExtend();
	var plain = requireIsPlainObj();
	var trough = requireTrough();
	var vfile = requireVfile();

	// Expose a frozen processor.
	unified_1$1 = unified().freeze();

	var slice = [].slice;
	var own = {}.hasOwnProperty;

	// Process pipeline.
	var pipeline = trough()
	  .use(pipelineParse)
	  .use(pipelineRun)
	  .use(pipelineStringify);

	function pipelineParse(p, ctx) {
	  ctx.tree = p.parse(ctx.file);
	}

	function pipelineRun(p, ctx, next) {
	  p.run(ctx.tree, ctx.file, done);

	  function done(err, tree, file) {
	    if (err) {
	      next(err);
	    } else {
	      ctx.tree = tree;
	      ctx.file = file;
	      next();
	    }
	  }
	}

	function pipelineStringify(p, ctx) {
	  var result = p.stringify(ctx.tree, ctx.file);
	  var file = ctx.file;

	  if (result === undefined || result === null) ; else if (typeof result === 'string' || buffer(result)) {
	    file.contents = result;
	  } else {
	    file.result = result;
	  }
	}

	// Function to create the first processor.
	function unified() {
	  var attachers = [];
	  var transformers = trough();
	  var namespace = {};
	  var frozen = false;
	  var freezeIndex = -1;

	  // Data management.
	  processor.data = data;

	  // Lock.
	  processor.freeze = freeze;

	  // Plugins.
	  processor.attachers = attachers;
	  processor.use = use;

	  // API.
	  processor.parse = parse;
	  processor.stringify = stringify;
	  processor.run = run;
	  processor.runSync = runSync;
	  processor.process = process;
	  processor.processSync = processSync;

	  // Expose.
	  return processor

	  // Create a new processor based on the processor in the current scope.
	  function processor() {
	    var destination = unified();
	    var length = attachers.length;
	    var index = -1;

	    while (++index < length) {
	      destination.use.apply(null, attachers[index]);
	    }

	    destination.data(extend(true, {}, namespace));

	    return destination
	  }

	  // Freeze: used to signal a processor that has finished configuration.
	  //
	  // For example, take unified itself: it’s frozen.
	  // Plugins should not be added to it.
	  // Rather, it should be extended, by invoking it, before modifying it.
	  //
	  // In essence, always invoke this when exporting a processor.
	  function freeze() {
	    var values;
	    var plugin;
	    var options;
	    var transformer;

	    if (frozen) {
	      return processor
	    }

	    while (++freezeIndex < attachers.length) {
	      values = attachers[freezeIndex];
	      plugin = values[0];
	      options = values[1];
	      transformer = null;

	      if (options === false) {
	        continue
	      }

	      if (options === true) {
	        values[1] = undefined;
	      }

	      transformer = plugin.apply(processor, values.slice(1));

	      if (typeof transformer === 'function') {
	        transformers.use(transformer);
	      }
	    }

	    frozen = true;
	    freezeIndex = Infinity;

	    return processor
	  }

	  // Data management.
	  // Getter / setter for processor-specific informtion.
	  function data(key, value) {
	    if (typeof key === 'string') {
	      // Set `key`.
	      if (arguments.length === 2) {
	        assertUnfrozen('data', frozen);

	        namespace[key] = value;

	        return processor
	      }

	      // Get `key`.
	      return (own.call(namespace, key) && namespace[key]) || null
	    }

	    // Set space.
	    if (key) {
	      assertUnfrozen('data', frozen);
	      namespace = key;
	      return processor
	    }

	    // Get space.
	    return namespace
	  }

	  // Plugin management.
	  //
	  // Pass it:
	  // *   an attacher and options,
	  // *   a preset,
	  // *   a list of presets, attachers, and arguments (list of attachers and
	  //     options).
	  function use(value) {
	    var settings;

	    assertUnfrozen('use', frozen);

	    if (value === null || value === undefined) ; else if (typeof value === 'function') {
	      addPlugin.apply(null, arguments);
	    } else if (typeof value === 'object') {
	      if ('length' in value) {
	        addList(value);
	      } else {
	        addPreset(value);
	      }
	    } else {
	      throw new Error('Expected usable value, not `' + value + '`')
	    }

	    if (settings) {
	      namespace.settings = extend(namespace.settings || {}, settings);
	    }

	    return processor

	    function addPreset(result) {
	      addList(result.plugins);

	      if (result.settings) {
	        settings = extend(settings || {}, result.settings);
	      }
	    }

	    function add(value) {
	      if (typeof value === 'function') {
	        addPlugin(value);
	      } else if (typeof value === 'object') {
	        if ('length' in value) {
	          addPlugin.apply(null, value);
	        } else {
	          addPreset(value);
	        }
	      } else {
	        throw new Error('Expected usable value, not `' + value + '`')
	      }
	    }

	    function addList(plugins) {
	      var length;
	      var index;

	      if (plugins === null || plugins === undefined) ; else if (typeof plugins === 'object' && 'length' in plugins) {
	        length = plugins.length;
	        index = -1;

	        while (++index < length) {
	          add(plugins[index]);
	        }
	      } else {
	        throw new Error('Expected a list of plugins, not `' + plugins + '`')
	      }
	    }

	    function addPlugin(plugin, value) {
	      var entry = find(plugin);

	      if (entry) {
	        if (plain(entry[1]) && plain(value)) {
	          value = extend(entry[1], value);
	        }

	        entry[1] = value;
	      } else {
	        attachers.push(slice.call(arguments));
	      }
	    }
	  }

	  function find(plugin) {
	    var length = attachers.length;
	    var index = -1;
	    var entry;

	    while (++index < length) {
	      entry = attachers[index];

	      if (entry[0] === plugin) {
	        return entry
	      }
	    }
	  }

	  // Parse a file (in string or vfile representation) into a unist node using
	  // the `Parser` on the processor.
	  function parse(doc) {
	    var file = vfile(doc);
	    var Parser;

	    freeze();
	    Parser = processor.Parser;
	    assertParser('parse', Parser);

	    if (newable(Parser, 'parse')) {
	      return new Parser(String(file), file).parse()
	    }

	    return Parser(String(file), file) // eslint-disable-line new-cap
	  }

	  // Run transforms on a unist node representation of a file (in string or
	  // vfile representation), async.
	  function run(node, file, cb) {
	    assertNode(node);
	    freeze();

	    if (!cb && typeof file === 'function') {
	      cb = file;
	      file = null;
	    }

	    if (!cb) {
	      return new Promise(executor)
	    }

	    executor(null, cb);

	    function executor(resolve, reject) {
	      transformers.run(node, vfile(file), done);

	      function done(err, tree, file) {
	        tree = tree || node;
	        if (err) {
	          reject(err);
	        } else if (resolve) {
	          resolve(tree);
	        } else {
	          cb(null, tree, file);
	        }
	      }
	    }
	  }

	  // Run transforms on a unist node representation of a file (in string or
	  // vfile representation), sync.
	  function runSync(node, file) {
	    var complete = false;
	    var result;

	    run(node, file, done);

	    assertDone('runSync', 'run', complete);

	    return result

	    function done(err, tree) {
	      complete = true;
	      bail(err);
	      result = tree;
	    }
	  }

	  // Stringify a unist node representation of a file (in string or vfile
	  // representation) into a string using the `Compiler` on the processor.
	  function stringify(node, doc) {
	    var file = vfile(doc);
	    var Compiler;

	    freeze();
	    Compiler = processor.Compiler;
	    assertCompiler('stringify', Compiler);
	    assertNode(node);

	    if (newable(Compiler, 'compile')) {
	      return new Compiler(node, file).compile()
	    }

	    return Compiler(node, file) // eslint-disable-line new-cap
	  }

	  // Parse a file (in string or vfile representation) into a unist node using
	  // the `Parser` on the processor, then run transforms on that node, and
	  // compile the resulting node using the `Compiler` on the processor, and
	  // store that result on the vfile.
	  function process(doc, cb) {
	    freeze();
	    assertParser('process', processor.Parser);
	    assertCompiler('process', processor.Compiler);

	    if (!cb) {
	      return new Promise(executor)
	    }

	    executor(null, cb);

	    function executor(resolve, reject) {
	      var file = vfile(doc);

	      pipeline.run(processor, {file: file}, done);

	      function done(err) {
	        if (err) {
	          reject(err);
	        } else if (resolve) {
	          resolve(file);
	        } else {
	          cb(null, file);
	        }
	      }
	    }
	  }

	  // Process the given document (in string or vfile representation), sync.
	  function processSync(doc) {
	    var complete = false;
	    var file;

	    freeze();
	    assertParser('processSync', processor.Parser);
	    assertCompiler('processSync', processor.Compiler);
	    file = vfile(doc);

	    process(file, done);

	    assertDone('processSync', 'process', complete);

	    return file

	    function done(err) {
	      complete = true;
	      bail(err);
	    }
	  }
	}

	// Check if `value` is a constructor.
	function newable(value, name) {
	  return (
	    typeof value === 'function' &&
	    value.prototype &&
	    // A function with keys in its prototype is probably a constructor.
	    // Classes’ prototype methods are not enumerable, so we check if some value
	    // exists in the prototype.
	    (keys(value.prototype) || name in value.prototype)
	  )
	}

	// Check if `value` is an object with keys.
	function keys(value) {
	  var key;
	  for (key in value) {
	    return true
	  }

	  return false
	}

	// Assert a parser is available.
	function assertParser(name, Parser) {
	  if (typeof Parser !== 'function') {
	    throw new Error('Cannot `' + name + '` without `Parser`')
	  }
	}

	// Assert a compiler is available.
	function assertCompiler(name, Compiler) {
	  if (typeof Compiler !== 'function') {
	    throw new Error('Cannot `' + name + '` without `Compiler`')
	  }
	}

	// Assert the processor is not frozen.
	function assertUnfrozen(name, frozen) {
	  if (frozen) {
	    throw new Error(
	      'Cannot invoke `' +
	        name +
	        '` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.'
	    )
	  }
	}

	// Assert `node` is a unist node.
	function assertNode(node) {
	  if (!node || typeof node.type !== 'string') {
	    throw new Error('Expected node, got `' + node + '`')
	  }
	}

	// Assert that `complete` is `true`.
	function assertDone(name, asyncName, complete) {
	  if (!complete) {
	    throw new Error(
	      '`' + name + '` finished async. Use `' + asyncName + '` instead'
	    )
	  }
	}
	return unified_1$1;
}

var unifiedExports = requireUnified$1();
var unified = /*@__PURE__*/getDefaultExportFromCjs(unifiedExports);

var immutable;
var hasRequiredImmutable;

function requireImmutable () {
	if (hasRequiredImmutable) return immutable;
	hasRequiredImmutable = 1;
	immutable = extend;

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	function extend() {
	    var target = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var source = arguments[i];

	        for (var key in source) {
	            if (hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }

	    return target
	}
	return immutable;
}

var inherits_browser = {exports: {}};

var hasRequiredInherits_browser;

function requireInherits_browser () {
	if (hasRequiredInherits_browser) return inherits_browser.exports;
	hasRequiredInherits_browser = 1;
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      ctor.prototype = Object.create(superCtor.prototype, {
	        constructor: {
	          value: ctor,
	          enumerable: false,
	          writable: true,
	          configurable: true
	        }
	      });
	    }
	  };
	} else {
	  // old school shim for old browsers
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      var TempCtor = function () {};
	      TempCtor.prototype = superCtor.prototype;
	      ctor.prototype = new TempCtor();
	      ctor.prototype.constructor = ctor;
	    }
	  };
	}
	return inherits_browser.exports;
}

var unherit_1;
var hasRequiredUnherit;

function requireUnherit () {
	if (hasRequiredUnherit) return unherit_1;
	hasRequiredUnherit = 1;

	var xtend = requireImmutable();
	var inherits = requireInherits_browser();

	unherit_1 = unherit;

	// Create a custom constructor which can be modified without affecting the
	// original class.
	function unherit(Super) {
	  var result;
	  var key;
	  var value;

	  inherits(Of, Super);
	  inherits(From, Of);

	  // Clone values.
	  result = Of.prototype;

	  for (key in result) {
	    value = result[key];

	    if (value && typeof value === 'object') {
	      result[key] = 'concat' in value ? value.concat() : xtend(value);
	    }
	  }

	  return Of

	  // Constructor accepting a single argument, which itself is an `arguments`
	  // object.
	  function From(parameters) {
	    return Super.apply(this, parameters)
	  }

	  // Constructor accepting variadic arguments.
	  function Of() {
	    if (!(this instanceof Of)) {
	      return new From(arguments)
	    }

	    return Super.apply(this, arguments)
	  }
	}
	return unherit_1;
}

var stateToggle;
var hasRequiredStateToggle;

function requireStateToggle () {
	if (hasRequiredStateToggle) return stateToggle;
	hasRequiredStateToggle = 1;

	stateToggle = factory;

	// Construct a state `toggler`: a function which inverses `property` in context
	// based on its current value.
	// The by `toggler` returned function restores that value.
	function factory(key, state, ctx) {
	  return enter

	  function enter() {
	    var context = ctx || this;
	    var current = context[key];

	    context[key] = !state;

	    return exit

	    function exit() {
	      context[key] = current;
	    }
	  }
	}
	return stateToggle;
}

var vfileLocation;
var hasRequiredVfileLocation;

function requireVfileLocation () {
	if (hasRequiredVfileLocation) return vfileLocation;
	hasRequiredVfileLocation = 1;

	vfileLocation = factory;

	function factory(file) {
	  var contents = indices(String(file));

	  return {
	    toPosition: offsetToPositionFactory(contents),
	    toOffset: positionToOffsetFactory(contents)
	  }
	}

	// Factory to get the line and column-based `position` for `offset` in the bound
	// indices.
	function offsetToPositionFactory(indices) {
	  return offsetToPosition

	  // Get the line and column-based `position` for `offset` in the bound indices.
	  function offsetToPosition(offset) {
	    var index = -1;
	    var length = indices.length;

	    if (offset < 0) {
	      return {}
	    }

	    while (++index < length) {
	      if (indices[index] > offset) {
	        return {
	          line: index + 1,
	          column: offset - (indices[index - 1] || 0) + 1,
	          offset: offset
	        }
	      }
	    }

	    return {}
	  }
	}

	// Factory to get the `offset` for a line and column-based `position` in the
	// bound indices.
	function positionToOffsetFactory(indices) {
	  return positionToOffset

	  // Get the `offset` for a line and column-based `position` in the bound
	  // indices.
	  function positionToOffset(position) {
	    var line = position && position.line;
	    var column = position && position.column;

	    if (!isNaN(line) && !isNaN(column) && line - 1 in indices) {
	      return (indices[line - 2] || 0) + column - 1 || 0
	    }

	    return -1
	  }
	}

	// Get indices of line-breaks in `value`.
	function indices(value) {
	  var result = [];
	  var index = value.indexOf('\n');

	  while (index !== -1) {
	    result.push(index + 1);
	    index = value.indexOf('\n', index + 1);
	  }

	  result.push(value.length + 1);

	  return result
	}
	return vfileLocation;
}

var _unescape;
var hasRequired_unescape;

function require_unescape () {
	if (hasRequired_unescape) return _unescape;
	hasRequired_unescape = 1;

	_unescape = factory;

	var backslash = '\\';

	// Factory to de-escape a value, based on a list at `key` in `ctx`.
	function factory(ctx, key) {
	  return unescape

	  // De-escape a string using the expression at `key` in `ctx`.
	  function unescape(value) {
	    var previous = 0;
	    var index = value.indexOf(backslash);
	    var escape = ctx[key];
	    var queue = [];
	    var character;

	    while (index !== -1) {
	      queue.push(value.slice(previous, index));
	      previous = index + 1;
	      character = value.charAt(previous);

	      // If the following character is not a valid escape, add the slash.
	      if (!character || escape.indexOf(character) === -1) {
	        queue.push(backslash);
	      }

	      index = value.indexOf(backslash, previous + 1);
	    }

	    queue.push(value.slice(previous));

	    return queue.join('')
	  }
	}
	return _unescape;
}

const AElig$1 = "Æ";
const AMP = "&";
const Aacute$1 = "Á";
const Acirc$1 = "Â";
const Agrave$1 = "À";
const Aring$1 = "Å";
const Atilde$1 = "Ã";
const Auml$1 = "Ä";
const COPY = "©";
const Ccedil$1 = "Ç";
const ETH$1 = "Ð";
const Eacute$1 = "É";
const Ecirc$1 = "Ê";
const Egrave$1 = "È";
const Euml$1 = "Ë";
const GT = ">";
const Iacute$1 = "Í";
const Icirc$1 = "Î";
const Igrave$1 = "Ì";
const Iuml$1 = "Ï";
const LT = "<";
const Ntilde$1 = "Ñ";
const Oacute$1 = "Ó";
const Ocirc$1 = "Ô";
const Ograve$1 = "Ò";
const Oslash$1 = "Ø";
const Otilde$1 = "Õ";
const Ouml$1 = "Ö";
const QUOT = "\"";
const REG = "®";
const THORN$1 = "Þ";
const Uacute$1 = "Ú";
const Ucirc$1 = "Û";
const Ugrave$1 = "Ù";
const Uuml$1 = "Ü";
const Yacute$1 = "Ý";
const aacute$1 = "á";
const acirc$1 = "â";
const acute$1 = "´";
const aelig$1 = "æ";
const agrave$1 = "à";
const amp$1 = "&";
const aring$1 = "å";
const atilde$1 = "ã";
const auml$1 = "ä";
const brvbar$1 = "¦";
const ccedil$1 = "ç";
const cedil$1 = "¸";
const cent$1 = "¢";
const copy$1 = "©";
const curren$1 = "¤";
const deg$1 = "°";
const divide$1 = "÷";
const eacute$1 = "é";
const ecirc$1 = "ê";
const egrave$1 = "è";
const eth$1 = "ð";
const euml$1 = "ë";
const frac12$1 = "½";
const frac14$1 = "¼";
const frac34$1 = "¾";
const gt$1 = ">";
const iacute$1 = "í";
const icirc$1 = "î";
const iexcl$1 = "¡";
const igrave$1 = "ì";
const iquest$1 = "¿";
const iuml$1 = "ï";
const laquo$1 = "«";
const lt$1 = "<";
const macr$1 = "¯";
const micro$1 = "µ";
const middot$1 = "·";
const nbsp$1 = " ";
const not$1 = "¬";
const ntilde$1 = "ñ";
const oacute$1 = "ó";
const ocirc$1 = "ô";
const ograve$1 = "ò";
const ordf$1 = "ª";
const ordm$1 = "º";
const oslash$1 = "ø";
const otilde$1 = "õ";
const ouml$1 = "ö";
const para$1 = "¶";
const plusmn$1 = "±";
const pound$1 = "£";
const quot$1 = "\"";
const raquo$1 = "»";
const reg$1 = "®";
const sect$1 = "§";
const shy$1 = "­";
const sup1$1 = "¹";
const sup2$1 = "²";
const sup3$1 = "³";
const szlig$1 = "ß";
const thorn$1 = "þ";
const times$1 = "×";
const uacute$1 = "ú";
const ucirc$1 = "û";
const ugrave$1 = "ù";
const uml$1 = "¨";
const uuml$1 = "ü";
const yacute$1 = "ý";
const yen$1 = "¥";
const yuml$1 = "ÿ";
var require$$1$2 = {
	AElig: AElig$1,
	AMP: AMP,
	Aacute: Aacute$1,
	Acirc: Acirc$1,
	Agrave: Agrave$1,
	Aring: Aring$1,
	Atilde: Atilde$1,
	Auml: Auml$1,
	COPY: COPY,
	Ccedil: Ccedil$1,
	ETH: ETH$1,
	Eacute: Eacute$1,
	Ecirc: Ecirc$1,
	Egrave: Egrave$1,
	Euml: Euml$1,
	GT: GT,
	Iacute: Iacute$1,
	Icirc: Icirc$1,
	Igrave: Igrave$1,
	Iuml: Iuml$1,
	LT: LT,
	Ntilde: Ntilde$1,
	Oacute: Oacute$1,
	Ocirc: Ocirc$1,
	Ograve: Ograve$1,
	Oslash: Oslash$1,
	Otilde: Otilde$1,
	Ouml: Ouml$1,
	QUOT: QUOT,
	REG: REG,
	THORN: THORN$1,
	Uacute: Uacute$1,
	Ucirc: Ucirc$1,
	Ugrave: Ugrave$1,
	Uuml: Uuml$1,
	Yacute: Yacute$1,
	aacute: aacute$1,
	acirc: acirc$1,
	acute: acute$1,
	aelig: aelig$1,
	agrave: agrave$1,
	amp: amp$1,
	aring: aring$1,
	atilde: atilde$1,
	auml: auml$1,
	brvbar: brvbar$1,
	ccedil: ccedil$1,
	cedil: cedil$1,
	cent: cent$1,
	copy: copy$1,
	curren: curren$1,
	deg: deg$1,
	divide: divide$1,
	eacute: eacute$1,
	ecirc: ecirc$1,
	egrave: egrave$1,
	eth: eth$1,
	euml: euml$1,
	frac12: frac12$1,
	frac14: frac14$1,
	frac34: frac34$1,
	gt: gt$1,
	iacute: iacute$1,
	icirc: icirc$1,
	iexcl: iexcl$1,
	igrave: igrave$1,
	iquest: iquest$1,
	iuml: iuml$1,
	laquo: laquo$1,
	lt: lt$1,
	macr: macr$1,
	micro: micro$1,
	middot: middot$1,
	nbsp: nbsp$1,
	not: not$1,
	ntilde: ntilde$1,
	oacute: oacute$1,
	ocirc: ocirc$1,
	ograve: ograve$1,
	ordf: ordf$1,
	ordm: ordm$1,
	oslash: oslash$1,
	otilde: otilde$1,
	ouml: ouml$1,
	para: para$1,
	plusmn: plusmn$1,
	pound: pound$1,
	quot: quot$1,
	raquo: raquo$1,
	reg: reg$1,
	sect: sect$1,
	shy: shy$1,
	sup1: sup1$1,
	sup2: sup2$1,
	sup3: sup3$1,
	szlig: szlig$1,
	thorn: thorn$1,
	times: times$1,
	uacute: uacute$1,
	ucirc: ucirc$1,
	ugrave: ugrave$1,
	uml: uml$1,
	uuml: uuml$1,
	yacute: yacute$1,
	yen: yen$1,
	yuml: yuml$1
};

var require$$1$1 = {
	"0": "�",
	"128": "€",
	"130": "‚",
	"131": "ƒ",
	"132": "„",
	"133": "…",
	"134": "†",
	"135": "‡",
	"136": "ˆ",
	"137": "‰",
	"138": "Š",
	"139": "‹",
	"140": "Œ",
	"142": "Ž",
	"145": "‘",
	"146": "’",
	"147": "“",
	"148": "”",
	"149": "•",
	"150": "–",
	"151": "—",
	"152": "˜",
	"153": "™",
	"154": "š",
	"155": "›",
	"156": "œ",
	"158": "ž",
	"159": "Ÿ"
};

var isDecimal;
var hasRequiredIsDecimal;

function requireIsDecimal () {
	if (hasRequiredIsDecimal) return isDecimal;
	hasRequiredIsDecimal = 1;

	isDecimal = decimal;

	// Check if the given character code, or the character code at the first
	// character, is decimal.
	function decimal(character) {
	  var code = typeof character === 'string' ? character.charCodeAt(0) : character;

	  return code >= 48 && code <= 57 /* 0-9 */
	}
	return isDecimal;
}

var isHexadecimal;
var hasRequiredIsHexadecimal;

function requireIsHexadecimal () {
	if (hasRequiredIsHexadecimal) return isHexadecimal;
	hasRequiredIsHexadecimal = 1;

	isHexadecimal = hexadecimal;

	// Check if the given character code, or the character code at the first
	// character, is hexadecimal.
	function hexadecimal(character) {
	  var code = typeof character === 'string' ? character.charCodeAt(0) : character;

	  return (
	    (code >= 97 /* a */ && code <= 102) /* z */ ||
	    (code >= 65 /* A */ && code <= 70) /* Z */ ||
	    (code >= 48 /* A */ && code <= 57) /* Z */
	  )
	}
	return isHexadecimal;
}

var isAlphabetical;
var hasRequiredIsAlphabetical;

function requireIsAlphabetical () {
	if (hasRequiredIsAlphabetical) return isAlphabetical;
	hasRequiredIsAlphabetical = 1;

	isAlphabetical = alphabetical;

	// Check if the given character code, or the character code at the first
	// character, is alphabetical.
	function alphabetical(character) {
	  var code = typeof character === 'string' ? character.charCodeAt(0) : character;

	  return (
	    (code >= 97 && code <= 122) /* a-z */ ||
	    (code >= 65 && code <= 90) /* A-Z */
	  )
	}
	return isAlphabetical;
}

var isAlphanumerical;
var hasRequiredIsAlphanumerical;

function requireIsAlphanumerical () {
	if (hasRequiredIsAlphanumerical) return isAlphanumerical;
	hasRequiredIsAlphanumerical = 1;

	var alphabetical = requireIsAlphabetical();
	var decimal = requireIsDecimal();

	isAlphanumerical = alphanumerical;

	// Check if the given character code, or the character code at the first
	// character, is alphanumerical.
	function alphanumerical(character) {
	  return alphabetical(character) || decimal(character)
	}
	return isAlphanumerical;
}

var decodeEntity_browser;
var hasRequiredDecodeEntity_browser;

function requireDecodeEntity_browser () {
	if (hasRequiredDecodeEntity_browser) return decodeEntity_browser;
	hasRequiredDecodeEntity_browser = 1;

	/* eslint-env browser */

	var el;

	var semicolon = 59; //  ';'

	decodeEntity_browser = decodeEntity;

	function decodeEntity(characters) {
	  var entity = '&' + characters + ';';
	  var char;

	  el = el || document.createElement('i');
	  el.innerHTML = entity;
	  char = el.textContent;

	  // Some entities do not require the closing semicolon (`&not` - for instance),
	  // which leads to situations where parsing the assumed entity of &notit; will
	  // result in the string `¬it;`.  When we encounter a trailing semicolon after
	  // parsing and the entity to decode was not a semicolon (`&semi;`), we can
	  // assume that the matching was incomplete
	  if (char.charCodeAt(char.length - 1) === semicolon && characters !== 'semi') {
	    return false
	  }

	  // If the decoded string is equal to the input, the entity was not valid
	  return char === entity ? false : char
	}
	return decodeEntity_browser;
}

var parseEntities_1;
var hasRequiredParseEntities;

function requireParseEntities () {
	if (hasRequiredParseEntities) return parseEntities_1;
	hasRequiredParseEntities = 1;

	var legacy = require$$1$2;
	var invalid = require$$1$1;
	var decimal = requireIsDecimal();
	var hexadecimal = requireIsHexadecimal();
	var alphanumerical = requireIsAlphanumerical();
	var decodeEntity = requireDecodeEntity_browser();

	parseEntities_1 = parseEntities;

	var own = {}.hasOwnProperty;
	var fromCharCode = String.fromCharCode;
	var noop = Function.prototype;

	// Default settings.
	var defaults = {
	  warning: null,
	  reference: null,
	  text: null,
	  warningContext: null,
	  referenceContext: null,
	  textContext: null,
	  position: {},
	  additional: null,
	  attribute: false,
	  nonTerminated: true
	};

	// Characters.
	var tab = 9; // '\t'
	var lineFeed = 10; // '\n'
	var formFeed = 12; // '\f'
	var space = 32; // ' '
	var ampersand = 38; // '&'
	var semicolon = 59; // ';'
	var lessThan = 60; // '<'
	var equalsTo = 61; // '='
	var numberSign = 35; // '#'
	var uppercaseX = 88; // 'X'
	var lowercaseX = 120; // 'x'
	var replacementCharacter = 65533; // '�'

	// Reference types.
	var name = 'named';
	var hexa = 'hexadecimal';
	var deci = 'decimal';

	// Map of bases.
	var bases = {};

	bases[hexa] = 16;
	bases[deci] = 10;

	// Map of types to tests.
	// Each type of character reference accepts different characters.
	// This test is used to detect whether a reference has ended (as the semicolon
	// is not strictly needed).
	var tests = {};

	tests[name] = alphanumerical;
	tests[deci] = decimal;
	tests[hexa] = hexadecimal;

	// Warning types.
	var namedNotTerminated = 1;
	var numericNotTerminated = 2;
	var namedEmpty = 3;
	var numericEmpty = 4;
	var namedUnknown = 5;
	var numericDisallowed = 6;
	var numericProhibited = 7;

	// Warning messages.
	var messages = {};

	messages[namedNotTerminated] =
	  'Named character references must be terminated by a semicolon';
	messages[numericNotTerminated] =
	  'Numeric character references must be terminated by a semicolon';
	messages[namedEmpty] = 'Named character references cannot be empty';
	messages[numericEmpty] = 'Numeric character references cannot be empty';
	messages[namedUnknown] = 'Named character references must be known';
	messages[numericDisallowed] =
	  'Numeric character references cannot be disallowed';
	messages[numericProhibited] =
	  'Numeric character references cannot be outside the permissible Unicode range';

	// Wrap to ensure clean parameters are given to `parse`.
	function parseEntities(value, options) {
	  var settings = {};
	  var option;
	  var key;

	  if (!options) {
	    options = {};
	  }

	  for (key in defaults) {
	    option = options[key];
	    settings[key] =
	      option === null || option === undefined ? defaults[key] : option;
	  }

	  if (settings.position.indent || settings.position.start) {
	    settings.indent = settings.position.indent || [];
	    settings.position = settings.position.start;
	  }

	  return parse(value, settings)
	}

	// Parse entities.
	// eslint-disable-next-line complexity
	function parse(value, settings) {
	  var additional = settings.additional;
	  var nonTerminated = settings.nonTerminated;
	  var handleText = settings.text;
	  var handleReference = settings.reference;
	  var handleWarning = settings.warning;
	  var textContext = settings.textContext;
	  var referenceContext = settings.referenceContext;
	  var warningContext = settings.warningContext;
	  var pos = settings.position;
	  var indent = settings.indent || [];
	  var length = value.length;
	  var index = 0;
	  var lines = -1;
	  var column = pos.column || 1;
	  var line = pos.line || 1;
	  var queue = '';
	  var result = [];
	  var entityCharacters;
	  var namedEntity;
	  var terminated;
	  var characters;
	  var character;
	  var reference;
	  var following;
	  var warning;
	  var reason;
	  var output;
	  var entity;
	  var begin;
	  var start;
	  var type;
	  var test;
	  var prev;
	  var next;
	  var diff;
	  var end;

	  if (typeof additional === 'string') {
	    additional = additional.charCodeAt(0);
	  }

	  // Cache the current point.
	  prev = now();

	  // Wrap `handleWarning`.
	  warning = handleWarning ? parseError : noop;

	  // Ensure the algorithm walks over the first character and the end
	  // (inclusive).
	  index--;
	  length++;

	  while (++index < length) {
	    // If the previous character was a newline.
	    if (character === lineFeed) {
	      column = indent[lines] || 1;
	    }

	    character = value.charCodeAt(index);

	    if (character === ampersand) {
	      following = value.charCodeAt(index + 1);

	      // The behaviour depends on the identity of the next character.
	      if (
	        following === tab ||
	        following === lineFeed ||
	        following === formFeed ||
	        following === space ||
	        following === ampersand ||
	        following === lessThan ||
	        following !== following ||
	        (additional && following === additional)
	      ) {
	        // Not a character reference.
	        // No characters are consumed, and nothing is returned.
	        // This is not an error, either.
	        queue += fromCharCode(character);
	        column++;

	        continue
	      }

	      start = index + 1;
	      begin = start;
	      end = start;

	      if (following === numberSign) {
	        // Numerical entity.
	        end = ++begin;

	        // The behaviour further depends on the next character.
	        following = value.charCodeAt(end);

	        if (following === uppercaseX || following === lowercaseX) {
	          // ASCII hex digits.
	          type = hexa;
	          end = ++begin;
	        } else {
	          // ASCII digits.
	          type = deci;
	        }
	      } else {
	        // Named entity.
	        type = name;
	      }

	      entityCharacters = '';
	      entity = '';
	      characters = '';
	      test = tests[type];
	      end--;

	      while (++end < length) {
	        following = value.charCodeAt(end);

	        if (!test(following)) {
	          break
	        }

	        characters += fromCharCode(following);

	        // Check if we can match a legacy named reference.
	        // If so, we cache that as the last viable named reference.
	        // This ensures we do not need to walk backwards later.
	        if (type === name && own.call(legacy, characters)) {
	          entityCharacters = characters;
	          entity = legacy[characters];
	        }
	      }

	      terminated = value.charCodeAt(end) === semicolon;

	      if (terminated) {
	        end++;

	        namedEntity = type === name ? decodeEntity(characters) : false;

	        if (namedEntity) {
	          entityCharacters = characters;
	          entity = namedEntity;
	        }
	      }

	      diff = 1 + end - start;

	      if (!terminated && !nonTerminated) ; else if (!characters) {
	        // An empty (possible) entity is valid, unless it’s numeric (thus an
	        // ampersand followed by an octothorp).
	        if (type !== name) {
	          warning(numericEmpty, diff);
	        }
	      } else if (type === name) {
	        // An ampersand followed by anything unknown, and not terminated, is
	        // invalid.
	        if (terminated && !entity) {
	          warning(namedUnknown, 1);
	        } else {
	          // If theres something after an entity name which is not known, cap
	          // the reference.
	          if (entityCharacters !== characters) {
	            end = begin + entityCharacters.length;
	            diff = 1 + end - begin;
	            terminated = false;
	          }

	          // If the reference is not terminated, warn.
	          if (!terminated) {
	            reason = entityCharacters ? namedNotTerminated : namedEmpty;

	            if (settings.attribute) {
	              following = value.charCodeAt(end);

	              if (following === equalsTo) {
	                warning(reason, diff);
	                entity = null;
	              } else if (alphanumerical(following)) {
	                entity = null;
	              } else {
	                warning(reason, diff);
	              }
	            } else {
	              warning(reason, diff);
	            }
	          }
	        }

	        reference = entity;
	      } else {
	        if (!terminated) {
	          // All non-terminated numeric entities are not rendered, and trigger a
	          // warning.
	          warning(numericNotTerminated, diff);
	        }

	        // When terminated and number, parse as either hexadecimal or decimal.
	        reference = parseInt(characters, bases[type]);

	        // Trigger a warning when the parsed number is prohibited, and replace
	        // with replacement character.
	        if (prohibited(reference)) {
	          warning(numericProhibited, diff);
	          reference = fromCharCode(replacementCharacter);
	        } else if (reference in invalid) {
	          // Trigger a warning when the parsed number is disallowed, and replace
	          // by an alternative.
	          warning(numericDisallowed, diff);
	          reference = invalid[reference];
	        } else {
	          // Parse the number.
	          output = '';

	          // Trigger a warning when the parsed number should not be used.
	          if (disallowed(reference)) {
	            warning(numericDisallowed, diff);
	          }

	          // Stringify the number.
	          if (reference > 0xffff) {
	            reference -= 0x10000;
	            output += fromCharCode((reference >>> (10 & 0x3ff)) | 0xd800);
	            reference = 0xdc00 | (reference & 0x3ff);
	          }

	          reference = output + fromCharCode(reference);
	        }
	      }

	      // Found it!
	      // First eat the queued characters as normal text, then eat an entity.
	      if (reference) {
	        flush();

	        prev = now();
	        index = end - 1;
	        column += end - start + 1;
	        result.push(reference);
	        next = now();
	        next.offset++;

	        if (handleReference) {
	          handleReference.call(
	            referenceContext,
	            reference,
	            {start: prev, end: next},
	            value.slice(start - 1, end)
	          );
	        }

	        prev = next;
	      } else {
	        // If we could not find a reference, queue the checked characters (as
	        // normal characters), and move the pointer to their end.
	        // This is possible because we can be certain neither newlines nor
	        // ampersands are included.
	        characters = value.slice(start - 1, end);
	        queue += characters;
	        column += characters.length;
	        index = end - 1;
	      }
	    } else {
	      // Handle anything other than an ampersand, including newlines and EOF.
	      if (
	        character === 10 // Line feed
	      ) {
	        line++;
	        lines++;
	        column = 0;
	      }

	      if (character === character) {
	        queue += fromCharCode(character);
	        column++;
	      } else {
	        flush();
	      }
	    }
	  }

	  // Return the reduced nodes.
	  return result.join('')

	  // Get current position.
	  function now() {
	    return {
	      line: line,
	      column: column,
	      offset: index + (pos.offset || 0)
	    }
	  }

	  // “Throw” a parse-error: a warning.
	  function parseError(code, offset) {
	    var position = now();

	    position.column += offset;
	    position.offset += offset;

	    handleWarning.call(warningContext, messages[code], position, code);
	  }

	  // Flush `queue` (normal text).
	  // Macro invoked before each entity and at the end of `value`.
	  // Does nothing when `queue` is empty.
	  function flush() {
	    if (queue) {
	      result.push(queue);

	      if (handleText) {
	        handleText.call(textContext, queue, {start: prev, end: now()});
	      }

	      queue = '';
	    }
	  }
	}

	// Check if `character` is outside the permissible unicode range.
	function prohibited(code) {
	  return (code >= 0xd800 && code <= 0xdfff) || code > 0x10ffff
	}

	// Check if `character` is disallowed.
	function disallowed(code) {
	  return (
	    (code >= 0x0001 && code <= 0x0008) ||
	    code === 0x000b ||
	    (code >= 0x000d && code <= 0x001f) ||
	    (code >= 0x007f && code <= 0x009f) ||
	    (code >= 0xfdd0 && code <= 0xfdef) ||
	    (code & 0xffff) === 0xffff ||
	    (code & 0xffff) === 0xfffe
	  )
	}
	return parseEntities_1;
}

var decode;
var hasRequiredDecode;

function requireDecode () {
	if (hasRequiredDecode) return decode;
	hasRequiredDecode = 1;

	var xtend = requireImmutable();
	var entities = requireParseEntities();

	decode = factory;

	// Factory to create an entity decoder.
	function factory(ctx) {
	  decoder.raw = decodeRaw;

	  return decoder

	  // Normalize `position` to add an `indent`.
	  function normalize(position) {
	    var offsets = ctx.offset;
	    var line = position.line;
	    var result = [];

	    while (++line) {
	      if (!(line in offsets)) {
	        break
	      }

	      result.push((offsets[line] || 0) + 1);
	    }

	    return {start: position, indent: result}
	  }

	  // Decode `value` (at `position`) into text-nodes.
	  function decoder(value, position, handler) {
	    entities(value, {
	      position: normalize(position),
	      warning: handleWarning,
	      text: handler,
	      reference: handler,
	      textContext: ctx,
	      referenceContext: ctx
	    });
	  }

	  // Decode `value` (at `position`) into a string.
	  function decodeRaw(value, position, options) {
	    return entities(
	      value,
	      xtend(options, {position: normalize(position), warning: handleWarning})
	    )
	  }

	  // Handle a warning.
	  // See <https://github.com/wooorm/parse-entities> for the warnings.
	  function handleWarning(reason, position, code) {
	    if (code !== 3) {
	      ctx.file.message(reason, position);
	    }
	  }
	}
	return decode;
}

var tokenizer$2;
var hasRequiredTokenizer$2;

function requireTokenizer$2 () {
	if (hasRequiredTokenizer$2) return tokenizer$2;
	hasRequiredTokenizer$2 = 1;

	tokenizer$2 = factory;

	// Construct a tokenizer.  This creates both `tokenizeInline` and `tokenizeBlock`.
	function factory(type) {
	  return tokenize

	  // Tokenizer for a bound `type`.
	  function tokenize(value, location) {
	    var self = this;
	    var offset = self.offset;
	    var tokens = [];
	    var methods = self[type + 'Methods'];
	    var tokenizers = self[type + 'Tokenizers'];
	    var line = location.line;
	    var column = location.column;
	    var index;
	    var length;
	    var method;
	    var name;
	    var matched;
	    var valueLength;

	    // Trim white space only lines.
	    if (!value) {
	      return tokens
	    }

	    // Expose on `eat`.
	    eat.now = now;
	    eat.file = self.file;

	    // Sync initial offset.
	    updatePosition('');

	    // Iterate over `value`, and iterate over all tokenizers.  When one eats
	    // something, re-iterate with the remaining value.  If no tokenizer eats,
	    // something failed (should not happen) and an exception is thrown.
	    while (value) {
	      index = -1;
	      length = methods.length;
	      matched = false;

	      while (++index < length) {
	        name = methods[index];
	        method = tokenizers[name];

	        // Previously, we had constructs such as footnotes and YAML that used
	        // these properties.
	        // Those are now external (plus there are userland extensions), that may
	        // still use them.
	        if (
	          method &&
	          /* istanbul ignore next */ (!method.onlyAtStart || self.atStart) &&
	          /* istanbul ignore next */ (!method.notInList || !self.inList) &&
	          /* istanbul ignore next */ (!method.notInBlock || !self.inBlock) &&
	          (!method.notInLink || !self.inLink)
	        ) {
	          valueLength = value.length;

	          method.apply(self, [eat, value]);

	          matched = valueLength !== value.length;

	          if (matched) {
	            break
	          }
	        }
	      }

	      /* istanbul ignore if */
	      if (!matched) {
	        self.file.fail(new Error('Infinite loop'), eat.now());
	      }
	    }

	    self.eof = now();

	    return tokens

	    // Update line, column, and offset based on `value`.
	    function updatePosition(subvalue) {
	      var lastIndex = -1;
	      var index = subvalue.indexOf('\n');

	      while (index !== -1) {
	        line++;
	        lastIndex = index;
	        index = subvalue.indexOf('\n', index + 1);
	      }

	      if (lastIndex === -1) {
	        column += subvalue.length;
	      } else {
	        column = subvalue.length - lastIndex;
	      }

	      if (line in offset) {
	        if (lastIndex !== -1) {
	          column += offset[line];
	        } else if (column <= offset[line]) {
	          column = offset[line] + 1;
	        }
	      }
	    }

	    // Get offset.  Called before the first character is eaten to retrieve the
	    // range’s offsets.
	    function getOffset() {
	      var indentation = [];
	      var pos = line + 1;

	      // Done.  Called when the last character is eaten to retrieve the range’s
	      // offsets.
	      return function () {
	        var last = line + 1;

	        while (pos < last) {
	          indentation.push((offset[pos] || 0) + 1);

	          pos++;
	        }

	        return indentation
	      }
	    }

	    // Get the current position.
	    function now() {
	      var pos = {line: line, column: column};

	      pos.offset = self.toOffset(pos);

	      return pos
	    }

	    // Store position information for a node.
	    function Position(start) {
	      this.start = start;
	      this.end = now();
	    }

	    // Throw when a value is incorrectly eaten.  This shouldn’t happen but will
	    // throw on new, incorrect rules.
	    function validateEat(subvalue) {
	      /* istanbul ignore if */
	      if (value.slice(0, subvalue.length) !== subvalue) {
	        // Capture stack-trace.
	        self.file.fail(
	          new Error(
	            'Incorrectly eaten value: please report this warning on https://git.io/vg5Ft'
	          ),
	          now()
	        );
	      }
	    }

	    // Mark position and patch `node.position`.
	    function position() {
	      var before = now();

	      return update

	      // Add the position to a node.
	      function update(node, indent) {
	        var previous = node.position;
	        var start = previous ? previous.start : before;
	        var combined = [];
	        var n = previous && previous.end.line;
	        var l = before.line;

	        node.position = new Position(start);

	        // If there was already a `position`, this node was merged.  Fixing
	        // `start` wasn’t hard, but the indent is different.  Especially
	        // because some information, the indent between `n` and `l` wasn’t
	        // tracked.  Luckily, that space is (should be?) empty, so we can
	        // safely check for it now.
	        if (previous && indent && previous.indent) {
	          combined = previous.indent;

	          if (n < l) {
	            while (++n < l) {
	              combined.push((offset[n] || 0) + 1);
	            }

	            combined.push(before.column);
	          }

	          indent = combined.concat(indent);
	        }

	        node.position.indent = indent || [];

	        return node
	      }
	    }

	    // Add `node` to `parent`s children or to `tokens`.  Performs merges where
	    // possible.
	    function add(node, parent) {
	      var children = parent ? parent.children : tokens;
	      var previous = children[children.length - 1];
	      var fn;

	      if (
	        previous &&
	        node.type === previous.type &&
	        (node.type === 'text' || node.type === 'blockquote') &&
	        mergeable(previous) &&
	        mergeable(node)
	      ) {
	        fn = node.type === 'text' ? mergeText : mergeBlockquote;
	        node = fn.call(self, previous, node);
	      }

	      if (node !== previous) {
	        children.push(node);
	      }

	      if (self.atStart && tokens.length !== 0) {
	        self.exitStart();
	      }

	      return node
	    }

	    // Remove `subvalue` from `value`.  `subvalue` must be at the start of
	    // `value`.
	    function eat(subvalue) {
	      var indent = getOffset();
	      var pos = position();
	      var current = now();

	      validateEat(subvalue);

	      apply.reset = reset;
	      reset.test = test;
	      apply.test = test;

	      value = value.slice(subvalue.length);

	      updatePosition(subvalue);

	      indent = indent();

	      return apply

	      // Add the given arguments, add `position` to the returned node, and
	      // return the node.
	      function apply(node, parent) {
	        return pos(add(pos(node), parent), indent)
	      }

	      // Functions just like apply, but resets the content: the line and
	      // column are reversed, and the eaten value is re-added.   This is
	      // useful for nodes with a single type of content, such as lists and
	      // tables.  See `apply` above for what parameters are expected.
	      function reset() {
	        var node = apply.apply(null, arguments);

	        line = current.line;
	        column = current.column;
	        value = subvalue + value;

	        return node
	      }

	      // Test the position, after eating, and reverse to a not-eaten state.
	      function test() {
	        var result = pos({});

	        line = current.line;
	        column = current.column;
	        value = subvalue + value;

	        return result.position
	      }
	    }
	  }
	}

	// Check whether a node is mergeable with adjacent nodes.
	function mergeable(node) {
	  var start;
	  var end;

	  if (node.type !== 'text' || !node.position) {
	    return true
	  }

	  start = node.position.start;
	  end = node.position.end;

	  // Only merge nodes which occupy the same size as their `value`.
	  return (
	    start.line !== end.line || end.column - start.column === node.value.length
	  )
	}

	// Merge two text nodes: `node` into `prev`.
	function mergeText(previous, node) {
	  previous.value += node.value;

	  return previous
	}

	// Merge two blockquotes: `node` into `prev`, unless in CommonMark or gfm modes.
	function mergeBlockquote(previous, node) {
	  if (this.options.commonmark || this.options.gfm) {
	    return node
	  }

	  previous.children = previous.children.concat(node.children);

	  return previous
	}
	return tokenizer$2;
}

var markdownEscapes;
var hasRequiredMarkdownEscapes;

function requireMarkdownEscapes () {
	if (hasRequiredMarkdownEscapes) return markdownEscapes;
	hasRequiredMarkdownEscapes = 1;

	markdownEscapes = escapes;

	var defaults = [
	  '\\',
	  '`',
	  '*',
	  '{',
	  '}',
	  '[',
	  ']',
	  '(',
	  ')',
	  '#',
	  '+',
	  '-',
	  '.',
	  '!',
	  '_',
	  '>'
	];

	var gfm = defaults.concat(['~', '|']);

	var commonmark = gfm.concat([
	  '\n',
	  '"',
	  '$',
	  '%',
	  '&',
	  "'",
	  ',',
	  '/',
	  ':',
	  ';',
	  '<',
	  '=',
	  '?',
	  '@',
	  '^'
	]);

	escapes.default = defaults;
	escapes.gfm = gfm;
	escapes.commonmark = commonmark;

	// Get markdown escapes.
	function escapes(options) {
	  var settings = options || {};

	  if (settings.commonmark) {
	    return commonmark
	  }

	  return settings.gfm ? gfm : defaults
	}
	return markdownEscapes;
}

var blockElements;
var hasRequiredBlockElements;

function requireBlockElements () {
	if (hasRequiredBlockElements) return blockElements;
	hasRequiredBlockElements = 1;

	blockElements = [
	  'address',
	  'article',
	  'aside',
	  'base',
	  'basefont',
	  'blockquote',
	  'body',
	  'caption',
	  'center',
	  'col',
	  'colgroup',
	  'dd',
	  'details',
	  'dialog',
	  'dir',
	  'div',
	  'dl',
	  'dt',
	  'fieldset',
	  'figcaption',
	  'figure',
	  'footer',
	  'form',
	  'frame',
	  'frameset',
	  'h1',
	  'h2',
	  'h3',
	  'h4',
	  'h5',
	  'h6',
	  'head',
	  'header',
	  'hgroup',
	  'hr',
	  'html',
	  'iframe',
	  'legend',
	  'li',
	  'link',
	  'main',
	  'menu',
	  'menuitem',
	  'meta',
	  'nav',
	  'noframes',
	  'ol',
	  'optgroup',
	  'option',
	  'p',
	  'param',
	  'pre',
	  'section',
	  'source',
	  'title',
	  'summary',
	  'table',
	  'tbody',
	  'td',
	  'tfoot',
	  'th',
	  'thead',
	  'title',
	  'tr',
	  'track',
	  'ul'
	];
	return blockElements;
}

var defaults;
var hasRequiredDefaults;

function requireDefaults () {
	if (hasRequiredDefaults) return defaults;
	hasRequiredDefaults = 1;

	defaults = {
	  position: true,
	  gfm: true,
	  commonmark: false,
	  pedantic: false,
	  blocks: requireBlockElements()
	};
	return defaults;
}

var setOptions_1;
var hasRequiredSetOptions;

function requireSetOptions () {
	if (hasRequiredSetOptions) return setOptions_1;
	hasRequiredSetOptions = 1;

	var xtend = requireImmutable();
	var escapes = requireMarkdownEscapes();
	var defaults = requireDefaults();

	setOptions_1 = setOptions;

	function setOptions(options) {
	  var self = this;
	  var current = self.options;
	  var key;
	  var value;

	  if (options == null) {
	    options = {};
	  } else if (typeof options === 'object') {
	    options = xtend(options);
	  } else {
	    throw new Error('Invalid value `' + options + '` for setting `options`')
	  }

	  for (key in defaults) {
	    value = options[key];

	    if (value == null) {
	      value = current[key];
	    }

	    if (
	      (key !== 'blocks' && typeof value !== 'boolean') ||
	      (key === 'blocks' && typeof value !== 'object')
	    ) {
	      throw new Error(
	        'Invalid value `' + value + '` for setting `options.' + key + '`'
	      )
	    }

	    options[key] = value;
	  }

	  self.options = options;
	  self.escape = escapes(options);

	  return self
	}
	return setOptions_1;
}

var convert_1$1;
var hasRequiredConvert$1;

function requireConvert$1 () {
	if (hasRequiredConvert$1) return convert_1$1;
	hasRequiredConvert$1 = 1;

	convert_1$1 = convert;

	function convert(test) {
	  if (typeof test === 'string') {
	    return typeFactory(test)
	  }

	  if (test === null || test === undefined) {
	    return ok
	  }

	  if (typeof test === 'object') {
	    return ('length' in test ? anyFactory : matchesFactory)(test)
	  }

	  if (typeof test === 'function') {
	    return test
	  }

	  throw new Error('Expected function, string, or object as test')
	}

	function convertAll(tests) {
	  var results = [];
	  var length = tests.length;
	  var index = -1;

	  while (++index < length) {
	    results[index] = convert(tests[index]);
	  }

	  return results
	}

	// Utility assert each property in `test` is represented in `node`, and each
	// values are strictly equal.
	function matchesFactory(test) {
	  return matches

	  function matches(node) {
	    var key;

	    for (key in test) {
	      if (node[key] !== test[key]) {
	        return false
	      }
	    }

	    return true
	  }
	}

	function anyFactory(tests) {
	  var checks = convertAll(tests);
	  var length = checks.length;

	  return matches

	  function matches() {
	    var index = -1;

	    while (++index < length) {
	      if (checks[index].apply(this, arguments)) {
	        return true
	      }
	    }

	    return false
	  }
	}

	// Utility to convert a string into a function which checks a given node’s type
	// for said string.
	function typeFactory(test) {
	  return type

	  function type(node) {
	    return Boolean(node && node.type === test)
	  }
	}

	// Utility to return true.
	function ok() {
	  return true
	}
	return convert_1$1;
}

var unistUtilVisitParents;
var hasRequiredUnistUtilVisitParents;

function requireUnistUtilVisitParents () {
	if (hasRequiredUnistUtilVisitParents) return unistUtilVisitParents;
	hasRequiredUnistUtilVisitParents = 1;

	unistUtilVisitParents = visitParents;

	var convert = requireConvert$1();

	var CONTINUE = true;
	var SKIP = 'skip';
	var EXIT = false;

	visitParents.CONTINUE = CONTINUE;
	visitParents.SKIP = SKIP;
	visitParents.EXIT = EXIT;

	function visitParents(tree, test, visitor, reverse) {
	  var is;

	  if (typeof test === 'function' && typeof visitor !== 'function') {
	    reverse = visitor;
	    visitor = test;
	    test = null;
	  }

	  is = convert(test);

	  one(tree, null, []);

	  // Visit a single node.
	  function one(node, index, parents) {
	    var result = [];
	    var subresult;

	    if (!test || is(node, index, parents[parents.length - 1] || null)) {
	      result = toResult(visitor(node, parents));

	      if (result[0] === EXIT) {
	        return result
	      }
	    }

	    if (node.children && result[0] !== SKIP) {
	      subresult = toResult(all(node.children, parents.concat(node)));
	      return subresult[0] === EXIT ? subresult : result
	    }

	    return result
	  }

	  // Visit children in `parent`.
	  function all(children, parents) {
	    var min = -1;
	    var step = reverse ? -1 : 1;
	    var index = (reverse ? children.length : min) + step;
	    var result;

	    while (index > min && index < children.length) {
	      result = one(children[index], index, parents);

	      if (result[0] === EXIT) {
	        return result
	      }

	      index = typeof result[1] === 'number' ? result[1] : index + step;
	    }
	  }
	}

	function toResult(value) {
	  if (value !== null && typeof value === 'object' && 'length' in value) {
	    return value
	  }

	  if (typeof value === 'number') {
	    return [CONTINUE, value]
	  }

	  return [value]
	}
	return unistUtilVisitParents;
}

var unistUtilVisit;
var hasRequiredUnistUtilVisit;

function requireUnistUtilVisit () {
	if (hasRequiredUnistUtilVisit) return unistUtilVisit;
	hasRequiredUnistUtilVisit = 1;

	unistUtilVisit = visit;

	var visitParents = requireUnistUtilVisitParents();

	var CONTINUE = visitParents.CONTINUE;
	var SKIP = visitParents.SKIP;
	var EXIT = visitParents.EXIT;

	visit.CONTINUE = CONTINUE;
	visit.SKIP = SKIP;
	visit.EXIT = EXIT;

	function visit(tree, test, visitor, reverse) {
	  if (typeof test === 'function' && typeof visitor !== 'function') {
	    reverse = visitor;
	    visitor = test;
	    test = null;
	  }

	  visitParents(tree, test, overload, reverse);

	  function overload(node, parents) {
	    var parent = parents[parents.length - 1];
	    var index = parent ? parent.children.indexOf(node) : null;
	    return visitor(node, index, parent)
	  }
	}
	return unistUtilVisit;
}

var unistUtilRemovePosition;
var hasRequiredUnistUtilRemovePosition;

function requireUnistUtilRemovePosition () {
	if (hasRequiredUnistUtilRemovePosition) return unistUtilRemovePosition;
	hasRequiredUnistUtilRemovePosition = 1;

	var visit = requireUnistUtilVisit();

	unistUtilRemovePosition = removePosition;

	function removePosition(node, force) {
	  visit(node, force ? hard : soft);
	  return node
	}

	function hard(node) {
	  delete node.position;
	}

	function soft(node) {
	  node.position = undefined;
	}
	return unistUtilRemovePosition;
}

var parse_1;
var hasRequiredParse$1;

function requireParse$1 () {
	if (hasRequiredParse$1) return parse_1;
	hasRequiredParse$1 = 1;

	var xtend = requireImmutable();
	var removePosition = requireUnistUtilRemovePosition();

	parse_1 = parse;

	var lineFeed = '\n';
	var lineBreaksExpression = /\r\n|\r/g;

	// Parse the bound file.
	function parse() {
	  var self = this;
	  var value = String(self.file);
	  var start = {line: 1, column: 1, offset: 0};
	  var content = xtend(start);
	  var node;

	  // Clean non-unix newlines: `\r\n` and `\r` are all changed to `\n`.
	  // This should not affect positional information.
	  value = value.replace(lineBreaksExpression, lineFeed);

	  // BOM.
	  if (value.charCodeAt(0) === 0xfeff) {
	    value = value.slice(1);

	    content.column++;
	    content.offset++;
	  }

	  node = {
	    type: 'root',
	    children: self.tokenizeBlock(value, content),
	    position: {start: start, end: self.eof || xtend(start)}
	  };

	  if (!self.options.position) {
	    removePosition(node, true);
	  }

	  return node
	}
	return parse_1;
}

var blankLine_1;
var hasRequiredBlankLine;

function requireBlankLine () {
	if (hasRequiredBlankLine) return blankLine_1;
	hasRequiredBlankLine = 1;

	// A line containing no characters, or a line containing only spaces (U+0020) or
	// tabs (U+0009), is called a blank line.
	// See <https://spec.commonmark.org/0.29/#blank-line>.
	var reBlankLine = /^[ \t]*(\n|$)/;

	// Note that though blank lines play a special role in lists to determine
	// whether the list is tight or loose
	// (<https://spec.commonmark.org/0.29/#blank-lines>), it’s done by the list
	// tokenizer and this blank line tokenizer does not have to be responsible for
	// that.
	// Therefore, configs such as `blankLine.notInList` do not have to be set here.
	blankLine_1 = blankLine;

	function blankLine(eat, value, silent) {
	  var match;
	  var subvalue = '';
	  var index = 0;
	  var length = value.length;

	  while (index < length) {
	    match = reBlankLine.exec(value.slice(index));

	    if (match == null) {
	      break
	    }

	    index += match[0].length;
	    subvalue += match[0];
	  }

	  if (subvalue === '') {
	    return
	  }

	  /* istanbul ignore if - never used (yet) */
	  if (silent) {
	    return true
	  }

	  eat(subvalue);
	}
	return blankLine_1;
}

/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

var repeatString;
var hasRequiredRepeatString;

function requireRepeatString () {
	if (hasRequiredRepeatString) return repeatString;
	hasRequiredRepeatString = 1;

	/**
	 * Results cache
	 */

	var res = '';
	var cache;

	/**
	 * Expose `repeat`
	 */

	repeatString = repeat;

	/**
	 * Repeat the given `string` the specified `number`
	 * of times.
	 *
	 * **Example:**
	 *
	 * ```js
	 * var repeat = require('repeat-string');
	 * repeat('A', 5);
	 * //=> AAAAA
	 * ```
	 *
	 * @param {String} `string` The string to repeat
	 * @param {Number} `number` The number of times to repeat the string
	 * @return {String} Repeated string
	 * @api public
	 */

	function repeat(str, num) {
	  if (typeof str !== 'string') {
	    throw new TypeError('expected a string');
	  }

	  // cover common, quick use cases
	  if (num === 1) return str;
	  if (num === 2) return str + str;

	  var max = str.length * num;
	  if (cache !== str || typeof cache === 'undefined') {
	    cache = str;
	    res = '';
	  } else if (res.length >= max) {
	    return res.substr(0, max);
	  }

	  while (max > res.length && num > 1) {
	    if (num & 1) {
	      res += str;
	    }

	    num >>= 1;
	    str += str;
	  }

	  res += str;
	  res = res.substr(0, max);
	  return res;
	}
	return repeatString;
}

var trimTrailingLines_1;
var hasRequiredTrimTrailingLines;

function requireTrimTrailingLines () {
	if (hasRequiredTrimTrailingLines) return trimTrailingLines_1;
	hasRequiredTrimTrailingLines = 1;

	trimTrailingLines_1 = trimTrailingLines;

	var line = '\n';

	// Remove final newline characters from `value`.
	function trimTrailingLines(value) {
	  var val = String(value);
	  var index = val.length;

	  while (val.charAt(--index) === line) {
	    // Empty
	  }

	  return val.slice(0, index + 1)
	}
	return trimTrailingLines_1;
}

var codeIndented;
var hasRequiredCodeIndented;

function requireCodeIndented () {
	if (hasRequiredCodeIndented) return codeIndented;
	hasRequiredCodeIndented = 1;

	var repeat = requireRepeatString();
	var trim = requireTrimTrailingLines();

	codeIndented = indentedCode;

	var lineFeed = '\n';
	var tab = '\t';
	var space = ' ';

	var tabSize = 4;
	var codeIndent = repeat(space, tabSize);

	function indentedCode(eat, value, silent) {
	  var index = -1;
	  var length = value.length;
	  var subvalue = '';
	  var content = '';
	  var subvalueQueue = '';
	  var contentQueue = '';
	  var character;
	  var blankQueue;
	  var indent;

	  while (++index < length) {
	    character = value.charAt(index);

	    if (indent) {
	      indent = false;

	      subvalue += subvalueQueue;
	      content += contentQueue;
	      subvalueQueue = '';
	      contentQueue = '';

	      if (character === lineFeed) {
	        subvalueQueue = character;
	        contentQueue = character;
	      } else {
	        subvalue += character;
	        content += character;

	        while (++index < length) {
	          character = value.charAt(index);

	          if (!character || character === lineFeed) {
	            contentQueue = character;
	            subvalueQueue = character;
	            break
	          }

	          subvalue += character;
	          content += character;
	        }
	      }
	    } else if (
	      character === space &&
	      value.charAt(index + 1) === character &&
	      value.charAt(index + 2) === character &&
	      value.charAt(index + 3) === character
	    ) {
	      subvalueQueue += codeIndent;
	      index += 3;
	      indent = true;
	    } else if (character === tab) {
	      subvalueQueue += character;
	      indent = true;
	    } else {
	      blankQueue = '';

	      while (character === tab || character === space) {
	        blankQueue += character;
	        character = value.charAt(++index);
	      }

	      if (character !== lineFeed) {
	        break
	      }

	      subvalueQueue += blankQueue + character;
	      contentQueue += character;
	    }
	  }

	  if (content) {
	    if (silent) {
	      return true
	    }

	    return eat(subvalue)({
	      type: 'code',
	      lang: null,
	      meta: null,
	      value: trim(content)
	    })
	  }
	}
	return codeIndented;
}

var codeFenced;
var hasRequiredCodeFenced;

function requireCodeFenced () {
	if (hasRequiredCodeFenced) return codeFenced;
	hasRequiredCodeFenced = 1;

	codeFenced = fencedCode;

	var lineFeed = '\n';
	var tab = '\t';
	var space = ' ';
	var tilde = '~';
	var graveAccent = '`';

	var minFenceCount = 3;
	var tabSize = 4;

	function fencedCode(eat, value, silent) {
	  var self = this;
	  var gfm = self.options.gfm;
	  var length = value.length + 1;
	  var index = 0;
	  var subvalue = '';
	  var fenceCount;
	  var marker;
	  var character;
	  var flag;
	  var lang;
	  var meta;
	  var queue;
	  var content;
	  var exdentedContent;
	  var closing;
	  var exdentedClosing;
	  var indent;
	  var now;

	  if (!gfm) {
	    return
	  }

	  // Eat initial spacing.
	  while (index < length) {
	    character = value.charAt(index);

	    if (character !== space && character !== tab) {
	      break
	    }

	    subvalue += character;
	    index++;
	  }

	  indent = index;

	  // Eat the fence.
	  character = value.charAt(index);

	  if (character !== tilde && character !== graveAccent) {
	    return
	  }

	  index++;
	  marker = character;
	  fenceCount = 1;
	  subvalue += character;

	  while (index < length) {
	    character = value.charAt(index);

	    if (character !== marker) {
	      break
	    }

	    subvalue += character;
	    fenceCount++;
	    index++;
	  }

	  if (fenceCount < minFenceCount) {
	    return
	  }

	  // Eat spacing before flag.
	  while (index < length) {
	    character = value.charAt(index);

	    if (character !== space && character !== tab) {
	      break
	    }

	    subvalue += character;
	    index++;
	  }

	  // Eat flag.
	  flag = '';
	  queue = '';

	  while (index < length) {
	    character = value.charAt(index);

	    if (
	      character === lineFeed ||
	      (marker === graveAccent && character === marker)
	    ) {
	      break
	    }

	    if (character === space || character === tab) {
	      queue += character;
	    } else {
	      flag += queue + character;
	      queue = '';
	    }

	    index++;
	  }

	  character = value.charAt(index);

	  if (character && character !== lineFeed) {
	    return
	  }

	  if (silent) {
	    return true
	  }

	  now = eat.now();
	  now.column += subvalue.length;
	  now.offset += subvalue.length;

	  subvalue += flag;
	  flag = self.decode.raw(self.unescape(flag), now);

	  if (queue) {
	    subvalue += queue;
	  }

	  queue = '';
	  closing = '';
	  exdentedClosing = '';
	  content = '';
	  exdentedContent = '';
	  var skip = true;

	  // Eat content.
	  while (index < length) {
	    character = value.charAt(index);
	    content += closing;
	    exdentedContent += exdentedClosing;
	    closing = '';
	    exdentedClosing = '';

	    if (character !== lineFeed) {
	      content += character;
	      exdentedClosing += character;
	      index++;
	      continue
	    }

	    // The first line feed is ignored. Others aren’t.
	    if (skip) {
	      subvalue += character;
	      skip = false;
	    } else {
	      closing += character;
	      exdentedClosing += character;
	    }

	    queue = '';
	    index++;

	    while (index < length) {
	      character = value.charAt(index);

	      if (character !== space) {
	        break
	      }

	      queue += character;
	      index++;
	    }

	    closing += queue;
	    exdentedClosing += queue.slice(indent);

	    if (queue.length >= tabSize) {
	      continue
	    }

	    queue = '';

	    while (index < length) {
	      character = value.charAt(index);

	      if (character !== marker) {
	        break
	      }

	      queue += character;
	      index++;
	    }

	    closing += queue;
	    exdentedClosing += queue;

	    if (queue.length < fenceCount) {
	      continue
	    }

	    queue = '';

	    while (index < length) {
	      character = value.charAt(index);

	      if (character !== space && character !== tab) {
	        break
	      }

	      closing += character;
	      exdentedClosing += character;
	      index++;
	    }

	    if (!character || character === lineFeed) {
	      break
	    }
	  }

	  subvalue += content + closing;

	  // Get lang and meta from the flag.
	  index = -1;
	  length = flag.length;

	  while (++index < length) {
	    character = flag.charAt(index);

	    if (character === space || character === tab) {
	      if (!lang) {
	        lang = flag.slice(0, index);
	      }
	    } else if (lang) {
	      meta = flag.slice(index);
	      break
	    }
	  }

	  return eat(subvalue)({
	    type: 'code',
	    lang: lang || flag || null,
	    meta: meta || null,
	    value: exdentedContent
	  })
	}
	return codeFenced;
}

var trim = {exports: {}};

var hasRequiredTrim;

function requireTrim () {
	if (hasRequiredTrim) return trim.exports;
	hasRequiredTrim = 1;
	(function (module, exports) {
		exports = module.exports = trim;

		function trim(str){
		  return str.replace(/^\s*|\s*$/g, '');
		}

		exports.left = function(str){
		  return str.replace(/^\s*/, '');
		};

		exports.right = function(str){
		  return str.replace(/\s*$/, '');
		}; 
	} (trim, trim.exports));
	return trim.exports;
}

var interrupt_1;
var hasRequiredInterrupt;

function requireInterrupt () {
	if (hasRequiredInterrupt) return interrupt_1;
	hasRequiredInterrupt = 1;

	interrupt_1 = interrupt;

	function interrupt(interruptors, tokenizers, ctx, parameters) {
	  var length = interruptors.length;
	  var index = -1;
	  var interruptor;
	  var config;

	  while (++index < length) {
	    interruptor = interruptors[index];
	    config = interruptor[1] || {};

	    if (
	      config.pedantic !== undefined &&
	      config.pedantic !== ctx.options.pedantic
	    ) {
	      continue
	    }

	    if (
	      config.commonmark !== undefined &&
	      config.commonmark !== ctx.options.commonmark
	    ) {
	      continue
	    }

	    if (tokenizers[interruptor[0]].apply(ctx, parameters)) {
	      return true
	    }
	  }

	  return false
	}
	return interrupt_1;
}

var blockquote_1$1;
var hasRequiredBlockquote$1;

function requireBlockquote$1 () {
	if (hasRequiredBlockquote$1) return blockquote_1$1;
	hasRequiredBlockquote$1 = 1;

	var trim = requireTrim();
	var interrupt = requireInterrupt();

	blockquote_1$1 = blockquote;

	var lineFeed = '\n';
	var tab = '\t';
	var space = ' ';
	var greaterThan = '>';

	function blockquote(eat, value, silent) {
	  var self = this;
	  var offsets = self.offset;
	  var tokenizers = self.blockTokenizers;
	  var interruptors = self.interruptBlockquote;
	  var now = eat.now();
	  var currentLine = now.line;
	  var length = value.length;
	  var values = [];
	  var contents = [];
	  var indents = [];
	  var add;
	  var index = 0;
	  var character;
	  var rest;
	  var nextIndex;
	  var content;
	  var line;
	  var startIndex;
	  var prefixed;
	  var exit;

	  while (index < length) {
	    character = value.charAt(index);

	    if (character !== space && character !== tab) {
	      break
	    }

	    index++;
	  }

	  if (value.charAt(index) !== greaterThan) {
	    return
	  }

	  if (silent) {
	    return true
	  }

	  index = 0;

	  while (index < length) {
	    nextIndex = value.indexOf(lineFeed, index);
	    startIndex = index;
	    prefixed = false;

	    if (nextIndex === -1) {
	      nextIndex = length;
	    }

	    while (index < length) {
	      character = value.charAt(index);

	      if (character !== space && character !== tab) {
	        break
	      }

	      index++;
	    }

	    if (value.charAt(index) === greaterThan) {
	      index++;
	      prefixed = true;

	      if (value.charAt(index) === space) {
	        index++;
	      }
	    } else {
	      index = startIndex;
	    }

	    content = value.slice(index, nextIndex);

	    if (!prefixed && !trim(content)) {
	      index = startIndex;
	      break
	    }

	    if (!prefixed) {
	      rest = value.slice(index);

	      // Check if the following code contains a possible block.
	      if (interrupt(interruptors, tokenizers, self, [eat, rest, true])) {
	        break
	      }
	    }

	    line = startIndex === index ? content : value.slice(startIndex, nextIndex);

	    indents.push(index - startIndex);
	    values.push(line);
	    contents.push(content);

	    index = nextIndex + 1;
	  }

	  index = -1;
	  length = indents.length;
	  add = eat(values.join(lineFeed));

	  while (++index < length) {
	    offsets[currentLine] = (offsets[currentLine] || 0) + indents[index];
	    currentLine++;
	  }

	  exit = self.enterBlock();
	  contents = self.tokenizeBlock(contents.join(lineFeed), now);
	  exit();

	  return add({type: 'blockquote', children: contents})
	}
	return blockquote_1$1;
}

var headingAtx;
var hasRequiredHeadingAtx;

function requireHeadingAtx () {
	if (hasRequiredHeadingAtx) return headingAtx;
	hasRequiredHeadingAtx = 1;

	headingAtx = atxHeading;

	var lineFeed = '\n';
	var tab = '\t';
	var space = ' ';
	var numberSign = '#';

	var maxFenceCount = 6;

	function atxHeading(eat, value, silent) {
	  var self = this;
	  var pedantic = self.options.pedantic;
	  var length = value.length + 1;
	  var index = -1;
	  var now = eat.now();
	  var subvalue = '';
	  var content = '';
	  var character;
	  var queue;
	  var depth;

	  // Eat initial spacing.
	  while (++index < length) {
	    character = value.charAt(index);

	    if (character !== space && character !== tab) {
	      index--;
	      break
	    }

	    subvalue += character;
	  }

	  // Eat hashes.
	  depth = 0;

	  while (++index <= length) {
	    character = value.charAt(index);

	    if (character !== numberSign) {
	      index--;
	      break
	    }

	    subvalue += character;
	    depth++;
	  }

	  if (depth > maxFenceCount) {
	    return
	  }

	  if (!depth || (!pedantic && value.charAt(index + 1) === numberSign)) {
	    return
	  }

	  length = value.length + 1;

	  // Eat intermediate white-space.
	  queue = '';

	  while (++index < length) {
	    character = value.charAt(index);

	    if (character !== space && character !== tab) {
	      index--;
	      break
	    }

	    queue += character;
	  }

	  // Exit when not in pedantic mode without spacing.
	  if (!pedantic && queue.length === 0 && character && character !== lineFeed) {
	    return
	  }

	  if (silent) {
	    return true
	  }

	  // Eat content.
	  subvalue += queue;
	  queue = '';
	  content = '';

	  while (++index < length) {
	    character = value.charAt(index);

	    if (!character || character === lineFeed) {
	      break
	    }

	    if (character !== space && character !== tab && character !== numberSign) {
	      content += queue + character;
	      queue = '';
	      continue
	    }

	    while (character === space || character === tab) {
	      queue += character;
	      character = value.charAt(++index);
	    }

	    // `#` without a queue is part of the content.
	    if (!pedantic && content && !queue && character === numberSign) {
	      content += character;
	      continue
	    }

	    while (character === numberSign) {
	      queue += character;
	      character = value.charAt(++index);
	    }

	    while (character === space || character === tab) {
	      queue += character;
	      character = value.charAt(++index);
	    }

	    index--;
	  }

	  now.column += subvalue.length;
	  now.offset += subvalue.length;
	  subvalue += content + queue;

	  return eat(subvalue)({
	    type: 'heading',
	    depth: depth,
	    children: self.tokenizeInline(content, now)
	  })
	}
	return headingAtx;
}

var thematicBreak_1$1;
var hasRequiredThematicBreak$1;

function requireThematicBreak$1 () {
	if (hasRequiredThematicBreak$1) return thematicBreak_1$1;
	hasRequiredThematicBreak$1 = 1;

	thematicBreak_1$1 = thematicBreak;

	var tab = '\t';
	var lineFeed = '\n';
	var space = ' ';
	var asterisk = '*';
	var dash = '-';
	var underscore = '_';

	var maxCount = 3;

	function thematicBreak(eat, value, silent) {
	  var index = -1;
	  var length = value.length + 1;
	  var subvalue = '';
	  var character;
	  var marker;
	  var markerCount;
	  var queue;

	  while (++index < length) {
	    character = value.charAt(index);

	    if (character !== tab && character !== space) {
	      break
	    }

	    subvalue += character;
	  }

	  if (
	    character !== asterisk &&
	    character !== dash &&
	    character !== underscore
	  ) {
	    return
	  }

	  marker = character;
	  subvalue += character;
	  markerCount = 1;
	  queue = '';

	  while (++index < length) {
	    character = value.charAt(index);

	    if (character === marker) {
	      markerCount++;
	      subvalue += queue + marker;
	      queue = '';
	    } else if (character === space) {
	      queue += character;
	    } else if (
	      markerCount >= maxCount &&
	      (!character || character === lineFeed)
	    ) {
	      subvalue += queue;

	      if (silent) {
	        return true
	      }

	      return eat(subvalue)({type: 'thematicBreak'})
	    } else {
	      return
	    }
	  }
	}
	return thematicBreak_1$1;
}

var getIndentation;
var hasRequiredGetIndentation;

function requireGetIndentation () {
	if (hasRequiredGetIndentation) return getIndentation;
	hasRequiredGetIndentation = 1;

	getIndentation = indentation;

	var tab = '\t';
	var space = ' ';

	var spaceSize = 1;
	var tabSize = 4;

	// Gets indentation information for a line.
	function indentation(value) {
	  var index = 0;
	  var indent = 0;
	  var character = value.charAt(index);
	  var stops = {};
	  var size;
	  var lastIndent = 0;

	  while (character === tab || character === space) {
	    size = character === tab ? tabSize : spaceSize;

	    indent += size;

	    if (size > 1) {
	      indent = Math.floor(indent / size) * size;
	    }

	    while (lastIndent < indent) {
	      stops[++lastIndent] = index;
	    }

	    character = value.charAt(++index);
	  }

	  return {indent: indent, stops: stops}
	}
	return getIndentation;
}

var removeIndentation;
var hasRequiredRemoveIndentation;

function requireRemoveIndentation () {
	if (hasRequiredRemoveIndentation) return removeIndentation;
	hasRequiredRemoveIndentation = 1;

	var trim = requireTrim();
	var repeat = requireRepeatString();
	var getIndent = requireGetIndentation();

	removeIndentation = indentation;

	var lineFeed = '\n';
	var space = ' ';
	var exclamationMark = '!';

	// Remove the minimum indent from every line in `value`.  Supports both tab,
	// spaced, and mixed indentation (as well as possible).
	function indentation(value, maximum) {
	  var values = value.split(lineFeed);
	  var position = values.length + 1;
	  var minIndent = Infinity;
	  var matrix = [];
	  var index;
	  var indentation;
	  var stops;

	  values.unshift(repeat(space, maximum) + exclamationMark);

	  while (position--) {
	    indentation = getIndent(values[position]);

	    matrix[position] = indentation.stops;

	    if (trim(values[position]).length === 0) {
	      continue
	    }

	    if (indentation.indent) {
	      if (indentation.indent > 0 && indentation.indent < minIndent) {
	        minIndent = indentation.indent;
	      }
	    } else {
	      minIndent = Infinity;

	      break
	    }
	  }

	  if (minIndent !== Infinity) {
	    position = values.length;

	    while (position--) {
	      stops = matrix[position];
	      index = minIndent;

	      while (index && !(index in stops)) {
	        index--;
	      }

	      values[position] = values[position].slice(stops[index] + 1);
	    }
	  }

	  values.shift();

	  return values.join(lineFeed)
	}
	return removeIndentation;
}

var list_1$1;
var hasRequiredList$1;

function requireList$1 () {
	if (hasRequiredList$1) return list_1$1;
	hasRequiredList$1 = 1;

	var trim = requireTrim();
	var repeat = requireRepeatString();
	var decimal = requireIsDecimal();
	var getIndent = requireGetIndentation();
	var removeIndent = requireRemoveIndentation();
	var interrupt = requireInterrupt();

	list_1$1 = list;

	var asterisk = '*';
	var underscore = '_';
	var plusSign = '+';
	var dash = '-';
	var dot = '.';
	var space = ' ';
	var lineFeed = '\n';
	var tab = '\t';
	var rightParenthesis = ')';
	var lowercaseX = 'x';

	var tabSize = 4;
	var looseListItemExpression = /\n\n(?!\s*$)/;
	var taskItemExpression = /^\[([ X\tx])][ \t]/;
	var bulletExpression = /^([ \t]*)([*+-]|\d+[.)])( {1,4}(?! )| |\t|$|(?=\n))([^\n]*)/;
	var pedanticBulletExpression = /^([ \t]*)([*+-]|\d+[.)])([ \t]+)/;
	var initialIndentExpression = /^( {1,4}|\t)?/gm;

	function list(eat, value, silent) {
	  var self = this;
	  var commonmark = self.options.commonmark;
	  var pedantic = self.options.pedantic;
	  var tokenizers = self.blockTokenizers;
	  var interuptors = self.interruptList;
	  var index = 0;
	  var length = value.length;
	  var start = null;
	  var size;
	  var queue;
	  var ordered;
	  var character;
	  var marker;
	  var nextIndex;
	  var startIndex;
	  var prefixed;
	  var currentMarker;
	  var content;
	  var line;
	  var previousEmpty;
	  var empty;
	  var items;
	  var allLines;
	  var emptyLines;
	  var item;
	  var enterTop;
	  var exitBlockquote;
	  var spread = false;
	  var node;
	  var now;
	  var end;
	  var indented;

	  while (index < length) {
	    character = value.charAt(index);

	    if (character !== tab && character !== space) {
	      break
	    }

	    index++;
	  }

	  character = value.charAt(index);

	  if (character === asterisk || character === plusSign || character === dash) {
	    marker = character;
	    ordered = false;
	  } else {
	    ordered = true;
	    queue = '';

	    while (index < length) {
	      character = value.charAt(index);

	      if (!decimal(character)) {
	        break
	      }

	      queue += character;
	      index++;
	    }

	    character = value.charAt(index);

	    if (
	      !queue ||
	      !(character === dot || (commonmark && character === rightParenthesis))
	    ) {
	      return
	    }

	    /* Slightly abusing `silent` mode, whose goal is to make interrupting
	     * paragraphs work.
	     * Well, that’s exactly what we want to do here: don’t interrupt:
	     * 2. here, because the “list” doesn’t start with `1`. */
	    if (silent && queue !== '1') {
	      return
	    }

	    start = parseInt(queue, 10);
	    marker = character;
	  }

	  character = value.charAt(++index);

	  if (
	    character !== space &&
	    character !== tab &&
	    (pedantic || (character !== lineFeed && character !== ''))
	  ) {
	    return
	  }

	  if (silent) {
	    return true
	  }

	  index = 0;
	  items = [];
	  allLines = [];
	  emptyLines = [];

	  while (index < length) {
	    nextIndex = value.indexOf(lineFeed, index);
	    startIndex = index;
	    prefixed = false;
	    indented = false;

	    if (nextIndex === -1) {
	      nextIndex = length;
	    }

	    size = 0;

	    while (index < length) {
	      character = value.charAt(index);

	      if (character === tab) {
	        size += tabSize - (size % tabSize);
	      } else if (character === space) {
	        size++;
	      } else {
	        break
	      }

	      index++;
	    }

	    if (item && size >= item.indent) {
	      indented = true;
	    }

	    character = value.charAt(index);
	    currentMarker = null;

	    if (!indented) {
	      if (
	        character === asterisk ||
	        character === plusSign ||
	        character === dash
	      ) {
	        currentMarker = character;
	        index++;
	        size++;
	      } else {
	        queue = '';

	        while (index < length) {
	          character = value.charAt(index);

	          if (!decimal(character)) {
	            break
	          }

	          queue += character;
	          index++;
	        }

	        character = value.charAt(index);
	        index++;

	        if (
	          queue &&
	          (character === dot || (commonmark && character === rightParenthesis))
	        ) {
	          currentMarker = character;
	          size += queue.length + 1;
	        }
	      }

	      if (currentMarker) {
	        character = value.charAt(index);

	        if (character === tab) {
	          size += tabSize - (size % tabSize);
	          index++;
	        } else if (character === space) {
	          end = index + tabSize;

	          while (index < end) {
	            if (value.charAt(index) !== space) {
	              break
	            }

	            index++;
	            size++;
	          }

	          if (index === end && value.charAt(index) === space) {
	            index -= tabSize - 1;
	            size -= tabSize - 1;
	          }
	        } else if (character !== lineFeed && character !== '') {
	          currentMarker = null;
	        }
	      }
	    }

	    if (currentMarker) {
	      if (!pedantic && marker !== currentMarker) {
	        break
	      }

	      prefixed = true;
	    } else {
	      if (!commonmark && !indented && value.charAt(startIndex) === space) {
	        indented = true;
	      } else if (commonmark && item) {
	        indented = size >= item.indent || size > tabSize;
	      }

	      prefixed = false;
	      index = startIndex;
	    }

	    line = value.slice(startIndex, nextIndex);
	    content = startIndex === index ? line : value.slice(index, nextIndex);

	    if (
	      currentMarker === asterisk ||
	      currentMarker === underscore ||
	      currentMarker === dash
	    ) {
	      if (tokenizers.thematicBreak.call(self, eat, line, true)) {
	        break
	      }
	    }

	    previousEmpty = empty;
	    empty = !prefixed && !trim(content).length;

	    if (indented && item) {
	      item.value = item.value.concat(emptyLines, line);
	      allLines = allLines.concat(emptyLines, line);
	      emptyLines = [];
	    } else if (prefixed) {
	      if (emptyLines.length !== 0) {
	        spread = true;
	        item.value.push('');
	        item.trail = emptyLines.concat();
	      }

	      item = {
	        value: [line],
	        indent: size,
	        trail: []
	      };

	      items.push(item);
	      allLines = allLines.concat(emptyLines, line);
	      emptyLines = [];
	    } else if (empty) {
	      if (previousEmpty && !commonmark) {
	        break
	      }

	      emptyLines.push(line);
	    } else {
	      if (previousEmpty) {
	        break
	      }

	      if (interrupt(interuptors, tokenizers, self, [eat, line, true])) {
	        break
	      }

	      item.value = item.value.concat(emptyLines, line);
	      allLines = allLines.concat(emptyLines, line);
	      emptyLines = [];
	    }

	    index = nextIndex + 1;
	  }

	  node = eat(allLines.join(lineFeed)).reset({
	    type: 'list',
	    ordered: ordered,
	    start: start,
	    spread: spread,
	    children: []
	  });

	  enterTop = self.enterList();
	  exitBlockquote = self.enterBlock();
	  index = -1;
	  length = items.length;

	  while (++index < length) {
	    item = items[index].value.join(lineFeed);
	    now = eat.now();

	    eat(item)(listItem(self, item, now), node);

	    item = items[index].trail.join(lineFeed);

	    if (index !== length - 1) {
	      item += lineFeed;
	    }

	    eat(item);
	  }

	  enterTop();
	  exitBlockquote();

	  return node
	}

	function listItem(ctx, value, position) {
	  var offsets = ctx.offset;
	  var fn = ctx.options.pedantic ? pedanticListItem : normalListItem;
	  var checked = null;
	  var task;
	  var indent;

	  value = fn.apply(null, arguments);

	  if (ctx.options.gfm) {
	    task = value.match(taskItemExpression);

	    if (task) {
	      indent = task[0].length;
	      checked = task[1].toLowerCase() === lowercaseX;
	      offsets[position.line] += indent;
	      value = value.slice(indent);
	    }
	  }

	  return {
	    type: 'listItem',
	    spread: looseListItemExpression.test(value),
	    checked: checked,
	    children: ctx.tokenizeBlock(value, position)
	  }
	}

	// Create a list-item using overly simple mechanics.
	function pedanticListItem(ctx, value, position) {
	  var offsets = ctx.offset;
	  var line = position.line;

	  // Remove the list-item’s bullet.
	  value = value.replace(pedanticBulletExpression, replacer);

	  // The initial line was also matched by the below, so we reset the `line`.
	  line = position.line;

	  return value.replace(initialIndentExpression, replacer)

	  // A simple replacer which removed all matches, and adds their length to
	  // `offset`.
	  function replacer($0) {
	    offsets[line] = (offsets[line] || 0) + $0.length;
	    line++;

	    return ''
	  }
	}

	// Create a list-item using sane mechanics.
	function normalListItem(ctx, value, position) {
	  var offsets = ctx.offset;
	  var line = position.line;
	  var max;
	  var bullet;
	  var rest;
	  var lines;
	  var trimmedLines;
	  var index;
	  var length;

	  // Remove the list-item’s bullet.
	  value = value.replace(bulletExpression, replacer);

	  lines = value.split(lineFeed);

	  trimmedLines = removeIndent(value, getIndent(max).indent).split(lineFeed);

	  // We replaced the initial bullet with something else above, which was used
	  // to trick `removeIndentation` into removing some more characters when
	  // possible.  However, that could result in the initial line to be stripped
	  // more than it should be.
	  trimmedLines[0] = rest;

	  offsets[line] = (offsets[line] || 0) + bullet.length;
	  line++;

	  index = 0;
	  length = lines.length;

	  while (++index < length) {
	    offsets[line] =
	      (offsets[line] || 0) + lines[index].length - trimmedLines[index].length;
	    line++;
	  }

	  return trimmedLines.join(lineFeed)

	  /* eslint-disable-next-line max-params */
	  function replacer($0, $1, $2, $3, $4) {
	    bullet = $1 + $2 + $3;
	    rest = $4;

	    // Make sure that the first nine numbered list items can indent with an
	    // extra space.  That is, when the bullet did not receive an extra final
	    // space.
	    if (Number($2) < 10 && bullet.length % 2 === 1) {
	      $2 = space + $2;
	    }

	    max = $1 + repeat(space, $2.length) + $3;

	    return max + rest
	  }
	}
	return list_1$1;
}

var headingSetext;
var hasRequiredHeadingSetext;

function requireHeadingSetext () {
	if (hasRequiredHeadingSetext) return headingSetext;
	hasRequiredHeadingSetext = 1;

	headingSetext = setextHeading;

	var lineFeed = '\n';
	var tab = '\t';
	var space = ' ';
	var equalsTo = '=';
	var dash = '-';

	var maxIndent = 3;

	var equalsToDepth = 1;
	var dashDepth = 2;

	function setextHeading(eat, value, silent) {
	  var self = this;
	  var now = eat.now();
	  var length = value.length;
	  var index = -1;
	  var subvalue = '';
	  var content;
	  var queue;
	  var character;
	  var marker;
	  var depth;

	  // Eat initial indentation.
	  while (++index < length) {
	    character = value.charAt(index);

	    if (character !== space || index >= maxIndent) {
	      index--;
	      break
	    }

	    subvalue += character;
	  }

	  // Eat content.
	  content = '';
	  queue = '';

	  while (++index < length) {
	    character = value.charAt(index);

	    if (character === lineFeed) {
	      index--;
	      break
	    }

	    if (character === space || character === tab) {
	      queue += character;
	    } else {
	      content += queue + character;
	      queue = '';
	    }
	  }

	  now.column += subvalue.length;
	  now.offset += subvalue.length;
	  subvalue += content + queue;

	  // Ensure the content is followed by a newline and a valid marker.
	  character = value.charAt(++index);
	  marker = value.charAt(++index);

	  if (character !== lineFeed || (marker !== equalsTo && marker !== dash)) {
	    return
	  }

	  subvalue += character;

	  // Eat Setext-line.
	  queue = marker;
	  depth = marker === equalsTo ? equalsToDepth : dashDepth;

	  while (++index < length) {
	    character = value.charAt(index);

	    if (character !== marker) {
	      if (character !== lineFeed) {
	        return
	      }

	      index--;
	      break
	    }

	    queue += character;
	  }

	  if (silent) {
	    return true
	  }

	  return eat(subvalue + queue)({
	    type: 'heading',
	    depth: depth,
	    children: self.tokenizeInline(content, now)
	  })
	}
	return headingSetext;
}

var html$5 = {};

var hasRequiredHtml$6;

function requireHtml$6 () {
	if (hasRequiredHtml$6) return html$5;
	hasRequiredHtml$6 = 1;

	var attributeName = '[a-zA-Z_:][a-zA-Z0-9:._-]*';
	var unquoted = '[^"\'=<>`\\u0000-\\u0020]+';
	var singleQuoted = "'[^']*'";
	var doubleQuoted = '"[^"]*"';
	var attributeValue =
	  '(?:' + unquoted + '|' + singleQuoted + '|' + doubleQuoted + ')';
	var attribute =
	  '(?:\\s+' + attributeName + '(?:\\s*=\\s*' + attributeValue + ')?)';
	var openTag = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';
	var closeTag = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
	var comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
	var processing = '<[?].*?[?]>';
	var declaration = '<![A-Za-z]+\\s+[^>]*>';
	var cdata = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';

	html$5.openCloseTag = new RegExp('^(?:' + openTag + '|' + closeTag + ')');

	html$5.tag = new RegExp(
	  '^(?:' +
	    openTag +
	    '|' +
	    closeTag +
	    '|' +
	    comment +
	    '|' +
	    processing +
	    '|' +
	    declaration +
	    '|' +
	    cdata +
	    ')'
	);
	return html$5;
}

var htmlBlock;
var hasRequiredHtmlBlock;

function requireHtmlBlock () {
	if (hasRequiredHtmlBlock) return htmlBlock;
	hasRequiredHtmlBlock = 1;

	var openCloseTag = requireHtml$6().openCloseTag;

	htmlBlock = blockHtml;

	var tab = '\t';
	var space = ' ';
	var lineFeed = '\n';
	var lessThan = '<';

	var rawOpenExpression = /^<(script|pre|style)(?=(\s|>|$))/i;
	var rawCloseExpression = /<\/(script|pre|style)>/i;
	var commentOpenExpression = /^<!--/;
	var commentCloseExpression = /-->/;
	var instructionOpenExpression = /^<\?/;
	var instructionCloseExpression = /\?>/;
	var directiveOpenExpression = /^<![A-Za-z]/;
	var directiveCloseExpression = />/;
	var cdataOpenExpression = /^<!\[CDATA\[/;
	var cdataCloseExpression = /]]>/;
	var elementCloseExpression = /^$/;
	var otherElementOpenExpression = new RegExp(openCloseTag.source + '\\s*$');

	function blockHtml(eat, value, silent) {
	  var self = this;
	  var blocks = self.options.blocks.join('|');
	  var elementOpenExpression = new RegExp(
	    '^</?(' + blocks + ')(?=(\\s|/?>|$))',
	    'i'
	  );
	  var length = value.length;
	  var index = 0;
	  var next;
	  var line;
	  var offset;
	  var character;
	  var count;
	  var sequence;
	  var subvalue;

	  var sequences = [
	    [rawOpenExpression, rawCloseExpression, true],
	    [commentOpenExpression, commentCloseExpression, true],
	    [instructionOpenExpression, instructionCloseExpression, true],
	    [directiveOpenExpression, directiveCloseExpression, true],
	    [cdataOpenExpression, cdataCloseExpression, true],
	    [elementOpenExpression, elementCloseExpression, true],
	    [otherElementOpenExpression, elementCloseExpression, false]
	  ];

	  // Eat initial spacing.
	  while (index < length) {
	    character = value.charAt(index);

	    if (character !== tab && character !== space) {
	      break
	    }

	    index++;
	  }

	  if (value.charAt(index) !== lessThan) {
	    return
	  }

	  next = value.indexOf(lineFeed, index + 1);
	  next = next === -1 ? length : next;
	  line = value.slice(index, next);
	  offset = -1;
	  count = sequences.length;

	  while (++offset < count) {
	    if (sequences[offset][0].test(line)) {
	      sequence = sequences[offset];
	      break
	    }
	  }

	  if (!sequence) {
	    return
	  }

	  if (silent) {
	    return sequence[2]
	  }

	  index = next;

	  if (!sequence[1].test(line)) {
	    while (index < length) {
	      next = value.indexOf(lineFeed, index + 1);
	      next = next === -1 ? length : next;
	      line = value.slice(index + 1, next);

	      if (sequence[1].test(line)) {
	        if (line) {
	          index = next;
	        }

	        break
	      }

	      index = next;
	    }
	  }

	  subvalue = value.slice(0, index);

	  return eat(subvalue)({type: 'html', value: subvalue})
	}
	return htmlBlock;
}

var isWhitespaceCharacter;
var hasRequiredIsWhitespaceCharacter;

function requireIsWhitespaceCharacter () {
	if (hasRequiredIsWhitespaceCharacter) return isWhitespaceCharacter;
	hasRequiredIsWhitespaceCharacter = 1;

	isWhitespaceCharacter = whitespace;

	var fromCode = String.fromCharCode;
	var re = /\s/;

	// Check if the given character code, or the character code at the first
	// character, is a whitespace character.
	function whitespace(character) {
	  return re.test(
	    typeof character === 'number' ? fromCode(character) : character.charAt(0)
	  )
	}
	return isWhitespaceCharacter;
}

var collapseWhiteSpace;
var hasRequiredCollapseWhiteSpace;

function requireCollapseWhiteSpace () {
	if (hasRequiredCollapseWhiteSpace) return collapseWhiteSpace;
	hasRequiredCollapseWhiteSpace = 1;

	collapseWhiteSpace = collapse;

	// `collapse(' \t\nbar \nbaz\t') // ' bar baz '`
	function collapse(value) {
	  return String(value).replace(/\s+/g, ' ')
	}
	return collapseWhiteSpace;
}

var normalize_1$1;
var hasRequiredNormalize$1;

function requireNormalize$1 () {
	if (hasRequiredNormalize$1) return normalize_1$1;
	hasRequiredNormalize$1 = 1;

	var collapseWhiteSpace = requireCollapseWhiteSpace();

	normalize_1$1 = normalize;

	// Normalize an identifier.  Collapses multiple white space characters into a
	// single space, and removes casing.
	function normalize(value) {
	  return collapseWhiteSpace(value).toLowerCase()
	}
	return normalize_1$1;
}

var definition_1;
var hasRequiredDefinition;

function requireDefinition () {
	if (hasRequiredDefinition) return definition_1;
	hasRequiredDefinition = 1;

	var whitespace = requireIsWhitespaceCharacter();
	var normalize = requireNormalize$1();

	definition_1 = definition;

	var quotationMark = '"';
	var apostrophe = "'";
	var backslash = '\\';
	var lineFeed = '\n';
	var tab = '\t';
	var space = ' ';
	var leftSquareBracket = '[';
	var rightSquareBracket = ']';
	var leftParenthesis = '(';
	var rightParenthesis = ')';
	var colon = ':';
	var lessThan = '<';
	var greaterThan = '>';

	function definition(eat, value, silent) {
	  var self = this;
	  var commonmark = self.options.commonmark;
	  var index = 0;
	  var length = value.length;
	  var subvalue = '';
	  var beforeURL;
	  var beforeTitle;
	  var queue;
	  var character;
	  var test;
	  var identifier;
	  var url;
	  var title;

	  while (index < length) {
	    character = value.charAt(index);

	    if (character !== space && character !== tab) {
	      break
	    }

	    subvalue += character;
	    index++;
	  }

	  character = value.charAt(index);

	  if (character !== leftSquareBracket) {
	    return
	  }

	  index++;
	  subvalue += character;
	  queue = '';

	  while (index < length) {
	    character = value.charAt(index);

	    if (character === rightSquareBracket) {
	      break
	    } else if (character === backslash) {
	      queue += character;
	      index++;
	      character = value.charAt(index);
	    }

	    queue += character;
	    index++;
	  }

	  if (
	    !queue ||
	    value.charAt(index) !== rightSquareBracket ||
	    value.charAt(index + 1) !== colon
	  ) {
	    return
	  }

	  identifier = queue;
	  subvalue += queue + rightSquareBracket + colon;
	  index = subvalue.length;
	  queue = '';

	  while (index < length) {
	    character = value.charAt(index);

	    if (character !== tab && character !== space && character !== lineFeed) {
	      break
	    }

	    subvalue += character;
	    index++;
	  }

	  character = value.charAt(index);
	  queue = '';
	  beforeURL = subvalue;

	  if (character === lessThan) {
	    index++;

	    while (index < length) {
	      character = value.charAt(index);

	      if (!isEnclosedURLCharacter(character)) {
	        break
	      }

	      queue += character;
	      index++;
	    }

	    character = value.charAt(index);

	    if (character === isEnclosedURLCharacter.delimiter) {
	      subvalue += lessThan + queue + character;
	      index++;
	    } else {
	      if (commonmark) {
	        return
	      }

	      index -= queue.length + 1;
	      queue = '';
	    }
	  }

	  if (!queue) {
	    while (index < length) {
	      character = value.charAt(index);

	      if (!isUnclosedURLCharacter(character)) {
	        break
	      }

	      queue += character;
	      index++;
	    }

	    subvalue += queue;
	  }

	  if (!queue) {
	    return
	  }

	  url = queue;
	  queue = '';

	  while (index < length) {
	    character = value.charAt(index);

	    if (character !== tab && character !== space && character !== lineFeed) {
	      break
	    }

	    queue += character;
	    index++;
	  }

	  character = value.charAt(index);
	  test = null;

	  if (character === quotationMark) {
	    test = quotationMark;
	  } else if (character === apostrophe) {
	    test = apostrophe;
	  } else if (character === leftParenthesis) {
	    test = rightParenthesis;
	  }

	  if (!test) {
	    queue = '';
	    index = subvalue.length;
	  } else if (queue) {
	    subvalue += queue + character;
	    index = subvalue.length;
	    queue = '';

	    while (index < length) {
	      character = value.charAt(index);

	      if (character === test) {
	        break
	      }

	      if (character === lineFeed) {
	        index++;
	        character = value.charAt(index);

	        if (character === lineFeed || character === test) {
	          return
	        }

	        queue += lineFeed;
	      }

	      queue += character;
	      index++;
	    }

	    character = value.charAt(index);

	    if (character !== test) {
	      return
	    }

	    beforeTitle = subvalue;
	    subvalue += queue + character;
	    index++;
	    title = queue;
	    queue = '';
	  } else {
	    return
	  }

	  while (index < length) {
	    character = value.charAt(index);

	    if (character !== tab && character !== space) {
	      break
	    }

	    subvalue += character;
	    index++;
	  }

	  character = value.charAt(index);

	  if (!character || character === lineFeed) {
	    if (silent) {
	      return true
	    }

	    beforeURL = eat(beforeURL).test().end;
	    url = self.decode.raw(self.unescape(url), beforeURL, {nonTerminated: false});

	    if (title) {
	      beforeTitle = eat(beforeTitle).test().end;
	      title = self.decode.raw(self.unescape(title), beforeTitle);
	    }

	    return eat(subvalue)({
	      type: 'definition',
	      identifier: normalize(identifier),
	      label: identifier,
	      title: title || null,
	      url: url
	    })
	  }
	}

	// Check if `character` can be inside an enclosed URI.
	function isEnclosedURLCharacter(character) {
	  return (
	    character !== greaterThan &&
	    character !== leftSquareBracket &&
	    character !== rightSquareBracket
	  )
	}

	isEnclosedURLCharacter.delimiter = greaterThan;

	// Check if `character` can be inside an unclosed URI.
	function isUnclosedURLCharacter(character) {
	  return (
	    character !== leftSquareBracket &&
	    character !== rightSquareBracket &&
	    !whitespace(character)
	  )
	}
	return definition_1;
}

var table_1$1;
var hasRequiredTable$1;

function requireTable$1 () {
	if (hasRequiredTable$1) return table_1$1;
	hasRequiredTable$1 = 1;

	var whitespace = requireIsWhitespaceCharacter();

	table_1$1 = table;

	var tab = '\t';
	var lineFeed = '\n';
	var space = ' ';
	var dash = '-';
	var colon = ':';
	var backslash = '\\';
	var verticalBar = '|';

	var minColumns = 1;
	var minRows = 2;

	var left = 'left';
	var center = 'center';
	var right = 'right';

	function table(eat, value, silent) {
	  var self = this;
	  var index;
	  var alignments;
	  var alignment;
	  var subvalue;
	  var row;
	  var length;
	  var lines;
	  var queue;
	  var character;
	  var hasDash;
	  var align;
	  var cell;
	  var preamble;
	  var now;
	  var position;
	  var lineCount;
	  var line;
	  var rows;
	  var table;
	  var lineIndex;
	  var pipeIndex;
	  var first;

	  // Exit when not in gfm-mode.
	  if (!self.options.gfm) {
	    return
	  }

	  // Get the rows.
	  // Detecting tables soon is hard, so there are some checks for performance
	  // here, such as the minimum number of rows, and allowed characters in the
	  // alignment row.
	  index = 0;
	  lineCount = 0;
	  length = value.length + 1;
	  lines = [];

	  while (index < length) {
	    lineIndex = value.indexOf(lineFeed, index);
	    pipeIndex = value.indexOf(verticalBar, index + 1);

	    if (lineIndex === -1) {
	      lineIndex = value.length;
	    }

	    if (pipeIndex === -1 || pipeIndex > lineIndex) {
	      if (lineCount < minRows) {
	        return
	      }

	      break
	    }

	    lines.push(value.slice(index, lineIndex));
	    lineCount++;
	    index = lineIndex + 1;
	  }

	  // Parse the alignment row.
	  subvalue = lines.join(lineFeed);
	  alignments = lines.splice(1, 1)[0] || [];
	  index = 0;
	  length = alignments.length;
	  lineCount--;
	  alignment = false;
	  align = [];

	  while (index < length) {
	    character = alignments.charAt(index);

	    if (character === verticalBar) {
	      hasDash = null;

	      if (alignment === false) {
	        if (first === false) {
	          return
	        }
	      } else {
	        align.push(alignment);
	        alignment = false;
	      }

	      first = false;
	    } else if (character === dash) {
	      hasDash = true;
	      alignment = alignment || null;
	    } else if (character === colon) {
	      if (alignment === left) {
	        alignment = center;
	      } else if (hasDash && alignment === null) {
	        alignment = right;
	      } else {
	        alignment = left;
	      }
	    } else if (!whitespace(character)) {
	      return
	    }

	    index++;
	  }

	  if (alignment !== false) {
	    align.push(alignment);
	  }

	  // Exit when without enough columns.
	  if (align.length < minColumns) {
	    return
	  }

	  /* istanbul ignore if - never used (yet) */
	  if (silent) {
	    return true
	  }

	  // Parse the rows.
	  position = -1;
	  rows = [];

	  table = eat(subvalue).reset({type: 'table', align: align, children: rows});

	  while (++position < lineCount) {
	    line = lines[position];
	    row = {type: 'tableRow', children: []};

	    // Eat a newline character when this is not the first row.
	    if (position) {
	      eat(lineFeed);
	    }

	    // Eat the row.
	    eat(line).reset(row, table);

	    length = line.length + 1;
	    index = 0;
	    queue = '';
	    cell = '';
	    preamble = true;

	    while (index < length) {
	      character = line.charAt(index);

	      if (character === tab || character === space) {
	        if (cell) {
	          queue += character;
	        } else {
	          eat(character);
	        }

	        index++;
	        continue
	      }

	      if (character === '' || character === verticalBar) {
	        if (preamble) {
	          eat(character);
	        } else {
	          if ((cell || character) && !preamble) {
	            subvalue = cell;

	            if (queue.length > 1) {
	              if (character) {
	                subvalue += queue.slice(0, -1);
	                queue = queue.charAt(queue.length - 1);
	              } else {
	                subvalue += queue;
	                queue = '';
	              }
	            }

	            now = eat.now();

	            eat(subvalue)(
	              {type: 'tableCell', children: self.tokenizeInline(cell, now)},
	              row
	            );
	          }

	          eat(queue + character);

	          queue = '';
	          cell = '';
	        }
	      } else {
	        if (queue) {
	          cell += queue;
	          queue = '';
	        }

	        cell += character;

	        if (character === backslash && index !== length - 2) {
	          cell += line.charAt(index + 1);
	          index++;
	        }
	      }

	      preamble = false;
	      index++;
	    }

	    // Eat the alignment row.
	    if (!position) {
	      eat(lineFeed + alignments);
	    }
	  }

	  return table
	}
	return table_1$1;
}

var paragraph_1$1;
var hasRequiredParagraph$1;

function requireParagraph$1 () {
	if (hasRequiredParagraph$1) return paragraph_1$1;
	hasRequiredParagraph$1 = 1;

	var trim = requireTrim();
	var trimTrailingLines = requireTrimTrailingLines();
	var interrupt = requireInterrupt();

	paragraph_1$1 = paragraph;

	var tab = '\t';
	var lineFeed = '\n';
	var space = ' ';

	var tabSize = 4;

	// Tokenise paragraph.
	function paragraph(eat, value, silent) {
	  var self = this;
	  var settings = self.options;
	  var commonmark = settings.commonmark;
	  var tokenizers = self.blockTokenizers;
	  var interruptors = self.interruptParagraph;
	  var index = value.indexOf(lineFeed);
	  var length = value.length;
	  var position;
	  var subvalue;
	  var character;
	  var size;
	  var now;

	  while (index < length) {
	    // Eat everything if there’s no following newline.
	    if (index === -1) {
	      index = length;
	      break
	    }

	    // Stop if the next character is NEWLINE.
	    if (value.charAt(index + 1) === lineFeed) {
	      break
	    }

	    // In commonmark-mode, following indented lines are part of the paragraph.
	    if (commonmark) {
	      size = 0;
	      position = index + 1;

	      while (position < length) {
	        character = value.charAt(position);

	        if (character === tab) {
	          size = tabSize;
	          break
	        } else if (character === space) {
	          size++;
	        } else {
	          break
	        }

	        position++;
	      }

	      if (size >= tabSize && character !== lineFeed) {
	        index = value.indexOf(lineFeed, index + 1);
	        continue
	      }
	    }

	    subvalue = value.slice(index + 1);

	    // Check if the following code contains a possible block.
	    if (interrupt(interruptors, tokenizers, self, [eat, subvalue, true])) {
	      break
	    }

	    position = index;
	    index = value.indexOf(lineFeed, index + 1);

	    if (index !== -1 && trim(value.slice(position, index)) === '') {
	      index = position;
	      break
	    }
	  }

	  subvalue = value.slice(0, index);

	  /* istanbul ignore if - never used (yet) */
	  if (silent) {
	    return true
	  }

	  now = eat.now();
	  subvalue = trimTrailingLines(subvalue);

	  return eat(subvalue)({
	    type: 'paragraph',
	    children: self.tokenizeInline(subvalue, now)
	  })
	}
	return paragraph_1$1;
}

var _escape$1;
var hasRequired_escape$1;

function require_escape$1 () {
	if (hasRequired_escape$1) return _escape$1;
	hasRequired_escape$1 = 1;

	_escape$1 = locate;

	function locate(value, fromIndex) {
	  return value.indexOf('\\', fromIndex)
	}
	return _escape$1;
}

var _escape;
var hasRequired_escape;

function require_escape () {
	if (hasRequired_escape) return _escape;
	hasRequired_escape = 1;

	var locate = require_escape$1();

	_escape = escape;
	escape.locator = locate;

	var lineFeed = '\n';
	var backslash = '\\';

	function escape(eat, value, silent) {
	  var self = this;
	  var character;
	  var node;

	  if (value.charAt(0) === backslash) {
	    character = value.charAt(1);

	    if (self.escape.indexOf(character) !== -1) {
	      /* istanbul ignore if - never used (yet) */
	      if (silent) {
	        return true
	      }

	      if (character === lineFeed) {
	        node = {type: 'break'};
	      } else {
	        node = {type: 'text', value: character};
	      }

	      return eat(backslash + character)(node)
	    }
	  }
	}
	return _escape;
}

var tag;
var hasRequiredTag;

function requireTag () {
	if (hasRequiredTag) return tag;
	hasRequiredTag = 1;

	tag = locate;

	function locate(value, fromIndex) {
	  return value.indexOf('<', fromIndex)
	}
	return tag;
}

var autoLink_1;
var hasRequiredAutoLink;

function requireAutoLink () {
	if (hasRequiredAutoLink) return autoLink_1;
	hasRequiredAutoLink = 1;

	var whitespace = requireIsWhitespaceCharacter();
	var decode = requireParseEntities();
	var locate = requireTag();

	autoLink_1 = autoLink;
	autoLink.locator = locate;
	autoLink.notInLink = true;

	var lessThan = '<';
	var greaterThan = '>';
	var atSign = '@';
	var slash = '/';
	var mailto = 'mailto:';
	var mailtoLength = mailto.length;

	function autoLink(eat, value, silent) {
	  var self = this;
	  var subvalue = '';
	  var length = value.length;
	  var index = 0;
	  var queue = '';
	  var hasAtCharacter = false;
	  var link = '';
	  var character;
	  var now;
	  var content;
	  var tokenizers;
	  var exit;

	  if (value.charAt(0) !== lessThan) {
	    return
	  }

	  index++;
	  subvalue = lessThan;

	  while (index < length) {
	    character = value.charAt(index);

	    if (
	      whitespace(character) ||
	      character === greaterThan ||
	      character === atSign ||
	      (character === ':' && value.charAt(index + 1) === slash)
	    ) {
	      break
	    }

	    queue += character;
	    index++;
	  }

	  if (!queue) {
	    return
	  }

	  link += queue;
	  queue = '';

	  character = value.charAt(index);
	  link += character;
	  index++;

	  if (character === atSign) {
	    hasAtCharacter = true;
	  } else {
	    if (character !== ':' || value.charAt(index + 1) !== slash) {
	      return
	    }

	    link += slash;
	    index++;
	  }

	  while (index < length) {
	    character = value.charAt(index);

	    if (whitespace(character) || character === greaterThan) {
	      break
	    }

	    queue += character;
	    index++;
	  }

	  character = value.charAt(index);

	  if (!queue || character !== greaterThan) {
	    return
	  }

	  /* istanbul ignore if - never used (yet) */
	  if (silent) {
	    return true
	  }

	  link += queue;
	  content = link;
	  subvalue += link + character;
	  now = eat.now();
	  now.column++;
	  now.offset++;

	  if (hasAtCharacter) {
	    if (link.slice(0, mailtoLength).toLowerCase() === mailto) {
	      content = content.slice(mailtoLength);
	      now.column += mailtoLength;
	      now.offset += mailtoLength;
	    } else {
	      link = mailto + link;
	    }
	  }

	  // Temporarily remove all tokenizers except text in autolinks.
	  tokenizers = self.inlineTokenizers;
	  self.inlineTokenizers = {text: tokenizers.text};

	  exit = self.enterLink();

	  content = self.tokenizeInline(content, now);

	  self.inlineTokenizers = tokenizers;
	  exit();

	  return eat(subvalue)({
	    type: 'link',
	    title: null,
	    url: decode(link, {nonTerminated: false}),
	    children: content
	  })
	}
	return autoLink_1;
}

var ccount_1;
var hasRequiredCcount;

function requireCcount () {
	if (hasRequiredCcount) return ccount_1;
	hasRequiredCcount = 1;

	ccount_1 = ccount;

	function ccount(value, character) {
	  var val = String(value);
	  var count = 0;
	  var index;

	  if (typeof character !== 'string' || character.length !== 1) {
	    throw new Error('Expected character')
	  }

	  index = val.indexOf(character);

	  while (index !== -1) {
	    count++;
	    index = val.indexOf(character, index + 1);
	  }

	  return count
	}
	return ccount_1;
}

var url;
var hasRequiredUrl$1;

function requireUrl$1 () {
	if (hasRequiredUrl$1) return url;
	hasRequiredUrl$1 = 1;

	url = locate;

	var values = ['www.', 'http://', 'https://'];

	function locate(value, fromIndex) {
	  var min = -1;
	  var index;
	  var length;
	  var position;

	  if (!this.options.gfm) {
	    return min
	  }

	  length = values.length;
	  index = -1;

	  while (++index < length) {
	    position = value.indexOf(values[index], fromIndex);

	    if (position !== -1 && (min === -1 || position < min)) {
	      min = position;
	    }
	  }

	  return min
	}
	return url;
}

var url_1;
var hasRequiredUrl;

function requireUrl () {
	if (hasRequiredUrl) return url_1;
	hasRequiredUrl = 1;

	var ccount = requireCcount();
	var decode = requireParseEntities();
	var decimal = requireIsDecimal();
	var alphabetical = requireIsAlphabetical();
	var whitespace = requireIsWhitespaceCharacter();
	var locate = requireUrl$1();

	url_1 = url;
	url.locator = locate;
	url.notInLink = true;

	var exclamationMark = 33; // '!'
	var ampersand = 38; // '&'
	var rightParenthesis = 41; // ')'
	var asterisk = 42; // '*'
	var comma = 44; // ','
	var dash = 45; // '-'
	var dot = 46; // '.'
	var colon = 58; // ':'
	var semicolon = 59; // ';'
	var questionMark = 63; // '?'
	var lessThan = 60; // '<'
	var underscore = 95; // '_'
	var tilde = 126; // '~'

	var leftParenthesisCharacter = '(';
	var rightParenthesisCharacter = ')';

	function url(eat, value, silent) {
	  var self = this;
	  var gfm = self.options.gfm;
	  var tokenizers = self.inlineTokenizers;
	  var length = value.length;
	  var previousDot = -1;
	  var protocolless = false;
	  var dots;
	  var lastTwoPartsStart;
	  var start;
	  var index;
	  var pathStart;
	  var path;
	  var code;
	  var end;
	  var leftCount;
	  var rightCount;
	  var content;
	  var children;
	  var url;
	  var exit;

	  if (!gfm) {
	    return
	  }

	  // `WWW.` doesn’t work.
	  if (value.slice(0, 4) === 'www.') {
	    protocolless = true;
	    index = 4;
	  } else if (value.slice(0, 7).toLowerCase() === 'http://') {
	    index = 7;
	  } else if (value.slice(0, 8).toLowerCase() === 'https://') {
	    index = 8;
	  } else {
	    return
	  }

	  // Act as if the starting boundary is a dot.
	  previousDot = index - 1;

	  // Parse a valid domain.
	  start = index;
	  dots = [];

	  while (index < length) {
	    code = value.charCodeAt(index);

	    if (code === dot) {
	      // Dots may not appear after each other.
	      if (previousDot === index - 1) {
	        break
	      }

	      dots.push(index);
	      previousDot = index;
	      index++;
	      continue
	    }

	    if (
	      decimal(code) ||
	      alphabetical(code) ||
	      code === dash ||
	      code === underscore
	    ) {
	      index++;
	      continue
	    }

	    break
	  }

	  // Ignore a final dot:
	  if (code === dot) {
	    dots.pop();
	    index--;
	  }

	  // If there are not dots, exit.
	  if (dots[0] === undefined) {
	    return
	  }

	  // If there is an underscore in the last two domain parts, exit:
	  // `www.example.c_m` and `www.ex_ample.com` are not OK, but
	  // `www.sub_domain.example.com` is.
	  lastTwoPartsStart = dots.length < 2 ? start : dots[dots.length - 2] + 1;

	  if (value.slice(lastTwoPartsStart, index).indexOf('_') !== -1) {
	    return
	  }

	  /* istanbul ignore if - never used (yet) */
	  if (silent) {
	    return true
	  }

	  end = index;
	  pathStart = index;

	  // Parse a path.
	  while (index < length) {
	    code = value.charCodeAt(index);

	    if (whitespace(code) || code === lessThan) {
	      break
	    }

	    index++;

	    if (
	      code === exclamationMark ||
	      code === asterisk ||
	      code === comma ||
	      code === dot ||
	      code === colon ||
	      code === questionMark ||
	      code === underscore ||
	      code === tilde
	    ) ; else {
	      end = index;
	    }
	  }

	  index = end;

	  // If the path ends in a closing paren, and the count of closing parens is
	  // higher than the opening count, then remove the supefluous closing parens.
	  if (value.charCodeAt(index - 1) === rightParenthesis) {
	    path = value.slice(pathStart, index);
	    leftCount = ccount(path, leftParenthesisCharacter);
	    rightCount = ccount(path, rightParenthesisCharacter);

	    while (rightCount > leftCount) {
	      index = pathStart + path.lastIndexOf(rightParenthesisCharacter);
	      path = value.slice(pathStart, index);
	      rightCount--;
	    }
	  }

	  if (value.charCodeAt(index - 1) === semicolon) {
	    // GitHub doesn’t document this, but final semicolons aren’t paret of the
	    // URL either.
	    index--;

	    // // If the path ends in what looks like an entity, it’s not part of the path.
	    if (alphabetical(value.charCodeAt(index - 1))) {
	      end = index - 2;

	      while (alphabetical(value.charCodeAt(end))) {
	        end--;
	      }

	      if (value.charCodeAt(end) === ampersand) {
	        index = end;
	      }
	    }
	  }

	  content = value.slice(0, index);
	  url = decode(content, {nonTerminated: false});

	  if (protocolless) {
	    url = 'http://' + url;
	  }

	  exit = self.enterLink();

	  // Temporarily remove all tokenizers except text in url.
	  self.inlineTokenizers = {text: tokenizers.text};
	  children = self.tokenizeInline(content, eat.now());
	  self.inlineTokenizers = tokenizers;

	  exit();

	  return eat(content)({type: 'link', title: null, url: url, children: children})
	}
	return url_1;
}

var email;
var hasRequiredEmail$1;

function requireEmail$1 () {
	if (hasRequiredEmail$1) return email;
	hasRequiredEmail$1 = 1;

	var decimal = requireIsDecimal();
	var alphabetical = requireIsAlphabetical();

	var plusSign = 43; // '+'
	var dash = 45; // '-'
	var dot = 46; // '.'
	var underscore = 95; // '_'

	email = locate;

	// See: <https://github.github.com/gfm/#extended-email-autolink>
	function locate(value, fromIndex) {
	  var self = this;
	  var at;
	  var position;

	  if (!this.options.gfm) {
	    return -1
	  }

	  at = value.indexOf('@', fromIndex);

	  if (at === -1) {
	    return -1
	  }

	  position = at;

	  if (position === fromIndex || !isGfmAtext(value.charCodeAt(position - 1))) {
	    return locate.call(self, value, at + 1)
	  }

	  while (position > fromIndex && isGfmAtext(value.charCodeAt(position - 1))) {
	    position--;
	  }

	  return position
	}

	function isGfmAtext(code) {
	  return (
	    decimal(code) ||
	    alphabetical(code) ||
	    code === plusSign ||
	    code === dash ||
	    code === dot ||
	    code === underscore
	  )
	}
	return email;
}

var email_1;
var hasRequiredEmail;

function requireEmail () {
	if (hasRequiredEmail) return email_1;
	hasRequiredEmail = 1;

	var decode = requireParseEntities();
	var decimal = requireIsDecimal();
	var alphabetical = requireIsAlphabetical();
	var locate = requireEmail$1();

	email_1 = email;
	email.locator = locate;
	email.notInLink = true;

	var plusSign = 43; // '+'
	var dash = 45; // '-'
	var dot = 46; // '.'
	var atSign = 64; // '@'
	var underscore = 95; // '_'

	function email(eat, value, silent) {
	  var self = this;
	  var gfm = self.options.gfm;
	  var tokenizers = self.inlineTokenizers;
	  var index = 0;
	  var length = value.length;
	  var firstDot = -1;
	  var code;
	  var content;
	  var children;
	  var exit;

	  if (!gfm) {
	    return
	  }

	  code = value.charCodeAt(index);

	  while (
	    decimal(code) ||
	    alphabetical(code) ||
	    code === plusSign ||
	    code === dash ||
	    code === dot ||
	    code === underscore
	  ) {
	    code = value.charCodeAt(++index);
	  }

	  if (index === 0) {
	    return
	  }

	  if (code !== atSign) {
	    return
	  }

	  index++;

	  while (index < length) {
	    code = value.charCodeAt(index);

	    if (
	      decimal(code) ||
	      alphabetical(code) ||
	      code === dash ||
	      code === dot ||
	      code === underscore
	    ) {
	      index++;

	      if (firstDot === -1 && code === dot) {
	        firstDot = index;
	      }

	      continue
	    }

	    break
	  }

	  if (
	    firstDot === -1 ||
	    firstDot === index ||
	    code === dash ||
	    code === underscore
	  ) {
	    return
	  }

	  if (code === dot) {
	    index--;
	  }

	  content = value.slice(0, index);

	  /* istanbul ignore if - never used (yet) */
	  if (silent) {
	    return true
	  }

	  exit = self.enterLink();

	  // Temporarily remove all tokenizers except text in url.
	  self.inlineTokenizers = {text: tokenizers.text};
	  children = self.tokenizeInline(content, eat.now());
	  self.inlineTokenizers = tokenizers;

	  exit();

	  return eat(content)({
	    type: 'link',
	    title: null,
	    url: 'mailto:' + decode(content, {nonTerminated: false}),
	    children: children
	  })
	}
	return email_1;
}

var htmlInline;
var hasRequiredHtmlInline;

function requireHtmlInline () {
	if (hasRequiredHtmlInline) return htmlInline;
	hasRequiredHtmlInline = 1;

	var alphabetical = requireIsAlphabetical();
	var locate = requireTag();
	var tag = requireHtml$6().tag;

	htmlInline = inlineHTML;
	inlineHTML.locator = locate;

	var lessThan = '<';
	var questionMark = '?';
	var exclamationMark = '!';
	var slash = '/';

	var htmlLinkOpenExpression = /^<a /i;
	var htmlLinkCloseExpression = /^<\/a>/i;

	function inlineHTML(eat, value, silent) {
	  var self = this;
	  var length = value.length;
	  var character;
	  var subvalue;

	  if (value.charAt(0) !== lessThan || length < 3) {
	    return
	  }

	  character = value.charAt(1);

	  if (
	    !alphabetical(character) &&
	    character !== questionMark &&
	    character !== exclamationMark &&
	    character !== slash
	  ) {
	    return
	  }

	  subvalue = value.match(tag);

	  if (!subvalue) {
	    return
	  }

	  /* istanbul ignore if - not used yet. */
	  if (silent) {
	    return true
	  }

	  subvalue = subvalue[0];

	  if (!self.inLink && htmlLinkOpenExpression.test(subvalue)) {
	    self.inLink = true;
	  } else if (self.inLink && htmlLinkCloseExpression.test(subvalue)) {
	    self.inLink = false;
	  }

	  return eat(subvalue)({type: 'html', value: subvalue})
	}
	return htmlInline;
}

var link;
var hasRequiredLink$2;

function requireLink$2 () {
	if (hasRequiredLink$2) return link;
	hasRequiredLink$2 = 1;

	link = locate;

	function locate(value, fromIndex) {
	  var link = value.indexOf('[', fromIndex);
	  var image = value.indexOf('![', fromIndex);

	  if (image === -1) {
	    return link
	  }

	  // Link can never be `-1` if an image is found, so we don’t need to check
	  // for that :)
	  return link < image ? link : image
	}
	return link;
}

var link_1$1;
var hasRequiredLink$1;

function requireLink$1 () {
	if (hasRequiredLink$1) return link_1$1;
	hasRequiredLink$1 = 1;

	var whitespace = requireIsWhitespaceCharacter();
	var locate = requireLink$2();

	link_1$1 = link;
	link.locator = locate;

	var lineFeed = '\n';
	var exclamationMark = '!';
	var quotationMark = '"';
	var apostrophe = "'";
	var leftParenthesis = '(';
	var rightParenthesis = ')';
	var lessThan = '<';
	var greaterThan = '>';
	var leftSquareBracket = '[';
	var backslash = '\\';
	var rightSquareBracket = ']';
	var graveAccent = '`';

	function link(eat, value, silent) {
	  var self = this;
	  var subvalue = '';
	  var index = 0;
	  var character = value.charAt(0);
	  var pedantic = self.options.pedantic;
	  var commonmark = self.options.commonmark;
	  var gfm = self.options.gfm;
	  var closed;
	  var count;
	  var opening;
	  var beforeURL;
	  var beforeTitle;
	  var subqueue;
	  var hasMarker;
	  var isImage;
	  var content;
	  var marker;
	  var length;
	  var title;
	  var depth;
	  var queue;
	  var url;
	  var now;
	  var exit;
	  var node;

	  // Detect whether this is an image.
	  if (character === exclamationMark) {
	    isImage = true;
	    subvalue = character;
	    character = value.charAt(++index);
	  }

	  // Eat the opening.
	  if (character !== leftSquareBracket) {
	    return
	  }

	  // Exit when this is a link and we’re already inside a link.
	  if (!isImage && self.inLink) {
	    return
	  }

	  subvalue += character;
	  queue = '';
	  index++;

	  // Eat the content.
	  length = value.length;
	  now = eat.now();
	  depth = 0;

	  now.column += index;
	  now.offset += index;

	  while (index < length) {
	    character = value.charAt(index);
	    subqueue = character;

	    if (character === graveAccent) {
	      // Inline-code in link content.
	      count = 1;

	      while (value.charAt(index + 1) === graveAccent) {
	        subqueue += character;
	        index++;
	        count++;
	      }

	      if (!opening) {
	        opening = count;
	      } else if (count >= opening) {
	        opening = 0;
	      }
	    } else if (character === backslash) {
	      // Allow brackets to be escaped.
	      index++;
	      subqueue += value.charAt(index);
	    } else if ((!opening || gfm) && character === leftSquareBracket) {
	      // In GFM mode, brackets in code still count.  In all other modes,
	      // they don’t.
	      depth++;
	    } else if ((!opening || gfm) && character === rightSquareBracket) {
	      if (depth) {
	        depth--;
	      } else {
	        if (value.charAt(index + 1) !== leftParenthesis) {
	          return
	        }

	        subqueue += leftParenthesis;
	        closed = true;
	        index++;

	        break
	      }
	    }

	    queue += subqueue;
	    subqueue = '';
	    index++;
	  }

	  // Eat the content closing.
	  if (!closed) {
	    return
	  }

	  content = queue;
	  subvalue += queue + subqueue;
	  index++;

	  // Eat white-space.
	  while (index < length) {
	    character = value.charAt(index);

	    if (!whitespace(character)) {
	      break
	    }

	    subvalue += character;
	    index++;
	  }

	  // Eat the URL.
	  character = value.charAt(index);
	  queue = '';
	  beforeURL = subvalue;

	  if (character === lessThan) {
	    index++;
	    beforeURL += lessThan;

	    while (index < length) {
	      character = value.charAt(index);

	      if (character === greaterThan) {
	        break
	      }

	      if (commonmark && character === lineFeed) {
	        return
	      }

	      queue += character;
	      index++;
	    }

	    if (value.charAt(index) !== greaterThan) {
	      return
	    }

	    subvalue += lessThan + queue + greaterThan;
	    url = queue;
	    index++;
	  } else {
	    character = null;
	    subqueue = '';

	    while (index < length) {
	      character = value.charAt(index);

	      if (
	        subqueue &&
	        (character === quotationMark ||
	          character === apostrophe ||
	          (commonmark && character === leftParenthesis))
	      ) {
	        break
	      }

	      if (whitespace(character)) {
	        if (!pedantic) {
	          break
	        }

	        subqueue += character;
	      } else {
	        if (character === leftParenthesis) {
	          depth++;
	        } else if (character === rightParenthesis) {
	          if (depth === 0) {
	            break
	          }

	          depth--;
	        }

	        queue += subqueue;
	        subqueue = '';

	        if (character === backslash) {
	          queue += backslash;
	          character = value.charAt(++index);
	        }

	        queue += character;
	      }

	      index++;
	    }

	    subvalue += queue;
	    url = queue;
	    index = subvalue.length;
	  }

	  // Eat white-space.
	  queue = '';

	  while (index < length) {
	    character = value.charAt(index);

	    if (!whitespace(character)) {
	      break
	    }

	    queue += character;
	    index++;
	  }

	  character = value.charAt(index);
	  subvalue += queue;

	  // Eat the title.
	  if (
	    queue &&
	    (character === quotationMark ||
	      character === apostrophe ||
	      (commonmark && character === leftParenthesis))
	  ) {
	    index++;
	    subvalue += character;
	    queue = '';
	    marker = character === leftParenthesis ? rightParenthesis : character;
	    beforeTitle = subvalue;

	    // In commonmark-mode, things are pretty easy: the marker cannot occur
	    // inside the title.  Non-commonmark does, however, support nested
	    // delimiters.
	    if (commonmark) {
	      while (index < length) {
	        character = value.charAt(index);

	        if (character === marker) {
	          break
	        }

	        if (character === backslash) {
	          queue += backslash;
	          character = value.charAt(++index);
	        }

	        index++;
	        queue += character;
	      }

	      character = value.charAt(index);

	      if (character !== marker) {
	        return
	      }

	      title = queue;
	      subvalue += queue + character;
	      index++;

	      while (index < length) {
	        character = value.charAt(index);

	        if (!whitespace(character)) {
	          break
	        }

	        subvalue += character;
	        index++;
	      }
	    } else {
	      subqueue = '';

	      while (index < length) {
	        character = value.charAt(index);

	        if (character === marker) {
	          if (hasMarker) {
	            queue += marker + subqueue;
	            subqueue = '';
	          }

	          hasMarker = true;
	        } else if (!hasMarker) {
	          queue += character;
	        } else if (character === rightParenthesis) {
	          subvalue += queue + marker + subqueue;
	          title = queue;
	          break
	        } else if (whitespace(character)) {
	          subqueue += character;
	        } else {
	          queue += marker + subqueue + character;
	          subqueue = '';
	          hasMarker = false;
	        }

	        index++;
	      }
	    }
	  }

	  if (value.charAt(index) !== rightParenthesis) {
	    return
	  }

	  /* istanbul ignore if - never used (yet) */
	  if (silent) {
	    return true
	  }

	  subvalue += rightParenthesis;

	  url = self.decode.raw(self.unescape(url), eat(beforeURL).test().end, {
	    nonTerminated: false
	  });

	  if (title) {
	    beforeTitle = eat(beforeTitle).test().end;
	    title = self.decode.raw(self.unescape(title), beforeTitle);
	  }

	  node = {
	    type: isImage ? 'image' : 'link',
	    title: title || null,
	    url: url
	  };

	  if (isImage) {
	    node.alt = self.decode.raw(self.unescape(content), now) || null;
	  } else {
	    exit = self.enterLink();
	    node.children = self.tokenizeInline(content, now);
	    exit();
	  }

	  return eat(subvalue)(node)
	}
	return link_1$1;
}

var reference_1;
var hasRequiredReference;

function requireReference () {
	if (hasRequiredReference) return reference_1;
	hasRequiredReference = 1;

	var whitespace = requireIsWhitespaceCharacter();
	var locate = requireLink$2();
	var normalize = requireNormalize$1();

	reference_1 = reference;
	reference.locator = locate;

	var link = 'link';
	var image = 'image';
	var shortcut = 'shortcut';
	var collapsed = 'collapsed';
	var full = 'full';
	var exclamationMark = '!';
	var leftSquareBracket = '[';
	var backslash = '\\';
	var rightSquareBracket = ']';

	function reference(eat, value, silent) {
	  var self = this;
	  var commonmark = self.options.commonmark;
	  var character = value.charAt(0);
	  var index = 0;
	  var length = value.length;
	  var subvalue = '';
	  var intro = '';
	  var type = link;
	  var referenceType = shortcut;
	  var content;
	  var identifier;
	  var now;
	  var node;
	  var exit;
	  var queue;
	  var bracketed;
	  var depth;

	  // Check whether we’re eating an image.
	  if (character === exclamationMark) {
	    type = image;
	    intro = character;
	    character = value.charAt(++index);
	  }

	  if (character !== leftSquareBracket) {
	    return
	  }

	  index++;
	  intro += character;
	  queue = '';

	  // Eat the text.
	  depth = 0;

	  while (index < length) {
	    character = value.charAt(index);

	    if (character === leftSquareBracket) {
	      bracketed = true;
	      depth++;
	    } else if (character === rightSquareBracket) {
	      if (!depth) {
	        break
	      }

	      depth--;
	    }

	    if (character === backslash) {
	      queue += backslash;
	      character = value.charAt(++index);
	    }

	    queue += character;
	    index++;
	  }

	  subvalue = queue;
	  content = queue;
	  character = value.charAt(index);

	  if (character !== rightSquareBracket) {
	    return
	  }

	  index++;
	  subvalue += character;
	  queue = '';

	  if (!commonmark) {
	    // The original markdown syntax definition explicitly allows for whitespace
	    // between the link text and link label; commonmark departs from this, in
	    // part to improve support for shortcut reference links
	    while (index < length) {
	      character = value.charAt(index);

	      if (!whitespace(character)) {
	        break
	      }

	      queue += character;
	      index++;
	    }
	  }

	  character = value.charAt(index);

	  if (character === leftSquareBracket) {
	    identifier = '';
	    queue += character;
	    index++;

	    while (index < length) {
	      character = value.charAt(index);

	      if (character === leftSquareBracket || character === rightSquareBracket) {
	        break
	      }

	      if (character === backslash) {
	        identifier += backslash;
	        character = value.charAt(++index);
	      }

	      identifier += character;
	      index++;
	    }

	    character = value.charAt(index);

	    if (character === rightSquareBracket) {
	      referenceType = identifier ? full : collapsed;
	      queue += identifier + character;
	      index++;
	    } else {
	      identifier = '';
	    }

	    subvalue += queue;
	    queue = '';
	  } else {
	    if (!content) {
	      return
	    }

	    identifier = content;
	  }

	  // Brackets cannot be inside the identifier.
	  if (referenceType !== full && bracketed) {
	    return
	  }

	  subvalue = intro + subvalue;

	  if (type === link && self.inLink) {
	    return null
	  }

	  /* istanbul ignore if - never used (yet) */
	  if (silent) {
	    return true
	  }

	  now = eat.now();
	  now.column += intro.length;
	  now.offset += intro.length;
	  identifier = referenceType === full ? identifier : content;

	  node = {
	    type: type + 'Reference',
	    identifier: normalize(identifier),
	    label: identifier,
	    referenceType: referenceType
	  };

	  if (type === link) {
	    exit = self.enterLink();
	    node.children = self.tokenizeInline(content, now);
	    exit();
	  } else {
	    node.alt = self.decode.raw(self.unescape(content), now) || null;
	  }

	  return eat(subvalue)(node)
	}
	return reference_1;
}

var strong;
var hasRequiredStrong$2;

function requireStrong$2 () {
	if (hasRequiredStrong$2) return strong;
	hasRequiredStrong$2 = 1;

	strong = locate;

	function locate(value, fromIndex) {
	  var asterisk = value.indexOf('**', fromIndex);
	  var underscore = value.indexOf('__', fromIndex);

	  if (underscore === -1) {
	    return asterisk
	  }

	  if (asterisk === -1) {
	    return underscore
	  }

	  return underscore < asterisk ? underscore : asterisk
	}
	return strong;
}

var strong_1$1;
var hasRequiredStrong$1;

function requireStrong$1 () {
	if (hasRequiredStrong$1) return strong_1$1;
	hasRequiredStrong$1 = 1;

	var trim = requireTrim();
	var whitespace = requireIsWhitespaceCharacter();
	var locate = requireStrong$2();

	strong_1$1 = strong;
	strong.locator = locate;

	var backslash = '\\';
	var asterisk = '*';
	var underscore = '_';

	function strong(eat, value, silent) {
	  var self = this;
	  var index = 0;
	  var character = value.charAt(index);
	  var now;
	  var pedantic;
	  var marker;
	  var queue;
	  var subvalue;
	  var length;
	  var previous;

	  if (
	    (character !== asterisk && character !== underscore) ||
	    value.charAt(++index) !== character
	  ) {
	    return
	  }

	  pedantic = self.options.pedantic;
	  marker = character;
	  subvalue = marker + marker;
	  length = value.length;
	  index++;
	  queue = '';
	  character = '';

	  if (pedantic && whitespace(value.charAt(index))) {
	    return
	  }

	  while (index < length) {
	    previous = character;
	    character = value.charAt(index);

	    if (
	      character === marker &&
	      value.charAt(index + 1) === marker &&
	      (!pedantic || !whitespace(previous))
	    ) {
	      character = value.charAt(index + 2);

	      if (character !== marker) {
	        if (!trim(queue)) {
	          return
	        }

	        /* istanbul ignore if - never used (yet) */
	        if (silent) {
	          return true
	        }

	        now = eat.now();
	        now.column += 2;
	        now.offset += 2;

	        return eat(subvalue + queue + subvalue)({
	          type: 'strong',
	          children: self.tokenizeInline(queue, now)
	        })
	      }
	    }

	    if (!pedantic && character === backslash) {
	      queue += character;
	      character = value.charAt(++index);
	    }

	    queue += character;
	    index++;
	  }
	}
	return strong_1$1;
}

var isWordCharacter;
var hasRequiredIsWordCharacter;

function requireIsWordCharacter () {
	if (hasRequiredIsWordCharacter) return isWordCharacter;
	hasRequiredIsWordCharacter = 1;

	isWordCharacter = wordCharacter;

	var fromCode = String.fromCharCode;
	var re = /\w/;

	// Check if the given character code, or the character code at the first
	// character, is a word character.
	function wordCharacter(character) {
	  return re.test(
	    typeof character === 'number' ? fromCode(character) : character.charAt(0)
	  )
	}
	return isWordCharacter;
}

var emphasis;
var hasRequiredEmphasis$2;

function requireEmphasis$2 () {
	if (hasRequiredEmphasis$2) return emphasis;
	hasRequiredEmphasis$2 = 1;

	emphasis = locate;

	function locate(value, fromIndex) {
	  var asterisk = value.indexOf('*', fromIndex);
	  var underscore = value.indexOf('_', fromIndex);

	  if (underscore === -1) {
	    return asterisk
	  }

	  if (asterisk === -1) {
	    return underscore
	  }

	  return underscore < asterisk ? underscore : asterisk
	}
	return emphasis;
}

var emphasis_1$1;
var hasRequiredEmphasis$1;

function requireEmphasis$1 () {
	if (hasRequiredEmphasis$1) return emphasis_1$1;
	hasRequiredEmphasis$1 = 1;

	var trim = requireTrim();
	var word = requireIsWordCharacter();
	var whitespace = requireIsWhitespaceCharacter();
	var locate = requireEmphasis$2();

	emphasis_1$1 = emphasis;
	emphasis.locator = locate;

	var asterisk = '*';
	var underscore = '_';
	var backslash = '\\';

	function emphasis(eat, value, silent) {
	  var self = this;
	  var index = 0;
	  var character = value.charAt(index);
	  var now;
	  var pedantic;
	  var marker;
	  var queue;
	  var subvalue;
	  var length;
	  var previous;

	  if (character !== asterisk && character !== underscore) {
	    return
	  }

	  pedantic = self.options.pedantic;
	  subvalue = character;
	  marker = character;
	  length = value.length;
	  index++;
	  queue = '';
	  character = '';

	  if (pedantic && whitespace(value.charAt(index))) {
	    return
	  }

	  while (index < length) {
	    previous = character;
	    character = value.charAt(index);

	    if (character === marker && (!pedantic || !whitespace(previous))) {
	      character = value.charAt(++index);

	      if (character !== marker) {
	        if (!trim(queue) || previous === marker) {
	          return
	        }

	        if (!pedantic && marker === underscore && word(character)) {
	          queue += marker;
	          continue
	        }

	        /* istanbul ignore if - never used (yet) */
	        if (silent) {
	          return true
	        }

	        now = eat.now();
	        now.column++;
	        now.offset++;

	        return eat(subvalue + queue + marker)({
	          type: 'emphasis',
	          children: self.tokenizeInline(queue, now)
	        })
	      }

	      queue += marker;
	    }

	    if (!pedantic && character === backslash) {
	      queue += character;
	      character = value.charAt(++index);
	    }

	    queue += character;
	    index++;
	  }
	}
	return emphasis_1$1;
}

var _delete$2;
var hasRequired_delete$2;

function require_delete$2 () {
	if (hasRequired_delete$2) return _delete$2;
	hasRequired_delete$2 = 1;

	_delete$2 = locate;

	function locate(value, fromIndex) {
	  return value.indexOf('~~', fromIndex)
	}
	return _delete$2;
}

var _delete$1;
var hasRequired_delete$1;

function require_delete$1 () {
	if (hasRequired_delete$1) return _delete$1;
	hasRequired_delete$1 = 1;

	var whitespace = requireIsWhitespaceCharacter();
	var locate = require_delete$2();

	_delete$1 = strikethrough;
	strikethrough.locator = locate;

	var tilde = '~';
	var fence = '~~';

	function strikethrough(eat, value, silent) {
	  var self = this;
	  var character = '';
	  var previous = '';
	  var preceding = '';
	  var subvalue = '';
	  var index;
	  var length;
	  var now;

	  if (
	    !self.options.gfm ||
	    value.charAt(0) !== tilde ||
	    value.charAt(1) !== tilde ||
	    whitespace(value.charAt(2))
	  ) {
	    return
	  }

	  index = 1;
	  length = value.length;
	  now = eat.now();
	  now.column += 2;
	  now.offset += 2;

	  while (++index < length) {
	    character = value.charAt(index);

	    if (
	      character === tilde &&
	      previous === tilde &&
	      (!preceding || !whitespace(preceding))
	    ) {
	      /* istanbul ignore if - never used (yet) */
	      if (silent) {
	        return true
	      }

	      return eat(fence + subvalue + fence)({
	        type: 'delete',
	        children: self.tokenizeInline(subvalue, now)
	      })
	    }

	    subvalue += previous;
	    preceding = previous;
	    previous = character;
	  }
	}
	return _delete$1;
}

var codeInline$1;
var hasRequiredCodeInline$1;

function requireCodeInline$1 () {
	if (hasRequiredCodeInline$1) return codeInline$1;
	hasRequiredCodeInline$1 = 1;

	codeInline$1 = locate;

	function locate(value, fromIndex) {
	  return value.indexOf('`', fromIndex)
	}
	return codeInline$1;
}

var codeInline;
var hasRequiredCodeInline;

function requireCodeInline () {
	if (hasRequiredCodeInline) return codeInline;
	hasRequiredCodeInline = 1;

	var locate = requireCodeInline$1();

	codeInline = inlineCode;
	inlineCode.locator = locate;

	var lineFeed = 10; //  '\n'
	var space = 32; // ' '
	var graveAccent = 96; //  '`'

	function inlineCode(eat, value, silent) {
	  var length = value.length;
	  var index = 0;
	  var openingFenceEnd;
	  var closingFenceStart;
	  var closingFenceEnd;
	  var code;
	  var next;
	  var found;

	  while (index < length) {
	    if (value.charCodeAt(index) !== graveAccent) {
	      break
	    }

	    index++;
	  }

	  if (index === 0 || index === length) {
	    return
	  }

	  openingFenceEnd = index;
	  next = value.charCodeAt(index);

	  while (index < length) {
	    code = next;
	    next = value.charCodeAt(index + 1);

	    if (code === graveAccent) {
	      if (closingFenceStart === undefined) {
	        closingFenceStart = index;
	      }

	      closingFenceEnd = index + 1;

	      if (
	        next !== graveAccent &&
	        closingFenceEnd - closingFenceStart === openingFenceEnd
	      ) {
	        found = true;
	        break
	      }
	    } else if (closingFenceStart !== undefined) {
	      closingFenceStart = undefined;
	      closingFenceEnd = undefined;
	    }

	    index++;
	  }

	  if (!found) {
	    return
	  }

	  /* istanbul ignore if - never used (yet) */
	  if (silent) {
	    return true
	  }

	  // Remove the initial and final space (or line feed), iff they exist and there
	  // are non-space characters in the content.
	  index = openingFenceEnd;
	  length = closingFenceStart;
	  code = value.charCodeAt(index);
	  next = value.charCodeAt(length - 1);
	  found = false;

	  if (
	    length - index > 2 &&
	    (code === space || code === lineFeed) &&
	    (next === space || next === lineFeed)
	  ) {
	    index++;
	    length--;

	    while (index < length) {
	      code = value.charCodeAt(index);

	      if (code !== space && code !== lineFeed) {
	        found = true;
	        break
	      }

	      index++;
	    }

	    if (found === true) {
	      openingFenceEnd++;
	      closingFenceStart--;
	    }
	  }

	  return eat(value.slice(0, closingFenceEnd))({
	    type: 'inlineCode',
	    value: value.slice(openingFenceEnd, closingFenceStart)
	  })
	}
	return codeInline;
}

var _break$2;
var hasRequired_break$2;

function require_break$2 () {
	if (hasRequired_break$2) return _break$2;
	hasRequired_break$2 = 1;

	_break$2 = locate;

	function locate(value, fromIndex) {
	  var index = value.indexOf('\n', fromIndex);

	  while (index > fromIndex) {
	    if (value.charAt(index - 1) !== ' ') {
	      break
	    }

	    index--;
	  }

	  return index
	}
	return _break$2;
}

var _break$1;
var hasRequired_break$1;

function require_break$1 () {
	if (hasRequired_break$1) return _break$1;
	hasRequired_break$1 = 1;

	var locate = require_break$2();

	_break$1 = hardBreak;
	hardBreak.locator = locate;

	var space = ' ';
	var lineFeed = '\n';
	var minBreakLength = 2;

	function hardBreak(eat, value, silent) {
	  var length = value.length;
	  var index = -1;
	  var queue = '';
	  var character;

	  while (++index < length) {
	    character = value.charAt(index);

	    if (character === lineFeed) {
	      if (index < minBreakLength) {
	        return
	      }

	      /* istanbul ignore if - never used (yet) */
	      if (silent) {
	        return true
	      }

	      queue += character;

	      return eat(queue)({type: 'break'})
	    }

	    if (character !== space) {
	      return
	    }

	    queue += character;
	  }
	}
	return _break$1;
}

var text_1$1;
var hasRequiredText$2;

function requireText$2 () {
	if (hasRequiredText$2) return text_1$1;
	hasRequiredText$2 = 1;

	text_1$1 = text;

	function text(eat, value, silent) {
	  var self = this;
	  var methods;
	  var tokenizers;
	  var index;
	  var length;
	  var subvalue;
	  var position;
	  var tokenizer;
	  var name;
	  var min;
	  var now;

	  /* istanbul ignore if - never used (yet) */
	  if (silent) {
	    return true
	  }

	  methods = self.inlineMethods;
	  length = methods.length;
	  tokenizers = self.inlineTokenizers;
	  index = -1;
	  min = value.length;

	  while (++index < length) {
	    name = methods[index];

	    if (name === 'text' || !tokenizers[name]) {
	      continue
	    }

	    tokenizer = tokenizers[name].locator;

	    if (!tokenizer) {
	      eat.file.fail('Missing locator: `' + name + '`');
	    }

	    position = tokenizer.call(self, value, 1);

	    if (position !== -1 && position < min) {
	      min = position;
	    }
	  }

	  subvalue = value.slice(0, min);
	  now = eat.now();

	  self.decode(subvalue, now, handler);

	  function handler(content, position, source) {
	    eat(source || content)({type: 'text', value: content});
	  }
	}
	return text_1$1;
}

var parser$2;
var hasRequiredParser$2;

function requireParser$2 () {
	if (hasRequiredParser$2) return parser$2;
	hasRequiredParser$2 = 1;

	var xtend = requireImmutable();
	var toggle = requireStateToggle();
	var vfileLocation = requireVfileLocation();
	var unescape = require_unescape();
	var decode = requireDecode();
	var tokenizer = requireTokenizer$2();

	parser$2 = Parser;

	function Parser(doc, file) {
	  this.file = file;
	  this.offset = {};
	  this.options = xtend(this.options);
	  this.setOptions({});

	  this.inList = false;
	  this.inBlock = false;
	  this.inLink = false;
	  this.atStart = true;

	  this.toOffset = vfileLocation(file).toOffset;
	  this.unescape = unescape(this, 'escape');
	  this.decode = decode(this);
	}

	var proto = Parser.prototype;

	// Expose core.
	proto.setOptions = requireSetOptions();
	proto.parse = requireParse$1();

	// Expose `defaults`.
	proto.options = requireDefaults();

	// Enter and exit helpers.
	proto.exitStart = toggle('atStart', true);
	proto.enterList = toggle('inList', false);
	proto.enterLink = toggle('inLink', false);
	proto.enterBlock = toggle('inBlock', false);

	// Nodes that can interupt a paragraph:
	//
	// ```markdown
	// A paragraph, followed by a thematic break.
	// ___
	// ```
	//
	// In the above example, the thematic break “interupts” the paragraph.
	proto.interruptParagraph = [
	  ['thematicBreak'],
	  ['list'],
	  ['atxHeading'],
	  ['fencedCode'],
	  ['blockquote'],
	  ['html'],
	  ['setextHeading', {commonmark: false}],
	  ['definition', {commonmark: false}]
	];

	// Nodes that can interupt a list:
	//
	// ```markdown
	// - One
	// ___
	// ```
	//
	// In the above example, the thematic break “interupts” the list.
	proto.interruptList = [
	  ['atxHeading', {pedantic: false}],
	  ['fencedCode', {pedantic: false}],
	  ['thematicBreak', {pedantic: false}],
	  ['definition', {commonmark: false}]
	];

	// Nodes that can interupt a blockquote:
	//
	// ```markdown
	// > A paragraph.
	// ___
	// ```
	//
	// In the above example, the thematic break “interupts” the blockquote.
	proto.interruptBlockquote = [
	  ['indentedCode', {commonmark: true}],
	  ['fencedCode', {commonmark: true}],
	  ['atxHeading', {commonmark: true}],
	  ['setextHeading', {commonmark: true}],
	  ['thematicBreak', {commonmark: true}],
	  ['html', {commonmark: true}],
	  ['list', {commonmark: true}],
	  ['definition', {commonmark: false}]
	];

	// Handlers.
	proto.blockTokenizers = {
	  blankLine: requireBlankLine(),
	  indentedCode: requireCodeIndented(),
	  fencedCode: requireCodeFenced(),
	  blockquote: requireBlockquote$1(),
	  atxHeading: requireHeadingAtx(),
	  thematicBreak: requireThematicBreak$1(),
	  list: requireList$1(),
	  setextHeading: requireHeadingSetext(),
	  html: requireHtmlBlock(),
	  definition: requireDefinition(),
	  table: requireTable$1(),
	  paragraph: requireParagraph$1()
	};

	proto.inlineTokenizers = {
	  escape: require_escape(),
	  autoLink: requireAutoLink(),
	  url: requireUrl(),
	  email: requireEmail(),
	  html: requireHtmlInline(),
	  link: requireLink$1(),
	  reference: requireReference(),
	  strong: requireStrong$1(),
	  emphasis: requireEmphasis$1(),
	  deletion: require_delete$1(),
	  code: requireCodeInline(),
	  break: require_break$1(),
	  text: requireText$2()
	};

	// Expose precedence.
	proto.blockMethods = keys(proto.blockTokenizers);
	proto.inlineMethods = keys(proto.inlineTokenizers);

	// Tokenizers.
	proto.tokenizeBlock = tokenizer('block');
	proto.tokenizeInline = tokenizer('inline');
	proto.tokenizeFactory = tokenizer;

	// Get all keys in `value`.
	function keys(value) {
	  var result = [];
	  var key;

	  for (key in value) {
	    result.push(key);
	  }

	  return result
	}
	return parser$2;
}

var remarkParse;
var hasRequiredRemarkParse;

function requireRemarkParse () {
	if (hasRequiredRemarkParse) return remarkParse;
	hasRequiredRemarkParse = 1;

	var unherit = requireUnherit();
	var xtend = requireImmutable();
	var Parser = requireParser$2();

	remarkParse = parse;
	parse.Parser = Parser;

	function parse(options) {
	  var settings = this.data('settings');
	  var Local = unherit(Parser);

	  Local.prototype.options = xtend(Local.prototype.options, settings, options);

	  this.Parser = Local;
	}
	return remarkParse;
}

var remarkParseExports = requireRemarkParse();
var markdown = /*@__PURE__*/getDefaultExportFromCjs(remarkParseExports);

var format = {exports: {}};

var hasRequiredFormat;

function requireFormat () {
	if (hasRequiredFormat) return format.exports;
	hasRequiredFormat = 1;
	(function (module) {
(function() {

		  //// Export the API
		  var namespace;

		  // CommonJS / Node module
		  {
		    namespace = module.exports = format;
		  }

		  namespace.format = format;
		  namespace.vsprintf = vsprintf;

		  if (typeof console !== 'undefined' && typeof console.log === 'function') {
		    namespace.printf = printf;
		  }

		  function printf(/* ... */) {
		    console.log(format.apply(null, arguments));
		  }

		  function vsprintf(fmt, replacements) {
		    return format.apply(null, [fmt].concat(replacements));
		  }

		  function format(fmt) {
		    var argIndex = 1 // skip initial format argument
		      , args = [].slice.call(arguments)
		      , i = 0
		      , n = fmt.length
		      , result = ''
		      , c
		      , escaped = false
		      , arg
		      , tmp
		      , leadingZero = false
		      , precision
		      , nextArg = function() { return args[argIndex++]; }
		      , slurpNumber = function() {
		          var digits = '';
		          while (/\d/.test(fmt[i])) {
		            digits += fmt[i++];
		            c = fmt[i];
		          }
		          return digits.length > 0 ? parseInt(digits) : null;
		        }
		      ;
		    for (; i < n; ++i) {
		      c = fmt[i];
		      if (escaped) {
		        escaped = false;
		        if (c == '.') {
		          leadingZero = false;
		          c = fmt[++i];
		        }
		        else if (c == '0' && fmt[i + 1] == '.') {
		          leadingZero = true;
		          i += 2;
		          c = fmt[i];
		        }
		        else {
		          leadingZero = true;
		        }
		        precision = slurpNumber();
		        switch (c) {
		        case 'b': // number in binary
		          result += parseInt(nextArg(), 10).toString(2);
		          break;
		        case 'c': // character
		          arg = nextArg();
		          if (typeof arg === 'string' || arg instanceof String)
		            result += arg;
		          else
		            result += String.fromCharCode(parseInt(arg, 10));
		          break;
		        case 'd': // number in decimal
		          result += parseInt(nextArg(), 10);
		          break;
		        case 'f': // floating point number
		          tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
		          result += leadingZero ? tmp : tmp.replace(/^0/, '');
		          break;
		        case 'j': // JSON
		          result += JSON.stringify(nextArg());
		          break;
		        case 'o': // number in octal
		          result += '0' + parseInt(nextArg(), 10).toString(8);
		          break;
		        case 's': // string
		          result += nextArg();
		          break;
		        case 'x': // lowercase hexadecimal
		          result += '0x' + parseInt(nextArg(), 10).toString(16);
		          break;
		        case 'X': // uppercase hexadecimal
		          result += '0x' + parseInt(nextArg(), 10).toString(16).toUpperCase();
		          break;
		        default:
		          result += c;
		          break;
		        }
		      } else if (c === '%') {
		        escaped = true;
		      } else {
		        result += c;
		      }
		    }
		    return result;
		  }

		}()); 
	} (format));
	return format.exports;
}

var fault_1;
var hasRequiredFault;

function requireFault () {
	if (hasRequiredFault) return fault_1;
	hasRequiredFault = 1;

	var formatter = requireFormat();

	var fault = create(Error);

	fault_1 = fault;

	fault.eval = create(EvalError);
	fault.range = create(RangeError);
	fault.reference = create(ReferenceError);
	fault.syntax = create(SyntaxError);
	fault.type = create(TypeError);
	fault.uri = create(URIError);

	fault.create = create;

	// Create a new `EConstructor`, with the formatted `format` as a first argument.
	function create(EConstructor) {
	  FormattedError.displayName = EConstructor.displayName || EConstructor.name;

	  return FormattedError

	  function FormattedError(format) {
	    if (format) {
	      format = formatter.apply(null, arguments);
	    }

	    return new EConstructor(format)
	  }
	}
	return fault_1;
}

var matters_1;
var hasRequiredMatters;

function requireMatters () {
	if (hasRequiredMatters) return matters_1;
	hasRequiredMatters = 1;

	var fault = requireFault();

	matters_1 = matters;

	var own = {}.hasOwnProperty;

	var markers = {
	  yaml: '-',
	  toml: '+'
	};

	function matters(options) {
	  var results = [];
	  var index = -1;
	  var length;

	  // One preset or matter.
	  if (typeof options === 'string' || !('length' in options)) {
	    options = [options];
	  }

	  length = options.length;

	  while (++index < length) {
	    results[index] = matter(options[index]);
	  }

	  return results
	}

	function matter(option) {
	  var result = option;

	  if (typeof result === 'string') {
	    if (!own.call(markers, result)) {
	      throw fault('Missing matter definition for `%s`', result)
	    }

	    result = {type: result, marker: markers[result]};
	  } else if (typeof result !== 'object') {
	    throw fault('Expected matter to be an object, not `%j`', result)
	  }

	  if (!own.call(result, 'type')) {
	    throw fault('Missing `type` in matter `%j`', result)
	  }

	  if (!own.call(result, 'fence') && !own.call(result, 'marker')) {
	    throw fault('Missing `marker` or `fence` in matter `%j`', result)
	  }

	  return result
	}
	return matters_1;
}

var fence_1;
var hasRequiredFence;

function requireFence () {
	if (hasRequiredFence) return fence_1;
	hasRequiredFence = 1;

	fence_1 = fence;

	function fence(matter, prop) {
	  var marker;

	  if (matter.marker) {
	    marker = pick(matter.marker, prop);
	    return marker + marker + marker
	  }

	  return pick(matter.fence, prop)
	}

	function pick(schema, prop) {
	  return typeof schema === 'string' ? schema : schema[prop]
	}
	return fence_1;
}

var parse;
var hasRequiredParse;

function requireParse () {
	if (hasRequiredParse) return parse;
	hasRequiredParse = 1;

	var fence = requireFence();

	parse = create;

	function create(matter) {
	  var name = matter.type + 'FrontMatter';
	  var open = fence(matter, 'open');
	  var close = fence(matter, 'close');
	  var newline = '\n';
	  var anywhere = matter.anywhere;

	  frontmatter.displayName = name;
	  frontmatter.onlyAtStart = typeof anywhere === 'boolean' ? !anywhere : true;

	  return [name, frontmatter]

	  function frontmatter(eat, value, silent) {
	    var index = open.length;
	    var offset;

	    if (value.slice(0, index) !== open || value.charAt(index) !== newline) {
	      return
	    }

	    offset = value.indexOf(close, index);

	    while (offset !== -1 && value.charAt(offset - 1) !== newline) {
	      index = offset + close.length;
	      offset = value.indexOf(close, index);
	    }

	    if (offset !== -1) {
	      /* istanbul ignore if - never used (yet) */
	      if (silent) {
	        return true
	      }

	      return eat(value.slice(0, offset + close.length))({
	        type: matter.type,
	        value: value.slice(open.length + 1, offset - 1)
	      })
	    }
	  }
	}
	return parse;
}

var compile;
var hasRequiredCompile;

function requireCompile () {
	if (hasRequiredCompile) return compile;
	hasRequiredCompile = 1;

	var fence = requireFence();

	compile = create;

	function create(matter) {
	  var type = matter.type;
	  var open = fence(matter, 'open');
	  var close = fence(matter, 'close');

	  frontmatter.displayName = type + 'FrontMatter';

	  return [type, frontmatter]

	  function frontmatter(node) {
	    return open + (node.value ? '\n' + node.value : '') + '\n' + close
	  }
	}
	return compile;
}

var remarkFrontmatter;
var hasRequiredRemarkFrontmatter;

function requireRemarkFrontmatter () {
	if (hasRequiredRemarkFrontmatter) return remarkFrontmatter;
	hasRequiredRemarkFrontmatter = 1;

	var matters = requireMatters();
	var parse = requireParse();
	var compile = requireCompile();

	remarkFrontmatter = frontmatter;

	function frontmatter(options) {
	  var parser = this.Parser;
	  var compiler = this.Compiler;
	  var config = matters(options || ['yaml']);

	  if (isRemarkParser(parser)) {
	    attachParser(parser, config);
	  }

	  if (isRemarkCompiler(compiler)) {
	    attachCompiler(compiler, config);
	  }
	}

	function attachParser(parser, matters) {
	  var proto = parser.prototype;
	  var tokenizers = wrap(parse, matters);
	  var names = [];
	  var key;

	  for (key in tokenizers) {
	    names.push(key);
	  }

	  proto.blockMethods = names.concat(proto.blockMethods);
	  proto.blockTokenizers = Object.assign({}, tokenizers, proto.blockTokenizers);
	}

	function attachCompiler(compiler, matters) {
	  var proto = compiler.prototype;
	  proto.visitors = Object.assign({}, wrap(compile, matters), proto.visitors);
	}

	function wrap(func, matters) {
	  var result = {};
	  var length = matters.length;
	  var index = -1;
	  var tuple;

	  while (++index < length) {
	    tuple = func(matters[index]);
	    result[tuple[0]] = tuple[1];
	  }

	  return result
	}

	function isRemarkParser(parser) {
	  return Boolean(parser && parser.prototype && parser.prototype.blockTokenizers)
	}

	function isRemarkCompiler(compiler) {
	  return Boolean(compiler && compiler.prototype && compiler.prototype.visitors)
	}
	return remarkFrontmatter;
}

var remarkFrontmatterExports = requireRemarkFrontmatter();
var frontmatter = /*@__PURE__*/getDefaultExportFromCjs(remarkFrontmatterExports);

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

var objectAssign;
var hasRequiredObjectAssign;

function requireObjectAssign () {
	if (hasRequiredObjectAssign) return objectAssign;
	hasRequiredObjectAssign = 1;
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};
	return objectAssign;
}

var unistUtilMap$1;
var hasRequiredUnistUtilMap$1;

function requireUnistUtilMap$1 () {
	if (hasRequiredUnistUtilMap$1) return unistUtilMap$1;
	hasRequiredUnistUtilMap$1 = 1;

	var assign = requireObjectAssign();

	unistUtilMap$1 = map;

	function map(tree, iteratee) {
	  return preorder(tree, null, null)

	  function preorder(node, index, parent) {
	    var children = node.children;
	    var newNode = assign({}, iteratee(node, index, parent));

	    if (children) {
	      newNode.children = children.map(bound);
	    }

	    return newNode

	    function bound(child, index) {
	      return preorder(child, index, node)
	    }
	  }
	}
	return unistUtilMap$1;
}

var jsYaml$1 = {};

var loader = {};

var common = {};

var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common;
	hasRequiredCommon = 1;


	function isNothing(subject) {
	  return (typeof subject === 'undefined') || (subject === null);
	}


	function isObject(subject) {
	  return (typeof subject === 'object') && (subject !== null);
	}


	function toArray(sequence) {
	  if (Array.isArray(sequence)) return sequence;
	  else if (isNothing(sequence)) return [];

	  return [ sequence ];
	}


	function extend(target, source) {
	  var index, length, key, sourceKeys;

	  if (source) {
	    sourceKeys = Object.keys(source);

	    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
	      key = sourceKeys[index];
	      target[key] = source[key];
	    }
	  }

	  return target;
	}


	function repeat(string, count) {
	  var result = '', cycle;

	  for (cycle = 0; cycle < count; cycle += 1) {
	    result += string;
	  }

	  return result;
	}


	function isNegativeZero(number) {
	  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
	}


	common.isNothing      = isNothing;
	common.isObject       = isObject;
	common.toArray        = toArray;
	common.repeat         = repeat;
	common.isNegativeZero = isNegativeZero;
	common.extend         = extend;
	return common;
}

var exception;
var hasRequiredException;

function requireException () {
	if (hasRequiredException) return exception;
	hasRequiredException = 1;

	function YAMLException(reason, mark) {
	  // Super constructor
	  Error.call(this);

	  this.name = 'YAMLException';
	  this.reason = reason;
	  this.mark = mark;
	  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');

	  // Include stack trace in error object
	  if (Error.captureStackTrace) {
	    // Chrome and NodeJS
	    Error.captureStackTrace(this, this.constructor);
	  } else {
	    // FF, IE 10+ and Safari 6+. Fallback for others
	    this.stack = (new Error()).stack || '';
	  }
	}


	// Inherit from Error
	YAMLException.prototype = Object.create(Error.prototype);
	YAMLException.prototype.constructor = YAMLException;


	YAMLException.prototype.toString = function toString(compact) {
	  var result = this.name + ': ';

	  result += this.reason || '(unknown reason)';

	  if (!compact && this.mark) {
	    result += ' ' + this.mark.toString();
	  }

	  return result;
	};


	exception = YAMLException;
	return exception;
}

var mark;
var hasRequiredMark;

function requireMark () {
	if (hasRequiredMark) return mark;
	hasRequiredMark = 1;


	var common = requireCommon();


	function Mark(name, buffer, position, line, column) {
	  this.name     = name;
	  this.buffer   = buffer;
	  this.position = position;
	  this.line     = line;
	  this.column   = column;
	}


	Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
	  var head, start, tail, end, snippet;

	  if (!this.buffer) return null;

	  indent = indent || 4;
	  maxLength = maxLength || 75;

	  head = '';
	  start = this.position;

	  while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
	    start -= 1;
	    if (this.position - start > (maxLength / 2 - 1)) {
	      head = ' ... ';
	      start += 5;
	      break;
	    }
	  }

	  tail = '';
	  end = this.position;

	  while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
	    end += 1;
	    if (end - this.position > (maxLength / 2 - 1)) {
	      tail = ' ... ';
	      end -= 5;
	      break;
	    }
	  }

	  snippet = this.buffer.slice(start, end);

	  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
	         common.repeat(' ', indent + this.position - start + head.length) + '^';
	};


	Mark.prototype.toString = function toString(compact) {
	  var snippet, where = '';

	  if (this.name) {
	    where += 'in "' + this.name + '" ';
	  }

	  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

	  if (!compact) {
	    snippet = this.getSnippet();

	    if (snippet) {
	      where += ':\n' + snippet;
	    }
	  }

	  return where;
	};


	mark = Mark;
	return mark;
}

var type;
var hasRequiredType;

function requireType () {
	if (hasRequiredType) return type;
	hasRequiredType = 1;

	var YAMLException = requireException();

	var TYPE_CONSTRUCTOR_OPTIONS = [
	  'kind',
	  'resolve',
	  'construct',
	  'instanceOf',
	  'predicate',
	  'represent',
	  'defaultStyle',
	  'styleAliases'
	];

	var YAML_NODE_KINDS = [
	  'scalar',
	  'sequence',
	  'mapping'
	];

	function compileStyleAliases(map) {
	  var result = {};

	  if (map !== null) {
	    Object.keys(map).forEach(function (style) {
	      map[style].forEach(function (alias) {
	        result[String(alias)] = style;
	      });
	    });
	  }

	  return result;
	}

	function Type(tag, options) {
	  options = options || {};

	  Object.keys(options).forEach(function (name) {
	    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
	      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
	    }
	  });

	  // TODO: Add tag format check.
	  this.tag          = tag;
	  this.kind         = options['kind']         || null;
	  this.resolve      = options['resolve']      || function () { return true; };
	  this.construct    = options['construct']    || function (data) { return data; };
	  this.instanceOf   = options['instanceOf']   || null;
	  this.predicate    = options['predicate']    || null;
	  this.represent    = options['represent']    || null;
	  this.defaultStyle = options['defaultStyle'] || null;
	  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

	  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
	    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
	  }
	}

	type = Type;
	return type;
}

var schema$1;
var hasRequiredSchema$1;

function requireSchema$1 () {
	if (hasRequiredSchema$1) return schema$1;
	hasRequiredSchema$1 = 1;

	/*eslint-disable max-len*/

	var common        = requireCommon();
	var YAMLException = requireException();
	var Type          = requireType();


	function compileList(schema, name, result) {
	  var exclude = [];

	  schema.include.forEach(function (includedSchema) {
	    result = compileList(includedSchema, name, result);
	  });

	  schema[name].forEach(function (currentType) {
	    result.forEach(function (previousType, previousIndex) {
	      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
	        exclude.push(previousIndex);
	      }
	    });

	    result.push(currentType);
	  });

	  return result.filter(function (type, index) {
	    return exclude.indexOf(index) === -1;
	  });
	}


	function compileMap(/* lists... */) {
	  var result = {
	        scalar: {},
	        sequence: {},
	        mapping: {},
	        fallback: {}
	      }, index, length;

	  function collectType(type) {
	    result[type.kind][type.tag] = result['fallback'][type.tag] = type;
	  }

	  for (index = 0, length = arguments.length; index < length; index += 1) {
	    arguments[index].forEach(collectType);
	  }
	  return result;
	}


	function Schema(definition) {
	  this.include  = definition.include  || [];
	  this.implicit = definition.implicit || [];
	  this.explicit = definition.explicit || [];

	  this.implicit.forEach(function (type) {
	    if (type.loadKind && type.loadKind !== 'scalar') {
	      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
	    }
	  });

	  this.compiledImplicit = compileList(this, 'implicit', []);
	  this.compiledExplicit = compileList(this, 'explicit', []);
	  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
	}


	Schema.DEFAULT = null;


	Schema.create = function createSchema() {
	  var schemas, types;

	  switch (arguments.length) {
	    case 1:
	      schemas = Schema.DEFAULT;
	      types = arguments[0];
	      break;

	    case 2:
	      schemas = arguments[0];
	      types = arguments[1];
	      break;

	    default:
	      throw new YAMLException('Wrong number of arguments for Schema.create function');
	  }

	  schemas = common.toArray(schemas);
	  types = common.toArray(types);

	  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
	    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
	  }

	  if (!types.every(function (type) { return type instanceof Type; })) {
	    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
	  }

	  return new Schema({
	    include: schemas,
	    explicit: types
	  });
	};


	schema$1 = Schema;
	return schema$1;
}

var str;
var hasRequiredStr;

function requireStr () {
	if (hasRequiredStr) return str;
	hasRequiredStr = 1;

	var Type = requireType();

	str = new Type('tag:yaml.org,2002:str', {
	  kind: 'scalar',
	  construct: function (data) { return data !== null ? data : ''; }
	});
	return str;
}

var seq;
var hasRequiredSeq;

function requireSeq () {
	if (hasRequiredSeq) return seq;
	hasRequiredSeq = 1;

	var Type = requireType();

	seq = new Type('tag:yaml.org,2002:seq', {
	  kind: 'sequence',
	  construct: function (data) { return data !== null ? data : []; }
	});
	return seq;
}

var map$1;
var hasRequiredMap;

function requireMap () {
	if (hasRequiredMap) return map$1;
	hasRequiredMap = 1;

	var Type = requireType();

	map$1 = new Type('tag:yaml.org,2002:map', {
	  kind: 'mapping',
	  construct: function (data) { return data !== null ? data : {}; }
	});
	return map$1;
}

var failsafe;
var hasRequiredFailsafe;

function requireFailsafe () {
	if (hasRequiredFailsafe) return failsafe;
	hasRequiredFailsafe = 1;


	var Schema = requireSchema$1();


	failsafe = new Schema({
	  explicit: [
	    requireStr(),
	    requireSeq(),
	    requireMap()
	  ]
	});
	return failsafe;
}

var _null;
var hasRequired_null;

function require_null () {
	if (hasRequired_null) return _null;
	hasRequired_null = 1;

	var Type = requireType();

	function resolveYamlNull(data) {
	  if (data === null) return true;

	  var max = data.length;

	  return (max === 1 && data === '~') ||
	         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
	}

	function constructYamlNull() {
	  return null;
	}

	function isNull(object) {
	  return object === null;
	}

	_null = new Type('tag:yaml.org,2002:null', {
	  kind: 'scalar',
	  resolve: resolveYamlNull,
	  construct: constructYamlNull,
	  predicate: isNull,
	  represent: {
	    canonical: function () { return '~';    },
	    lowercase: function () { return 'null'; },
	    uppercase: function () { return 'NULL'; },
	    camelcase: function () { return 'Null'; }
	  },
	  defaultStyle: 'lowercase'
	});
	return _null;
}

var bool;
var hasRequiredBool;

function requireBool () {
	if (hasRequiredBool) return bool;
	hasRequiredBool = 1;

	var Type = requireType();

	function resolveYamlBoolean(data) {
	  if (data === null) return false;

	  var max = data.length;

	  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
	         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
	}

	function constructYamlBoolean(data) {
	  return data === 'true' ||
	         data === 'True' ||
	         data === 'TRUE';
	}

	function isBoolean(object) {
	  return Object.prototype.toString.call(object) === '[object Boolean]';
	}

	bool = new Type('tag:yaml.org,2002:bool', {
	  kind: 'scalar',
	  resolve: resolveYamlBoolean,
	  construct: constructYamlBoolean,
	  predicate: isBoolean,
	  represent: {
	    lowercase: function (object) { return object ? 'true' : 'false'; },
	    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
	    camelcase: function (object) { return object ? 'True' : 'False'; }
	  },
	  defaultStyle: 'lowercase'
	});
	return bool;
}

var int$1;
var hasRequiredInt;

function requireInt () {
	if (hasRequiredInt) return int$1;
	hasRequiredInt = 1;

	var common = requireCommon();
	var Type   = requireType();

	function isHexCode(c) {
	  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
	         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
	         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
	}

	function isOctCode(c) {
	  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
	}

	function isDecCode(c) {
	  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
	}

	function resolveYamlInteger(data) {
	  if (data === null) return false;

	  var max = data.length,
	      index = 0,
	      hasDigits = false,
	      ch;

	  if (!max) return false;

	  ch = data[index];

	  // sign
	  if (ch === '-' || ch === '+') {
	    ch = data[++index];
	  }

	  if (ch === '0') {
	    // 0
	    if (index + 1 === max) return true;
	    ch = data[++index];

	    // base 2, base 8, base 16

	    if (ch === 'b') {
	      // base 2
	      index++;

	      for (; index < max; index++) {
	        ch = data[index];
	        if (ch === '_') continue;
	        if (ch !== '0' && ch !== '1') return false;
	        hasDigits = true;
	      }
	      return hasDigits && ch !== '_';
	    }


	    if (ch === 'x') {
	      // base 16
	      index++;

	      for (; index < max; index++) {
	        ch = data[index];
	        if (ch === '_') continue;
	        if (!isHexCode(data.charCodeAt(index))) return false;
	        hasDigits = true;
	      }
	      return hasDigits && ch !== '_';
	    }

	    // base 8
	    for (; index < max; index++) {
	      ch = data[index];
	      if (ch === '_') continue;
	      if (!isOctCode(data.charCodeAt(index))) return false;
	      hasDigits = true;
	    }
	    return hasDigits && ch !== '_';
	  }

	  // base 10 (except 0) or base 60

	  // value should not start with `_`;
	  if (ch === '_') return false;

	  for (; index < max; index++) {
	    ch = data[index];
	    if (ch === '_') continue;
	    if (ch === ':') break;
	    if (!isDecCode(data.charCodeAt(index))) {
	      return false;
	    }
	    hasDigits = true;
	  }

	  // Should have digits and should not end with `_`
	  if (!hasDigits || ch === '_') return false;

	  // if !base60 - done;
	  if (ch !== ':') return true;

	  // base60 almost not used, no needs to optimize
	  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
	}

	function constructYamlInteger(data) {
	  var value = data, sign = 1, ch, base, digits = [];

	  if (value.indexOf('_') !== -1) {
	    value = value.replace(/_/g, '');
	  }

	  ch = value[0];

	  if (ch === '-' || ch === '+') {
	    if (ch === '-') sign = -1;
	    value = value.slice(1);
	    ch = value[0];
	  }

	  if (value === '0') return 0;

	  if (ch === '0') {
	    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
	    if (value[1] === 'x') return sign * parseInt(value, 16);
	    return sign * parseInt(value, 8);
	  }

	  if (value.indexOf(':') !== -1) {
	    value.split(':').forEach(function (v) {
	      digits.unshift(parseInt(v, 10));
	    });

	    value = 0;
	    base = 1;

	    digits.forEach(function (d) {
	      value += (d * base);
	      base *= 60;
	    });

	    return sign * value;

	  }

	  return sign * parseInt(value, 10);
	}

	function isInteger(object) {
	  return (Object.prototype.toString.call(object)) === '[object Number]' &&
	         (object % 1 === 0 && !common.isNegativeZero(object));
	}

	int$1 = new Type('tag:yaml.org,2002:int', {
	  kind: 'scalar',
	  resolve: resolveYamlInteger,
	  construct: constructYamlInteger,
	  predicate: isInteger,
	  represent: {
	    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
	    octal:       function (obj) { return obj >= 0 ? '0'  + obj.toString(8) : '-0'  + obj.toString(8).slice(1); },
	    decimal:     function (obj) { return obj.toString(10); },
	    /* eslint-disable max-len */
	    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
	  },
	  defaultStyle: 'decimal',
	  styleAliases: {
	    binary:      [ 2,  'bin' ],
	    octal:       [ 8,  'oct' ],
	    decimal:     [ 10, 'dec' ],
	    hexadecimal: [ 16, 'hex' ]
	  }
	});
	return int$1;
}

var float;
var hasRequiredFloat;

function requireFloat () {
	if (hasRequiredFloat) return float;
	hasRequiredFloat = 1;

	var common = requireCommon();
	var Type   = requireType();

	var YAML_FLOAT_PATTERN = new RegExp(
	  // 2.5e4, 2.5 and integers
	  '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
	  // .2e4, .2
	  // special case, seems not from spec
	  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
	  // 20:59
	  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
	  // .inf
	  '|[-+]?\\.(?:inf|Inf|INF)' +
	  // .nan
	  '|\\.(?:nan|NaN|NAN))$');

	function resolveYamlFloat(data) {
	  if (data === null) return false;

	  if (!YAML_FLOAT_PATTERN.test(data) ||
	      // Quick hack to not allow integers end with `_`
	      // Probably should update regexp & check speed
	      data[data.length - 1] === '_') {
	    return false;
	  }

	  return true;
	}

	function constructYamlFloat(data) {
	  var value, sign, base, digits;

	  value  = data.replace(/_/g, '').toLowerCase();
	  sign   = value[0] === '-' ? -1 : 1;
	  digits = [];

	  if ('+-'.indexOf(value[0]) >= 0) {
	    value = value.slice(1);
	  }

	  if (value === '.inf') {
	    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

	  } else if (value === '.nan') {
	    return NaN;

	  } else if (value.indexOf(':') >= 0) {
	    value.split(':').forEach(function (v) {
	      digits.unshift(parseFloat(v, 10));
	    });

	    value = 0.0;
	    base = 1;

	    digits.forEach(function (d) {
	      value += d * base;
	      base *= 60;
	    });

	    return sign * value;

	  }
	  return sign * parseFloat(value, 10);
	}


	var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

	function representYamlFloat(object, style) {
	  var res;

	  if (isNaN(object)) {
	    switch (style) {
	      case 'lowercase': return '.nan';
	      case 'uppercase': return '.NAN';
	      case 'camelcase': return '.NaN';
	    }
	  } else if (Number.POSITIVE_INFINITY === object) {
	    switch (style) {
	      case 'lowercase': return '.inf';
	      case 'uppercase': return '.INF';
	      case 'camelcase': return '.Inf';
	    }
	  } else if (Number.NEGATIVE_INFINITY === object) {
	    switch (style) {
	      case 'lowercase': return '-.inf';
	      case 'uppercase': return '-.INF';
	      case 'camelcase': return '-.Inf';
	    }
	  } else if (common.isNegativeZero(object)) {
	    return '-0.0';
	  }

	  res = object.toString(10);

	  // JS stringifier can build scientific format without dots: 5e-100,
	  // while YAML requres dot: 5.e-100. Fix it with simple hack

	  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
	}

	function isFloat(object) {
	  return (Object.prototype.toString.call(object) === '[object Number]') &&
	         (object % 1 !== 0 || common.isNegativeZero(object));
	}

	float = new Type('tag:yaml.org,2002:float', {
	  kind: 'scalar',
	  resolve: resolveYamlFloat,
	  construct: constructYamlFloat,
	  predicate: isFloat,
	  represent: representYamlFloat,
	  defaultStyle: 'lowercase'
	});
	return float;
}

var json;
var hasRequiredJson;

function requireJson () {
	if (hasRequiredJson) return json;
	hasRequiredJson = 1;


	var Schema = requireSchema$1();


	json = new Schema({
	  include: [
	    requireFailsafe()
	  ],
	  implicit: [
	    require_null(),
	    requireBool(),
	    requireInt(),
	    requireFloat()
	  ]
	});
	return json;
}

var core;
var hasRequiredCore;

function requireCore () {
	if (hasRequiredCore) return core;
	hasRequiredCore = 1;


	var Schema = requireSchema$1();


	core = new Schema({
	  include: [
	    requireJson()
	  ]
	});
	return core;
}

var timestamp;
var hasRequiredTimestamp;

function requireTimestamp () {
	if (hasRequiredTimestamp) return timestamp;
	hasRequiredTimestamp = 1;

	var Type = requireType();

	var YAML_DATE_REGEXP = new RegExp(
	  '^([0-9][0-9][0-9][0-9])'          + // [1] year
	  '-([0-9][0-9])'                    + // [2] month
	  '-([0-9][0-9])$');                   // [3] day

	var YAML_TIMESTAMP_REGEXP = new RegExp(
	  '^([0-9][0-9][0-9][0-9])'          + // [1] year
	  '-([0-9][0-9]?)'                   + // [2] month
	  '-([0-9][0-9]?)'                   + // [3] day
	  '(?:[Tt]|[ \\t]+)'                 + // ...
	  '([0-9][0-9]?)'                    + // [4] hour
	  ':([0-9][0-9])'                    + // [5] minute
	  ':([0-9][0-9])'                    + // [6] second
	  '(?:\\.([0-9]*))?'                 + // [7] fraction
	  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
	  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

	function resolveYamlTimestamp(data) {
	  if (data === null) return false;
	  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
	  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
	  return false;
	}

	function constructYamlTimestamp(data) {
	  var match, year, month, day, hour, minute, second, fraction = 0,
	      delta = null, tz_hour, tz_minute, date;

	  match = YAML_DATE_REGEXP.exec(data);
	  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

	  if (match === null) throw new Error('Date resolve error');

	  // match: [1] year [2] month [3] day

	  year = +(match[1]);
	  month = +(match[2]) - 1; // JS month starts with 0
	  day = +(match[3]);

	  if (!match[4]) { // no hour
	    return new Date(Date.UTC(year, month, day));
	  }

	  // match: [4] hour [5] minute [6] second [7] fraction

	  hour = +(match[4]);
	  minute = +(match[5]);
	  second = +(match[6]);

	  if (match[7]) {
	    fraction = match[7].slice(0, 3);
	    while (fraction.length < 3) { // milli-seconds
	      fraction += '0';
	    }
	    fraction = +fraction;
	  }

	  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

	  if (match[9]) {
	    tz_hour = +(match[10]);
	    tz_minute = +(match[11] || 0);
	    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
	    if (match[9] === '-') delta = -delta;
	  }

	  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

	  if (delta) date.setTime(date.getTime() - delta);

	  return date;
	}

	function representYamlTimestamp(object /*, style*/) {
	  return object.toISOString();
	}

	timestamp = new Type('tag:yaml.org,2002:timestamp', {
	  kind: 'scalar',
	  resolve: resolveYamlTimestamp,
	  construct: constructYamlTimestamp,
	  instanceOf: Date,
	  represent: representYamlTimestamp
	});
	return timestamp;
}

var merge;
var hasRequiredMerge$1;

function requireMerge$1 () {
	if (hasRequiredMerge$1) return merge;
	hasRequiredMerge$1 = 1;

	var Type = requireType();

	function resolveYamlMerge(data) {
	  return data === '<<' || data === null;
	}

	merge = new Type('tag:yaml.org,2002:merge', {
	  kind: 'scalar',
	  resolve: resolveYamlMerge
	});
	return merge;
}

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var binary;
var hasRequiredBinary;

function requireBinary () {
	if (hasRequiredBinary) return binary;
	hasRequiredBinary = 1;

	/*eslint-disable no-bitwise*/

	var NodeBuffer;

	try {
	  // A trick for browserified version, to not include `Buffer` shim
	  var _require = commonjsRequire;
	  NodeBuffer = _require('buffer').Buffer;
	} catch (__) {}

	var Type       = requireType();


	// [ 64, 65, 66 ] -> [ padding, CR, LF ]
	var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


	function resolveYamlBinary(data) {
	  if (data === null) return false;

	  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

	  // Convert one by one.
	  for (idx = 0; idx < max; idx++) {
	    code = map.indexOf(data.charAt(idx));

	    // Skip CR/LF
	    if (code > 64) continue;

	    // Fail on illegal characters
	    if (code < 0) return false;

	    bitlen += 6;
	  }

	  // If there are any bits left, source was corrupted
	  return (bitlen % 8) === 0;
	}

	function constructYamlBinary(data) {
	  var idx, tailbits,
	      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
	      max = input.length,
	      map = BASE64_MAP,
	      bits = 0,
	      result = [];

	  // Collect by 6*4 bits (3 bytes)

	  for (idx = 0; idx < max; idx++) {
	    if ((idx % 4 === 0) && idx) {
	      result.push((bits >> 16) & 0xFF);
	      result.push((bits >> 8) & 0xFF);
	      result.push(bits & 0xFF);
	    }

	    bits = (bits << 6) | map.indexOf(input.charAt(idx));
	  }

	  // Dump tail

	  tailbits = (max % 4) * 6;

	  if (tailbits === 0) {
	    result.push((bits >> 16) & 0xFF);
	    result.push((bits >> 8) & 0xFF);
	    result.push(bits & 0xFF);
	  } else if (tailbits === 18) {
	    result.push((bits >> 10) & 0xFF);
	    result.push((bits >> 2) & 0xFF);
	  } else if (tailbits === 12) {
	    result.push((bits >> 4) & 0xFF);
	  }

	  // Wrap into Buffer for NodeJS and leave Array for browser
	  if (NodeBuffer) {
	    // Support node 6.+ Buffer API when available
	    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
	  }

	  return result;
	}

	function representYamlBinary(object /*, style*/) {
	  var result = '', bits = 0, idx, tail,
	      max = object.length,
	      map = BASE64_MAP;

	  // Convert every three bytes to 4 ASCII characters.

	  for (idx = 0; idx < max; idx++) {
	    if ((idx % 3 === 0) && idx) {
	      result += map[(bits >> 18) & 0x3F];
	      result += map[(bits >> 12) & 0x3F];
	      result += map[(bits >> 6) & 0x3F];
	      result += map[bits & 0x3F];
	    }

	    bits = (bits << 8) + object[idx];
	  }

	  // Dump tail

	  tail = max % 3;

	  if (tail === 0) {
	    result += map[(bits >> 18) & 0x3F];
	    result += map[(bits >> 12) & 0x3F];
	    result += map[(bits >> 6) & 0x3F];
	    result += map[bits & 0x3F];
	  } else if (tail === 2) {
	    result += map[(bits >> 10) & 0x3F];
	    result += map[(bits >> 4) & 0x3F];
	    result += map[(bits << 2) & 0x3F];
	    result += map[64];
	  } else if (tail === 1) {
	    result += map[(bits >> 2) & 0x3F];
	    result += map[(bits << 4) & 0x3F];
	    result += map[64];
	    result += map[64];
	  }

	  return result;
	}

	function isBinary(object) {
	  return NodeBuffer && NodeBuffer.isBuffer(object);
	}

	binary = new Type('tag:yaml.org,2002:binary', {
	  kind: 'scalar',
	  resolve: resolveYamlBinary,
	  construct: constructYamlBinary,
	  predicate: isBinary,
	  represent: representYamlBinary
	});
	return binary;
}

var omap;
var hasRequiredOmap;

function requireOmap () {
	if (hasRequiredOmap) return omap;
	hasRequiredOmap = 1;

	var Type = requireType();

	var _hasOwnProperty = Object.prototype.hasOwnProperty;
	var _toString       = Object.prototype.toString;

	function resolveYamlOmap(data) {
	  if (data === null) return true;

	  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
	      object = data;

	  for (index = 0, length = object.length; index < length; index += 1) {
	    pair = object[index];
	    pairHasKey = false;

	    if (_toString.call(pair) !== '[object Object]') return false;

	    for (pairKey in pair) {
	      if (_hasOwnProperty.call(pair, pairKey)) {
	        if (!pairHasKey) pairHasKey = true;
	        else return false;
	      }
	    }

	    if (!pairHasKey) return false;

	    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
	    else return false;
	  }

	  return true;
	}

	function constructYamlOmap(data) {
	  return data !== null ? data : [];
	}

	omap = new Type('tag:yaml.org,2002:omap', {
	  kind: 'sequence',
	  resolve: resolveYamlOmap,
	  construct: constructYamlOmap
	});
	return omap;
}

var pairs;
var hasRequiredPairs;

function requirePairs () {
	if (hasRequiredPairs) return pairs;
	hasRequiredPairs = 1;

	var Type = requireType();

	var _toString = Object.prototype.toString;

	function resolveYamlPairs(data) {
	  if (data === null) return true;

	  var index, length, pair, keys, result,
	      object = data;

	  result = new Array(object.length);

	  for (index = 0, length = object.length; index < length; index += 1) {
	    pair = object[index];

	    if (_toString.call(pair) !== '[object Object]') return false;

	    keys = Object.keys(pair);

	    if (keys.length !== 1) return false;

	    result[index] = [ keys[0], pair[keys[0]] ];
	  }

	  return true;
	}

	function constructYamlPairs(data) {
	  if (data === null) return [];

	  var index, length, pair, keys, result,
	      object = data;

	  result = new Array(object.length);

	  for (index = 0, length = object.length; index < length; index += 1) {
	    pair = object[index];

	    keys = Object.keys(pair);

	    result[index] = [ keys[0], pair[keys[0]] ];
	  }

	  return result;
	}

	pairs = new Type('tag:yaml.org,2002:pairs', {
	  kind: 'sequence',
	  resolve: resolveYamlPairs,
	  construct: constructYamlPairs
	});
	return pairs;
}

var set;
var hasRequiredSet;

function requireSet () {
	if (hasRequiredSet) return set;
	hasRequiredSet = 1;

	var Type = requireType();

	var _hasOwnProperty = Object.prototype.hasOwnProperty;

	function resolveYamlSet(data) {
	  if (data === null) return true;

	  var key, object = data;

	  for (key in object) {
	    if (_hasOwnProperty.call(object, key)) {
	      if (object[key] !== null) return false;
	    }
	  }

	  return true;
	}

	function constructYamlSet(data) {
	  return data !== null ? data : {};
	}

	set = new Type('tag:yaml.org,2002:set', {
	  kind: 'mapping',
	  resolve: resolveYamlSet,
	  construct: constructYamlSet
	});
	return set;
}

var default_safe;
var hasRequiredDefault_safe;

function requireDefault_safe () {
	if (hasRequiredDefault_safe) return default_safe;
	hasRequiredDefault_safe = 1;


	var Schema = requireSchema$1();


	default_safe = new Schema({
	  include: [
	    requireCore()
	  ],
	  implicit: [
	    requireTimestamp(),
	    requireMerge$1()
	  ],
	  explicit: [
	    requireBinary(),
	    requireOmap(),
	    requirePairs(),
	    requireSet()
	  ]
	});
	return default_safe;
}

var _undefined;
var hasRequired_undefined;

function require_undefined () {
	if (hasRequired_undefined) return _undefined;
	hasRequired_undefined = 1;

	var Type = requireType();

	function resolveJavascriptUndefined() {
	  return true;
	}

	function constructJavascriptUndefined() {
	  /*eslint-disable no-undefined*/
	  return undefined;
	}

	function representJavascriptUndefined() {
	  return '';
	}

	function isUndefined(object) {
	  return typeof object === 'undefined';
	}

	_undefined = new Type('tag:yaml.org,2002:js/undefined', {
	  kind: 'scalar',
	  resolve: resolveJavascriptUndefined,
	  construct: constructJavascriptUndefined,
	  predicate: isUndefined,
	  represent: representJavascriptUndefined
	});
	return _undefined;
}

var regexp;
var hasRequiredRegexp;

function requireRegexp () {
	if (hasRequiredRegexp) return regexp;
	hasRequiredRegexp = 1;

	var Type = requireType();

	function resolveJavascriptRegExp(data) {
	  if (data === null) return false;
	  if (data.length === 0) return false;

	  var regexp = data,
	      tail   = /\/([gim]*)$/.exec(data),
	      modifiers = '';

	  // if regexp starts with '/' it can have modifiers and must be properly closed
	  // `/foo/gim` - modifiers tail can be maximum 3 chars
	  if (regexp[0] === '/') {
	    if (tail) modifiers = tail[1];

	    if (modifiers.length > 3) return false;
	    // if expression starts with /, is should be properly terminated
	    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
	  }

	  return true;
	}

	function constructJavascriptRegExp(data) {
	  var regexp = data,
	      tail   = /\/([gim]*)$/.exec(data),
	      modifiers = '';

	  // `/foo/gim` - tail can be maximum 4 chars
	  if (regexp[0] === '/') {
	    if (tail) modifiers = tail[1];
	    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
	  }

	  return new RegExp(regexp, modifiers);
	}

	function representJavascriptRegExp(object /*, style*/) {
	  var result = '/' + object.source + '/';

	  if (object.global) result += 'g';
	  if (object.multiline) result += 'm';
	  if (object.ignoreCase) result += 'i';

	  return result;
	}

	function isRegExp(object) {
	  return Object.prototype.toString.call(object) === '[object RegExp]';
	}

	regexp = new Type('tag:yaml.org,2002:js/regexp', {
	  kind: 'scalar',
	  resolve: resolveJavascriptRegExp,
	  construct: constructJavascriptRegExp,
	  predicate: isRegExp,
	  represent: representJavascriptRegExp
	});
	return regexp;
}

var _function;
var hasRequired_function;

function require_function () {
	if (hasRequired_function) return _function;
	hasRequired_function = 1;

	var esprima;

	// Browserified version does not have esprima
	//
	// 1. For node.js just require module as deps
	// 2. For browser try to require mudule via external AMD system.
	//    If not found - try to fallback to window.esprima. If not
	//    found too - then fail to parse.
	//
	try {
	  // workaround to exclude package from browserify list.
	  var _require = commonjsRequire;
	  esprima = _require('esprima');
	} catch (_) {
	  /* eslint-disable no-redeclare */
	  /* global window */
	  if (typeof window !== 'undefined') esprima = window.esprima;
	}

	var Type = requireType();

	function resolveJavascriptFunction(data) {
	  if (data === null) return false;

	  try {
	    var source = '(' + data + ')',
	        ast    = esprima.parse(source, { range: true });

	    if (ast.type                    !== 'Program'             ||
	        ast.body.length             !== 1                     ||
	        ast.body[0].type            !== 'ExpressionStatement' ||
	        (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
	          ast.body[0].expression.type !== 'FunctionExpression')) {
	      return false;
	    }

	    return true;
	  } catch (err) {
	    return false;
	  }
	}

	function constructJavascriptFunction(data) {
	  /*jslint evil:true*/

	  var source = '(' + data + ')',
	      ast    = esprima.parse(source, { range: true }),
	      params = [],
	      body;

	  if (ast.type                    !== 'Program'             ||
	      ast.body.length             !== 1                     ||
	      ast.body[0].type            !== 'ExpressionStatement' ||
	      (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
	        ast.body[0].expression.type !== 'FunctionExpression')) {
	    throw new Error('Failed to resolve function');
	  }

	  ast.body[0].expression.params.forEach(function (param) {
	    params.push(param.name);
	  });

	  body = ast.body[0].expression.body.range;

	  // Esprima's ranges include the first '{' and the last '}' characters on
	  // function expressions. So cut them out.
	  if (ast.body[0].expression.body.type === 'BlockStatement') {
	    /*eslint-disable no-new-func*/
	    return new Function(params, source.slice(body[0] + 1, body[1] - 1));
	  }
	  // ES6 arrow functions can omit the BlockStatement. In that case, just return
	  // the body.
	  /*eslint-disable no-new-func*/
	  return new Function(params, 'return ' + source.slice(body[0], body[1]));
	}

	function representJavascriptFunction(object /*, style*/) {
	  return object.toString();
	}

	function isFunction(object) {
	  return Object.prototype.toString.call(object) === '[object Function]';
	}

	_function = new Type('tag:yaml.org,2002:js/function', {
	  kind: 'scalar',
	  resolve: resolveJavascriptFunction,
	  construct: constructJavascriptFunction,
	  predicate: isFunction,
	  represent: representJavascriptFunction
	});
	return _function;
}

var default_full;
var hasRequiredDefault_full;

function requireDefault_full () {
	if (hasRequiredDefault_full) return default_full;
	hasRequiredDefault_full = 1;


	var Schema = requireSchema$1();


	default_full = Schema.DEFAULT = new Schema({
	  include: [
	    requireDefault_safe()
	  ],
	  explicit: [
	    require_undefined(),
	    requireRegexp(),
	    require_function()
	  ]
	});
	return default_full;
}

var hasRequiredLoader;

function requireLoader () {
	if (hasRequiredLoader) return loader;
	hasRequiredLoader = 1;

	/*eslint-disable max-len,no-use-before-define*/

	var common              = requireCommon();
	var YAMLException       = requireException();
	var Mark                = requireMark();
	var DEFAULT_SAFE_SCHEMA = requireDefault_safe();
	var DEFAULT_FULL_SCHEMA = requireDefault_full();


	var _hasOwnProperty = Object.prototype.hasOwnProperty;


	var CONTEXT_FLOW_IN   = 1;
	var CONTEXT_FLOW_OUT  = 2;
	var CONTEXT_BLOCK_IN  = 3;
	var CONTEXT_BLOCK_OUT = 4;


	var CHOMPING_CLIP  = 1;
	var CHOMPING_STRIP = 2;
	var CHOMPING_KEEP  = 3;


	var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
	var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
	var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
	var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
	var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


	function _class(obj) { return Object.prototype.toString.call(obj); }

	function is_EOL(c) {
	  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
	}

	function is_WHITE_SPACE(c) {
	  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
	}

	function is_WS_OR_EOL(c) {
	  return (c === 0x09/* Tab */) ||
	         (c === 0x20/* Space */) ||
	         (c === 0x0A/* LF */) ||
	         (c === 0x0D/* CR */);
	}

	function is_FLOW_INDICATOR(c) {
	  return c === 0x2C/* , */ ||
	         c === 0x5B/* [ */ ||
	         c === 0x5D/* ] */ ||
	         c === 0x7B/* { */ ||
	         c === 0x7D/* } */;
	}

	function fromHexCode(c) {
	  var lc;

	  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
	    return c - 0x30;
	  }

	  /*eslint-disable no-bitwise*/
	  lc = c | 0x20;

	  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
	    return lc - 0x61 + 10;
	  }

	  return -1;
	}

	function escapedHexLen(c) {
	  if (c === 0x78/* x */) { return 2; }
	  if (c === 0x75/* u */) { return 4; }
	  if (c === 0x55/* U */) { return 8; }
	  return 0;
	}

	function fromDecimalCode(c) {
	  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
	    return c - 0x30;
	  }

	  return -1;
	}

	function simpleEscapeSequence(c) {
	  /* eslint-disable indent */
	  return (c === 0x30/* 0 */) ? '\x00' :
	        (c === 0x61/* a */) ? '\x07' :
	        (c === 0x62/* b */) ? '\x08' :
	        (c === 0x74/* t */) ? '\x09' :
	        (c === 0x09/* Tab */) ? '\x09' :
	        (c === 0x6E/* n */) ? '\x0A' :
	        (c === 0x76/* v */) ? '\x0B' :
	        (c === 0x66/* f */) ? '\x0C' :
	        (c === 0x72/* r */) ? '\x0D' :
	        (c === 0x65/* e */) ? '\x1B' :
	        (c === 0x20/* Space */) ? ' ' :
	        (c === 0x22/* " */) ? '\x22' :
	        (c === 0x2F/* / */) ? '/' :
	        (c === 0x5C/* \ */) ? '\x5C' :
	        (c === 0x4E/* N */) ? '\x85' :
	        (c === 0x5F/* _ */) ? '\xA0' :
	        (c === 0x4C/* L */) ? '\u2028' :
	        (c === 0x50/* P */) ? '\u2029' : '';
	}

	function charFromCodepoint(c) {
	  if (c <= 0xFFFF) {
	    return String.fromCharCode(c);
	  }
	  // Encode UTF-16 surrogate pair
	  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
	  return String.fromCharCode(
	    ((c - 0x010000) >> 10) + 0xD800,
	    ((c - 0x010000) & 0x03FF) + 0xDC00
	  );
	}

	var simpleEscapeCheck = new Array(256); // integer, for fast access
	var simpleEscapeMap = new Array(256);
	for (var i = 0; i < 256; i++) {
	  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
	  simpleEscapeMap[i] = simpleEscapeSequence(i);
	}


	function State(input, options) {
	  this.input = input;

	  this.filename  = options['filename']  || null;
	  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
	  this.onWarning = options['onWarning'] || null;
	  this.legacy    = options['legacy']    || false;
	  this.json      = options['json']      || false;
	  this.listener  = options['listener']  || null;

	  this.implicitTypes = this.schema.compiledImplicit;
	  this.typeMap       = this.schema.compiledTypeMap;

	  this.length     = input.length;
	  this.position   = 0;
	  this.line       = 0;
	  this.lineStart  = 0;
	  this.lineIndent = 0;

	  this.documents = [];

	  /*
	  this.version;
	  this.checkLineBreaks;
	  this.tagMap;
	  this.anchorMap;
	  this.tag;
	  this.anchor;
	  this.kind;
	  this.result;*/

	}


	function generateError(state, message) {
	  return new YAMLException(
	    message,
	    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
	}

	function throwError(state, message) {
	  throw generateError(state, message);
	}

	function throwWarning(state, message) {
	  if (state.onWarning) {
	    state.onWarning.call(null, generateError(state, message));
	  }
	}


	var directiveHandlers = {

	  YAML: function handleYamlDirective(state, name, args) {

	    var match, major, minor;

	    if (state.version !== null) {
	      throwError(state, 'duplication of %YAML directive');
	    }

	    if (args.length !== 1) {
	      throwError(state, 'YAML directive accepts exactly one argument');
	    }

	    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

	    if (match === null) {
	      throwError(state, 'ill-formed argument of the YAML directive');
	    }

	    major = parseInt(match[1], 10);
	    minor = parseInt(match[2], 10);

	    if (major !== 1) {
	      throwError(state, 'unacceptable YAML version of the document');
	    }

	    state.version = args[0];
	    state.checkLineBreaks = (minor < 2);

	    if (minor !== 1 && minor !== 2) {
	      throwWarning(state, 'unsupported YAML version of the document');
	    }
	  },

	  TAG: function handleTagDirective(state, name, args) {

	    var handle, prefix;

	    if (args.length !== 2) {
	      throwError(state, 'TAG directive accepts exactly two arguments');
	    }

	    handle = args[0];
	    prefix = args[1];

	    if (!PATTERN_TAG_HANDLE.test(handle)) {
	      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
	    }

	    if (_hasOwnProperty.call(state.tagMap, handle)) {
	      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
	    }

	    if (!PATTERN_TAG_URI.test(prefix)) {
	      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
	    }

	    state.tagMap[handle] = prefix;
	  }
	};


	function captureSegment(state, start, end, checkJson) {
	  var _position, _length, _character, _result;

	  if (start < end) {
	    _result = state.input.slice(start, end);

	    if (checkJson) {
	      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
	        _character = _result.charCodeAt(_position);
	        if (!(_character === 0x09 ||
	              (0x20 <= _character && _character <= 0x10FFFF))) {
	          throwError(state, 'expected valid JSON character');
	        }
	      }
	    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
	      throwError(state, 'the stream contains non-printable characters');
	    }

	    state.result += _result;
	  }
	}

	function mergeMappings(state, destination, source, overridableKeys) {
	  var sourceKeys, key, index, quantity;

	  if (!common.isObject(source)) {
	    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
	  }

	  sourceKeys = Object.keys(source);

	  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
	    key = sourceKeys[index];

	    if (!_hasOwnProperty.call(destination, key)) {
	      destination[key] = source[key];
	      overridableKeys[key] = true;
	    }
	  }
	}

	function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
	  var index, quantity;

	  // The output is a plain object here, so keys can only be strings.
	  // We need to convert keyNode to a string, but doing so can hang the process
	  // (deeply nested arrays that explode exponentially using aliases).
	  if (Array.isArray(keyNode)) {
	    keyNode = Array.prototype.slice.call(keyNode);

	    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
	      if (Array.isArray(keyNode[index])) {
	        throwError(state, 'nested arrays are not supported inside keys');
	      }

	      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
	        keyNode[index] = '[object Object]';
	      }
	    }
	  }

	  // Avoid code execution in load() via toString property
	  // (still use its own toString for arrays, timestamps,
	  // and whatever user schema extensions happen to have @@toStringTag)
	  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
	    keyNode = '[object Object]';
	  }


	  keyNode = String(keyNode);

	  if (_result === null) {
	    _result = {};
	  }

	  if (keyTag === 'tag:yaml.org,2002:merge') {
	    if (Array.isArray(valueNode)) {
	      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
	        mergeMappings(state, _result, valueNode[index], overridableKeys);
	      }
	    } else {
	      mergeMappings(state, _result, valueNode, overridableKeys);
	    }
	  } else {
	    if (!state.json &&
	        !_hasOwnProperty.call(overridableKeys, keyNode) &&
	        _hasOwnProperty.call(_result, keyNode)) {
	      state.line = startLine || state.line;
	      state.position = startPos || state.position;
	      throwError(state, 'duplicated mapping key');
	    }
	    _result[keyNode] = valueNode;
	    delete overridableKeys[keyNode];
	  }

	  return _result;
	}

	function readLineBreak(state) {
	  var ch;

	  ch = state.input.charCodeAt(state.position);

	  if (ch === 0x0A/* LF */) {
	    state.position++;
	  } else if (ch === 0x0D/* CR */) {
	    state.position++;
	    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
	      state.position++;
	    }
	  } else {
	    throwError(state, 'a line break is expected');
	  }

	  state.line += 1;
	  state.lineStart = state.position;
	}

	function skipSeparationSpace(state, allowComments, checkIndent) {
	  var lineBreaks = 0,
	      ch = state.input.charCodeAt(state.position);

	  while (ch !== 0) {
	    while (is_WHITE_SPACE(ch)) {
	      ch = state.input.charCodeAt(++state.position);
	    }

	    if (allowComments && ch === 0x23/* # */) {
	      do {
	        ch = state.input.charCodeAt(++state.position);
	      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
	    }

	    if (is_EOL(ch)) {
	      readLineBreak(state);

	      ch = state.input.charCodeAt(state.position);
	      lineBreaks++;
	      state.lineIndent = 0;

	      while (ch === 0x20/* Space */) {
	        state.lineIndent++;
	        ch = state.input.charCodeAt(++state.position);
	      }
	    } else {
	      break;
	    }
	  }

	  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
	    throwWarning(state, 'deficient indentation');
	  }

	  return lineBreaks;
	}

	function testDocumentSeparator(state) {
	  var _position = state.position,
	      ch;

	  ch = state.input.charCodeAt(_position);

	  // Condition state.position === state.lineStart is tested
	  // in parent on each call, for efficiency. No needs to test here again.
	  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
	      ch === state.input.charCodeAt(_position + 1) &&
	      ch === state.input.charCodeAt(_position + 2)) {

	    _position += 3;

	    ch = state.input.charCodeAt(_position);

	    if (ch === 0 || is_WS_OR_EOL(ch)) {
	      return true;
	    }
	  }

	  return false;
	}

	function writeFoldedLines(state, count) {
	  if (count === 1) {
	    state.result += ' ';
	  } else if (count > 1) {
	    state.result += common.repeat('\n', count - 1);
	  }
	}


	function readPlainScalar(state, nodeIndent, withinFlowCollection) {
	  var preceding,
	      following,
	      captureStart,
	      captureEnd,
	      hasPendingContent,
	      _line,
	      _lineStart,
	      _lineIndent,
	      _kind = state.kind,
	      _result = state.result,
	      ch;

	  ch = state.input.charCodeAt(state.position);

	  if (is_WS_OR_EOL(ch)      ||
	      is_FLOW_INDICATOR(ch) ||
	      ch === 0x23/* # */    ||
	      ch === 0x26/* & */    ||
	      ch === 0x2A/* * */    ||
	      ch === 0x21/* ! */    ||
	      ch === 0x7C/* | */    ||
	      ch === 0x3E/* > */    ||
	      ch === 0x27/* ' */    ||
	      ch === 0x22/* " */    ||
	      ch === 0x25/* % */    ||
	      ch === 0x40/* @ */    ||
	      ch === 0x60/* ` */) {
	    return false;
	  }

	  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
	    following = state.input.charCodeAt(state.position + 1);

	    if (is_WS_OR_EOL(following) ||
	        withinFlowCollection && is_FLOW_INDICATOR(following)) {
	      return false;
	    }
	  }

	  state.kind = 'scalar';
	  state.result = '';
	  captureStart = captureEnd = state.position;
	  hasPendingContent = false;

	  while (ch !== 0) {
	    if (ch === 0x3A/* : */) {
	      following = state.input.charCodeAt(state.position + 1);

	      if (is_WS_OR_EOL(following) ||
	          withinFlowCollection && is_FLOW_INDICATOR(following)) {
	        break;
	      }

	    } else if (ch === 0x23/* # */) {
	      preceding = state.input.charCodeAt(state.position - 1);

	      if (is_WS_OR_EOL(preceding)) {
	        break;
	      }

	    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
	               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
	      break;

	    } else if (is_EOL(ch)) {
	      _line = state.line;
	      _lineStart = state.lineStart;
	      _lineIndent = state.lineIndent;
	      skipSeparationSpace(state, false, -1);

	      if (state.lineIndent >= nodeIndent) {
	        hasPendingContent = true;
	        ch = state.input.charCodeAt(state.position);
	        continue;
	      } else {
	        state.position = captureEnd;
	        state.line = _line;
	        state.lineStart = _lineStart;
	        state.lineIndent = _lineIndent;
	        break;
	      }
	    }

	    if (hasPendingContent) {
	      captureSegment(state, captureStart, captureEnd, false);
	      writeFoldedLines(state, state.line - _line);
	      captureStart = captureEnd = state.position;
	      hasPendingContent = false;
	    }

	    if (!is_WHITE_SPACE(ch)) {
	      captureEnd = state.position + 1;
	    }

	    ch = state.input.charCodeAt(++state.position);
	  }

	  captureSegment(state, captureStart, captureEnd, false);

	  if (state.result) {
	    return true;
	  }

	  state.kind = _kind;
	  state.result = _result;
	  return false;
	}

	function readSingleQuotedScalar(state, nodeIndent) {
	  var ch,
	      captureStart, captureEnd;

	  ch = state.input.charCodeAt(state.position);

	  if (ch !== 0x27/* ' */) {
	    return false;
	  }

	  state.kind = 'scalar';
	  state.result = '';
	  state.position++;
	  captureStart = captureEnd = state.position;

	  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
	    if (ch === 0x27/* ' */) {
	      captureSegment(state, captureStart, state.position, true);
	      ch = state.input.charCodeAt(++state.position);

	      if (ch === 0x27/* ' */) {
	        captureStart = state.position;
	        state.position++;
	        captureEnd = state.position;
	      } else {
	        return true;
	      }

	    } else if (is_EOL(ch)) {
	      captureSegment(state, captureStart, captureEnd, true);
	      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
	      captureStart = captureEnd = state.position;

	    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
	      throwError(state, 'unexpected end of the document within a single quoted scalar');

	    } else {
	      state.position++;
	      captureEnd = state.position;
	    }
	  }

	  throwError(state, 'unexpected end of the stream within a single quoted scalar');
	}

	function readDoubleQuotedScalar(state, nodeIndent) {
	  var captureStart,
	      captureEnd,
	      hexLength,
	      hexResult,
	      tmp,
	      ch;

	  ch = state.input.charCodeAt(state.position);

	  if (ch !== 0x22/* " */) {
	    return false;
	  }

	  state.kind = 'scalar';
	  state.result = '';
	  state.position++;
	  captureStart = captureEnd = state.position;

	  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
	    if (ch === 0x22/* " */) {
	      captureSegment(state, captureStart, state.position, true);
	      state.position++;
	      return true;

	    } else if (ch === 0x5C/* \ */) {
	      captureSegment(state, captureStart, state.position, true);
	      ch = state.input.charCodeAt(++state.position);

	      if (is_EOL(ch)) {
	        skipSeparationSpace(state, false, nodeIndent);

	        // TODO: rework to inline fn with no type cast?
	      } else if (ch < 256 && simpleEscapeCheck[ch]) {
	        state.result += simpleEscapeMap[ch];
	        state.position++;

	      } else if ((tmp = escapedHexLen(ch)) > 0) {
	        hexLength = tmp;
	        hexResult = 0;

	        for (; hexLength > 0; hexLength--) {
	          ch = state.input.charCodeAt(++state.position);

	          if ((tmp = fromHexCode(ch)) >= 0) {
	            hexResult = (hexResult << 4) + tmp;

	          } else {
	            throwError(state, 'expected hexadecimal character');
	          }
	        }

	        state.result += charFromCodepoint(hexResult);

	        state.position++;

	      } else {
	        throwError(state, 'unknown escape sequence');
	      }

	      captureStart = captureEnd = state.position;

	    } else if (is_EOL(ch)) {
	      captureSegment(state, captureStart, captureEnd, true);
	      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
	      captureStart = captureEnd = state.position;

	    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
	      throwError(state, 'unexpected end of the document within a double quoted scalar');

	    } else {
	      state.position++;
	      captureEnd = state.position;
	    }
	  }

	  throwError(state, 'unexpected end of the stream within a double quoted scalar');
	}

	function readFlowCollection(state, nodeIndent) {
	  var readNext = true,
	      _line,
	      _tag     = state.tag,
	      _result,
	      _anchor  = state.anchor,
	      following,
	      terminator,
	      isPair,
	      isExplicitPair,
	      isMapping,
	      overridableKeys = {},
	      keyNode,
	      keyTag,
	      valueNode,
	      ch;

	  ch = state.input.charCodeAt(state.position);

	  if (ch === 0x5B/* [ */) {
	    terminator = 0x5D;/* ] */
	    isMapping = false;
	    _result = [];
	  } else if (ch === 0x7B/* { */) {
	    terminator = 0x7D;/* } */
	    isMapping = true;
	    _result = {};
	  } else {
	    return false;
	  }

	  if (state.anchor !== null) {
	    state.anchorMap[state.anchor] = _result;
	  }

	  ch = state.input.charCodeAt(++state.position);

	  while (ch !== 0) {
	    skipSeparationSpace(state, true, nodeIndent);

	    ch = state.input.charCodeAt(state.position);

	    if (ch === terminator) {
	      state.position++;
	      state.tag = _tag;
	      state.anchor = _anchor;
	      state.kind = isMapping ? 'mapping' : 'sequence';
	      state.result = _result;
	      return true;
	    } else if (!readNext) {
	      throwError(state, 'missed comma between flow collection entries');
	    }

	    keyTag = keyNode = valueNode = null;
	    isPair = isExplicitPair = false;

	    if (ch === 0x3F/* ? */) {
	      following = state.input.charCodeAt(state.position + 1);

	      if (is_WS_OR_EOL(following)) {
	        isPair = isExplicitPair = true;
	        state.position++;
	        skipSeparationSpace(state, true, nodeIndent);
	      }
	    }

	    _line = state.line;
	    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
	    keyTag = state.tag;
	    keyNode = state.result;
	    skipSeparationSpace(state, true, nodeIndent);

	    ch = state.input.charCodeAt(state.position);

	    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
	      isPair = true;
	      ch = state.input.charCodeAt(++state.position);
	      skipSeparationSpace(state, true, nodeIndent);
	      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
	      valueNode = state.result;
	    }

	    if (isMapping) {
	      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
	    } else if (isPair) {
	      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
	    } else {
	      _result.push(keyNode);
	    }

	    skipSeparationSpace(state, true, nodeIndent);

	    ch = state.input.charCodeAt(state.position);

	    if (ch === 0x2C/* , */) {
	      readNext = true;
	      ch = state.input.charCodeAt(++state.position);
	    } else {
	      readNext = false;
	    }
	  }

	  throwError(state, 'unexpected end of the stream within a flow collection');
	}

	function readBlockScalar(state, nodeIndent) {
	  var captureStart,
	      folding,
	      chomping       = CHOMPING_CLIP,
	      didReadContent = false,
	      detectedIndent = false,
	      textIndent     = nodeIndent,
	      emptyLines     = 0,
	      atMoreIndented = false,
	      tmp,
	      ch;

	  ch = state.input.charCodeAt(state.position);

	  if (ch === 0x7C/* | */) {
	    folding = false;
	  } else if (ch === 0x3E/* > */) {
	    folding = true;
	  } else {
	    return false;
	  }

	  state.kind = 'scalar';
	  state.result = '';

	  while (ch !== 0) {
	    ch = state.input.charCodeAt(++state.position);

	    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
	      if (CHOMPING_CLIP === chomping) {
	        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
	      } else {
	        throwError(state, 'repeat of a chomping mode identifier');
	      }

	    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
	      if (tmp === 0) {
	        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
	      } else if (!detectedIndent) {
	        textIndent = nodeIndent + tmp - 1;
	        detectedIndent = true;
	      } else {
	        throwError(state, 'repeat of an indentation width identifier');
	      }

	    } else {
	      break;
	    }
	  }

	  if (is_WHITE_SPACE(ch)) {
	    do { ch = state.input.charCodeAt(++state.position); }
	    while (is_WHITE_SPACE(ch));

	    if (ch === 0x23/* # */) {
	      do { ch = state.input.charCodeAt(++state.position); }
	      while (!is_EOL(ch) && (ch !== 0));
	    }
	  }

	  while (ch !== 0) {
	    readLineBreak(state);
	    state.lineIndent = 0;

	    ch = state.input.charCodeAt(state.position);

	    while ((!detectedIndent || state.lineIndent < textIndent) &&
	           (ch === 0x20/* Space */)) {
	      state.lineIndent++;
	      ch = state.input.charCodeAt(++state.position);
	    }

	    if (!detectedIndent && state.lineIndent > textIndent) {
	      textIndent = state.lineIndent;
	    }

	    if (is_EOL(ch)) {
	      emptyLines++;
	      continue;
	    }

	    // End of the scalar.
	    if (state.lineIndent < textIndent) {

	      // Perform the chomping.
	      if (chomping === CHOMPING_KEEP) {
	        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
	      } else if (chomping === CHOMPING_CLIP) {
	        if (didReadContent) { // i.e. only if the scalar is not empty.
	          state.result += '\n';
	        }
	      }

	      // Break this `while` cycle and go to the funciton's epilogue.
	      break;
	    }

	    // Folded style: use fancy rules to handle line breaks.
	    if (folding) {

	      // Lines starting with white space characters (more-indented lines) are not folded.
	      if (is_WHITE_SPACE(ch)) {
	        atMoreIndented = true;
	        // except for the first content line (cf. Example 8.1)
	        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

	      // End of more-indented block.
	      } else if (atMoreIndented) {
	        atMoreIndented = false;
	        state.result += common.repeat('\n', emptyLines + 1);

	      // Just one line break - perceive as the same line.
	      } else if (emptyLines === 0) {
	        if (didReadContent) { // i.e. only if we have already read some scalar content.
	          state.result += ' ';
	        }

	      // Several line breaks - perceive as different lines.
	      } else {
	        state.result += common.repeat('\n', emptyLines);
	      }

	    // Literal style: just add exact number of line breaks between content lines.
	    } else {
	      // Keep all line breaks except the header line break.
	      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
	    }

	    didReadContent = true;
	    detectedIndent = true;
	    emptyLines = 0;
	    captureStart = state.position;

	    while (!is_EOL(ch) && (ch !== 0)) {
	      ch = state.input.charCodeAt(++state.position);
	    }

	    captureSegment(state, captureStart, state.position, false);
	  }

	  return true;
	}

	function readBlockSequence(state, nodeIndent) {
	  var _line,
	      _tag      = state.tag,
	      _anchor   = state.anchor,
	      _result   = [],
	      following,
	      detected  = false,
	      ch;

	  if (state.anchor !== null) {
	    state.anchorMap[state.anchor] = _result;
	  }

	  ch = state.input.charCodeAt(state.position);

	  while (ch !== 0) {

	    if (ch !== 0x2D/* - */) {
	      break;
	    }

	    following = state.input.charCodeAt(state.position + 1);

	    if (!is_WS_OR_EOL(following)) {
	      break;
	    }

	    detected = true;
	    state.position++;

	    if (skipSeparationSpace(state, true, -1)) {
	      if (state.lineIndent <= nodeIndent) {
	        _result.push(null);
	        ch = state.input.charCodeAt(state.position);
	        continue;
	      }
	    }

	    _line = state.line;
	    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
	    _result.push(state.result);
	    skipSeparationSpace(state, true, -1);

	    ch = state.input.charCodeAt(state.position);

	    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
	      throwError(state, 'bad indentation of a sequence entry');
	    } else if (state.lineIndent < nodeIndent) {
	      break;
	    }
	  }

	  if (detected) {
	    state.tag = _tag;
	    state.anchor = _anchor;
	    state.kind = 'sequence';
	    state.result = _result;
	    return true;
	  }
	  return false;
	}

	function readBlockMapping(state, nodeIndent, flowIndent) {
	  var following,
	      allowCompact,
	      _line,
	      _pos,
	      _tag          = state.tag,
	      _anchor       = state.anchor,
	      _result       = {},
	      overridableKeys = {},
	      keyTag        = null,
	      keyNode       = null,
	      valueNode     = null,
	      atExplicitKey = false,
	      detected      = false,
	      ch;

	  if (state.anchor !== null) {
	    state.anchorMap[state.anchor] = _result;
	  }

	  ch = state.input.charCodeAt(state.position);

	  while (ch !== 0) {
	    following = state.input.charCodeAt(state.position + 1);
	    _line = state.line; // Save the current line.
	    _pos = state.position;

	    //
	    // Explicit notation case. There are two separate blocks:
	    // first for the key (denoted by "?") and second for the value (denoted by ":")
	    //
	    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

	      if (ch === 0x3F/* ? */) {
	        if (atExplicitKey) {
	          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
	          keyTag = keyNode = valueNode = null;
	        }

	        detected = true;
	        atExplicitKey = true;
	        allowCompact = true;

	      } else if (atExplicitKey) {
	        // i.e. 0x3A/* : */ === character after the explicit key.
	        atExplicitKey = false;
	        allowCompact = true;

	      } else {
	        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
	      }

	      state.position += 1;
	      ch = following;

	    //
	    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
	    //
	    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

	      if (state.line === _line) {
	        ch = state.input.charCodeAt(state.position);

	        while (is_WHITE_SPACE(ch)) {
	          ch = state.input.charCodeAt(++state.position);
	        }

	        if (ch === 0x3A/* : */) {
	          ch = state.input.charCodeAt(++state.position);

	          if (!is_WS_OR_EOL(ch)) {
	            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
	          }

	          if (atExplicitKey) {
	            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
	            keyTag = keyNode = valueNode = null;
	          }

	          detected = true;
	          atExplicitKey = false;
	          allowCompact = false;
	          keyTag = state.tag;
	          keyNode = state.result;

	        } else if (detected) {
	          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

	        } else {
	          state.tag = _tag;
	          state.anchor = _anchor;
	          return true; // Keep the result of `composeNode`.
	        }

	      } else if (detected) {
	        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

	      } else {
	        state.tag = _tag;
	        state.anchor = _anchor;
	        return true; // Keep the result of `composeNode`.
	      }

	    } else {
	      break; // Reading is done. Go to the epilogue.
	    }

	    //
	    // Common reading code for both explicit and implicit notations.
	    //
	    if (state.line === _line || state.lineIndent > nodeIndent) {
	      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
	        if (atExplicitKey) {
	          keyNode = state.result;
	        } else {
	          valueNode = state.result;
	        }
	      }

	      if (!atExplicitKey) {
	        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
	        keyTag = keyNode = valueNode = null;
	      }

	      skipSeparationSpace(state, true, -1);
	      ch = state.input.charCodeAt(state.position);
	    }

	    if (state.lineIndent > nodeIndent && (ch !== 0)) {
	      throwError(state, 'bad indentation of a mapping entry');
	    } else if (state.lineIndent < nodeIndent) {
	      break;
	    }
	  }

	  //
	  // Epilogue.
	  //

	  // Special case: last mapping's node contains only the key in explicit notation.
	  if (atExplicitKey) {
	    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
	  }

	  // Expose the resulting mapping.
	  if (detected) {
	    state.tag = _tag;
	    state.anchor = _anchor;
	    state.kind = 'mapping';
	    state.result = _result;
	  }

	  return detected;
	}

	function readTagProperty(state) {
	  var _position,
	      isVerbatim = false,
	      isNamed    = false,
	      tagHandle,
	      tagName,
	      ch;

	  ch = state.input.charCodeAt(state.position);

	  if (ch !== 0x21/* ! */) return false;

	  if (state.tag !== null) {
	    throwError(state, 'duplication of a tag property');
	  }

	  ch = state.input.charCodeAt(++state.position);

	  if (ch === 0x3C/* < */) {
	    isVerbatim = true;
	    ch = state.input.charCodeAt(++state.position);

	  } else if (ch === 0x21/* ! */) {
	    isNamed = true;
	    tagHandle = '!!';
	    ch = state.input.charCodeAt(++state.position);

	  } else {
	    tagHandle = '!';
	  }

	  _position = state.position;

	  if (isVerbatim) {
	    do { ch = state.input.charCodeAt(++state.position); }
	    while (ch !== 0 && ch !== 0x3E/* > */);

	    if (state.position < state.length) {
	      tagName = state.input.slice(_position, state.position);
	      ch = state.input.charCodeAt(++state.position);
	    } else {
	      throwError(state, 'unexpected end of the stream within a verbatim tag');
	    }
	  } else {
	    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

	      if (ch === 0x21/* ! */) {
	        if (!isNamed) {
	          tagHandle = state.input.slice(_position - 1, state.position + 1);

	          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
	            throwError(state, 'named tag handle cannot contain such characters');
	          }

	          isNamed = true;
	          _position = state.position + 1;
	        } else {
	          throwError(state, 'tag suffix cannot contain exclamation marks');
	        }
	      }

	      ch = state.input.charCodeAt(++state.position);
	    }

	    tagName = state.input.slice(_position, state.position);

	    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
	      throwError(state, 'tag suffix cannot contain flow indicator characters');
	    }
	  }

	  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
	    throwError(state, 'tag name cannot contain such characters: ' + tagName);
	  }

	  if (isVerbatim) {
	    state.tag = tagName;

	  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
	    state.tag = state.tagMap[tagHandle] + tagName;

	  } else if (tagHandle === '!') {
	    state.tag = '!' + tagName;

	  } else if (tagHandle === '!!') {
	    state.tag = 'tag:yaml.org,2002:' + tagName;

	  } else {
	    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
	  }

	  return true;
	}

	function readAnchorProperty(state) {
	  var _position,
	      ch;

	  ch = state.input.charCodeAt(state.position);

	  if (ch !== 0x26/* & */) return false;

	  if (state.anchor !== null) {
	    throwError(state, 'duplication of an anchor property');
	  }

	  ch = state.input.charCodeAt(++state.position);
	  _position = state.position;

	  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
	    ch = state.input.charCodeAt(++state.position);
	  }

	  if (state.position === _position) {
	    throwError(state, 'name of an anchor node must contain at least one character');
	  }

	  state.anchor = state.input.slice(_position, state.position);
	  return true;
	}

	function readAlias(state) {
	  var _position, alias,
	      ch;

	  ch = state.input.charCodeAt(state.position);

	  if (ch !== 0x2A/* * */) return false;

	  ch = state.input.charCodeAt(++state.position);
	  _position = state.position;

	  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
	    ch = state.input.charCodeAt(++state.position);
	  }

	  if (state.position === _position) {
	    throwError(state, 'name of an alias node must contain at least one character');
	  }

	  alias = state.input.slice(_position, state.position);

	  if (!state.anchorMap.hasOwnProperty(alias)) {
	    throwError(state, 'unidentified alias "' + alias + '"');
	  }

	  state.result = state.anchorMap[alias];
	  skipSeparationSpace(state, true, -1);
	  return true;
	}

	function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
	  var allowBlockStyles,
	      allowBlockScalars,
	      allowBlockCollections,
	      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
	      atNewLine  = false,
	      hasContent = false,
	      typeIndex,
	      typeQuantity,
	      type,
	      flowIndent,
	      blockIndent;

	  if (state.listener !== null) {
	    state.listener('open', state);
	  }

	  state.tag    = null;
	  state.anchor = null;
	  state.kind   = null;
	  state.result = null;

	  allowBlockStyles = allowBlockScalars = allowBlockCollections =
	    CONTEXT_BLOCK_OUT === nodeContext ||
	    CONTEXT_BLOCK_IN  === nodeContext;

	  if (allowToSeek) {
	    if (skipSeparationSpace(state, true, -1)) {
	      atNewLine = true;

	      if (state.lineIndent > parentIndent) {
	        indentStatus = 1;
	      } else if (state.lineIndent === parentIndent) {
	        indentStatus = 0;
	      } else if (state.lineIndent < parentIndent) {
	        indentStatus = -1;
	      }
	    }
	  }

	  if (indentStatus === 1) {
	    while (readTagProperty(state) || readAnchorProperty(state)) {
	      if (skipSeparationSpace(state, true, -1)) {
	        atNewLine = true;
	        allowBlockCollections = allowBlockStyles;

	        if (state.lineIndent > parentIndent) {
	          indentStatus = 1;
	        } else if (state.lineIndent === parentIndent) {
	          indentStatus = 0;
	        } else if (state.lineIndent < parentIndent) {
	          indentStatus = -1;
	        }
	      } else {
	        allowBlockCollections = false;
	      }
	    }
	  }

	  if (allowBlockCollections) {
	    allowBlockCollections = atNewLine || allowCompact;
	  }

	  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
	    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
	      flowIndent = parentIndent;
	    } else {
	      flowIndent = parentIndent + 1;
	    }

	    blockIndent = state.position - state.lineStart;

	    if (indentStatus === 1) {
	      if (allowBlockCollections &&
	          (readBlockSequence(state, blockIndent) ||
	           readBlockMapping(state, blockIndent, flowIndent)) ||
	          readFlowCollection(state, flowIndent)) {
	        hasContent = true;
	      } else {
	        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
	            readSingleQuotedScalar(state, flowIndent) ||
	            readDoubleQuotedScalar(state, flowIndent)) {
	          hasContent = true;

	        } else if (readAlias(state)) {
	          hasContent = true;

	          if (state.tag !== null || state.anchor !== null) {
	            throwError(state, 'alias node should not have any properties');
	          }

	        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
	          hasContent = true;

	          if (state.tag === null) {
	            state.tag = '?';
	          }
	        }

	        if (state.anchor !== null) {
	          state.anchorMap[state.anchor] = state.result;
	        }
	      }
	    } else if (indentStatus === 0) {
	      // Special case: block sequences are allowed to have same indentation level as the parent.
	      // http://www.yaml.org/spec/1.2/spec.html#id2799784
	      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
	    }
	  }

	  if (state.tag !== null && state.tag !== '!') {
	    if (state.tag === '?') {
	      // Implicit resolving is not allowed for non-scalar types, and '?'
	      // non-specific tag is only automatically assigned to plain scalars.
	      //
	      // We only need to check kind conformity in case user explicitly assigns '?'
	      // tag, for example like this: "!<?> [0]"
	      //
	      if (state.result !== null && state.kind !== 'scalar') {
	        throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
	      }

	      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
	        type = state.implicitTypes[typeIndex];

	        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
	          state.result = type.construct(state.result);
	          state.tag = type.tag;
	          if (state.anchor !== null) {
	            state.anchorMap[state.anchor] = state.result;
	          }
	          break;
	        }
	      }
	    } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
	      type = state.typeMap[state.kind || 'fallback'][state.tag];

	      if (state.result !== null && type.kind !== state.kind) {
	        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
	      }

	      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
	        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
	      } else {
	        state.result = type.construct(state.result);
	        if (state.anchor !== null) {
	          state.anchorMap[state.anchor] = state.result;
	        }
	      }
	    } else {
	      throwError(state, 'unknown tag !<' + state.tag + '>');
	    }
	  }

	  if (state.listener !== null) {
	    state.listener('close', state);
	  }
	  return state.tag !== null ||  state.anchor !== null || hasContent;
	}

	function readDocument(state) {
	  var documentStart = state.position,
	      _position,
	      directiveName,
	      directiveArgs,
	      hasDirectives = false,
	      ch;

	  state.version = null;
	  state.checkLineBreaks = state.legacy;
	  state.tagMap = {};
	  state.anchorMap = {};

	  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
	    skipSeparationSpace(state, true, -1);

	    ch = state.input.charCodeAt(state.position);

	    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
	      break;
	    }

	    hasDirectives = true;
	    ch = state.input.charCodeAt(++state.position);
	    _position = state.position;

	    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
	      ch = state.input.charCodeAt(++state.position);
	    }

	    directiveName = state.input.slice(_position, state.position);
	    directiveArgs = [];

	    if (directiveName.length < 1) {
	      throwError(state, 'directive name must not be less than one character in length');
	    }

	    while (ch !== 0) {
	      while (is_WHITE_SPACE(ch)) {
	        ch = state.input.charCodeAt(++state.position);
	      }

	      if (ch === 0x23/* # */) {
	        do { ch = state.input.charCodeAt(++state.position); }
	        while (ch !== 0 && !is_EOL(ch));
	        break;
	      }

	      if (is_EOL(ch)) break;

	      _position = state.position;

	      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
	        ch = state.input.charCodeAt(++state.position);
	      }

	      directiveArgs.push(state.input.slice(_position, state.position));
	    }

	    if (ch !== 0) readLineBreak(state);

	    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
	      directiveHandlers[directiveName](state, directiveName, directiveArgs);
	    } else {
	      throwWarning(state, 'unknown document directive "' + directiveName + '"');
	    }
	  }

	  skipSeparationSpace(state, true, -1);

	  if (state.lineIndent === 0 &&
	      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
	      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
	      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
	    state.position += 3;
	    skipSeparationSpace(state, true, -1);

	  } else if (hasDirectives) {
	    throwError(state, 'directives end mark is expected');
	  }

	  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
	  skipSeparationSpace(state, true, -1);

	  if (state.checkLineBreaks &&
	      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
	    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
	  }

	  state.documents.push(state.result);

	  if (state.position === state.lineStart && testDocumentSeparator(state)) {

	    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
	      state.position += 3;
	      skipSeparationSpace(state, true, -1);
	    }
	    return;
	  }

	  if (state.position < (state.length - 1)) {
	    throwError(state, 'end of the stream or a document separator is expected');
	  } else {
	    return;
	  }
	}


	function loadDocuments(input, options) {
	  input = String(input);
	  options = options || {};

	  if (input.length !== 0) {

	    // Add tailing `\n` if not exists
	    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
	        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
	      input += '\n';
	    }

	    // Strip BOM
	    if (input.charCodeAt(0) === 0xFEFF) {
	      input = input.slice(1);
	    }
	  }

	  var state = new State(input, options);

	  var nullpos = input.indexOf('\0');

	  if (nullpos !== -1) {
	    state.position = nullpos;
	    throwError(state, 'null byte is not allowed in input');
	  }

	  // Use 0 as string terminator. That significantly simplifies bounds check.
	  state.input += '\0';

	  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
	    state.lineIndent += 1;
	    state.position += 1;
	  }

	  while (state.position < (state.length - 1)) {
	    readDocument(state);
	  }

	  return state.documents;
	}


	function loadAll(input, iterator, options) {
	  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
	    options = iterator;
	    iterator = null;
	  }

	  var documents = loadDocuments(input, options);

	  if (typeof iterator !== 'function') {
	    return documents;
	  }

	  for (var index = 0, length = documents.length; index < length; index += 1) {
	    iterator(documents[index]);
	  }
	}


	function load(input, options) {
	  var documents = loadDocuments(input, options);

	  if (documents.length === 0) {
	    /*eslint-disable no-undefined*/
	    return undefined;
	  } else if (documents.length === 1) {
	    return documents[0];
	  }
	  throw new YAMLException('expected a single document in the stream, but found more');
	}


	function safeLoadAll(input, iterator, options) {
	  if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {
	    options = iterator;
	    iterator = null;
	  }

	  return loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	}


	function safeLoad(input, options) {
	  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	}


	loader.loadAll     = loadAll;
	loader.load        = load;
	loader.safeLoadAll = safeLoadAll;
	loader.safeLoad    = safeLoad;
	return loader;
}

var dumper = {};

var hasRequiredDumper;

function requireDumper () {
	if (hasRequiredDumper) return dumper;
	hasRequiredDumper = 1;

	/*eslint-disable no-use-before-define*/

	var common              = requireCommon();
	var YAMLException       = requireException();
	var DEFAULT_FULL_SCHEMA = requireDefault_full();
	var DEFAULT_SAFE_SCHEMA = requireDefault_safe();

	var _toString       = Object.prototype.toString;
	var _hasOwnProperty = Object.prototype.hasOwnProperty;

	var CHAR_TAB                  = 0x09; /* Tab */
	var CHAR_LINE_FEED            = 0x0A; /* LF */
	var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
	var CHAR_SPACE                = 0x20; /* Space */
	var CHAR_EXCLAMATION          = 0x21; /* ! */
	var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
	var CHAR_SHARP                = 0x23; /* # */
	var CHAR_PERCENT              = 0x25; /* % */
	var CHAR_AMPERSAND            = 0x26; /* & */
	var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
	var CHAR_ASTERISK             = 0x2A; /* * */
	var CHAR_COMMA                = 0x2C; /* , */
	var CHAR_MINUS                = 0x2D; /* - */
	var CHAR_COLON                = 0x3A; /* : */
	var CHAR_EQUALS               = 0x3D; /* = */
	var CHAR_GREATER_THAN         = 0x3E; /* > */
	var CHAR_QUESTION             = 0x3F; /* ? */
	var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
	var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
	var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
	var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
	var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
	var CHAR_VERTICAL_LINE        = 0x7C; /* | */
	var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

	var ESCAPE_SEQUENCES = {};

	ESCAPE_SEQUENCES[0x00]   = '\\0';
	ESCAPE_SEQUENCES[0x07]   = '\\a';
	ESCAPE_SEQUENCES[0x08]   = '\\b';
	ESCAPE_SEQUENCES[0x09]   = '\\t';
	ESCAPE_SEQUENCES[0x0A]   = '\\n';
	ESCAPE_SEQUENCES[0x0B]   = '\\v';
	ESCAPE_SEQUENCES[0x0C]   = '\\f';
	ESCAPE_SEQUENCES[0x0D]   = '\\r';
	ESCAPE_SEQUENCES[0x1B]   = '\\e';
	ESCAPE_SEQUENCES[0x22]   = '\\"';
	ESCAPE_SEQUENCES[0x5C]   = '\\\\';
	ESCAPE_SEQUENCES[0x85]   = '\\N';
	ESCAPE_SEQUENCES[0xA0]   = '\\_';
	ESCAPE_SEQUENCES[0x2028] = '\\L';
	ESCAPE_SEQUENCES[0x2029] = '\\P';

	var DEPRECATED_BOOLEANS_SYNTAX = [
	  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
	  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
	];

	function compileStyleMap(schema, map) {
	  var result, keys, index, length, tag, style, type;

	  if (map === null) return {};

	  result = {};
	  keys = Object.keys(map);

	  for (index = 0, length = keys.length; index < length; index += 1) {
	    tag = keys[index];
	    style = String(map[tag]);

	    if (tag.slice(0, 2) === '!!') {
	      tag = 'tag:yaml.org,2002:' + tag.slice(2);
	    }
	    type = schema.compiledTypeMap['fallback'][tag];

	    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
	      style = type.styleAliases[style];
	    }

	    result[tag] = style;
	  }

	  return result;
	}

	function encodeHex(character) {
	  var string, handle, length;

	  string = character.toString(16).toUpperCase();

	  if (character <= 0xFF) {
	    handle = 'x';
	    length = 2;
	  } else if (character <= 0xFFFF) {
	    handle = 'u';
	    length = 4;
	  } else if (character <= 0xFFFFFFFF) {
	    handle = 'U';
	    length = 8;
	  } else {
	    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
	  }

	  return '\\' + handle + common.repeat('0', length - string.length) + string;
	}

	function State(options) {
	  this.schema        = options['schema'] || DEFAULT_FULL_SCHEMA;
	  this.indent        = Math.max(1, (options['indent'] || 2));
	  this.noArrayIndent = options['noArrayIndent'] || false;
	  this.skipInvalid   = options['skipInvalid'] || false;
	  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
	  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
	  this.sortKeys      = options['sortKeys'] || false;
	  this.lineWidth     = options['lineWidth'] || 80;
	  this.noRefs        = options['noRefs'] || false;
	  this.noCompatMode  = options['noCompatMode'] || false;
	  this.condenseFlow  = options['condenseFlow'] || false;

	  this.implicitTypes = this.schema.compiledImplicit;
	  this.explicitTypes = this.schema.compiledExplicit;

	  this.tag = null;
	  this.result = '';

	  this.duplicates = [];
	  this.usedDuplicates = null;
	}

	// Indents every line in a string. Empty lines (\n only) are not indented.
	function indentString(string, spaces) {
	  var ind = common.repeat(' ', spaces),
	      position = 0,
	      next = -1,
	      result = '',
	      line,
	      length = string.length;

	  while (position < length) {
	    next = string.indexOf('\n', position);
	    if (next === -1) {
	      line = string.slice(position);
	      position = length;
	    } else {
	      line = string.slice(position, next + 1);
	      position = next + 1;
	    }

	    if (line.length && line !== '\n') result += ind;

	    result += line;
	  }

	  return result;
	}

	function generateNextLine(state, level) {
	  return '\n' + common.repeat(' ', state.indent * level);
	}

	function testImplicitResolving(state, str) {
	  var index, length, type;

	  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
	    type = state.implicitTypes[index];

	    if (type.resolve(str)) {
	      return true;
	    }
	  }

	  return false;
	}

	// [33] s-white ::= s-space | s-tab
	function isWhitespace(c) {
	  return c === CHAR_SPACE || c === CHAR_TAB;
	}

	// Returns true if the character can be printed without escaping.
	// From YAML 1.2: "any allowed characters known to be non-printable
	// should also be escaped. [However,] This isn’t mandatory"
	// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
	function isPrintable(c) {
	  return  (0x00020 <= c && c <= 0x00007E)
	      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
	      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)
	      ||  (0x10000 <= c && c <= 0x10FFFF);
	}

	// [34] ns-char ::= nb-char - s-white
	// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
	// [26] b-char  ::= b-line-feed | b-carriage-return
	// [24] b-line-feed       ::=     #xA    /* LF */
	// [25] b-carriage-return ::=     #xD    /* CR */
	// [3]  c-byte-order-mark ::=     #xFEFF
	function isNsChar(c) {
	  return isPrintable(c) && !isWhitespace(c)
	    // byte-order-mark
	    && c !== 0xFEFF
	    // b-char
	    && c !== CHAR_CARRIAGE_RETURN
	    && c !== CHAR_LINE_FEED;
	}

	// Simplified test for values allowed after the first character in plain style.
	function isPlainSafe(c, prev) {
	  // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
	  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
	  return isPrintable(c) && c !== 0xFEFF
	    // - c-flow-indicator
	    && c !== CHAR_COMMA
	    && c !== CHAR_LEFT_SQUARE_BRACKET
	    && c !== CHAR_RIGHT_SQUARE_BRACKET
	    && c !== CHAR_LEFT_CURLY_BRACKET
	    && c !== CHAR_RIGHT_CURLY_BRACKET
	    // - ":" - "#"
	    // /* An ns-char preceding */ "#"
	    && c !== CHAR_COLON
	    && ((c !== CHAR_SHARP) || (prev && isNsChar(prev)));
	}

	// Simplified test for values allowed as the first character in plain style.
	function isPlainSafeFirst(c) {
	  // Uses a subset of ns-char - c-indicator
	  // where ns-char = nb-char - s-white.
	  return isPrintable(c) && c !== 0xFEFF
	    && !isWhitespace(c) // - s-white
	    // - (c-indicator ::=
	    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
	    && c !== CHAR_MINUS
	    && c !== CHAR_QUESTION
	    && c !== CHAR_COLON
	    && c !== CHAR_COMMA
	    && c !== CHAR_LEFT_SQUARE_BRACKET
	    && c !== CHAR_RIGHT_SQUARE_BRACKET
	    && c !== CHAR_LEFT_CURLY_BRACKET
	    && c !== CHAR_RIGHT_CURLY_BRACKET
	    // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “"”
	    && c !== CHAR_SHARP
	    && c !== CHAR_AMPERSAND
	    && c !== CHAR_ASTERISK
	    && c !== CHAR_EXCLAMATION
	    && c !== CHAR_VERTICAL_LINE
	    && c !== CHAR_EQUALS
	    && c !== CHAR_GREATER_THAN
	    && c !== CHAR_SINGLE_QUOTE
	    && c !== CHAR_DOUBLE_QUOTE
	    // | “%” | “@” | “`”)
	    && c !== CHAR_PERCENT
	    && c !== CHAR_COMMERCIAL_AT
	    && c !== CHAR_GRAVE_ACCENT;
	}

	// Determines whether block indentation indicator is required.
	function needIndentIndicator(string) {
	  var leadingSpaceRe = /^\n* /;
	  return leadingSpaceRe.test(string);
	}

	var STYLE_PLAIN   = 1,
	    STYLE_SINGLE  = 2,
	    STYLE_LITERAL = 3,
	    STYLE_FOLDED  = 4,
	    STYLE_DOUBLE  = 5;

	// Determines which scalar styles are possible and returns the preferred style.
	// lineWidth = -1 => no limit.
	// Pre-conditions: str.length > 0.
	// Post-conditions:
	//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
	//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
	//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
	function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
	  var i;
	  var char, prev_char;
	  var hasLineBreak = false;
	  var hasFoldableLine = false; // only checked if shouldTrackWidth
	  var shouldTrackWidth = lineWidth !== -1;
	  var previousLineBreak = -1; // count the first line correctly
	  var plain = isPlainSafeFirst(string.charCodeAt(0))
	          && !isWhitespace(string.charCodeAt(string.length - 1));

	  if (singleLineOnly) {
	    // Case: no block styles.
	    // Check for disallowed characters to rule out plain and single.
	    for (i = 0; i < string.length; i++) {
	      char = string.charCodeAt(i);
	      if (!isPrintable(char)) {
	        return STYLE_DOUBLE;
	      }
	      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
	      plain = plain && isPlainSafe(char, prev_char);
	    }
	  } else {
	    // Case: block styles permitted.
	    for (i = 0; i < string.length; i++) {
	      char = string.charCodeAt(i);
	      if (char === CHAR_LINE_FEED) {
	        hasLineBreak = true;
	        // Check if any line can be folded.
	        if (shouldTrackWidth) {
	          hasFoldableLine = hasFoldableLine ||
	            // Foldable line = too long, and not more-indented.
	            (i - previousLineBreak - 1 > lineWidth &&
	             string[previousLineBreak + 1] !== ' ');
	          previousLineBreak = i;
	        }
	      } else if (!isPrintable(char)) {
	        return STYLE_DOUBLE;
	      }
	      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
	      plain = plain && isPlainSafe(char, prev_char);
	    }
	    // in case the end is missing a \n
	    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
	      (i - previousLineBreak - 1 > lineWidth &&
	       string[previousLineBreak + 1] !== ' '));
	  }
	  // Although every style can represent \n without escaping, prefer block styles
	  // for multiline, since they're more readable and they don't add empty lines.
	  // Also prefer folding a super-long line.
	  if (!hasLineBreak && !hasFoldableLine) {
	    // Strings interpretable as another type have to be quoted;
	    // e.g. the string 'true' vs. the boolean true.
	    return plain && !testAmbiguousType(string)
	      ? STYLE_PLAIN : STYLE_SINGLE;
	  }
	  // Edge case: block indentation indicator can only have one digit.
	  if (indentPerLevel > 9 && needIndentIndicator(string)) {
	    return STYLE_DOUBLE;
	  }
	  // At this point we know block styles are valid.
	  // Prefer literal style unless we want to fold.
	  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
	}

	// Note: line breaking/folding is implemented for only the folded style.
	// NB. We drop the last trailing newline (if any) of a returned block scalar
	//  since the dumper adds its own newline. This always works:
	//    • No ending newline => unaffected; already using strip "-" chomping.
	//    • Ending newline    => removed then restored.
	//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
	function writeScalar(state, string, level, iskey) {
	  state.dump = (function () {
	    if (string.length === 0) {
	      return "''";
	    }
	    if (!state.noCompatMode &&
	        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
	      return "'" + string + "'";
	    }

	    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
	    // As indentation gets deeper, let the width decrease monotonically
	    // to the lower bound min(state.lineWidth, 40).
	    // Note that this implies
	    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
	    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
	    // This behaves better than a constant minimum width which disallows narrower options,
	    // or an indent threshold which causes the width to suddenly increase.
	    var lineWidth = state.lineWidth === -1
	      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

	    // Without knowing if keys are implicit/explicit, assume implicit for safety.
	    var singleLineOnly = iskey
	      // No block styles in flow mode.
	      || (state.flowLevel > -1 && level >= state.flowLevel);
	    function testAmbiguity(string) {
	      return testImplicitResolving(state, string);
	    }

	    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
	      case STYLE_PLAIN:
	        return string;
	      case STYLE_SINGLE:
	        return "'" + string.replace(/'/g, "''") + "'";
	      case STYLE_LITERAL:
	        return '|' + blockHeader(string, state.indent)
	          + dropEndingNewline(indentString(string, indent));
	      case STYLE_FOLDED:
	        return '>' + blockHeader(string, state.indent)
	          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
	      case STYLE_DOUBLE:
	        return '"' + escapeString(string) + '"';
	      default:
	        throw new YAMLException('impossible error: invalid scalar style');
	    }
	  }());
	}

	// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
	function blockHeader(string, indentPerLevel) {
	  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

	  // note the special case: the string '\n' counts as a "trailing" empty line.
	  var clip =          string[string.length - 1] === '\n';
	  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
	  var chomp = keep ? '+' : (clip ? '' : '-');

	  return indentIndicator + chomp + '\n';
	}

	// (See the note for writeScalar.)
	function dropEndingNewline(string) {
	  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
	}

	// Note: a long line without a suitable break point will exceed the width limit.
	// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
	function foldString(string, width) {
	  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
	  // unless they're before or after a more-indented line, or at the very
	  // beginning or end, in which case $k$ maps to $k$.
	  // Therefore, parse each chunk as newline(s) followed by a content line.
	  var lineRe = /(\n+)([^\n]*)/g;

	  // first line (possibly an empty line)
	  var result = (function () {
	    var nextLF = string.indexOf('\n');
	    nextLF = nextLF !== -1 ? nextLF : string.length;
	    lineRe.lastIndex = nextLF;
	    return foldLine(string.slice(0, nextLF), width);
	  }());
	  // If we haven't reached the first content line yet, don't add an extra \n.
	  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
	  var moreIndented;

	  // rest of the lines
	  var match;
	  while ((match = lineRe.exec(string))) {
	    var prefix = match[1], line = match[2];
	    moreIndented = (line[0] === ' ');
	    result += prefix
	      + (!prevMoreIndented && !moreIndented && line !== ''
	        ? '\n' : '')
	      + foldLine(line, width);
	    prevMoreIndented = moreIndented;
	  }

	  return result;
	}

	// Greedy line breaking.
	// Picks the longest line under the limit each time,
	// otherwise settles for the shortest line over the limit.
	// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
	function foldLine(line, width) {
	  if (line === '' || line[0] === ' ') return line;

	  // Since a more-indented line adds a \n, breaks can't be followed by a space.
	  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
	  var match;
	  // start is an inclusive index. end, curr, and next are exclusive.
	  var start = 0, end, curr = 0, next = 0;
	  var result = '';

	  // Invariants: 0 <= start <= length-1.
	  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
	  // Inside the loop:
	  //   A match implies length >= 2, so curr and next are <= length-2.
	  while ((match = breakRe.exec(line))) {
	    next = match.index;
	    // maintain invariant: curr - start <= width
	    if (next - start > width) {
	      end = (curr > start) ? curr : next; // derive end <= length-2
	      result += '\n' + line.slice(start, end);
	      // skip the space that was output as \n
	      start = end + 1;                    // derive start <= length-1
	    }
	    curr = next;
	  }

	  // By the invariants, start <= length-1, so there is something left over.
	  // It is either the whole string or a part starting from non-whitespace.
	  result += '\n';
	  // Insert a break if the remainder is too long and there is a break available.
	  if (line.length - start > width && curr > start) {
	    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
	  } else {
	    result += line.slice(start);
	  }

	  return result.slice(1); // drop extra \n joiner
	}

	// Escapes a double-quoted string.
	function escapeString(string) {
	  var result = '';
	  var char, nextChar;
	  var escapeSeq;

	  for (var i = 0; i < string.length; i++) {
	    char = string.charCodeAt(i);
	    // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
	    if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {
	      nextChar = string.charCodeAt(i + 1);
	      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {
	        // Combine the surrogate pair and store it escaped.
	        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
	        // Advance index one extra since we already used that char here.
	        i++; continue;
	      }
	    }
	    escapeSeq = ESCAPE_SEQUENCES[char];
	    result += !escapeSeq && isPrintable(char)
	      ? string[i]
	      : escapeSeq || encodeHex(char);
	  }

	  return result;
	}

	function writeFlowSequence(state, level, object) {
	  var _result = '',
	      _tag    = state.tag,
	      index,
	      length;

	  for (index = 0, length = object.length; index < length; index += 1) {
	    // Write only valid elements.
	    if (writeNode(state, level, object[index], false, false)) {
	      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
	      _result += state.dump;
	    }
	  }

	  state.tag = _tag;
	  state.dump = '[' + _result + ']';
	}

	function writeBlockSequence(state, level, object, compact) {
	  var _result = '',
	      _tag    = state.tag,
	      index,
	      length;

	  for (index = 0, length = object.length; index < length; index += 1) {
	    // Write only valid elements.
	    if (writeNode(state, level + 1, object[index], true, true)) {
	      if (!compact || index !== 0) {
	        _result += generateNextLine(state, level);
	      }

	      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
	        _result += '-';
	      } else {
	        _result += '- ';
	      }

	      _result += state.dump;
	    }
	  }

	  state.tag = _tag;
	  state.dump = _result || '[]'; // Empty sequence if no valid values.
	}

	function writeFlowMapping(state, level, object) {
	  var _result       = '',
	      _tag          = state.tag,
	      objectKeyList = Object.keys(object),
	      index,
	      length,
	      objectKey,
	      objectValue,
	      pairBuffer;

	  for (index = 0, length = objectKeyList.length; index < length; index += 1) {

	    pairBuffer = '';
	    if (index !== 0) pairBuffer += ', ';

	    if (state.condenseFlow) pairBuffer += '"';

	    objectKey = objectKeyList[index];
	    objectValue = object[objectKey];

	    if (!writeNode(state, level, objectKey, false, false)) {
	      continue; // Skip this pair because of invalid key;
	    }

	    if (state.dump.length > 1024) pairBuffer += '? ';

	    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

	    if (!writeNode(state, level, objectValue, false, false)) {
	      continue; // Skip this pair because of invalid value.
	    }

	    pairBuffer += state.dump;

	    // Both key and value are valid.
	    _result += pairBuffer;
	  }

	  state.tag = _tag;
	  state.dump = '{' + _result + '}';
	}

	function writeBlockMapping(state, level, object, compact) {
	  var _result       = '',
	      _tag          = state.tag,
	      objectKeyList = Object.keys(object),
	      index,
	      length,
	      objectKey,
	      objectValue,
	      explicitPair,
	      pairBuffer;

	  // Allow sorting keys so that the output file is deterministic
	  if (state.sortKeys === true) {
	    // Default sorting
	    objectKeyList.sort();
	  } else if (typeof state.sortKeys === 'function') {
	    // Custom sort function
	    objectKeyList.sort(state.sortKeys);
	  } else if (state.sortKeys) {
	    // Something is wrong
	    throw new YAMLException('sortKeys must be a boolean or a function');
	  }

	  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
	    pairBuffer = '';

	    if (!compact || index !== 0) {
	      pairBuffer += generateNextLine(state, level);
	    }

	    objectKey = objectKeyList[index];
	    objectValue = object[objectKey];

	    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
	      continue; // Skip this pair because of invalid key.
	    }

	    explicitPair = (state.tag !== null && state.tag !== '?') ||
	                   (state.dump && state.dump.length > 1024);

	    if (explicitPair) {
	      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
	        pairBuffer += '?';
	      } else {
	        pairBuffer += '? ';
	      }
	    }

	    pairBuffer += state.dump;

	    if (explicitPair) {
	      pairBuffer += generateNextLine(state, level);
	    }

	    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
	      continue; // Skip this pair because of invalid value.
	    }

	    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
	      pairBuffer += ':';
	    } else {
	      pairBuffer += ': ';
	    }

	    pairBuffer += state.dump;

	    // Both key and value are valid.
	    _result += pairBuffer;
	  }

	  state.tag = _tag;
	  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
	}

	function detectType(state, object, explicit) {
	  var _result, typeList, index, length, type, style;

	  typeList = explicit ? state.explicitTypes : state.implicitTypes;

	  for (index = 0, length = typeList.length; index < length; index += 1) {
	    type = typeList[index];

	    if ((type.instanceOf  || type.predicate) &&
	        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
	        (!type.predicate  || type.predicate(object))) {

	      state.tag = explicit ? type.tag : '?';

	      if (type.represent) {
	        style = state.styleMap[type.tag] || type.defaultStyle;

	        if (_toString.call(type.represent) === '[object Function]') {
	          _result = type.represent(object, style);
	        } else if (_hasOwnProperty.call(type.represent, style)) {
	          _result = type.represent[style](object, style);
	        } else {
	          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
	        }

	        state.dump = _result;
	      }

	      return true;
	    }
	  }

	  return false;
	}

	// Serializes `object` and writes it to global `result`.
	// Returns true on success, or false on invalid object.
	//
	function writeNode(state, level, object, block, compact, iskey) {
	  state.tag = null;
	  state.dump = object;

	  if (!detectType(state, object, false)) {
	    detectType(state, object, true);
	  }

	  var type = _toString.call(state.dump);

	  if (block) {
	    block = (state.flowLevel < 0 || state.flowLevel > level);
	  }

	  var objectOrArray = type === '[object Object]' || type === '[object Array]',
	      duplicateIndex,
	      duplicate;

	  if (objectOrArray) {
	    duplicateIndex = state.duplicates.indexOf(object);
	    duplicate = duplicateIndex !== -1;
	  }

	  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
	    compact = false;
	  }

	  if (duplicate && state.usedDuplicates[duplicateIndex]) {
	    state.dump = '*ref_' + duplicateIndex;
	  } else {
	    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
	      state.usedDuplicates[duplicateIndex] = true;
	    }
	    if (type === '[object Object]') {
	      if (block && (Object.keys(state.dump).length !== 0)) {
	        writeBlockMapping(state, level, state.dump, compact);
	        if (duplicate) {
	          state.dump = '&ref_' + duplicateIndex + state.dump;
	        }
	      } else {
	        writeFlowMapping(state, level, state.dump);
	        if (duplicate) {
	          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
	        }
	      }
	    } else if (type === '[object Array]') {
	      var arrayLevel = (state.noArrayIndent && (level > 0)) ? level - 1 : level;
	      if (block && (state.dump.length !== 0)) {
	        writeBlockSequence(state, arrayLevel, state.dump, compact);
	        if (duplicate) {
	          state.dump = '&ref_' + duplicateIndex + state.dump;
	        }
	      } else {
	        writeFlowSequence(state, arrayLevel, state.dump);
	        if (duplicate) {
	          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
	        }
	      }
	    } else if (type === '[object String]') {
	      if (state.tag !== '?') {
	        writeScalar(state, state.dump, level, iskey);
	      }
	    } else {
	      if (state.skipInvalid) return false;
	      throw new YAMLException('unacceptable kind of an object to dump ' + type);
	    }

	    if (state.tag !== null && state.tag !== '?') {
	      state.dump = '!<' + state.tag + '> ' + state.dump;
	    }
	  }

	  return true;
	}

	function getDuplicateReferences(object, state) {
	  var objects = [],
	      duplicatesIndexes = [],
	      index,
	      length;

	  inspectNode(object, objects, duplicatesIndexes);

	  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
	    state.duplicates.push(objects[duplicatesIndexes[index]]);
	  }
	  state.usedDuplicates = new Array(length);
	}

	function inspectNode(object, objects, duplicatesIndexes) {
	  var objectKeyList,
	      index,
	      length;

	  if (object !== null && typeof object === 'object') {
	    index = objects.indexOf(object);
	    if (index !== -1) {
	      if (duplicatesIndexes.indexOf(index) === -1) {
	        duplicatesIndexes.push(index);
	      }
	    } else {
	      objects.push(object);

	      if (Array.isArray(object)) {
	        for (index = 0, length = object.length; index < length; index += 1) {
	          inspectNode(object[index], objects, duplicatesIndexes);
	        }
	      } else {
	        objectKeyList = Object.keys(object);

	        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
	          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
	        }
	      }
	    }
	  }
	}

	function dump(input, options) {
	  options = options || {};

	  var state = new State(options);

	  if (!state.noRefs) getDuplicateReferences(input, state);

	  if (writeNode(state, 0, input, true, true)) return state.dump + '\n';

	  return '';
	}

	function safeDump(input, options) {
	  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	}

	dumper.dump     = dump;
	dumper.safeDump = safeDump;
	return dumper;
}

var hasRequiredJsYaml$1;

function requireJsYaml$1 () {
	if (hasRequiredJsYaml$1) return jsYaml$1;
	hasRequiredJsYaml$1 = 1;


	var loader = requireLoader();
	var dumper = requireDumper();


	function deprecated(name) {
	  return function () {
	    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
	  };
	}


	jsYaml$1.Type                = requireType();
	jsYaml$1.Schema              = requireSchema$1();
	jsYaml$1.FAILSAFE_SCHEMA     = requireFailsafe();
	jsYaml$1.JSON_SCHEMA         = requireJson();
	jsYaml$1.CORE_SCHEMA         = requireCore();
	jsYaml$1.DEFAULT_SAFE_SCHEMA = requireDefault_safe();
	jsYaml$1.DEFAULT_FULL_SCHEMA = requireDefault_full();
	jsYaml$1.load                = loader.load;
	jsYaml$1.loadAll             = loader.loadAll;
	jsYaml$1.safeLoad            = loader.safeLoad;
	jsYaml$1.safeLoadAll         = loader.safeLoadAll;
	jsYaml$1.dump                = dumper.dump;
	jsYaml$1.safeDump            = dumper.safeDump;
	jsYaml$1.YAMLException       = requireException();

	// Deprecated schema names from JS-YAML 2.0.x
	jsYaml$1.MINIMAL_SCHEMA = requireFailsafe();
	jsYaml$1.SAFE_SCHEMA    = requireDefault_safe();
	jsYaml$1.DEFAULT_SCHEMA = requireDefault_full();

	// Deprecated functions from JS-YAML 1.x.x
	jsYaml$1.scan           = deprecated('scan');
	jsYaml$1.parse          = deprecated('parse');
	jsYaml$1.compose        = deprecated('compose');
	jsYaml$1.addConstructor = deprecated('addConstructor');
	return jsYaml$1;
}

var jsYaml;
var hasRequiredJsYaml;

function requireJsYaml () {
	if (hasRequiredJsYaml) return jsYaml;
	hasRequiredJsYaml = 1;


	var yaml = requireJsYaml$1();


	jsYaml = yaml;
	return jsYaml;
}

var lib$3;
var hasRequiredLib$3;

function requireLib$3 () {
	if (hasRequiredLib$3) return lib$3;
	hasRequiredLib$3 = 1;

	var map = requireUnistUtilMap$1();
	var yaml = requireJsYaml();

	var yamlPlugin = function yamlPlugin(options) {

	    function transformer(ast) {
	        return map(ast, function (node) {
	            if (node.type == "yaml") {
	                var parsedValue = yaml.safeLoad(node.value, 'utf8');
	                var newNode = Object.assign({}, node, { data: { parsedValue: parsedValue } });
	                return newNode;
	            } else {
	                return node;
	            }
	        });
	    }

	    // Stringify for yaml
	    var Compiler = this.Compiler;

	    if (Compiler != null) {
	        var visitors = Compiler.prototype.visitors;
	        if (visitors) {
	            visitors.yaml = function (node) {
	                if (node.data && node.data.parsedValue) {
	                    var yml = yaml.safeDump(node.data.parsedValue);
	                    return '---\n' + yml + '---';
	                }
	            };
	        }
	    }

	    return transformer;
	};

	lib$3 = yamlPlugin;
	return lib$3;
}

var libExports$1 = requireLib$3();
var parseFrontmatter = /*@__PURE__*/getDefaultExportFromCjs(libExports$1);

var unified_1;
var hasRequiredUnified;

function requireUnified () {
	if (hasRequiredUnified) return unified_1;
	hasRequiredUnified = 1;

	var extend = requireExtend();
	var bail = requireBail();
	var vfile = requireVfile();
	var trough = requireTrough();
	var plain = requireIsPlainObj();

	// Expose a frozen processor.
	unified_1 = unified().freeze();

	var slice = [].slice;
	var own = {}.hasOwnProperty;

	// Process pipeline.
	var pipeline = trough()
	  .use(pipelineParse)
	  .use(pipelineRun)
	  .use(pipelineStringify);

	function pipelineParse(p, ctx) {
	  ctx.tree = p.parse(ctx.file);
	}

	function pipelineRun(p, ctx, next) {
	  p.run(ctx.tree, ctx.file, done);

	  function done(err, tree, file) {
	    if (err) {
	      next(err);
	    } else {
	      ctx.tree = tree;
	      ctx.file = file;
	      next();
	    }
	  }
	}

	function pipelineStringify(p, ctx) {
	  ctx.file.contents = p.stringify(ctx.tree, ctx.file);
	}

	// Function to create the first processor.
	function unified() {
	  var attachers = [];
	  var transformers = trough();
	  var namespace = {};
	  var frozen = false;
	  var freezeIndex = -1;

	  // Data management.
	  processor.data = data;

	  // Lock.
	  processor.freeze = freeze;

	  // Plugins.
	  processor.attachers = attachers;
	  processor.use = use;

	  // API.
	  processor.parse = parse;
	  processor.stringify = stringify;
	  processor.run = run;
	  processor.runSync = runSync;
	  processor.process = process;
	  processor.processSync = processSync;

	  // Expose.
	  return processor

	  // Create a new processor based on the processor in the current scope.
	  function processor() {
	    var destination = unified();
	    var length = attachers.length;
	    var index = -1;

	    while (++index < length) {
	      destination.use.apply(null, attachers[index]);
	    }

	    destination.data(extend(true, {}, namespace));

	    return destination
	  }

	  // Freeze: used to signal a processor that has finished configuration.
	  //
	  // For example, take unified itself: it’s frozen.
	  // Plugins should not be added to it.
	  // Rather, it should be extended, by invoking it, before modifying it.
	  //
	  // In essence, always invoke this when exporting a processor.
	  function freeze() {
	    var values;
	    var plugin;
	    var options;
	    var transformer;

	    if (frozen) {
	      return processor
	    }

	    while (++freezeIndex < attachers.length) {
	      values = attachers[freezeIndex];
	      plugin = values[0];
	      options = values[1];
	      transformer = null;

	      if (options === false) {
	        continue
	      }

	      if (options === true) {
	        values[1] = undefined;
	      }

	      transformer = plugin.apply(processor, values.slice(1));

	      if (typeof transformer === 'function') {
	        transformers.use(transformer);
	      }
	    }

	    frozen = true;
	    freezeIndex = Infinity;

	    return processor
	  }

	  // Data management.
	  // Getter / setter for processor-specific informtion.
	  function data(key, value) {
	    if (typeof key === 'string') {
	      // Set `key`.
	      if (arguments.length === 2) {
	        assertUnfrozen('data', frozen);

	        namespace[key] = value;

	        return processor
	      }

	      // Get `key`.
	      return (own.call(namespace, key) && namespace[key]) || null
	    }

	    // Set space.
	    if (key) {
	      assertUnfrozen('data', frozen);
	      namespace = key;
	      return processor
	    }

	    // Get space.
	    return namespace
	  }

	  // Plugin management.
	  //
	  // Pass it:
	  // *   an attacher and options,
	  // *   a preset,
	  // *   a list of presets, attachers, and arguments (list of attachers and
	  //     options).
	  function use(value) {
	    var settings;

	    assertUnfrozen('use', frozen);

	    if (value === null || value === undefined) ; else if (typeof value === 'function') {
	      addPlugin.apply(null, arguments);
	    } else if (typeof value === 'object') {
	      if ('length' in value) {
	        addList(value);
	      } else {
	        addPreset(value);
	      }
	    } else {
	      throw new Error('Expected usable value, not `' + value + '`')
	    }

	    if (settings) {
	      namespace.settings = extend(namespace.settings || {}, settings);
	    }

	    return processor

	    function addPreset(result) {
	      addList(result.plugins);

	      if (result.settings) {
	        settings = extend(settings || {}, result.settings);
	      }
	    }

	    function add(value) {
	      if (typeof value === 'function') {
	        addPlugin(value);
	      } else if (typeof value === 'object') {
	        if ('length' in value) {
	          addPlugin.apply(null, value);
	        } else {
	          addPreset(value);
	        }
	      } else {
	        throw new Error('Expected usable value, not `' + value + '`')
	      }
	    }

	    function addList(plugins) {
	      var length;
	      var index;

	      if (plugins === null || plugins === undefined) ; else if (typeof plugins === 'object' && 'length' in plugins) {
	        length = plugins.length;
	        index = -1;

	        while (++index < length) {
	          add(plugins[index]);
	        }
	      } else {
	        throw new Error('Expected a list of plugins, not `' + plugins + '`')
	      }
	    }

	    function addPlugin(plugin, value) {
	      var entry = find(plugin);

	      if (entry) {
	        if (plain(entry[1]) && plain(value)) {
	          value = extend(entry[1], value);
	        }

	        entry[1] = value;
	      } else {
	        attachers.push(slice.call(arguments));
	      }
	    }
	  }

	  function find(plugin) {
	    var length = attachers.length;
	    var index = -1;
	    var entry;

	    while (++index < length) {
	      entry = attachers[index];

	      if (entry[0] === plugin) {
	        return entry
	      }
	    }
	  }

	  // Parse a file (in string or vfile representation) into a unist node using
	  // the `Parser` on the processor.
	  function parse(doc) {
	    var file = vfile(doc);
	    var Parser;

	    freeze();
	    Parser = processor.Parser;
	    assertParser('parse', Parser);

	    if (newable(Parser, 'parse')) {
	      return new Parser(String(file), file).parse()
	    }

	    return Parser(String(file), file) // eslint-disable-line new-cap
	  }

	  // Run transforms on a unist node representation of a file (in string or
	  // vfile representation), async.
	  function run(node, file, cb) {
	    assertNode(node);
	    freeze();

	    if (!cb && typeof file === 'function') {
	      cb = file;
	      file = null;
	    }

	    if (!cb) {
	      return new Promise(executor)
	    }

	    executor(null, cb);

	    function executor(resolve, reject) {
	      transformers.run(node, vfile(file), done);

	      function done(err, tree, file) {
	        tree = tree || node;
	        if (err) {
	          reject(err);
	        } else if (resolve) {
	          resolve(tree);
	        } else {
	          cb(null, tree, file);
	        }
	      }
	    }
	  }

	  // Run transforms on a unist node representation of a file (in string or
	  // vfile representation), sync.
	  function runSync(node, file) {
	    var complete = false;
	    var result;

	    run(node, file, done);

	    assertDone('runSync', 'run', complete);

	    return result

	    function done(err, tree) {
	      complete = true;
	      bail(err);
	      result = tree;
	    }
	  }

	  // Stringify a unist node representation of a file (in string or vfile
	  // representation) into a string using the `Compiler` on the processor.
	  function stringify(node, doc) {
	    var file = vfile(doc);
	    var Compiler;

	    freeze();
	    Compiler = processor.Compiler;
	    assertCompiler('stringify', Compiler);
	    assertNode(node);

	    if (newable(Compiler, 'compile')) {
	      return new Compiler(node, file).compile()
	    }

	    return Compiler(node, file) // eslint-disable-line new-cap
	  }

	  // Parse a file (in string or vfile representation) into a unist node using
	  // the `Parser` on the processor, then run transforms on that node, and
	  // compile the resulting node using the `Compiler` on the processor, and
	  // store that result on the vfile.
	  function process(doc, cb) {
	    freeze();
	    assertParser('process', processor.Parser);
	    assertCompiler('process', processor.Compiler);

	    if (!cb) {
	      return new Promise(executor)
	    }

	    executor(null, cb);

	    function executor(resolve, reject) {
	      var file = vfile(doc);

	      pipeline.run(processor, {file: file}, done);

	      function done(err) {
	        if (err) {
	          reject(err);
	        } else if (resolve) {
	          resolve(file);
	        } else {
	          cb(null, file);
	        }
	      }
	    }
	  }

	  // Process the given document (in string or vfile representation), sync.
	  function processSync(doc) {
	    var complete = false;
	    var file;

	    freeze();
	    assertParser('processSync', processor.Parser);
	    assertCompiler('processSync', processor.Compiler);
	    file = vfile(doc);

	    process(file, done);

	    assertDone('processSync', 'process', complete);

	    return file

	    function done(err) {
	      complete = true;
	      bail(err);
	    }
	  }
	}

	// Check if `value` is a constructor.
	function newable(value, name) {
	  return (
	    typeof value === 'function' &&
	    value.prototype &&
	    // A function with keys in its prototype is probably a constructor.
	    // Classes’ prototype methods are not enumerable, so we check if some value
	    // exists in the prototype.
	    (keys(value.prototype) || name in value.prototype)
	  )
	}

	// Check if `value` is an object with keys.
	function keys(value) {
	  var key;
	  for (key in value) {
	    return true
	  }

	  return false
	}

	// Assert a parser is available.
	function assertParser(name, Parser) {
	  if (typeof Parser !== 'function') {
	    throw new Error('Cannot `' + name + '` without `Parser`')
	  }
	}

	// Assert a compiler is available.
	function assertCompiler(name, Compiler) {
	  if (typeof Compiler !== 'function') {
	    throw new Error('Cannot `' + name + '` without `Compiler`')
	  }
	}

	// Assert the processor is not frozen.
	function assertUnfrozen(name, frozen) {
	  if (frozen) {
	    throw new Error(
	      'Cannot invoke `' +
	        name +
	        '` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.'
	    )
	  }
	}

	// Assert `node` is a unist node.
	function assertNode(node) {
	  if (!node || typeof node.type !== 'string') {
	    throw new Error('Expected node, got `' + node + '`')
	  }
	}

	// Assert that `complete` is `true`.
	function assertDone(name, asyncName, complete) {
	  if (!complete) {
	    throw new Error(
	      '`' + name + '` finished async. Use `' + asyncName + '` instead'
	    )
	  }
	}
	return unified_1;
}

var schema;
var hasRequiredSchema;

function requireSchema () {
	if (hasRequiredSchema) return schema;
	hasRequiredSchema = 1;

	schema = Schema;

	var proto = Schema.prototype;

	proto.space = null;
	proto.normal = {};
	proto.property = {};

	function Schema(property, normal, space) {
	  this.property = property;
	  this.normal = normal;

	  if (space) {
	    this.space = space;
	  }
	}
	return schema;
}

var merge_1;
var hasRequiredMerge;

function requireMerge () {
	if (hasRequiredMerge) return merge_1;
	hasRequiredMerge = 1;

	var xtend = requireImmutable();
	var Schema = requireSchema();

	merge_1 = merge;

	function merge(definitions) {
	  var length = definitions.length;
	  var property = [];
	  var normal = [];
	  var index = -1;
	  var info;
	  var space;

	  while (++index < length) {
	    info = definitions[index];
	    property.push(info.property);
	    normal.push(info.normal);
	    space = info.space;
	  }

	  return new Schema(
	    xtend.apply(null, property),
	    xtend.apply(null, normal),
	    space
	  )
	}
	return merge_1;
}

var normalize_1;
var hasRequiredNormalize;

function requireNormalize () {
	if (hasRequiredNormalize) return normalize_1;
	hasRequiredNormalize = 1;

	normalize_1 = normalize;

	function normalize(value) {
	  return value.toLowerCase()
	}
	return normalize_1;
}

var info;
var hasRequiredInfo;

function requireInfo () {
	if (hasRequiredInfo) return info;
	hasRequiredInfo = 1;

	info = Info;

	var proto = Info.prototype;

	proto.space = null;
	proto.attribute = null;
	proto.property = null;
	proto.boolean = false;
	proto.booleanish = false;
	proto.overloadedBoolean = false;
	proto.number = false;
	proto.commaSeparated = false;
	proto.spaceSeparated = false;
	proto.commaOrSpaceSeparated = false;
	proto.mustUseProperty = false;
	proto.defined = false;

	function Info(property, attribute) {
	  this.property = property;
	  this.attribute = attribute;
	}
	return info;
}

var types = {};

var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types;
	hasRequiredTypes = 1;

	var powers = 0;

	types.boolean = increment();
	types.booleanish = increment();
	types.overloadedBoolean = increment();
	types.number = increment();
	types.spaceSeparated = increment();
	types.commaSeparated = increment();
	types.commaOrSpaceSeparated = increment();

	function increment() {
	  return Math.pow(2, ++powers)
	}
	return types;
}

var definedInfo;
var hasRequiredDefinedInfo;

function requireDefinedInfo () {
	if (hasRequiredDefinedInfo) return definedInfo;
	hasRequiredDefinedInfo = 1;

	var Info = requireInfo();
	var types = requireTypes();

	definedInfo = DefinedInfo;

	DefinedInfo.prototype = new Info();
	DefinedInfo.prototype.defined = true;

	var checks = [
	  'boolean',
	  'booleanish',
	  'overloadedBoolean',
	  'number',
	  'commaSeparated',
	  'spaceSeparated',
	  'commaOrSpaceSeparated'
	];
	var checksLength = checks.length;

	function DefinedInfo(property, attribute, mask, space) {
	  var index = -1;
	  var check;

	  mark(this, 'space', space);

	  Info.call(this, property, attribute);

	  while (++index < checksLength) {
	    check = checks[index];
	    mark(this, check, (mask & types[check]) === types[check]);
	  }
	}

	function mark(values, key, value) {
	  if (value) {
	    values[key] = value;
	  }
	}
	return definedInfo;
}

var create_1;
var hasRequiredCreate;

function requireCreate () {
	if (hasRequiredCreate) return create_1;
	hasRequiredCreate = 1;

	var normalize = requireNormalize();
	var Schema = requireSchema();
	var DefinedInfo = requireDefinedInfo();

	create_1 = create;

	function create(definition) {
	  var space = definition.space;
	  var mustUseProperty = definition.mustUseProperty || [];
	  var attributes = definition.attributes || {};
	  var props = definition.properties;
	  var transform = definition.transform;
	  var property = {};
	  var normal = {};
	  var prop;
	  var info;

	  for (prop in props) {
	    info = new DefinedInfo(
	      prop,
	      transform(attributes, prop),
	      props[prop],
	      space
	    );

	    if (mustUseProperty.indexOf(prop) !== -1) {
	      info.mustUseProperty = true;
	    }

	    property[prop] = info;

	    normal[normalize(prop)] = prop;
	    normal[normalize(info.attribute)] = prop;
	  }

	  return new Schema(property, normal, space)
	}
	return create_1;
}

var xlink$1;
var hasRequiredXlink;

function requireXlink () {
	if (hasRequiredXlink) return xlink$1;
	hasRequiredXlink = 1;

	var create = requireCreate();

	xlink$1 = create({
	  space: 'xlink',
	  transform: xlinkTransform,
	  properties: {
	    xLinkActuate: null,
	    xLinkArcRole: null,
	    xLinkHref: null,
	    xLinkRole: null,
	    xLinkShow: null,
	    xLinkTitle: null,
	    xLinkType: null
	  }
	});

	function xlinkTransform(_, prop) {
	  return 'xlink:' + prop.slice(5).toLowerCase()
	}
	return xlink$1;
}

var xml$1;
var hasRequiredXml;

function requireXml () {
	if (hasRequiredXml) return xml$1;
	hasRequiredXml = 1;

	var create = requireCreate();

	xml$1 = create({
	  space: 'xml',
	  transform: xmlTransform,
	  properties: {
	    xmlLang: null,
	    xmlBase: null,
	    xmlSpace: null
	  }
	});

	function xmlTransform(_, prop) {
	  return 'xml:' + prop.slice(3).toLowerCase()
	}
	return xml$1;
}

var caseSensitiveTransform_1;
var hasRequiredCaseSensitiveTransform;

function requireCaseSensitiveTransform () {
	if (hasRequiredCaseSensitiveTransform) return caseSensitiveTransform_1;
	hasRequiredCaseSensitiveTransform = 1;

	caseSensitiveTransform_1 = caseSensitiveTransform;

	function caseSensitiveTransform(attributes, attribute) {
	  return attribute in attributes ? attributes[attribute] : attribute
	}
	return caseSensitiveTransform_1;
}

var caseInsensitiveTransform_1;
var hasRequiredCaseInsensitiveTransform;

function requireCaseInsensitiveTransform () {
	if (hasRequiredCaseInsensitiveTransform) return caseInsensitiveTransform_1;
	hasRequiredCaseInsensitiveTransform = 1;

	var caseSensitiveTransform = requireCaseSensitiveTransform();

	caseInsensitiveTransform_1 = caseInsensitiveTransform;

	function caseInsensitiveTransform(attributes, property) {
	  return caseSensitiveTransform(attributes, property.toLowerCase())
	}
	return caseInsensitiveTransform_1;
}

var xmlns$1;
var hasRequiredXmlns;

function requireXmlns () {
	if (hasRequiredXmlns) return xmlns$1;
	hasRequiredXmlns = 1;

	var create = requireCreate();
	var caseInsensitiveTransform = requireCaseInsensitiveTransform();

	xmlns$1 = create({
	  space: 'xmlns',
	  attributes: {
	    xmlnsxlink: 'xmlns:xlink'
	  },
	  transform: caseInsensitiveTransform,
	  properties: {
	    xmlns: null,
	    xmlnsXLink: null
	  }
	});
	return xmlns$1;
}

var aria;
var hasRequiredAria;

function requireAria () {
	if (hasRequiredAria) return aria;
	hasRequiredAria = 1;

	var types = requireTypes();
	var create = requireCreate();

	var booleanish = types.booleanish;
	var number = types.number;
	var spaceSeparated = types.spaceSeparated;

	aria = create({
	  transform: ariaTransform,
	  properties: {
	    ariaActiveDescendant: null,
	    ariaAtomic: booleanish,
	    ariaAutoComplete: null,
	    ariaBusy: booleanish,
	    ariaChecked: booleanish,
	    ariaColCount: number,
	    ariaColIndex: number,
	    ariaColSpan: number,
	    ariaControls: spaceSeparated,
	    ariaCurrent: null,
	    ariaDescribedBy: spaceSeparated,
	    ariaDetails: null,
	    ariaDisabled: booleanish,
	    ariaDropEffect: spaceSeparated,
	    ariaErrorMessage: null,
	    ariaExpanded: booleanish,
	    ariaFlowTo: spaceSeparated,
	    ariaGrabbed: booleanish,
	    ariaHasPopup: null,
	    ariaHidden: booleanish,
	    ariaInvalid: null,
	    ariaKeyShortcuts: null,
	    ariaLabel: null,
	    ariaLabelledBy: spaceSeparated,
	    ariaLevel: number,
	    ariaLive: null,
	    ariaModal: booleanish,
	    ariaMultiLine: booleanish,
	    ariaMultiSelectable: booleanish,
	    ariaOrientation: null,
	    ariaOwns: spaceSeparated,
	    ariaPlaceholder: null,
	    ariaPosInSet: number,
	    ariaPressed: booleanish,
	    ariaReadOnly: booleanish,
	    ariaRelevant: null,
	    ariaRequired: booleanish,
	    ariaRoleDescription: spaceSeparated,
	    ariaRowCount: number,
	    ariaRowIndex: number,
	    ariaRowSpan: number,
	    ariaSelected: booleanish,
	    ariaSetSize: number,
	    ariaSort: null,
	    ariaValueMax: number,
	    ariaValueMin: number,
	    ariaValueNow: number,
	    ariaValueText: null,
	    role: null
	  }
	});

	function ariaTransform(_, prop) {
	  return prop === 'role' ? prop : 'aria-' + prop.slice(4).toLowerCase()
	}
	return aria;
}

var html$4;
var hasRequiredHtml$5;

function requireHtml$5 () {
	if (hasRequiredHtml$5) return html$4;
	hasRequiredHtml$5 = 1;

	var types = requireTypes();
	var create = requireCreate();
	var caseInsensitiveTransform = requireCaseInsensitiveTransform();

	var boolean = types.boolean;
	var overloadedBoolean = types.overloadedBoolean;
	var booleanish = types.booleanish;
	var number = types.number;
	var spaceSeparated = types.spaceSeparated;
	var commaSeparated = types.commaSeparated;

	html$4 = create({
	  space: 'html',
	  attributes: {
	    acceptcharset: 'accept-charset',
	    classname: 'class',
	    htmlfor: 'for',
	    httpequiv: 'http-equiv'
	  },
	  transform: caseInsensitiveTransform,
	  mustUseProperty: ['checked', 'multiple', 'muted', 'selected'],
	  properties: {
	    // Standard Properties.
	    abbr: null,
	    accept: commaSeparated,
	    acceptCharset: spaceSeparated,
	    accessKey: spaceSeparated,
	    action: null,
	    allow: null,
	    allowFullScreen: boolean,
	    allowPaymentRequest: boolean,
	    allowUserMedia: boolean,
	    alt: null,
	    as: null,
	    async: boolean,
	    autoCapitalize: null,
	    autoComplete: spaceSeparated,
	    autoFocus: boolean,
	    autoPlay: boolean,
	    capture: boolean,
	    charSet: null,
	    checked: boolean,
	    cite: null,
	    className: spaceSeparated,
	    cols: number,
	    colSpan: null,
	    content: null,
	    contentEditable: booleanish,
	    controls: boolean,
	    controlsList: spaceSeparated,
	    coords: number | commaSeparated,
	    crossOrigin: null,
	    data: null,
	    dateTime: null,
	    decoding: null,
	    default: boolean,
	    defer: boolean,
	    dir: null,
	    dirName: null,
	    disabled: boolean,
	    download: overloadedBoolean,
	    draggable: booleanish,
	    encType: null,
	    enterKeyHint: null,
	    form: null,
	    formAction: null,
	    formEncType: null,
	    formMethod: null,
	    formNoValidate: boolean,
	    formTarget: null,
	    headers: spaceSeparated,
	    height: number,
	    hidden: boolean,
	    high: number,
	    href: null,
	    hrefLang: null,
	    htmlFor: spaceSeparated,
	    httpEquiv: spaceSeparated,
	    id: null,
	    imageSizes: null,
	    imageSrcSet: commaSeparated,
	    inputMode: null,
	    integrity: null,
	    is: null,
	    isMap: boolean,
	    itemId: null,
	    itemProp: spaceSeparated,
	    itemRef: spaceSeparated,
	    itemScope: boolean,
	    itemType: spaceSeparated,
	    kind: null,
	    label: null,
	    lang: null,
	    language: null,
	    list: null,
	    loop: boolean,
	    low: number,
	    manifest: null,
	    max: null,
	    maxLength: number,
	    media: null,
	    method: null,
	    min: null,
	    minLength: number,
	    multiple: boolean,
	    muted: boolean,
	    name: null,
	    nonce: null,
	    noModule: boolean,
	    noValidate: boolean,
	    onAbort: null,
	    onAfterPrint: null,
	    onAuxClick: null,
	    onBeforePrint: null,
	    onBeforeUnload: null,
	    onBlur: null,
	    onCancel: null,
	    onCanPlay: null,
	    onCanPlayThrough: null,
	    onChange: null,
	    onClick: null,
	    onClose: null,
	    onContextMenu: null,
	    onCopy: null,
	    onCueChange: null,
	    onCut: null,
	    onDblClick: null,
	    onDrag: null,
	    onDragEnd: null,
	    onDragEnter: null,
	    onDragExit: null,
	    onDragLeave: null,
	    onDragOver: null,
	    onDragStart: null,
	    onDrop: null,
	    onDurationChange: null,
	    onEmptied: null,
	    onEnded: null,
	    onError: null,
	    onFocus: null,
	    onFormData: null,
	    onHashChange: null,
	    onInput: null,
	    onInvalid: null,
	    onKeyDown: null,
	    onKeyPress: null,
	    onKeyUp: null,
	    onLanguageChange: null,
	    onLoad: null,
	    onLoadedData: null,
	    onLoadedMetadata: null,
	    onLoadEnd: null,
	    onLoadStart: null,
	    onMessage: null,
	    onMessageError: null,
	    onMouseDown: null,
	    onMouseEnter: null,
	    onMouseLeave: null,
	    onMouseMove: null,
	    onMouseOut: null,
	    onMouseOver: null,
	    onMouseUp: null,
	    onOffline: null,
	    onOnline: null,
	    onPageHide: null,
	    onPageShow: null,
	    onPaste: null,
	    onPause: null,
	    onPlay: null,
	    onPlaying: null,
	    onPopState: null,
	    onProgress: null,
	    onRateChange: null,
	    onRejectionHandled: null,
	    onReset: null,
	    onResize: null,
	    onScroll: null,
	    onSecurityPolicyViolation: null,
	    onSeeked: null,
	    onSeeking: null,
	    onSelect: null,
	    onSlotChange: null,
	    onStalled: null,
	    onStorage: null,
	    onSubmit: null,
	    onSuspend: null,
	    onTimeUpdate: null,
	    onToggle: null,
	    onUnhandledRejection: null,
	    onUnload: null,
	    onVolumeChange: null,
	    onWaiting: null,
	    onWheel: null,
	    open: boolean,
	    optimum: number,
	    pattern: null,
	    ping: spaceSeparated,
	    placeholder: null,
	    playsInline: boolean,
	    poster: null,
	    preload: null,
	    readOnly: boolean,
	    referrerPolicy: null,
	    rel: spaceSeparated,
	    required: boolean,
	    reversed: boolean,
	    rows: number,
	    rowSpan: number,
	    sandbox: spaceSeparated,
	    scope: null,
	    scoped: boolean,
	    seamless: boolean,
	    selected: boolean,
	    shape: null,
	    size: number,
	    sizes: null,
	    slot: null,
	    span: number,
	    spellCheck: booleanish,
	    src: null,
	    srcDoc: null,
	    srcLang: null,
	    srcSet: commaSeparated,
	    start: number,
	    step: null,
	    style: null,
	    tabIndex: number,
	    target: null,
	    title: null,
	    translate: null,
	    type: null,
	    typeMustMatch: boolean,
	    useMap: null,
	    value: booleanish,
	    width: number,
	    wrap: null,

	    // Legacy.
	    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
	    align: null, // Several. Use CSS `text-align` instead,
	    aLink: null, // `<body>`. Use CSS `a:active {color}` instead
	    archive: spaceSeparated, // `<object>`. List of URIs to archives
	    axis: null, // `<td>` and `<th>`. Use `scope` on `<th>`
	    background: null, // `<body>`. Use CSS `background-image` instead
	    bgColor: null, // `<body>` and table elements. Use CSS `background-color` instead
	    border: number, // `<table>`. Use CSS `border-width` instead,
	    borderColor: null, // `<table>`. Use CSS `border-color` instead,
	    bottomMargin: number, // `<body>`
	    cellPadding: null, // `<table>`
	    cellSpacing: null, // `<table>`
	    char: null, // Several table elements. When `align=char`, sets the character to align on
	    charOff: null, // Several table elements. When `char`, offsets the alignment
	    classId: null, // `<object>`
	    clear: null, // `<br>`. Use CSS `clear` instead
	    code: null, // `<object>`
	    codeBase: null, // `<object>`
	    codeType: null, // `<object>`
	    color: null, // `<font>` and `<hr>`. Use CSS instead
	    compact: boolean, // Lists. Use CSS to reduce space between items instead
	    declare: boolean, // `<object>`
	    event: null, // `<script>`
	    face: null, // `<font>`. Use CSS instead
	    frame: null, // `<table>`
	    frameBorder: null, // `<iframe>`. Use CSS `border` instead
	    hSpace: number, // `<img>` and `<object>`
	    leftMargin: number, // `<body>`
	    link: null, // `<body>`. Use CSS `a:link {color: *}` instead
	    longDesc: null, // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
	    lowSrc: null, // `<img>`. Use a `<picture>`
	    marginHeight: number, // `<body>`
	    marginWidth: number, // `<body>`
	    noResize: boolean, // `<frame>`
	    noHref: boolean, // `<area>`. Use no href instead of an explicit `nohref`
	    noShade: boolean, // `<hr>`. Use background-color and height instead of borders
	    noWrap: boolean, // `<td>` and `<th>`
	    object: null, // `<applet>`
	    profile: null, // `<head>`
	    prompt: null, // `<isindex>`
	    rev: null, // `<link>`
	    rightMargin: number, // `<body>`
	    rules: null, // `<table>`
	    scheme: null, // `<meta>`
	    scrolling: booleanish, // `<frame>`. Use overflow in the child context
	    standby: null, // `<object>`
	    summary: null, // `<table>`
	    text: null, // `<body>`. Use CSS `color` instead
	    topMargin: number, // `<body>`
	    valueType: null, // `<param>`
	    version: null, // `<html>`. Use a doctype.
	    vAlign: null, // Several. Use CSS `vertical-align` instead
	    vLink: null, // `<body>`. Use CSS `a:visited {color}` instead
	    vSpace: number, // `<img>` and `<object>`

	    // Non-standard Properties.
	    allowTransparency: null,
	    autoCorrect: null,
	    autoSave: null,
	    disablePictureInPicture: boolean,
	    disableRemotePlayback: boolean,
	    prefix: null,
	    property: null,
	    results: number,
	    security: null,
	    unselectable: null
	  }
	});
	return html$4;
}

var html_1$2;
var hasRequiredHtml$4;

function requireHtml$4 () {
	if (hasRequiredHtml$4) return html_1$2;
	hasRequiredHtml$4 = 1;

	var merge = requireMerge();
	var xlink = requireXlink();
	var xml = requireXml();
	var xmlns = requireXmlns();
	var aria = requireAria();
	var html = requireHtml$5();

	html_1$2 = merge([xml, xlink, xmlns, aria, html]);
	return html_1$2;
}

var svg$1;
var hasRequiredSvg$2;

function requireSvg$2 () {
	if (hasRequiredSvg$2) return svg$1;
	hasRequiredSvg$2 = 1;

	var types = requireTypes();
	var create = requireCreate();
	var caseSensitiveTransform = requireCaseSensitiveTransform();

	var boolean = types.boolean;
	var number = types.number;
	var spaceSeparated = types.spaceSeparated;
	var commaSeparated = types.commaSeparated;
	var commaOrSpaceSeparated = types.commaOrSpaceSeparated;

	svg$1 = create({
	  space: 'svg',
	  attributes: {
	    accentHeight: 'accent-height',
	    alignmentBaseline: 'alignment-baseline',
	    arabicForm: 'arabic-form',
	    baselineShift: 'baseline-shift',
	    capHeight: 'cap-height',
	    className: 'class',
	    clipPath: 'clip-path',
	    clipRule: 'clip-rule',
	    colorInterpolation: 'color-interpolation',
	    colorInterpolationFilters: 'color-interpolation-filters',
	    colorProfile: 'color-profile',
	    colorRendering: 'color-rendering',
	    crossOrigin: 'crossorigin',
	    dataType: 'datatype',
	    dominantBaseline: 'dominant-baseline',
	    enableBackground: 'enable-background',
	    fillOpacity: 'fill-opacity',
	    fillRule: 'fill-rule',
	    floodColor: 'flood-color',
	    floodOpacity: 'flood-opacity',
	    fontFamily: 'font-family',
	    fontSize: 'font-size',
	    fontSizeAdjust: 'font-size-adjust',
	    fontStretch: 'font-stretch',
	    fontStyle: 'font-style',
	    fontVariant: 'font-variant',
	    fontWeight: 'font-weight',
	    glyphName: 'glyph-name',
	    glyphOrientationHorizontal: 'glyph-orientation-horizontal',
	    glyphOrientationVertical: 'glyph-orientation-vertical',
	    hrefLang: 'hreflang',
	    horizAdvX: 'horiz-adv-x',
	    horizOriginX: 'horiz-origin-x',
	    horizOriginY: 'horiz-origin-y',
	    imageRendering: 'image-rendering',
	    letterSpacing: 'letter-spacing',
	    lightingColor: 'lighting-color',
	    markerEnd: 'marker-end',
	    markerMid: 'marker-mid',
	    markerStart: 'marker-start',
	    navDown: 'nav-down',
	    navDownLeft: 'nav-down-left',
	    navDownRight: 'nav-down-right',
	    navLeft: 'nav-left',
	    navNext: 'nav-next',
	    navPrev: 'nav-prev',
	    navRight: 'nav-right',
	    navUp: 'nav-up',
	    navUpLeft: 'nav-up-left',
	    navUpRight: 'nav-up-right',
	    onAbort: 'onabort',
	    onActivate: 'onactivate',
	    onAfterPrint: 'onafterprint',
	    onBeforePrint: 'onbeforeprint',
	    onBegin: 'onbegin',
	    onCancel: 'oncancel',
	    onCanPlay: 'oncanplay',
	    onCanPlayThrough: 'oncanplaythrough',
	    onChange: 'onchange',
	    onClick: 'onclick',
	    onClose: 'onclose',
	    onCopy: 'oncopy',
	    onCueChange: 'oncuechange',
	    onCut: 'oncut',
	    onDblClick: 'ondblclick',
	    onDrag: 'ondrag',
	    onDragEnd: 'ondragend',
	    onDragEnter: 'ondragenter',
	    onDragExit: 'ondragexit',
	    onDragLeave: 'ondragleave',
	    onDragOver: 'ondragover',
	    onDragStart: 'ondragstart',
	    onDrop: 'ondrop',
	    onDurationChange: 'ondurationchange',
	    onEmptied: 'onemptied',
	    onEnd: 'onend',
	    onEnded: 'onended',
	    onError: 'onerror',
	    onFocus: 'onfocus',
	    onFocusIn: 'onfocusin',
	    onFocusOut: 'onfocusout',
	    onHashChange: 'onhashchange',
	    onInput: 'oninput',
	    onInvalid: 'oninvalid',
	    onKeyDown: 'onkeydown',
	    onKeyPress: 'onkeypress',
	    onKeyUp: 'onkeyup',
	    onLoad: 'onload',
	    onLoadedData: 'onloadeddata',
	    onLoadedMetadata: 'onloadedmetadata',
	    onLoadStart: 'onloadstart',
	    onMessage: 'onmessage',
	    onMouseDown: 'onmousedown',
	    onMouseEnter: 'onmouseenter',
	    onMouseLeave: 'onmouseleave',
	    onMouseMove: 'onmousemove',
	    onMouseOut: 'onmouseout',
	    onMouseOver: 'onmouseover',
	    onMouseUp: 'onmouseup',
	    onMouseWheel: 'onmousewheel',
	    onOffline: 'onoffline',
	    onOnline: 'ononline',
	    onPageHide: 'onpagehide',
	    onPageShow: 'onpageshow',
	    onPaste: 'onpaste',
	    onPause: 'onpause',
	    onPlay: 'onplay',
	    onPlaying: 'onplaying',
	    onPopState: 'onpopstate',
	    onProgress: 'onprogress',
	    onRateChange: 'onratechange',
	    onRepeat: 'onrepeat',
	    onReset: 'onreset',
	    onResize: 'onresize',
	    onScroll: 'onscroll',
	    onSeeked: 'onseeked',
	    onSeeking: 'onseeking',
	    onSelect: 'onselect',
	    onShow: 'onshow',
	    onStalled: 'onstalled',
	    onStorage: 'onstorage',
	    onSubmit: 'onsubmit',
	    onSuspend: 'onsuspend',
	    onTimeUpdate: 'ontimeupdate',
	    onToggle: 'ontoggle',
	    onUnload: 'onunload',
	    onVolumeChange: 'onvolumechange',
	    onWaiting: 'onwaiting',
	    onZoom: 'onzoom',
	    overlinePosition: 'overline-position',
	    overlineThickness: 'overline-thickness',
	    paintOrder: 'paint-order',
	    panose1: 'panose-1',
	    pointerEvents: 'pointer-events',
	    referrerPolicy: 'referrerpolicy',
	    renderingIntent: 'rendering-intent',
	    shapeRendering: 'shape-rendering',
	    stopColor: 'stop-color',
	    stopOpacity: 'stop-opacity',
	    strikethroughPosition: 'strikethrough-position',
	    strikethroughThickness: 'strikethrough-thickness',
	    strokeDashArray: 'stroke-dasharray',
	    strokeDashOffset: 'stroke-dashoffset',
	    strokeLineCap: 'stroke-linecap',
	    strokeLineJoin: 'stroke-linejoin',
	    strokeMiterLimit: 'stroke-miterlimit',
	    strokeOpacity: 'stroke-opacity',
	    strokeWidth: 'stroke-width',
	    tabIndex: 'tabindex',
	    textAnchor: 'text-anchor',
	    textDecoration: 'text-decoration',
	    textRendering: 'text-rendering',
	    typeOf: 'typeof',
	    underlinePosition: 'underline-position',
	    underlineThickness: 'underline-thickness',
	    unicodeBidi: 'unicode-bidi',
	    unicodeRange: 'unicode-range',
	    unitsPerEm: 'units-per-em',
	    vAlphabetic: 'v-alphabetic',
	    vHanging: 'v-hanging',
	    vIdeographic: 'v-ideographic',
	    vMathematical: 'v-mathematical',
	    vectorEffect: 'vector-effect',
	    vertAdvY: 'vert-adv-y',
	    vertOriginX: 'vert-origin-x',
	    vertOriginY: 'vert-origin-y',
	    wordSpacing: 'word-spacing',
	    writingMode: 'writing-mode',
	    xHeight: 'x-height',
	    // These were camelcased in Tiny. Now lowercased in SVG 2
	    playbackOrder: 'playbackorder',
	    timelineBegin: 'timelinebegin'
	  },
	  transform: caseSensitiveTransform,
	  properties: {
	    about: commaOrSpaceSeparated,
	    accentHeight: number,
	    accumulate: null,
	    additive: null,
	    alignmentBaseline: null,
	    alphabetic: number,
	    amplitude: number,
	    arabicForm: null,
	    ascent: number,
	    attributeName: null,
	    attributeType: null,
	    azimuth: number,
	    bandwidth: null,
	    baselineShift: null,
	    baseFrequency: null,
	    baseProfile: null,
	    bbox: null,
	    begin: null,
	    bias: number,
	    by: null,
	    calcMode: null,
	    capHeight: number,
	    className: spaceSeparated,
	    clip: null,
	    clipPath: null,
	    clipPathUnits: null,
	    clipRule: null,
	    color: null,
	    colorInterpolation: null,
	    colorInterpolationFilters: null,
	    colorProfile: null,
	    colorRendering: null,
	    content: null,
	    contentScriptType: null,
	    contentStyleType: null,
	    crossOrigin: null,
	    cursor: null,
	    cx: null,
	    cy: null,
	    d: null,
	    dataType: null,
	    defaultAction: null,
	    descent: number,
	    diffuseConstant: number,
	    direction: null,
	    display: null,
	    dur: null,
	    divisor: number,
	    dominantBaseline: null,
	    download: boolean,
	    dx: null,
	    dy: null,
	    edgeMode: null,
	    editable: null,
	    elevation: number,
	    enableBackground: null,
	    end: null,
	    event: null,
	    exponent: number,
	    externalResourcesRequired: null,
	    fill: null,
	    fillOpacity: number,
	    fillRule: null,
	    filter: null,
	    filterRes: null,
	    filterUnits: null,
	    floodColor: null,
	    floodOpacity: null,
	    focusable: null,
	    focusHighlight: null,
	    fontFamily: null,
	    fontSize: null,
	    fontSizeAdjust: null,
	    fontStretch: null,
	    fontStyle: null,
	    fontVariant: null,
	    fontWeight: null,
	    format: null,
	    fr: null,
	    from: null,
	    fx: null,
	    fy: null,
	    g1: commaSeparated,
	    g2: commaSeparated,
	    glyphName: commaSeparated,
	    glyphOrientationHorizontal: null,
	    glyphOrientationVertical: null,
	    glyphRef: null,
	    gradientTransform: null,
	    gradientUnits: null,
	    handler: null,
	    hanging: number,
	    hatchContentUnits: null,
	    hatchUnits: null,
	    height: null,
	    href: null,
	    hrefLang: null,
	    horizAdvX: number,
	    horizOriginX: number,
	    horizOriginY: number,
	    id: null,
	    ideographic: number,
	    imageRendering: null,
	    initialVisibility: null,
	    in: null,
	    in2: null,
	    intercept: number,
	    k: number,
	    k1: number,
	    k2: number,
	    k3: number,
	    k4: number,
	    kernelMatrix: commaOrSpaceSeparated,
	    kernelUnitLength: null,
	    keyPoints: null, // SEMI_COLON_SEPARATED
	    keySplines: null, // SEMI_COLON_SEPARATED
	    keyTimes: null, // SEMI_COLON_SEPARATED
	    kerning: null,
	    lang: null,
	    lengthAdjust: null,
	    letterSpacing: null,
	    lightingColor: null,
	    limitingConeAngle: number,
	    local: null,
	    markerEnd: null,
	    markerMid: null,
	    markerStart: null,
	    markerHeight: null,
	    markerUnits: null,
	    markerWidth: null,
	    mask: null,
	    maskContentUnits: null,
	    maskUnits: null,
	    mathematical: null,
	    max: null,
	    media: null,
	    mediaCharacterEncoding: null,
	    mediaContentEncodings: null,
	    mediaSize: number,
	    mediaTime: null,
	    method: null,
	    min: null,
	    mode: null,
	    name: null,
	    navDown: null,
	    navDownLeft: null,
	    navDownRight: null,
	    navLeft: null,
	    navNext: null,
	    navPrev: null,
	    navRight: null,
	    navUp: null,
	    navUpLeft: null,
	    navUpRight: null,
	    numOctaves: null,
	    observer: null,
	    offset: null,
	    onAbort: null,
	    onActivate: null,
	    onAfterPrint: null,
	    onBeforePrint: null,
	    onBegin: null,
	    onCancel: null,
	    onCanPlay: null,
	    onCanPlayThrough: null,
	    onChange: null,
	    onClick: null,
	    onClose: null,
	    onCopy: null,
	    onCueChange: null,
	    onCut: null,
	    onDblClick: null,
	    onDrag: null,
	    onDragEnd: null,
	    onDragEnter: null,
	    onDragExit: null,
	    onDragLeave: null,
	    onDragOver: null,
	    onDragStart: null,
	    onDrop: null,
	    onDurationChange: null,
	    onEmptied: null,
	    onEnd: null,
	    onEnded: null,
	    onError: null,
	    onFocus: null,
	    onFocusIn: null,
	    onFocusOut: null,
	    onHashChange: null,
	    onInput: null,
	    onInvalid: null,
	    onKeyDown: null,
	    onKeyPress: null,
	    onKeyUp: null,
	    onLoad: null,
	    onLoadedData: null,
	    onLoadedMetadata: null,
	    onLoadStart: null,
	    onMessage: null,
	    onMouseDown: null,
	    onMouseEnter: null,
	    onMouseLeave: null,
	    onMouseMove: null,
	    onMouseOut: null,
	    onMouseOver: null,
	    onMouseUp: null,
	    onMouseWheel: null,
	    onOffline: null,
	    onOnline: null,
	    onPageHide: null,
	    onPageShow: null,
	    onPaste: null,
	    onPause: null,
	    onPlay: null,
	    onPlaying: null,
	    onPopState: null,
	    onProgress: null,
	    onRateChange: null,
	    onRepeat: null,
	    onReset: null,
	    onResize: null,
	    onScroll: null,
	    onSeeked: null,
	    onSeeking: null,
	    onSelect: null,
	    onShow: null,
	    onStalled: null,
	    onStorage: null,
	    onSubmit: null,
	    onSuspend: null,
	    onTimeUpdate: null,
	    onToggle: null,
	    onUnload: null,
	    onVolumeChange: null,
	    onWaiting: null,
	    onZoom: null,
	    opacity: null,
	    operator: null,
	    order: null,
	    orient: null,
	    orientation: null,
	    origin: null,
	    overflow: null,
	    overlay: null,
	    overlinePosition: number,
	    overlineThickness: number,
	    paintOrder: null,
	    panose1: null,
	    path: null,
	    pathLength: number,
	    patternContentUnits: null,
	    patternTransform: null,
	    patternUnits: null,
	    phase: null,
	    ping: spaceSeparated,
	    pitch: null,
	    playbackOrder: null,
	    pointerEvents: null,
	    points: null,
	    pointsAtX: number,
	    pointsAtY: number,
	    pointsAtZ: number,
	    preserveAlpha: null,
	    preserveAspectRatio: null,
	    primitiveUnits: null,
	    propagate: null,
	    property: commaOrSpaceSeparated,
	    r: null,
	    radius: null,
	    referrerPolicy: null,
	    refX: null,
	    refY: null,
	    rel: commaOrSpaceSeparated,
	    rev: commaOrSpaceSeparated,
	    renderingIntent: null,
	    repeatCount: null,
	    repeatDur: null,
	    requiredExtensions: commaOrSpaceSeparated,
	    requiredFeatures: commaOrSpaceSeparated,
	    requiredFonts: commaOrSpaceSeparated,
	    requiredFormats: commaOrSpaceSeparated,
	    resource: null,
	    restart: null,
	    result: null,
	    rotate: null,
	    rx: null,
	    ry: null,
	    scale: null,
	    seed: null,
	    shapeRendering: null,
	    side: null,
	    slope: null,
	    snapshotTime: null,
	    specularConstant: number,
	    specularExponent: number,
	    spreadMethod: null,
	    spacing: null,
	    startOffset: null,
	    stdDeviation: null,
	    stemh: null,
	    stemv: null,
	    stitchTiles: null,
	    stopColor: null,
	    stopOpacity: null,
	    strikethroughPosition: number,
	    strikethroughThickness: number,
	    string: null,
	    stroke: null,
	    strokeDashArray: commaOrSpaceSeparated,
	    strokeDashOffset: null,
	    strokeLineCap: null,
	    strokeLineJoin: null,
	    strokeMiterLimit: number,
	    strokeOpacity: number,
	    strokeWidth: null,
	    style: null,
	    surfaceScale: number,
	    syncBehavior: null,
	    syncBehaviorDefault: null,
	    syncMaster: null,
	    syncTolerance: null,
	    syncToleranceDefault: null,
	    systemLanguage: commaOrSpaceSeparated,
	    tabIndex: number,
	    tableValues: null,
	    target: null,
	    targetX: number,
	    targetY: number,
	    textAnchor: null,
	    textDecoration: null,
	    textRendering: null,
	    textLength: null,
	    timelineBegin: null,
	    title: null,
	    transformBehavior: null,
	    type: null,
	    typeOf: commaOrSpaceSeparated,
	    to: null,
	    transform: null,
	    u1: null,
	    u2: null,
	    underlinePosition: number,
	    underlineThickness: number,
	    unicode: null,
	    unicodeBidi: null,
	    unicodeRange: null,
	    unitsPerEm: number,
	    values: null,
	    vAlphabetic: number,
	    vMathematical: number,
	    vectorEffect: null,
	    vHanging: number,
	    vIdeographic: number,
	    version: null,
	    vertAdvY: number,
	    vertOriginX: number,
	    vertOriginY: number,
	    viewBox: null,
	    viewTarget: null,
	    visibility: null,
	    width: null,
	    widths: null,
	    wordSpacing: null,
	    writingMode: null,
	    x: null,
	    x1: null,
	    x2: null,
	    xChannelSelector: null,
	    xHeight: number,
	    y: null,
	    y1: null,
	    y2: null,
	    yChannelSelector: null,
	    z: null,
	    zoomAndPan: null
	  }
	});
	return svg$1;
}

var svg_1$1;
var hasRequiredSvg$1;

function requireSvg$1 () {
	if (hasRequiredSvg$1) return svg_1$1;
	hasRequiredSvg$1 = 1;

	var merge = requireMerge();
	var xlink = requireXlink();
	var xml = requireXml();
	var xmlns = requireXmlns();
	var aria = requireAria();
	var svg = requireSvg$2();

	svg_1$1 = merge([xml, xlink, xmlns, aria, svg]);
	return svg_1$1;
}

var find_1;
var hasRequiredFind;

function requireFind () {
	if (hasRequiredFind) return find_1;
	hasRequiredFind = 1;

	var normalize = requireNormalize();
	var DefinedInfo = requireDefinedInfo();
	var Info = requireInfo();

	var data = 'data';

	find_1 = find;

	var valid = /^data[-\w.:]+$/i;
	var dash = /-[a-z]/g;
	var cap = /[A-Z]/g;

	function find(schema, value) {
	  var normal = normalize(value);
	  var prop = value;
	  var Type = Info;

	  if (normal in schema.normal) {
	    return schema.property[schema.normal[normal]]
	  }

	  if (normal.length > 4 && normal.slice(0, 4) === data && valid.test(value)) {
	    // Attribute or property.
	    if (value.charAt(4) === '-') {
	      prop = datasetToProperty(value);
	    } else {
	      value = datasetToAttribute(value);
	    }

	    Type = DefinedInfo;
	  }

	  return new Type(prop, value)
	}

	function datasetToProperty(attribute) {
	  var value = attribute.slice(5).replace(dash, camelcase);
	  return data + value.charAt(0).toUpperCase() + value.slice(1)
	}

	function datasetToAttribute(property) {
	  var value = property.slice(4);

	  if (dash.test(value)) {
	    return property
	  }

	  value = value.replace(cap, kebab);

	  if (value.charAt(0) !== '-') {
	    value = '-' + value;
	  }

	  return data + value
	}

	function kebab($0) {
	  return '-' + $0.toLowerCase()
	}

	function camelcase($0) {
	  return $0.charAt(1).toUpperCase()
	}
	return find_1;
}

const html$3 = "http://www.w3.org/1999/xhtml";
const mathml = "http://www.w3.org/1998/Math/MathML";
const svg = "http://www.w3.org/2000/svg";
const xlink = "http://www.w3.org/1999/xlink";
const xml = "http://www.w3.org/XML/1998/namespace";
const xmlns = "http://www.w3.org/2000/xmlns/";
var require$$5$1 = {
	html: html$3,
	mathml: mathml,
	svg: svg,
	xlink: xlink,
	xml: xml,
	xmlns: xmlns
};

var require$$1 = [
	"altGlyph",
	"altGlyphDef",
	"altGlyphItem",
	"animateColor",
	"animateMotion",
	"animateTransform",
	"clipPath",
	"feBlend",
	"feColorMatrix",
	"feComponentTransfer",
	"feComposite",
	"feConvolveMatrix",
	"feDiffuseLighting",
	"feDisplacementMap",
	"feDistantLight",
	"feDropShadow",
	"feFlood",
	"feFuncA",
	"feFuncB",
	"feFuncG",
	"feFuncR",
	"feGaussianBlur",
	"feImage",
	"feMerge",
	"feMergeNode",
	"feMorphology",
	"feOffset",
	"fePointLight",
	"feSpecularLighting",
	"feSpotLight",
	"feTile",
	"feTurbulence",
	"foreignObject",
	"glyphRef",
	"linearGradient",
	"radialGradient",
	"solidColor",
	"textArea",
	"textPath"
];

var hastUtilParseSelector;
var hasRequiredHastUtilParseSelector;

function requireHastUtilParseSelector () {
	if (hasRequiredHastUtilParseSelector) return hastUtilParseSelector;
	hasRequiredHastUtilParseSelector = 1;

	hastUtilParseSelector = parse;

	var numberSign = 35; //  '#'
	var dot = 46; //  '.'

	// Create a hast element from a simple CSS selector.
	function parse(selector, defaultTagName) {
	  var value = selector || '';
	  var name = defaultTagName || 'div';
	  var props = {};
	  var index = -1;
	  var length = value.length;
	  var className;
	  var type;
	  var code;
	  var subvalue;
	  var lastIndex;

	  while (++index <= length) {
	    code = value.charCodeAt(index);

	    if (!code || code === dot || code === numberSign) {
	      subvalue = value.slice(lastIndex, index);

	      if (subvalue) {
	        if (type === dot) {
	          // eslint-disable-next-line max-depth
	          if (className) {
	            className.push(subvalue);
	          } else {
	            className = [subvalue];
	            props.className = className;
	          }
	        } else if (type === numberSign) {
	          props.id = subvalue;
	        } else {
	          name = subvalue;
	        }
	      }

	      lastIndex = index + 1;
	      type = code;
	    }
	  }

	  return {
	    type: 'element',
	    tagName: name,
	    properties: props,
	    children: []
	  }
	}
	return hastUtilParseSelector;
}

var spaceSeparatedTokens = {};

var hasRequiredSpaceSeparatedTokens;

function requireSpaceSeparatedTokens () {
	if (hasRequiredSpaceSeparatedTokens) return spaceSeparatedTokens;
	hasRequiredSpaceSeparatedTokens = 1;

	spaceSeparatedTokens.parse = parse;
	spaceSeparatedTokens.stringify = stringify;

	var empty = '';
	var space = ' ';
	var whiteSpace = /[ \t\n\r\f]+/g;

	function parse(value) {
	  var input = String(value || empty).trim();
	  return input === empty ? [] : input.split(whiteSpace)
	}

	function stringify(values) {
	  return values.join(space).trim()
	}
	return spaceSeparatedTokens;
}

var commaSeparatedTokens = {};

var hasRequiredCommaSeparatedTokens;

function requireCommaSeparatedTokens () {
	if (hasRequiredCommaSeparatedTokens) return commaSeparatedTokens;
	hasRequiredCommaSeparatedTokens = 1;

	commaSeparatedTokens.parse = parse;
	commaSeparatedTokens.stringify = stringify;

	var comma = ',';
	var space = ' ';
	var empty = '';

	// Parse comma-separated tokens to an array.
	function parse(value) {
	  var values = [];
	  var input = String(value || empty);
	  var index = input.indexOf(comma);
	  var lastIndex = 0;
	  var end = false;
	  var val;

	  while (!end) {
	    if (index === -1) {
	      index = input.length;
	      end = true;
	    }

	    val = input.slice(lastIndex, index).trim();

	    if (val || !end) {
	      values.push(val);
	    }

	    lastIndex = index + 1;
	    index = input.indexOf(comma, lastIndex);
	  }

	  return values
	}

	// Compile an array to comma-separated tokens.
	// `options.padLeft` (default: `true`) pads a space left of each token, and
	// `options.padRight` (default: `false`) pads a space to the right of each token.
	function stringify(values, options) {
	  var settings = options || {};
	  var left = settings.padLeft === false ? empty : space;
	  var right = settings.padRight ? space : empty;

	  // Ensure the last empty entry is seen.
	  if (values[values.length - 1] === empty) {
	    values = values.concat(empty);
	  }

	  return values.join(right + comma + left).trim()
	}
	return commaSeparatedTokens;
}

var factory_1;
var hasRequiredFactory;

function requireFactory () {
	if (hasRequiredFactory) return factory_1;
	hasRequiredFactory = 1;

	var find = requireFind();
	var normalize = requireNormalize();
	var parseSelector = requireHastUtilParseSelector();
	var spaces = requireSpaceSeparatedTokens().parse;
	var commas = requireCommaSeparatedTokens().parse;

	factory_1 = factory;

	var own = {}.hasOwnProperty;

	function factory(schema, defaultTagName, caseSensitive) {
	  var adjust = caseSensitive ? createAdjustMap(caseSensitive) : null;

	  return h

	  // Hyperscript compatible DSL for creating virtual hast trees.
	  function h(selector, properties) {
	    var node = parseSelector(selector, defaultTagName);
	    var children = Array.prototype.slice.call(arguments, 2);
	    var name = node.tagName.toLowerCase();
	    var property;

	    node.tagName = adjust && own.call(adjust, name) ? adjust[name] : name;

	    if (properties && isChildren(properties, node)) {
	      children.unshift(properties);
	      properties = null;
	    }

	    if (properties) {
	      for (property in properties) {
	        addProperty(node.properties, property, properties[property]);
	      }
	    }

	    addChild(node.children, children);

	    if (node.tagName === 'template') {
	      node.content = {type: 'root', children: node.children};
	      node.children = [];
	    }

	    return node
	  }

	  function addProperty(properties, key, value) {
	    var info;
	    var property;
	    var result;

	    // Ignore nully and NaN values.
	    if (value === null || value === undefined || value !== value) {
	      return
	    }

	    info = find(schema, key);
	    property = info.property;
	    result = value;

	    // Handle list values.
	    if (typeof result === 'string') {
	      if (info.spaceSeparated) {
	        result = spaces(result);
	      } else if (info.commaSeparated) {
	        result = commas(result);
	      } else if (info.commaOrSpaceSeparated) {
	        result = spaces(commas(result).join(' '));
	      }
	    }

	    // Accept `object` on style.
	    if (property === 'style' && typeof value !== 'string') {
	      result = style(result);
	    }

	    // Class-names (which can be added both on the `selector` and here).
	    if (property === 'className' && properties.className) {
	      result = properties.className.concat(result);
	    }

	    properties[property] = parsePrimitives(info, property, result);
	  }
	}

	function isChildren(value, node) {
	  return (
	    typeof value === 'string' ||
	    'length' in value ||
	    isNode(node.tagName, value)
	  )
	}

	function isNode(tagName, value) {
	  var type = value.type;

	  if (tagName === 'input' || !type || typeof type !== 'string') {
	    return false
	  }

	  if (typeof value.children === 'object' && 'length' in value.children) {
	    return true
	  }

	  type = type.toLowerCase();

	  if (tagName === 'button') {
	    return (
	      type !== 'menu' &&
	      type !== 'submit' &&
	      type !== 'reset' &&
	      type !== 'button'
	    )
	  }

	  return 'value' in value
	}

	function addChild(nodes, value) {
	  var index;
	  var length;

	  if (typeof value === 'string' || typeof value === 'number') {
	    nodes.push({type: 'text', value: String(value)});
	    return
	  }

	  if (typeof value === 'object' && 'length' in value) {
	    index = -1;
	    length = value.length;

	    while (++index < length) {
	      addChild(nodes, value[index]);
	    }

	    return
	  }

	  if (typeof value !== 'object' || !('type' in value)) {
	    throw new Error('Expected node, nodes, or string, got `' + value + '`')
	  }

	  nodes.push(value);
	}

	// Parse a (list of) primitives.
	function parsePrimitives(info, name, value) {
	  var index;
	  var length;
	  var result;

	  if (typeof value !== 'object' || !('length' in value)) {
	    return parsePrimitive(info, name, value)
	  }

	  length = value.length;
	  index = -1;
	  result = [];

	  while (++index < length) {
	    result[index] = parsePrimitive(info, name, value[index]);
	  }

	  return result
	}

	// Parse a single primitives.
	function parsePrimitive(info, name, value) {
	  var result = value;

	  if (info.number || info.positiveNumber) {
	    if (!isNaN(result) && result !== '') {
	      result = Number(result);
	    }
	  } else if (info.boolean || info.overloadedBoolean) {
	    // Accept `boolean` and `string`.
	    if (
	      typeof result === 'string' &&
	      (result === '' || normalize(value) === normalize(name))
	    ) {
	      result = true;
	    }
	  }

	  return result
	}

	function style(value) {
	  var result = [];
	  var key;

	  for (key in value) {
	    result.push([key, value[key]].join(': '));
	  }

	  return result.join('; ')
	}

	function createAdjustMap(values) {
	  var length = values.length;
	  var index = -1;
	  var result = {};
	  var value;

	  while (++index < length) {
	    value = values[index];
	    result[value.toLowerCase()] = value;
	  }

	  return result
	}
	return factory_1;
}

var svg_1;
var hasRequiredSvg;

function requireSvg () {
	if (hasRequiredSvg) return svg_1;
	hasRequiredSvg = 1;

	var schema = requireSvg$1();
	var caseSensitive = require$$1;
	var factory = requireFactory();

	var svg = factory(schema, 'g', caseSensitive);
	svg.displayName = 'svg';

	svg_1 = svg;
	return svg_1;
}

var html_1$1;
var hasRequiredHtml$3;

function requireHtml$3 () {
	if (hasRequiredHtml$3) return html_1$1;
	hasRequiredHtml$3 = 1;

	var schema = requireHtml$4();
	var factory = requireFactory();

	var html = factory(schema, 'div');
	html.displayName = 'html';

	html_1$1 = html;
	return html_1$1;
}

var hastscript;
var hasRequiredHastscript;

function requireHastscript () {
	if (hasRequiredHastscript) return hastscript;
	hasRequiredHastscript = 1;

	hastscript = requireHtml$3();
	return hastscript;
}

var hastUtilFromParse5;
var hasRequiredHastUtilFromParse5;

function requireHastUtilFromParse5 () {
	if (hasRequiredHastUtilFromParse5) return hastUtilFromParse5;
	hasRequiredHastUtilFromParse5 = 1;

	var html = requireHtml$4();
	var svg = requireSvg$1();
	var find = requireFind();
	var ns = require$$5$1;
	var s = requireSvg();
	var h = requireHastscript();
	var xtend = requireImmutable();
	var count = requireCcount();

	hastUtilFromParse5 = wrapper;

	var own = {}.hasOwnProperty;

	// Handlers.
	var map = {
	  '#document': root,
	  '#document-fragment': root,
	  '#text': text,
	  '#comment': comment,
	  '#documentType': doctype
	};

	// Wrapper to normalise options.
	function wrapper(ast, options) {
	  var settings = options || {};
	  var file;

	  if (settings.messages) {
	    file = settings;
	    settings = {};
	  } else {
	    file = settings.file;
	  }

	  return transform(ast, {
	    schema: settings.space === 'svg' ? svg : html,
	    file: file,
	    verbose: settings.verbose,
	    location: false
	  })
	}

	// Transform a node.
	function transform(ast, config) {
	  var schema = config.schema;
	  var fn = own.call(map, ast.nodeName) ? map[ast.nodeName] : element;
	  var children;
	  var node;
	  var pos;

	  if (fn === element) {
	    config.schema = ast.namespaceURI === ns.svg ? svg : html;
	  }

	  if (ast.childNodes) {
	    children = nodes(ast.childNodes, config);
	  }

	  node = fn(ast, children, config);

	  if (ast.sourceCodeLocation && config.file) {
	    pos = location(node, ast.sourceCodeLocation, config);

	    if (pos) {
	      config.location = true;
	      node.position = pos;
	    }
	  }

	  config.schema = schema;

	  return node
	}

	// Transform children.
	function nodes(children, config) {
	  var length = children.length;
	  var index = -1;
	  var result = [];

	  while (++index < length) {
	    result[index] = transform(children[index], config);
	  }

	  return result
	}

	// Transform a document.
	// Stores `ast.quirksMode` in `node.data.quirksMode`.
	function root(ast, children, config) {
	  var node = {type: 'root', children: children, data: {}};
	  var doc;

	  node.data.quirksMode = ast.mode === 'quirks' || ast.mode === 'limited-quirks';

	  if (config.file && config.location) {
	    doc = String(config.file);

	    node.position = {
	      start: {line: 1, column: 1, offset: 0},
	      end: {
	        line: count(doc, '\n') + 1,
	        column: doc.length - doc.lastIndexOf('\n'),
	        offset: doc.length
	      }
	    };
	  }

	  return node
	}

	// Transform a doctype.
	function doctype(ast) {
	  return {
	    type: 'doctype',
	    name: ast.name || '',
	    public: ast.publicId || null,
	    system: ast.systemId || null
	  }
	}

	// Transform a text.
	function text(ast) {
	  return {type: 'text', value: ast.value}
	}

	// Transform a comment.
	function comment(ast) {
	  return {type: 'comment', value: ast.data}
	}

	// Transform an element.
	function element(ast, children, config) {
	  var fn = config.schema.space === 'svg' ? s : h;
	  var name = ast.tagName;
	  var attributes = ast.attrs;
	  var length = attributes.length;
	  var props = {};
	  var index = -1;
	  var attribute;
	  var prop;
	  var node;
	  var pos;
	  var start;
	  var end;

	  while (++index < length) {
	    attribute = attributes[index];
	    prop = (attribute.prefix ? attribute.prefix + ':' : '') + attribute.name;
	    props[prop] = attribute.value;
	  }

	  node = fn(name, props, children);

	  if (name === 'template' && 'content' in ast) {
	    pos = ast.sourceCodeLocation;
	    start = pos && pos.startTag && position(pos.startTag).end;
	    end = pos && pos.endTag && position(pos.endTag).start;

	    node.content = transform(ast.content, config);

	    if ((start || end) && config.file) {
	      node.content.position = {start: start, end: end};
	    }
	  }

	  return node
	}

	// Create clean positional information.
	function location(node, location, config) {
	  var schema = config.schema;
	  var verbose = config.verbose;
	  var pos = position(location);
	  var reference;
	  var attributes;
	  var attribute;
	  var props;
	  var prop;

	  if (node.type === 'element') {
	    reference = node.children[node.children.length - 1];

	    // Bug for unclosed with children.
	    // See: <https://github.com/inikulin/parse5/issues/109>.
	    if (
	      !location.endTag &&
	      reference &&
	      reference.position &&
	      reference.position.end
	    ) {
	      pos.end = xtend(reference.position.end);
	    }

	    if (verbose) {
	      attributes = location.attrs;
	      props = {};

	      for (attribute in attributes) {
	        prop = find(schema, attribute).property;
	        props[prop] = position(attributes[attribute]);
	      }

	      node.data = {
	        position: {
	          opening: position(location.startTag),
	          closing: location.endTag ? position(location.endTag) : null,
	          properties: props
	        }
	      };
	    }
	  }

	  return pos
	}

	function position(loc) {
	  var start = point({
	    line: loc.startLine,
	    column: loc.startCol,
	    offset: loc.startOffset
	  });
	  var end = point({
	    line: loc.endLine,
	    column: loc.endCol,
	    offset: loc.endOffset
	  });
	  return start || end ? {start: start, end: end} : null
	}

	function point(point) {
	  return point.line && point.column ? point : null
	}
	return hastUtilFromParse5;
}

var unicode$1 = {};

var hasRequiredUnicode$1;

function requireUnicode$1 () {
	if (hasRequiredUnicode$1) return unicode$1;
	hasRequiredUnicode$1 = 1;

	const UNDEFINED_CODE_POINTS = [
	    0xfffe,
	    0xffff,
	    0x1fffe,
	    0x1ffff,
	    0x2fffe,
	    0x2ffff,
	    0x3fffe,
	    0x3ffff,
	    0x4fffe,
	    0x4ffff,
	    0x5fffe,
	    0x5ffff,
	    0x6fffe,
	    0x6ffff,
	    0x7fffe,
	    0x7ffff,
	    0x8fffe,
	    0x8ffff,
	    0x9fffe,
	    0x9ffff,
	    0xafffe,
	    0xaffff,
	    0xbfffe,
	    0xbffff,
	    0xcfffe,
	    0xcffff,
	    0xdfffe,
	    0xdffff,
	    0xefffe,
	    0xeffff,
	    0xffffe,
	    0xfffff,
	    0x10fffe,
	    0x10ffff
	];

	unicode$1.REPLACEMENT_CHARACTER = '\uFFFD';

	unicode$1.CODE_POINTS = {
	    EOF: -1,
	    NULL: 0x00,
	    TABULATION: 0x09,
	    CARRIAGE_RETURN: 0x0d,
	    LINE_FEED: 0x0a,
	    FORM_FEED: 0x0c,
	    SPACE: 0x20,
	    EXCLAMATION_MARK: 0x21,
	    QUOTATION_MARK: 0x22,
	    NUMBER_SIGN: 0x23,
	    AMPERSAND: 0x26,
	    APOSTROPHE: 0x27,
	    HYPHEN_MINUS: 0x2d,
	    SOLIDUS: 0x2f,
	    DIGIT_0: 0x30,
	    DIGIT_9: 0x39,
	    SEMICOLON: 0x3b,
	    LESS_THAN_SIGN: 0x3c,
	    EQUALS_SIGN: 0x3d,
	    GREATER_THAN_SIGN: 0x3e,
	    QUESTION_MARK: 0x3f,
	    LATIN_CAPITAL_A: 0x41,
	    LATIN_CAPITAL_F: 0x46,
	    LATIN_CAPITAL_X: 0x58,
	    LATIN_CAPITAL_Z: 0x5a,
	    RIGHT_SQUARE_BRACKET: 0x5d,
	    GRAVE_ACCENT: 0x60,
	    LATIN_SMALL_A: 0x61,
	    LATIN_SMALL_F: 0x66,
	    LATIN_SMALL_X: 0x78,
	    LATIN_SMALL_Z: 0x7a,
	    REPLACEMENT_CHARACTER: 0xfffd
	};

	unicode$1.CODE_POINT_SEQUENCES = {
	    DASH_DASH_STRING: [0x2d, 0x2d], //--
	    DOCTYPE_STRING: [0x44, 0x4f, 0x43, 0x54, 0x59, 0x50, 0x45], //DOCTYPE
	    CDATA_START_STRING: [0x5b, 0x43, 0x44, 0x41, 0x54, 0x41, 0x5b], //[CDATA[
	    SCRIPT_STRING: [0x73, 0x63, 0x72, 0x69, 0x70, 0x74], //script
	    PUBLIC_STRING: [0x50, 0x55, 0x42, 0x4c, 0x49, 0x43], //PUBLIC
	    SYSTEM_STRING: [0x53, 0x59, 0x53, 0x54, 0x45, 0x4d] //SYSTEM
	};

	//Surrogates
	unicode$1.isSurrogate = function(cp) {
	    return cp >= 0xd800 && cp <= 0xdfff;
	};

	unicode$1.isSurrogatePair = function(cp) {
	    return cp >= 0xdc00 && cp <= 0xdfff;
	};

	unicode$1.getSurrogatePairCodePoint = function(cp1, cp2) {
	    return (cp1 - 0xd800) * 0x400 + 0x2400 + cp2;
	};

	//NOTE: excluding NULL and ASCII whitespace
	unicode$1.isControlCodePoint = function(cp) {
	    return (
	        (cp !== 0x20 && cp !== 0x0a && cp !== 0x0d && cp !== 0x09 && cp !== 0x0c && cp >= 0x01 && cp <= 0x1f) ||
	        (cp >= 0x7f && cp <= 0x9f)
	    );
	};

	unicode$1.isUndefinedCodePoint = function(cp) {
	    return (cp >= 0xfdd0 && cp <= 0xfdef) || UNDEFINED_CODE_POINTS.indexOf(cp) > -1;
	};
	return unicode$1;
}

var errorCodes$1;
var hasRequiredErrorCodes$1;

function requireErrorCodes$1 () {
	if (hasRequiredErrorCodes$1) return errorCodes$1;
	hasRequiredErrorCodes$1 = 1;

	errorCodes$1 = {
	    controlCharacterInInputStream: 'control-character-in-input-stream',
	    noncharacterInInputStream: 'noncharacter-in-input-stream',
	    surrogateInInputStream: 'surrogate-in-input-stream',
	    nonVoidHtmlElementStartTagWithTrailingSolidus: 'non-void-html-element-start-tag-with-trailing-solidus',
	    endTagWithAttributes: 'end-tag-with-attributes',
	    endTagWithTrailingSolidus: 'end-tag-with-trailing-solidus',
	    unexpectedSolidusInTag: 'unexpected-solidus-in-tag',
	    unexpectedNullCharacter: 'unexpected-null-character',
	    unexpectedQuestionMarkInsteadOfTagName: 'unexpected-question-mark-instead-of-tag-name',
	    invalidFirstCharacterOfTagName: 'invalid-first-character-of-tag-name',
	    unexpectedEqualsSignBeforeAttributeName: 'unexpected-equals-sign-before-attribute-name',
	    missingEndTagName: 'missing-end-tag-name',
	    unexpectedCharacterInAttributeName: 'unexpected-character-in-attribute-name',
	    unknownNamedCharacterReference: 'unknown-named-character-reference',
	    missingSemicolonAfterCharacterReference: 'missing-semicolon-after-character-reference',
	    unexpectedCharacterAfterDoctypeSystemIdentifier: 'unexpected-character-after-doctype-system-identifier',
	    unexpectedCharacterInUnquotedAttributeValue: 'unexpected-character-in-unquoted-attribute-value',
	    eofBeforeTagName: 'eof-before-tag-name',
	    eofInTag: 'eof-in-tag',
	    missingAttributeValue: 'missing-attribute-value',
	    missingWhitespaceBetweenAttributes: 'missing-whitespace-between-attributes',
	    missingWhitespaceAfterDoctypePublicKeyword: 'missing-whitespace-after-doctype-public-keyword',
	    missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers:
	        'missing-whitespace-between-doctype-public-and-system-identifiers',
	    missingWhitespaceAfterDoctypeSystemKeyword: 'missing-whitespace-after-doctype-system-keyword',
	    missingQuoteBeforeDoctypePublicIdentifier: 'missing-quote-before-doctype-public-identifier',
	    missingQuoteBeforeDoctypeSystemIdentifier: 'missing-quote-before-doctype-system-identifier',
	    missingDoctypePublicIdentifier: 'missing-doctype-public-identifier',
	    missingDoctypeSystemIdentifier: 'missing-doctype-system-identifier',
	    abruptDoctypePublicIdentifier: 'abrupt-doctype-public-identifier',
	    abruptDoctypeSystemIdentifier: 'abrupt-doctype-system-identifier',
	    cdataInHtmlContent: 'cdata-in-html-content',
	    incorrectlyOpenedComment: 'incorrectly-opened-comment',
	    eofInScriptHtmlCommentLikeText: 'eof-in-script-html-comment-like-text',
	    eofInDoctype: 'eof-in-doctype',
	    nestedComment: 'nested-comment',
	    abruptClosingOfEmptyComment: 'abrupt-closing-of-empty-comment',
	    eofInComment: 'eof-in-comment',
	    incorrectlyClosedComment: 'incorrectly-closed-comment',
	    eofInCdata: 'eof-in-cdata',
	    absenceOfDigitsInNumericCharacterReference: 'absence-of-digits-in-numeric-character-reference',
	    nullCharacterReference: 'null-character-reference',
	    surrogateCharacterReference: 'surrogate-character-reference',
	    characterReferenceOutsideUnicodeRange: 'character-reference-outside-unicode-range',
	    controlCharacterReference: 'control-character-reference',
	    noncharacterCharacterReference: 'noncharacter-character-reference',
	    missingWhitespaceBeforeDoctypeName: 'missing-whitespace-before-doctype-name',
	    missingDoctypeName: 'missing-doctype-name',
	    invalidCharacterSequenceAfterDoctypeName: 'invalid-character-sequence-after-doctype-name',
	    duplicateAttribute: 'duplicate-attribute',
	    nonConformingDoctype: 'non-conforming-doctype',
	    missingDoctype: 'missing-doctype',
	    misplacedDoctype: 'misplaced-doctype',
	    endTagWithoutMatchingOpenElement: 'end-tag-without-matching-open-element',
	    closingOfElementWithOpenChildElements: 'closing-of-element-with-open-child-elements',
	    disallowedContentInNoscriptInHead: 'disallowed-content-in-noscript-in-head',
	    openElementsLeftAfterEof: 'open-elements-left-after-eof',
	    abandonedHeadElementChild: 'abandoned-head-element-child',
	    misplacedStartTagForHeadElement: 'misplaced-start-tag-for-head-element',
	    nestedNoscriptInHead: 'nested-noscript-in-head',
	    eofInElementThatCanContainOnlyText: 'eof-in-element-that-can-contain-only-text'
	};
	return errorCodes$1;
}

var preprocessor$1;
var hasRequiredPreprocessor$1;

function requirePreprocessor$1 () {
	if (hasRequiredPreprocessor$1) return preprocessor$1;
	hasRequiredPreprocessor$1 = 1;

	const unicode = requireUnicode$1();
	const ERR = requireErrorCodes$1();

	//Aliases
	const $ = unicode.CODE_POINTS;

	//Const
	const DEFAULT_BUFFER_WATERLINE = 1 << 16;

	//Preprocessor
	//NOTE: HTML input preprocessing
	//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)
	class Preprocessor {
	    constructor() {
	        this.html = null;

	        this.pos = -1;
	        this.lastGapPos = -1;
	        this.lastCharPos = -1;

	        this.gapStack = [];

	        this.skipNextNewLine = false;

	        this.lastChunkWritten = false;
	        this.endOfChunkHit = false;
	        this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
	    }

	    _err() {
	        // NOTE: err reporting is noop by default. Enabled by mixin.
	    }

	    _addGap() {
	        this.gapStack.push(this.lastGapPos);
	        this.lastGapPos = this.pos;
	    }

	    _processSurrogate(cp) {
	        //NOTE: try to peek a surrogate pair
	        if (this.pos !== this.lastCharPos) {
	            const nextCp = this.html.charCodeAt(this.pos + 1);

	            if (unicode.isSurrogatePair(nextCp)) {
	                //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.
	                this.pos++;

	                //NOTE: add gap that should be avoided during retreat
	                this._addGap();

	                return unicode.getSurrogatePairCodePoint(cp, nextCp);
	            }
	        }

	        //NOTE: we are at the end of a chunk, therefore we can't infer surrogate pair yet.
	        else if (!this.lastChunkWritten) {
	            this.endOfChunkHit = true;
	            return $.EOF;
	        }

	        //NOTE: isolated surrogate
	        this._err(ERR.surrogateInInputStream);

	        return cp;
	    }

	    dropParsedChunk() {
	        if (this.pos > this.bufferWaterline) {
	            this.lastCharPos -= this.pos;
	            this.html = this.html.substring(this.pos);
	            this.pos = 0;
	            this.lastGapPos = -1;
	            this.gapStack = [];
	        }
	    }

	    write(chunk, isLastChunk) {
	        if (this.html) {
	            this.html += chunk;
	        } else {
	            this.html = chunk;
	        }

	        this.lastCharPos = this.html.length - 1;
	        this.endOfChunkHit = false;
	        this.lastChunkWritten = isLastChunk;
	    }

	    insertHtmlAtCurrentPos(chunk) {
	        this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1, this.html.length);

	        this.lastCharPos = this.html.length - 1;
	        this.endOfChunkHit = false;
	    }

	    advance() {
	        this.pos++;

	        if (this.pos > this.lastCharPos) {
	            this.endOfChunkHit = !this.lastChunkWritten;
	            return $.EOF;
	        }

	        let cp = this.html.charCodeAt(this.pos);

	        //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character
	        //must be ignored.
	        if (this.skipNextNewLine && cp === $.LINE_FEED) {
	            this.skipNextNewLine = false;
	            this._addGap();
	            return this.advance();
	        }

	        //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters
	        if (cp === $.CARRIAGE_RETURN) {
	            this.skipNextNewLine = true;
	            return $.LINE_FEED;
	        }

	        this.skipNextNewLine = false;

	        if (unicode.isSurrogate(cp)) {
	            cp = this._processSurrogate(cp);
	        }

	        //OPTIMIZATION: first check if code point is in the common allowed
	        //range (ASCII alphanumeric, whitespaces, big chunk of BMP)
	        //before going into detailed performance cost validation.
	        const isCommonValidRange =
	            (cp > 0x1f && cp < 0x7f) || cp === $.LINE_FEED || cp === $.CARRIAGE_RETURN || (cp > 0x9f && cp < 0xfdd0);

	        if (!isCommonValidRange) {
	            this._checkForProblematicCharacters(cp);
	        }

	        return cp;
	    }

	    _checkForProblematicCharacters(cp) {
	        if (unicode.isControlCodePoint(cp)) {
	            this._err(ERR.controlCharacterInInputStream);
	        } else if (unicode.isUndefinedCodePoint(cp)) {
	            this._err(ERR.noncharacterInInputStream);
	        }
	    }

	    retreat() {
	        if (this.pos === this.lastGapPos) {
	            this.lastGapPos = this.gapStack.pop();
	            this.pos--;
	        }

	        this.pos--;
	    }
	}

	preprocessor$1 = Preprocessor;
	return preprocessor$1;
}

var namedEntityData$1;
var hasRequiredNamedEntityData$1;

function requireNamedEntityData$1 () {
	if (hasRequiredNamedEntityData$1) return namedEntityData$1;
	hasRequiredNamedEntityData$1 = 1;

	//NOTE: this file contains auto-generated array mapped radix tree that is used for the named entity references consumption
	//(details: https://github.com/inikulin/parse5/tree/master/scripts/generate-named-entity-data/README.md)
	namedEntityData$1 = new Uint16Array([4,52,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,106,303,412,810,1432,1701,1796,1987,2114,2360,2420,2484,3170,3251,4140,4393,4575,4610,5106,5512,5728,6117,6274,6315,6345,6427,6516,7002,7910,8733,9323,9870,10170,10631,10893,11318,11386,11467,12773,13092,14474,14922,15448,15542,16419,17666,18166,18611,19004,19095,19298,19397,4,16,69,77,97,98,99,102,103,108,109,110,111,112,114,115,116,117,140,150,158,169,176,194,199,210,216,222,226,242,256,266,283,294,108,105,103,5,198,1,59,148,1,198,80,5,38,1,59,156,1,38,99,117,116,101,5,193,1,59,167,1,193,114,101,118,101,59,1,258,4,2,105,121,182,191,114,99,5,194,1,59,189,1,194,59,1,1040,114,59,3,55349,56580,114,97,118,101,5,192,1,59,208,1,192,112,104,97,59,1,913,97,99,114,59,1,256,100,59,1,10835,4,2,103,112,232,237,111,110,59,1,260,102,59,3,55349,56632,112,108,121,70,117,110,99,116,105,111,110,59,1,8289,105,110,103,5,197,1,59,264,1,197,4,2,99,115,272,277,114,59,3,55349,56476,105,103,110,59,1,8788,105,108,100,101,5,195,1,59,292,1,195,109,108,5,196,1,59,301,1,196,4,8,97,99,101,102,111,114,115,117,321,350,354,383,388,394,400,405,4,2,99,114,327,336,107,115,108,97,115,104,59,1,8726,4,2,118,119,342,345,59,1,10983,101,100,59,1,8966,121,59,1,1041,4,3,99,114,116,362,369,379,97,117,115,101,59,1,8757,110,111,117,108,108,105,115,59,1,8492,97,59,1,914,114,59,3,55349,56581,112,102,59,3,55349,56633,101,118,101,59,1,728,99,114,59,1,8492,109,112,101,113,59,1,8782,4,14,72,79,97,99,100,101,102,104,105,108,111,114,115,117,442,447,456,504,542,547,569,573,577,616,678,784,790,796,99,121,59,1,1063,80,89,5,169,1,59,454,1,169,4,3,99,112,121,464,470,497,117,116,101,59,1,262,4,2,59,105,476,478,1,8914,116,97,108,68,105,102,102,101,114,101,110,116,105,97,108,68,59,1,8517,108,101,121,115,59,1,8493,4,4,97,101,105,111,514,520,530,535,114,111,110,59,1,268,100,105,108,5,199,1,59,528,1,199,114,99,59,1,264,110,105,110,116,59,1,8752,111,116,59,1,266,4,2,100,110,553,560,105,108,108,97,59,1,184,116,101,114,68,111,116,59,1,183,114,59,1,8493,105,59,1,935,114,99,108,101,4,4,68,77,80,84,591,596,603,609,111,116,59,1,8857,105,110,117,115,59,1,8854,108,117,115,59,1,8853,105,109,101,115,59,1,8855,111,4,2,99,115,623,646,107,119,105,115,101,67,111,110,116,111,117,114,73,110,116,101,103,114,97,108,59,1,8754,101,67,117,114,108,121,4,2,68,81,658,671,111,117,98,108,101,81,117,111,116,101,59,1,8221,117,111,116,101,59,1,8217,4,4,108,110,112,117,688,701,736,753,111,110,4,2,59,101,696,698,1,8759,59,1,10868,4,3,103,105,116,709,717,722,114,117,101,110,116,59,1,8801,110,116,59,1,8751,111,117,114,73,110,116,101,103,114,97,108,59,1,8750,4,2,102,114,742,745,59,1,8450,111,100,117,99,116,59,1,8720,110,116,101,114,67,108,111,99,107,119,105,115,101,67,111,110,116,111,117,114,73,110,116,101,103,114,97,108,59,1,8755,111,115,115,59,1,10799,99,114,59,3,55349,56478,112,4,2,59,67,803,805,1,8915,97,112,59,1,8781,4,11,68,74,83,90,97,99,101,102,105,111,115,834,850,855,860,865,888,903,916,921,1011,1415,4,2,59,111,840,842,1,8517,116,114,97,104,100,59,1,10513,99,121,59,1,1026,99,121,59,1,1029,99,121,59,1,1039,4,3,103,114,115,873,879,883,103,101,114,59,1,8225,114,59,1,8609,104,118,59,1,10980,4,2,97,121,894,900,114,111,110,59,1,270,59,1,1044,108,4,2,59,116,910,912,1,8711,97,59,1,916,114,59,3,55349,56583,4,2,97,102,927,998,4,2,99,109,933,992,114,105,116,105,99,97,108,4,4,65,68,71,84,950,957,978,985,99,117,116,101,59,1,180,111,4,2,116,117,964,967,59,1,729,98,108,101,65,99,117,116,101,59,1,733,114,97,118,101,59,1,96,105,108,100,101,59,1,732,111,110,100,59,1,8900,102,101,114,101,110,116,105,97,108,68,59,1,8518,4,4,112,116,117,119,1021,1026,1048,1249,102,59,3,55349,56635,4,3,59,68,69,1034,1036,1041,1,168,111,116,59,1,8412,113,117,97,108,59,1,8784,98,108,101,4,6,67,68,76,82,85,86,1065,1082,1101,1189,1211,1236,111,110,116,111,117,114,73,110,116,101,103,114,97,108,59,1,8751,111,4,2,116,119,1089,1092,59,1,168,110,65,114,114,111,119,59,1,8659,4,2,101,111,1107,1141,102,116,4,3,65,82,84,1117,1124,1136,114,114,111,119,59,1,8656,105,103,104,116,65,114,114,111,119,59,1,8660,101,101,59,1,10980,110,103,4,2,76,82,1149,1177,101,102,116,4,2,65,82,1158,1165,114,114,111,119,59,1,10232,105,103,104,116,65,114,114,111,119,59,1,10234,105,103,104,116,65,114,114,111,119,59,1,10233,105,103,104,116,4,2,65,84,1199,1206,114,114,111,119,59,1,8658,101,101,59,1,8872,112,4,2,65,68,1218,1225,114,114,111,119,59,1,8657,111,119,110,65,114,114,111,119,59,1,8661,101,114,116,105,99,97,108,66,97,114,59,1,8741,110,4,6,65,66,76,82,84,97,1264,1292,1299,1352,1391,1408,114,114,111,119,4,3,59,66,85,1276,1278,1283,1,8595,97,114,59,1,10515,112,65,114,114,111,119,59,1,8693,114,101,118,101,59,1,785,101,102,116,4,3,82,84,86,1310,1323,1334,105,103,104,116,86,101,99,116,111,114,59,1,10576,101,101,86,101,99,116,111,114,59,1,10590,101,99,116,111,114,4,2,59,66,1345,1347,1,8637,97,114,59,1,10582,105,103,104,116,4,2,84,86,1362,1373,101,101,86,101,99,116,111,114,59,1,10591,101,99,116,111,114,4,2,59,66,1384,1386,1,8641,97,114,59,1,10583,101,101,4,2,59,65,1399,1401,1,8868,114,114,111,119,59,1,8615,114,114,111,119,59,1,8659,4,2,99,116,1421,1426,114,59,3,55349,56479,114,111,107,59,1,272,4,16,78,84,97,99,100,102,103,108,109,111,112,113,115,116,117,120,1466,1470,1478,1489,1515,1520,1525,1536,1544,1593,1609,1617,1650,1664,1668,1677,71,59,1,330,72,5,208,1,59,1476,1,208,99,117,116,101,5,201,1,59,1487,1,201,4,3,97,105,121,1497,1503,1512,114,111,110,59,1,282,114,99,5,202,1,59,1510,1,202,59,1,1069,111,116,59,1,278,114,59,3,55349,56584,114,97,118,101,5,200,1,59,1534,1,200,101,109,101,110,116,59,1,8712,4,2,97,112,1550,1555,99,114,59,1,274,116,121,4,2,83,86,1563,1576,109,97,108,108,83,113,117,97,114,101,59,1,9723,101,114,121,83,109,97,108,108,83,113,117,97,114,101,59,1,9643,4,2,103,112,1599,1604,111,110,59,1,280,102,59,3,55349,56636,115,105,108,111,110,59,1,917,117,4,2,97,105,1624,1640,108,4,2,59,84,1631,1633,1,10869,105,108,100,101,59,1,8770,108,105,98,114,105,117,109,59,1,8652,4,2,99,105,1656,1660,114,59,1,8496,109,59,1,10867,97,59,1,919,109,108,5,203,1,59,1675,1,203,4,2,105,112,1683,1689,115,116,115,59,1,8707,111,110,101,110,116,105,97,108,69,59,1,8519,4,5,99,102,105,111,115,1713,1717,1722,1762,1791,121,59,1,1060,114,59,3,55349,56585,108,108,101,100,4,2,83,86,1732,1745,109,97,108,108,83,113,117,97,114,101,59,1,9724,101,114,121,83,109,97,108,108,83,113,117,97,114,101,59,1,9642,4,3,112,114,117,1770,1775,1781,102,59,3,55349,56637,65,108,108,59,1,8704,114,105,101,114,116,114,102,59,1,8497,99,114,59,1,8497,4,12,74,84,97,98,99,100,102,103,111,114,115,116,1822,1827,1834,1848,1855,1877,1882,1887,1890,1896,1978,1984,99,121,59,1,1027,5,62,1,59,1832,1,62,109,109,97,4,2,59,100,1843,1845,1,915,59,1,988,114,101,118,101,59,1,286,4,3,101,105,121,1863,1869,1874,100,105,108,59,1,290,114,99,59,1,284,59,1,1043,111,116,59,1,288,114,59,3,55349,56586,59,1,8921,112,102,59,3,55349,56638,101,97,116,101,114,4,6,69,70,71,76,83,84,1915,1933,1944,1953,1959,1971,113,117,97,108,4,2,59,76,1925,1927,1,8805,101,115,115,59,1,8923,117,108,108,69,113,117,97,108,59,1,8807,114,101,97,116,101,114,59,1,10914,101,115,115,59,1,8823,108,97,110,116,69,113,117,97,108,59,1,10878,105,108,100,101,59,1,8819,99,114,59,3,55349,56482,59,1,8811,4,8,65,97,99,102,105,111,115,117,2005,2012,2026,2032,2036,2049,2073,2089,82,68,99,121,59,1,1066,4,2,99,116,2018,2023,101,107,59,1,711,59,1,94,105,114,99,59,1,292,114,59,1,8460,108,98,101,114,116,83,112,97,99,101,59,1,8459,4,2,112,114,2055,2059,102,59,1,8461,105,122,111,110,116,97,108,76,105,110,101,59,1,9472,4,2,99,116,2079,2083,114,59,1,8459,114,111,107,59,1,294,109,112,4,2,68,69,2097,2107,111,119,110,72,117,109,112,59,1,8782,113,117,97,108,59,1,8783,4,14,69,74,79,97,99,100,102,103,109,110,111,115,116,117,2144,2149,2155,2160,2171,2189,2194,2198,2209,2245,2307,2329,2334,2341,99,121,59,1,1045,108,105,103,59,1,306,99,121,59,1,1025,99,117,116,101,5,205,1,59,2169,1,205,4,2,105,121,2177,2186,114,99,5,206,1,59,2184,1,206,59,1,1048,111,116,59,1,304,114,59,1,8465,114,97,118,101,5,204,1,59,2207,1,204,4,3,59,97,112,2217,2219,2238,1,8465,4,2,99,103,2225,2229,114,59,1,298,105,110,97,114,121,73,59,1,8520,108,105,101,115,59,1,8658,4,2,116,118,2251,2281,4,2,59,101,2257,2259,1,8748,4,2,103,114,2265,2271,114,97,108,59,1,8747,115,101,99,116,105,111,110,59,1,8898,105,115,105,98,108,101,4,2,67,84,2293,2300,111,109,109,97,59,1,8291,105,109,101,115,59,1,8290,4,3,103,112,116,2315,2320,2325,111,110,59,1,302,102,59,3,55349,56640,97,59,1,921,99,114,59,1,8464,105,108,100,101,59,1,296,4,2,107,109,2347,2352,99,121,59,1,1030,108,5,207,1,59,2358,1,207,4,5,99,102,111,115,117,2372,2386,2391,2397,2414,4,2,105,121,2378,2383,114,99,59,1,308,59,1,1049,114,59,3,55349,56589,112,102,59,3,55349,56641,4,2,99,101,2403,2408,114,59,3,55349,56485,114,99,121,59,1,1032,107,99,121,59,1,1028,4,7,72,74,97,99,102,111,115,2436,2441,2446,2452,2467,2472,2478,99,121,59,1,1061,99,121,59,1,1036,112,112,97,59,1,922,4,2,101,121,2458,2464,100,105,108,59,1,310,59,1,1050,114,59,3,55349,56590,112,102,59,3,55349,56642,99,114,59,3,55349,56486,4,11,74,84,97,99,101,102,108,109,111,115,116,2508,2513,2520,2562,2585,2981,2986,3004,3011,3146,3167,99,121,59,1,1033,5,60,1,59,2518,1,60,4,5,99,109,110,112,114,2532,2538,2544,2548,2558,117,116,101,59,1,313,98,100,97,59,1,923,103,59,1,10218,108,97,99,101,116,114,102,59,1,8466,114,59,1,8606,4,3,97,101,121,2570,2576,2582,114,111,110,59,1,317,100,105,108,59,1,315,59,1,1051,4,2,102,115,2591,2907,116,4,10,65,67,68,70,82,84,85,86,97,114,2614,2663,2672,2728,2735,2760,2820,2870,2888,2895,4,2,110,114,2620,2633,103,108,101,66,114,97,99,107,101,116,59,1,10216,114,111,119,4,3,59,66,82,2644,2646,2651,1,8592,97,114,59,1,8676,105,103,104,116,65,114,114,111,119,59,1,8646,101,105,108,105,110,103,59,1,8968,111,4,2,117,119,2679,2692,98,108,101,66,114,97,99,107,101,116,59,1,10214,110,4,2,84,86,2699,2710,101,101,86,101,99,116,111,114,59,1,10593,101,99,116,111,114,4,2,59,66,2721,2723,1,8643,97,114,59,1,10585,108,111,111,114,59,1,8970,105,103,104,116,4,2,65,86,2745,2752,114,114,111,119,59,1,8596,101,99,116,111,114,59,1,10574,4,2,101,114,2766,2792,101,4,3,59,65,86,2775,2777,2784,1,8867,114,114,111,119,59,1,8612,101,99,116,111,114,59,1,10586,105,97,110,103,108,101,4,3,59,66,69,2806,2808,2813,1,8882,97,114,59,1,10703,113,117,97,108,59,1,8884,112,4,3,68,84,86,2829,2841,2852,111,119,110,86,101,99,116,111,114,59,1,10577,101,101,86,101,99,116,111,114,59,1,10592,101,99,116,111,114,4,2,59,66,2863,2865,1,8639,97,114,59,1,10584,101,99,116,111,114,4,2,59,66,2881,2883,1,8636,97,114,59,1,10578,114,114,111,119,59,1,8656,105,103,104,116,97,114,114,111,119,59,1,8660,115,4,6,69,70,71,76,83,84,2922,2936,2947,2956,2962,2974,113,117,97,108,71,114,101,97,116,101,114,59,1,8922,117,108,108,69,113,117,97,108,59,1,8806,114,101,97,116,101,114,59,1,8822,101,115,115,59,1,10913,108,97,110,116,69,113,117,97,108,59,1,10877,105,108,100,101,59,1,8818,114,59,3,55349,56591,4,2,59,101,2992,2994,1,8920,102,116,97,114,114,111,119,59,1,8666,105,100,111,116,59,1,319,4,3,110,112,119,3019,3110,3115,103,4,4,76,82,108,114,3030,3058,3070,3098,101,102,116,4,2,65,82,3039,3046,114,114,111,119,59,1,10229,105,103,104,116,65,114,114,111,119,59,1,10231,105,103,104,116,65,114,114,111,119,59,1,10230,101,102,116,4,2,97,114,3079,3086,114,114,111,119,59,1,10232,105,103,104,116,97,114,114,111,119,59,1,10234,105,103,104,116,97,114,114,111,119,59,1,10233,102,59,3,55349,56643,101,114,4,2,76,82,3123,3134,101,102,116,65,114,114,111,119,59,1,8601,105,103,104,116,65,114,114,111,119,59,1,8600,4,3,99,104,116,3154,3158,3161,114,59,1,8466,59,1,8624,114,111,107,59,1,321,59,1,8810,4,8,97,99,101,102,105,111,115,117,3188,3192,3196,3222,3227,3237,3243,3248,112,59,1,10501,121,59,1,1052,4,2,100,108,3202,3213,105,117,109,83,112,97,99,101,59,1,8287,108,105,110,116,114,102,59,1,8499,114,59,3,55349,56592,110,117,115,80,108,117,115,59,1,8723,112,102,59,3,55349,56644,99,114,59,1,8499,59,1,924,4,9,74,97,99,101,102,111,115,116,117,3271,3276,3283,3306,3422,3427,4120,4126,4137,99,121,59,1,1034,99,117,116,101,59,1,323,4,3,97,101,121,3291,3297,3303,114,111,110,59,1,327,100,105,108,59,1,325,59,1,1053,4,3,103,115,119,3314,3380,3415,97,116,105,118,101,4,3,77,84,86,3327,3340,3365,101,100,105,117,109,83,112,97,99,101,59,1,8203,104,105,4,2,99,110,3348,3357,107,83,112,97,99,101,59,1,8203,83,112,97,99,101,59,1,8203,101,114,121,84,104,105,110,83,112,97,99,101,59,1,8203,116,101,100,4,2,71,76,3389,3405,114,101,97,116,101,114,71,114,101,97,116,101,114,59,1,8811,101,115,115,76,101,115,115,59,1,8810,76,105,110,101,59,1,10,114,59,3,55349,56593,4,4,66,110,112,116,3437,3444,3460,3464,114,101,97,107,59,1,8288,66,114,101,97,107,105,110,103,83,112,97,99,101,59,1,160,102,59,1,8469,4,13,59,67,68,69,71,72,76,78,80,82,83,84,86,3492,3494,3517,3536,3578,3657,3685,3784,3823,3860,3915,4066,4107,1,10988,4,2,111,117,3500,3510,110,103,114,117,101,110,116,59,1,8802,112,67,97,112,59,1,8813,111,117,98,108,101,86,101,114,116,105,99,97,108,66,97,114,59,1,8742,4,3,108,113,120,3544,3552,3571,101,109,101,110,116,59,1,8713,117,97,108,4,2,59,84,3561,3563,1,8800,105,108,100,101,59,3,8770,824,105,115,116,115,59,1,8708,114,101,97,116,101,114,4,7,59,69,70,71,76,83,84,3600,3602,3609,3621,3631,3637,3650,1,8815,113,117,97,108,59,1,8817,117,108,108,69,113,117,97,108,59,3,8807,824,114,101,97,116,101,114,59,3,8811,824,101,115,115,59,1,8825,108,97,110,116,69,113,117,97,108,59,3,10878,824,105,108,100,101,59,1,8821,117,109,112,4,2,68,69,3666,3677,111,119,110,72,117,109,112,59,3,8782,824,113,117,97,108,59,3,8783,824,101,4,2,102,115,3692,3724,116,84,114,105,97,110,103,108,101,4,3,59,66,69,3709,3711,3717,1,8938,97,114,59,3,10703,824,113,117,97,108,59,1,8940,115,4,6,59,69,71,76,83,84,3739,3741,3748,3757,3764,3777,1,8814,113,117,97,108,59,1,8816,114,101,97,116,101,114,59,1,8824,101,115,115,59,3,8810,824,108,97,110,116,69,113,117,97,108,59,3,10877,824,105,108,100,101,59,1,8820,101,115,116,101,100,4,2,71,76,3795,3812,114,101,97,116,101,114,71,114,101,97,116,101,114,59,3,10914,824,101,115,115,76,101,115,115,59,3,10913,824,114,101,99,101,100,101,115,4,3,59,69,83,3838,3840,3848,1,8832,113,117,97,108,59,3,10927,824,108,97,110,116,69,113,117,97,108,59,1,8928,4,2,101,105,3866,3881,118,101,114,115,101,69,108,101,109,101,110,116,59,1,8716,103,104,116,84,114,105,97,110,103,108,101,4,3,59,66,69,3900,3902,3908,1,8939,97,114,59,3,10704,824,113,117,97,108,59,1,8941,4,2,113,117,3921,3973,117,97,114,101,83,117,4,2,98,112,3933,3952,115,101,116,4,2,59,69,3942,3945,3,8847,824,113,117,97,108,59,1,8930,101,114,115,101,116,4,2,59,69,3963,3966,3,8848,824,113,117,97,108,59,1,8931,4,3,98,99,112,3981,4000,4045,115,101,116,4,2,59,69,3990,3993,3,8834,8402,113,117,97,108,59,1,8840,99,101,101,100,115,4,4,59,69,83,84,4015,4017,4025,4037,1,8833,113,117,97,108,59,3,10928,824,108,97,110,116,69,113,117,97,108,59,1,8929,105,108,100,101,59,3,8831,824,101,114,115,101,116,4,2,59,69,4056,4059,3,8835,8402,113,117,97,108,59,1,8841,105,108,100,101,4,4,59,69,70,84,4080,4082,4089,4100,1,8769,113,117,97,108,59,1,8772,117,108,108,69,113,117,97,108,59,1,8775,105,108,100,101,59,1,8777,101,114,116,105,99,97,108,66,97,114,59,1,8740,99,114,59,3,55349,56489,105,108,100,101,5,209,1,59,4135,1,209,59,1,925,4,14,69,97,99,100,102,103,109,111,112,114,115,116,117,118,4170,4176,4187,4205,4212,4217,4228,4253,4259,4292,4295,4316,4337,4346,108,105,103,59,1,338,99,117,116,101,5,211,1,59,4185,1,211,4,2,105,121,4193,4202,114,99,5,212,1,59,4200,1,212,59,1,1054,98,108,97,99,59,1,336,114,59,3,55349,56594,114,97,118,101,5,210,1,59,4226,1,210,4,3,97,101,105,4236,4241,4246,99,114,59,1,332,103,97,59,1,937,99,114,111,110,59,1,927,112,102,59,3,55349,56646,101,110,67,117,114,108,121,4,2,68,81,4272,4285,111,117,98,108,101,81,117,111,116,101,59,1,8220,117,111,116,101,59,1,8216,59,1,10836,4,2,99,108,4301,4306,114,59,3,55349,56490,97,115,104,5,216,1,59,4314,1,216,105,4,2,108,109,4323,4332,100,101,5,213,1,59,4330,1,213,101,115,59,1,10807,109,108,5,214,1,59,4344,1,214,101,114,4,2,66,80,4354,4380,4,2,97,114,4360,4364,114,59,1,8254,97,99,4,2,101,107,4372,4375,59,1,9182,101,116,59,1,9140,97,114,101,110,116,104,101,115,105,115,59,1,9180,4,9,97,99,102,104,105,108,111,114,115,4413,4422,4426,4431,4435,4438,4448,4471,4561,114,116,105,97,108,68,59,1,8706,121,59,1,1055,114,59,3,55349,56595,105,59,1,934,59,1,928,117,115,77,105,110,117,115,59,1,177,4,2,105,112,4454,4467,110,99,97,114,101,112,108,97,110,101,59,1,8460,102,59,1,8473,4,4,59,101,105,111,4481,4483,4526,4531,1,10939,99,101,100,101,115,4,4,59,69,83,84,4498,4500,4507,4519,1,8826,113,117,97,108,59,1,10927,108,97,110,116,69,113,117,97,108,59,1,8828,105,108,100,101,59,1,8830,109,101,59,1,8243,4,2,100,112,4537,4543,117,99,116,59,1,8719,111,114,116,105,111,110,4,2,59,97,4555,4557,1,8759,108,59,1,8733,4,2,99,105,4567,4572,114,59,3,55349,56491,59,1,936,4,4,85,102,111,115,4585,4594,4599,4604,79,84,5,34,1,59,4592,1,34,114,59,3,55349,56596,112,102,59,1,8474,99,114,59,3,55349,56492,4,12,66,69,97,99,101,102,104,105,111,114,115,117,4636,4642,4650,4681,4704,4763,4767,4771,5047,5069,5081,5094,97,114,114,59,1,10512,71,5,174,1,59,4648,1,174,4,3,99,110,114,4658,4664,4668,117,116,101,59,1,340,103,59,1,10219,114,4,2,59,116,4675,4677,1,8608,108,59,1,10518,4,3,97,101,121,4689,4695,4701,114,111,110,59,1,344,100,105,108,59,1,342,59,1,1056,4,2,59,118,4710,4712,1,8476,101,114,115,101,4,2,69,85,4722,4748,4,2,108,113,4728,4736,101,109,101,110,116,59,1,8715,117,105,108,105,98,114,105,117,109,59,1,8651,112,69,113,117,105,108,105,98,114,105,117,109,59,1,10607,114,59,1,8476,111,59,1,929,103,104,116,4,8,65,67,68,70,84,85,86,97,4792,4840,4849,4905,4912,4972,5022,5040,4,2,110,114,4798,4811,103,108,101,66,114,97,99,107,101,116,59,1,10217,114,111,119,4,3,59,66,76,4822,4824,4829,1,8594,97,114,59,1,8677,101,102,116,65,114,114,111,119,59,1,8644,101,105,108,105,110,103,59,1,8969,111,4,2,117,119,4856,4869,98,108,101,66,114,97,99,107,101,116,59,1,10215,110,4,2,84,86,4876,4887,101,101,86,101,99,116,111,114,59,1,10589,101,99,116,111,114,4,2,59,66,4898,4900,1,8642,97,114,59,1,10581,108,111,111,114,59,1,8971,4,2,101,114,4918,4944,101,4,3,59,65,86,4927,4929,4936,1,8866,114,114,111,119,59,1,8614,101,99,116,111,114,59,1,10587,105,97,110,103,108,101,4,3,59,66,69,4958,4960,4965,1,8883,97,114,59,1,10704,113,117,97,108,59,1,8885,112,4,3,68,84,86,4981,4993,5004,111,119,110,86,101,99,116,111,114,59,1,10575,101,101,86,101,99,116,111,114,59,1,10588,101,99,116,111,114,4,2,59,66,5015,5017,1,8638,97,114,59,1,10580,101,99,116,111,114,4,2,59,66,5033,5035,1,8640,97,114,59,1,10579,114,114,111,119,59,1,8658,4,2,112,117,5053,5057,102,59,1,8477,110,100,73,109,112,108,105,101,115,59,1,10608,105,103,104,116,97,114,114,111,119,59,1,8667,4,2,99,104,5087,5091,114,59,1,8475,59,1,8625,108,101,68,101,108,97,121,101,100,59,1,10740,4,13,72,79,97,99,102,104,105,109,111,113,115,116,117,5134,5150,5157,5164,5198,5203,5259,5265,5277,5283,5374,5380,5385,4,2,67,99,5140,5146,72,99,121,59,1,1065,121,59,1,1064,70,84,99,121,59,1,1068,99,117,116,101,59,1,346,4,5,59,97,101,105,121,5176,5178,5184,5190,5195,1,10940,114,111,110,59,1,352,100,105,108,59,1,350,114,99,59,1,348,59,1,1057,114,59,3,55349,56598,111,114,116,4,4,68,76,82,85,5216,5227,5238,5250,111,119,110,65,114,114,111,119,59,1,8595,101,102,116,65,114,114,111,119,59,1,8592,105,103,104,116,65,114,114,111,119,59,1,8594,112,65,114,114,111,119,59,1,8593,103,109,97,59,1,931,97,108,108,67,105,114,99,108,101,59,1,8728,112,102,59,3,55349,56650,4,2,114,117,5289,5293,116,59,1,8730,97,114,101,4,4,59,73,83,85,5306,5308,5322,5367,1,9633,110,116,101,114,115,101,99,116,105,111,110,59,1,8851,117,4,2,98,112,5329,5347,115,101,116,4,2,59,69,5338,5340,1,8847,113,117,97,108,59,1,8849,101,114,115,101,116,4,2,59,69,5358,5360,1,8848,113,117,97,108,59,1,8850,110,105,111,110,59,1,8852,99,114,59,3,55349,56494,97,114,59,1,8902,4,4,98,99,109,112,5395,5420,5475,5478,4,2,59,115,5401,5403,1,8912,101,116,4,2,59,69,5411,5413,1,8912,113,117,97,108,59,1,8838,4,2,99,104,5426,5468,101,101,100,115,4,4,59,69,83,84,5440,5442,5449,5461,1,8827,113,117,97,108,59,1,10928,108,97,110,116,69,113,117,97,108,59,1,8829,105,108,100,101,59,1,8831,84,104,97,116,59,1,8715,59,1,8721,4,3,59,101,115,5486,5488,5507,1,8913,114,115,101,116,4,2,59,69,5498,5500,1,8835,113,117,97,108,59,1,8839,101,116,59,1,8913,4,11,72,82,83,97,99,102,104,105,111,114,115,5536,5546,5552,5567,5579,5602,5607,5655,5695,5701,5711,79,82,78,5,222,1,59,5544,1,222,65,68,69,59,1,8482,4,2,72,99,5558,5563,99,121,59,1,1035,121,59,1,1062,4,2,98,117,5573,5576,59,1,9,59,1,932,4,3,97,101,121,5587,5593,5599,114,111,110,59,1,356,100,105,108,59,1,354,59,1,1058,114,59,3,55349,56599,4,2,101,105,5613,5631,4,2,114,116,5619,5627,101,102,111,114,101,59,1,8756,97,59,1,920,4,2,99,110,5637,5647,107,83,112,97,99,101,59,3,8287,8202,83,112,97,99,101,59,1,8201,108,100,101,4,4,59,69,70,84,5668,5670,5677,5688,1,8764,113,117,97,108,59,1,8771,117,108,108,69,113,117,97,108,59,1,8773,105,108,100,101,59,1,8776,112,102,59,3,55349,56651,105,112,108,101,68,111,116,59,1,8411,4,2,99,116,5717,5722,114,59,3,55349,56495,114,111,107,59,1,358,4,14,97,98,99,100,102,103,109,110,111,112,114,115,116,117,5758,5789,5805,5823,5830,5835,5846,5852,5921,5937,6089,6095,6101,6108,4,2,99,114,5764,5774,117,116,101,5,218,1,59,5772,1,218,114,4,2,59,111,5781,5783,1,8607,99,105,114,59,1,10569,114,4,2,99,101,5796,5800,121,59,1,1038,118,101,59,1,364,4,2,105,121,5811,5820,114,99,5,219,1,59,5818,1,219,59,1,1059,98,108,97,99,59,1,368,114,59,3,55349,56600,114,97,118,101,5,217,1,59,5844,1,217,97,99,114,59,1,362,4,2,100,105,5858,5905,101,114,4,2,66,80,5866,5892,4,2,97,114,5872,5876,114,59,1,95,97,99,4,2,101,107,5884,5887,59,1,9183,101,116,59,1,9141,97,114,101,110,116,104,101,115,105,115,59,1,9181,111,110,4,2,59,80,5913,5915,1,8899,108,117,115,59,1,8846,4,2,103,112,5927,5932,111,110,59,1,370,102,59,3,55349,56652,4,8,65,68,69,84,97,100,112,115,5955,5985,5996,6009,6026,6033,6044,6075,114,114,111,119,4,3,59,66,68,5967,5969,5974,1,8593,97,114,59,1,10514,111,119,110,65,114,114,111,119,59,1,8645,111,119,110,65,114,114,111,119,59,1,8597,113,117,105,108,105,98,114,105,117,109,59,1,10606,101,101,4,2,59,65,6017,6019,1,8869,114,114,111,119,59,1,8613,114,114,111,119,59,1,8657,111,119,110,97,114,114,111,119,59,1,8661,101,114,4,2,76,82,6052,6063,101,102,116,65,114,114,111,119,59,1,8598,105,103,104,116,65,114,114,111,119,59,1,8599,105,4,2,59,108,6082,6084,1,978,111,110,59,1,933,105,110,103,59,1,366,99,114,59,3,55349,56496,105,108,100,101,59,1,360,109,108,5,220,1,59,6115,1,220,4,9,68,98,99,100,101,102,111,115,118,6137,6143,6148,6152,6166,6250,6255,6261,6267,97,115,104,59,1,8875,97,114,59,1,10987,121,59,1,1042,97,115,104,4,2,59,108,6161,6163,1,8873,59,1,10982,4,2,101,114,6172,6175,59,1,8897,4,3,98,116,121,6183,6188,6238,97,114,59,1,8214,4,2,59,105,6194,6196,1,8214,99,97,108,4,4,66,76,83,84,6209,6214,6220,6231,97,114,59,1,8739,105,110,101,59,1,124,101,112,97,114,97,116,111,114,59,1,10072,105,108,100,101,59,1,8768,84,104,105,110,83,112,97,99,101,59,1,8202,114,59,3,55349,56601,112,102,59,3,55349,56653,99,114,59,3,55349,56497,100,97,115,104,59,1,8874,4,5,99,101,102,111,115,6286,6292,6298,6303,6309,105,114,99,59,1,372,100,103,101,59,1,8896,114,59,3,55349,56602,112,102,59,3,55349,56654,99,114,59,3,55349,56498,4,4,102,105,111,115,6325,6330,6333,6339,114,59,3,55349,56603,59,1,926,112,102,59,3,55349,56655,99,114,59,3,55349,56499,4,9,65,73,85,97,99,102,111,115,117,6365,6370,6375,6380,6391,6405,6410,6416,6422,99,121,59,1,1071,99,121,59,1,1031,99,121,59,1,1070,99,117,116,101,5,221,1,59,6389,1,221,4,2,105,121,6397,6402,114,99,59,1,374,59,1,1067,114,59,3,55349,56604,112,102,59,3,55349,56656,99,114,59,3,55349,56500,109,108,59,1,376,4,8,72,97,99,100,101,102,111,115,6445,6450,6457,6472,6477,6501,6505,6510,99,121,59,1,1046,99,117,116,101,59,1,377,4,2,97,121,6463,6469,114,111,110,59,1,381,59,1,1047,111,116,59,1,379,4,2,114,116,6483,6497,111,87,105,100,116,104,83,112,97,99,101,59,1,8203,97,59,1,918,114,59,1,8488,112,102,59,1,8484,99,114,59,3,55349,56501,4,16,97,98,99,101,102,103,108,109,110,111,112,114,115,116,117,119,6550,6561,6568,6612,6622,6634,6645,6672,6699,6854,6870,6923,6933,6963,6974,6983,99,117,116,101,5,225,1,59,6559,1,225,114,101,118,101,59,1,259,4,6,59,69,100,105,117,121,6582,6584,6588,6591,6600,6609,1,8766,59,3,8766,819,59,1,8767,114,99,5,226,1,59,6598,1,226,116,101,5,180,1,59,6607,1,180,59,1,1072,108,105,103,5,230,1,59,6620,1,230,4,2,59,114,6628,6630,1,8289,59,3,55349,56606,114,97,118,101,5,224,1,59,6643,1,224,4,2,101,112,6651,6667,4,2,102,112,6657,6663,115,121,109,59,1,8501,104,59,1,8501,104,97,59,1,945,4,2,97,112,6678,6692,4,2,99,108,6684,6688,114,59,1,257,103,59,1,10815,5,38,1,59,6697,1,38,4,2,100,103,6705,6737,4,5,59,97,100,115,118,6717,6719,6724,6727,6734,1,8743,110,100,59,1,10837,59,1,10844,108,111,112,101,59,1,10840,59,1,10842,4,7,59,101,108,109,114,115,122,6753,6755,6758,6762,6814,6835,6848,1,8736,59,1,10660,101,59,1,8736,115,100,4,2,59,97,6770,6772,1,8737,4,8,97,98,99,100,101,102,103,104,6790,6793,6796,6799,6802,6805,6808,6811,59,1,10664,59,1,10665,59,1,10666,59,1,10667,59,1,10668,59,1,10669,59,1,10670,59,1,10671,116,4,2,59,118,6821,6823,1,8735,98,4,2,59,100,6830,6832,1,8894,59,1,10653,4,2,112,116,6841,6845,104,59,1,8738,59,1,197,97,114,114,59,1,9084,4,2,103,112,6860,6865,111,110,59,1,261,102,59,3,55349,56658,4,7,59,69,97,101,105,111,112,6886,6888,6891,6897,6900,6904,6908,1,8776,59,1,10864,99,105,114,59,1,10863,59,1,8778,100,59,1,8779,115,59,1,39,114,111,120,4,2,59,101,6917,6919,1,8776,113,59,1,8778,105,110,103,5,229,1,59,6931,1,229,4,3,99,116,121,6941,6946,6949,114,59,3,55349,56502,59,1,42,109,112,4,2,59,101,6957,6959,1,8776,113,59,1,8781,105,108,100,101,5,227,1,59,6972,1,227,109,108,5,228,1,59,6981,1,228,4,2,99,105,6989,6997,111,110,105,110,116,59,1,8755,110,116,59,1,10769,4,16,78,97,98,99,100,101,102,105,107,108,110,111,112,114,115,117,7036,7041,7119,7135,7149,7155,7219,7224,7347,7354,7463,7489,7786,7793,7814,7866,111,116,59,1,10989,4,2,99,114,7047,7094,107,4,4,99,101,112,115,7058,7064,7073,7080,111,110,103,59,1,8780,112,115,105,108,111,110,59,1,1014,114,105,109,101,59,1,8245,105,109,4,2,59,101,7088,7090,1,8765,113,59,1,8909,4,2,118,119,7100,7105,101,101,59,1,8893,101,100,4,2,59,103,7113,7115,1,8965,101,59,1,8965,114,107,4,2,59,116,7127,7129,1,9141,98,114,107,59,1,9142,4,2,111,121,7141,7146,110,103,59,1,8780,59,1,1073,113,117,111,59,1,8222,4,5,99,109,112,114,116,7167,7181,7188,7193,7199,97,117,115,4,2,59,101,7176,7178,1,8757,59,1,8757,112,116,121,118,59,1,10672,115,105,59,1,1014,110,111,117,59,1,8492,4,3,97,104,119,7207,7210,7213,59,1,946,59,1,8502,101,101,110,59,1,8812,114,59,3,55349,56607,103,4,7,99,111,115,116,117,118,119,7241,7262,7288,7305,7328,7335,7340,4,3,97,105,117,7249,7253,7258,112,59,1,8898,114,99,59,1,9711,112,59,1,8899,4,3,100,112,116,7270,7275,7281,111,116,59,1,10752,108,117,115,59,1,10753,105,109,101,115,59,1,10754,4,2,113,116,7294,7300,99,117,112,59,1,10758,97,114,59,1,9733,114,105,97,110,103,108,101,4,2,100,117,7318,7324,111,119,110,59,1,9661,112,59,1,9651,112,108,117,115,59,1,10756,101,101,59,1,8897,101,100,103,101,59,1,8896,97,114,111,119,59,1,10509,4,3,97,107,111,7362,7436,7458,4,2,99,110,7368,7432,107,4,3,108,115,116,7377,7386,7394,111,122,101,110,103,101,59,1,10731,113,117,97,114,101,59,1,9642,114,105,97,110,103,108,101,4,4,59,100,108,114,7411,7413,7419,7425,1,9652,111,119,110,59,1,9662,101,102,116,59,1,9666,105,103,104,116,59,1,9656,107,59,1,9251,4,2,49,51,7442,7454,4,2,50,52,7448,7451,59,1,9618,59,1,9617,52,59,1,9619,99,107,59,1,9608,4,2,101,111,7469,7485,4,2,59,113,7475,7478,3,61,8421,117,105,118,59,3,8801,8421,116,59,1,8976,4,4,112,116,119,120,7499,7504,7517,7523,102,59,3,55349,56659,4,2,59,116,7510,7512,1,8869,111,109,59,1,8869,116,105,101,59,1,8904,4,12,68,72,85,86,98,100,104,109,112,116,117,118,7549,7571,7597,7619,7655,7660,7682,7708,7715,7721,7728,7750,4,4,76,82,108,114,7559,7562,7565,7568,59,1,9559,59,1,9556,59,1,9558,59,1,9555,4,5,59,68,85,100,117,7583,7585,7588,7591,7594,1,9552,59,1,9574,59,1,9577,59,1,9572,59,1,9575,4,4,76,82,108,114,7607,7610,7613,7616,59,1,9565,59,1,9562,59,1,9564,59,1,9561,4,7,59,72,76,82,104,108,114,7635,7637,7640,7643,7646,7649,7652,1,9553,59,1,9580,59,1,9571,59,1,9568,59,1,9579,59,1,9570,59,1,9567,111,120,59,1,10697,4,4,76,82,108,114,7670,7673,7676,7679,59,1,9557,59,1,9554,59,1,9488,59,1,9484,4,5,59,68,85,100,117,7694,7696,7699,7702,7705,1,9472,59,1,9573,59,1,9576,59,1,9516,59,1,9524,105,110,117,115,59,1,8863,108,117,115,59,1,8862,105,109,101,115,59,1,8864,4,4,76,82,108,114,7738,7741,7744,7747,59,1,9563,59,1,9560,59,1,9496,59,1,9492,4,7,59,72,76,82,104,108,114,7766,7768,7771,7774,7777,7780,7783,1,9474,59,1,9578,59,1,9569,59,1,9566,59,1,9532,59,1,9508,59,1,9500,114,105,109,101,59,1,8245,4,2,101,118,7799,7804,118,101,59,1,728,98,97,114,5,166,1,59,7812,1,166,4,4,99,101,105,111,7824,7829,7834,7846,114,59,3,55349,56503,109,105,59,1,8271,109,4,2,59,101,7841,7843,1,8765,59,1,8909,108,4,3,59,98,104,7855,7857,7860,1,92,59,1,10693,115,117,98,59,1,10184,4,2,108,109,7872,7885,108,4,2,59,101,7879,7881,1,8226,116,59,1,8226,112,4,3,59,69,101,7894,7896,7899,1,8782,59,1,10926,4,2,59,113,7905,7907,1,8783,59,1,8783,4,15,97,99,100,101,102,104,105,108,111,114,115,116,117,119,121,7942,8021,8075,8080,8121,8126,8157,8279,8295,8430,8446,8485,8491,8707,8726,4,3,99,112,114,7950,7956,8007,117,116,101,59,1,263,4,6,59,97,98,99,100,115,7970,7972,7977,7984,7998,8003,1,8745,110,100,59,1,10820,114,99,117,112,59,1,10825,4,2,97,117,7990,7994,112,59,1,10827,112,59,1,10823,111,116,59,1,10816,59,3,8745,65024,4,2,101,111,8013,8017,116,59,1,8257,110,59,1,711,4,4,97,101,105,117,8031,8046,8056,8061,4,2,112,114,8037,8041,115,59,1,10829,111,110,59,1,269,100,105,108,5,231,1,59,8054,1,231,114,99,59,1,265,112,115,4,2,59,115,8069,8071,1,10828,109,59,1,10832,111,116,59,1,267,4,3,100,109,110,8088,8097,8104,105,108,5,184,1,59,8095,1,184,112,116,121,118,59,1,10674,116,5,162,2,59,101,8112,8114,1,162,114,100,111,116,59,1,183,114,59,3,55349,56608,4,3,99,101,105,8134,8138,8154,121,59,1,1095,99,107,4,2,59,109,8146,8148,1,10003,97,114,107,59,1,10003,59,1,967,114,4,7,59,69,99,101,102,109,115,8174,8176,8179,8258,8261,8268,8273,1,9675,59,1,10691,4,3,59,101,108,8187,8189,8193,1,710,113,59,1,8791,101,4,2,97,100,8200,8223,114,114,111,119,4,2,108,114,8210,8216,101,102,116,59,1,8634,105,103,104,116,59,1,8635,4,5,82,83,97,99,100,8235,8238,8241,8246,8252,59,1,174,59,1,9416,115,116,59,1,8859,105,114,99,59,1,8858,97,115,104,59,1,8861,59,1,8791,110,105,110,116,59,1,10768,105,100,59,1,10991,99,105,114,59,1,10690,117,98,115,4,2,59,117,8288,8290,1,9827,105,116,59,1,9827,4,4,108,109,110,112,8305,8326,8376,8400,111,110,4,2,59,101,8313,8315,1,58,4,2,59,113,8321,8323,1,8788,59,1,8788,4,2,109,112,8332,8344,97,4,2,59,116,8339,8341,1,44,59,1,64,4,3,59,102,108,8352,8354,8358,1,8705,110,59,1,8728,101,4,2,109,120,8365,8371,101,110,116,59,1,8705,101,115,59,1,8450,4,2,103,105,8382,8395,4,2,59,100,8388,8390,1,8773,111,116,59,1,10861,110,116,59,1,8750,4,3,102,114,121,8408,8412,8417,59,3,55349,56660,111,100,59,1,8720,5,169,2,59,115,8424,8426,1,169,114,59,1,8471,4,2,97,111,8436,8441,114,114,59,1,8629,115,115,59,1,10007,4,2,99,117,8452,8457,114,59,3,55349,56504,4,2,98,112,8463,8474,4,2,59,101,8469,8471,1,10959,59,1,10961,4,2,59,101,8480,8482,1,10960,59,1,10962,100,111,116,59,1,8943,4,7,100,101,108,112,114,118,119,8507,8522,8536,8550,8600,8697,8702,97,114,114,4,2,108,114,8516,8519,59,1,10552,59,1,10549,4,2,112,115,8528,8532,114,59,1,8926,99,59,1,8927,97,114,114,4,2,59,112,8545,8547,1,8630,59,1,10557,4,6,59,98,99,100,111,115,8564,8566,8573,8587,8592,8596,1,8746,114,99,97,112,59,1,10824,4,2,97,117,8579,8583,112,59,1,10822,112,59,1,10826,111,116,59,1,8845,114,59,1,10821,59,3,8746,65024,4,4,97,108,114,118,8610,8623,8663,8672,114,114,4,2,59,109,8618,8620,1,8631,59,1,10556,121,4,3,101,118,119,8632,8651,8656,113,4,2,112,115,8639,8645,114,101,99,59,1,8926,117,99,99,59,1,8927,101,101,59,1,8910,101,100,103,101,59,1,8911,101,110,5,164,1,59,8670,1,164,101,97,114,114,111,119,4,2,108,114,8684,8690,101,102,116,59,1,8630,105,103,104,116,59,1,8631,101,101,59,1,8910,101,100,59,1,8911,4,2,99,105,8713,8721,111,110,105,110,116,59,1,8754,110,116,59,1,8753,108,99,116,121,59,1,9005,4,19,65,72,97,98,99,100,101,102,104,105,106,108,111,114,115,116,117,119,122,8773,8778,8783,8821,8839,8854,8887,8914,8930,8944,9036,9041,9058,9197,9227,9258,9281,9297,9305,114,114,59,1,8659,97,114,59,1,10597,4,4,103,108,114,115,8793,8799,8805,8809,103,101,114,59,1,8224,101,116,104,59,1,8504,114,59,1,8595,104,4,2,59,118,8816,8818,1,8208,59,1,8867,4,2,107,108,8827,8834,97,114,111,119,59,1,10511,97,99,59,1,733,4,2,97,121,8845,8851,114,111,110,59,1,271,59,1,1076,4,3,59,97,111,8862,8864,8880,1,8518,4,2,103,114,8870,8876,103,101,114,59,1,8225,114,59,1,8650,116,115,101,113,59,1,10871,4,3,103,108,109,8895,8902,8907,5,176,1,59,8900,1,176,116,97,59,1,948,112,116,121,118,59,1,10673,4,2,105,114,8920,8926,115,104,116,59,1,10623,59,3,55349,56609,97,114,4,2,108,114,8938,8941,59,1,8643,59,1,8642,4,5,97,101,103,115,118,8956,8986,8989,8996,9001,109,4,3,59,111,115,8965,8967,8983,1,8900,110,100,4,2,59,115,8975,8977,1,8900,117,105,116,59,1,9830,59,1,9830,59,1,168,97,109,109,97,59,1,989,105,110,59,1,8946,4,3,59,105,111,9009,9011,9031,1,247,100,101,5,247,2,59,111,9020,9022,1,247,110,116,105,109,101,115,59,1,8903,110,120,59,1,8903,99,121,59,1,1106,99,4,2,111,114,9048,9053,114,110,59,1,8990,111,112,59,1,8973,4,5,108,112,116,117,119,9070,9076,9081,9130,9144,108,97,114,59,1,36,102,59,3,55349,56661,4,5,59,101,109,112,115,9093,9095,9109,9116,9122,1,729,113,4,2,59,100,9102,9104,1,8784,111,116,59,1,8785,105,110,117,115,59,1,8760,108,117,115,59,1,8724,113,117,97,114,101,59,1,8865,98,108,101,98,97,114,119,101,100,103,101,59,1,8966,110,4,3,97,100,104,9153,9160,9172,114,114,111,119,59,1,8595,111,119,110,97,114,114,111,119,115,59,1,8650,97,114,112,111,111,110,4,2,108,114,9184,9190,101,102,116,59,1,8643,105,103,104,116,59,1,8642,4,2,98,99,9203,9211,107,97,114,111,119,59,1,10512,4,2,111,114,9217,9222,114,110,59,1,8991,111,112,59,1,8972,4,3,99,111,116,9235,9248,9252,4,2,114,121,9241,9245,59,3,55349,56505,59,1,1109,108,59,1,10742,114,111,107,59,1,273,4,2,100,114,9264,9269,111,116,59,1,8945,105,4,2,59,102,9276,9278,1,9663,59,1,9662,4,2,97,104,9287,9292,114,114,59,1,8693,97,114,59,1,10607,97,110,103,108,101,59,1,10662,4,2,99,105,9311,9315,121,59,1,1119,103,114,97,114,114,59,1,10239,4,18,68,97,99,100,101,102,103,108,109,110,111,112,113,114,115,116,117,120,9361,9376,9398,9439,9444,9447,9462,9495,9531,9585,9598,9614,9659,9755,9771,9792,9808,9826,4,2,68,111,9367,9372,111,116,59,1,10871,116,59,1,8785,4,2,99,115,9382,9392,117,116,101,5,233,1,59,9390,1,233,116,101,114,59,1,10862,4,4,97,105,111,121,9408,9414,9430,9436,114,111,110,59,1,283,114,4,2,59,99,9421,9423,1,8790,5,234,1,59,9428,1,234,108,111,110,59,1,8789,59,1,1101,111,116,59,1,279,59,1,8519,4,2,68,114,9453,9458,111,116,59,1,8786,59,3,55349,56610,4,3,59,114,115,9470,9472,9482,1,10906,97,118,101,5,232,1,59,9480,1,232,4,2,59,100,9488,9490,1,10902,111,116,59,1,10904,4,4,59,105,108,115,9505,9507,9515,9518,1,10905,110,116,101,114,115,59,1,9191,59,1,8467,4,2,59,100,9524,9526,1,10901,111,116,59,1,10903,4,3,97,112,115,9539,9544,9564,99,114,59,1,275,116,121,4,3,59,115,118,9554,9556,9561,1,8709,101,116,59,1,8709,59,1,8709,112,4,2,49,59,9571,9583,4,2,51,52,9577,9580,59,1,8196,59,1,8197,1,8195,4,2,103,115,9591,9594,59,1,331,112,59,1,8194,4,2,103,112,9604,9609,111,110,59,1,281,102,59,3,55349,56662,4,3,97,108,115,9622,9635,9640,114,4,2,59,115,9629,9631,1,8917,108,59,1,10723,117,115,59,1,10865,105,4,3,59,108,118,9649,9651,9656,1,949,111,110,59,1,949,59,1,1013,4,4,99,115,117,118,9669,9686,9716,9747,4,2,105,111,9675,9680,114,99,59,1,8790,108,111,110,59,1,8789,4,2,105,108,9692,9696,109,59,1,8770,97,110,116,4,2,103,108,9705,9710,116,114,59,1,10902,101,115,115,59,1,10901,4,3,97,101,105,9724,9729,9734,108,115,59,1,61,115,116,59,1,8799,118,4,2,59,68,9741,9743,1,8801,68,59,1,10872,112,97,114,115,108,59,1,10725,4,2,68,97,9761,9766,111,116,59,1,8787,114,114,59,1,10609,4,3,99,100,105,9779,9783,9788,114,59,1,8495,111,116,59,1,8784,109,59,1,8770,4,2,97,104,9798,9801,59,1,951,5,240,1,59,9806,1,240,4,2,109,114,9814,9822,108,5,235,1,59,9820,1,235,111,59,1,8364,4,3,99,105,112,9834,9838,9843,108,59,1,33,115,116,59,1,8707,4,2,101,111,9849,9859,99,116,97,116,105,111,110,59,1,8496,110,101,110,116,105,97,108,101,59,1,8519,4,12,97,99,101,102,105,106,108,110,111,112,114,115,9896,9910,9914,9921,9954,9960,9967,9989,9994,10027,10036,10164,108,108,105,110,103,100,111,116,115,101,113,59,1,8786,121,59,1,1092,109,97,108,101,59,1,9792,4,3,105,108,114,9929,9935,9950,108,105,103,59,1,64259,4,2,105,108,9941,9945,103,59,1,64256,105,103,59,1,64260,59,3,55349,56611,108,105,103,59,1,64257,108,105,103,59,3,102,106,4,3,97,108,116,9975,9979,9984,116,59,1,9837,105,103,59,1,64258,110,115,59,1,9649,111,102,59,1,402,4,2,112,114,10000,10005,102,59,3,55349,56663,4,2,97,107,10011,10016,108,108,59,1,8704,4,2,59,118,10022,10024,1,8916,59,1,10969,97,114,116,105,110,116,59,1,10765,4,2,97,111,10042,10159,4,2,99,115,10048,10155,4,6,49,50,51,52,53,55,10062,10102,10114,10135,10139,10151,4,6,50,51,52,53,54,56,10076,10083,10086,10093,10096,10099,5,189,1,59,10081,1,189,59,1,8531,5,188,1,59,10091,1,188,59,1,8533,59,1,8537,59,1,8539,4,2,51,53,10108,10111,59,1,8532,59,1,8534,4,3,52,53,56,10122,10129,10132,5,190,1,59,10127,1,190,59,1,8535,59,1,8540,53,59,1,8536,4,2,54,56,10145,10148,59,1,8538,59,1,8541,56,59,1,8542,108,59,1,8260,119,110,59,1,8994,99,114,59,3,55349,56507,4,17,69,97,98,99,100,101,102,103,105,106,108,110,111,114,115,116,118,10206,10217,10247,10254,10268,10273,10358,10363,10374,10380,10385,10406,10458,10464,10470,10497,10610,4,2,59,108,10212,10214,1,8807,59,1,10892,4,3,99,109,112,10225,10231,10244,117,116,101,59,1,501,109,97,4,2,59,100,10239,10241,1,947,59,1,989,59,1,10886,114,101,118,101,59,1,287,4,2,105,121,10260,10265,114,99,59,1,285,59,1,1075,111,116,59,1,289,4,4,59,108,113,115,10283,10285,10288,10308,1,8805,59,1,8923,4,3,59,113,115,10296,10298,10301,1,8805,59,1,8807,108,97,110,116,59,1,10878,4,4,59,99,100,108,10318,10320,10324,10345,1,10878,99,59,1,10921,111,116,4,2,59,111,10332,10334,1,10880,4,2,59,108,10340,10342,1,10882,59,1,10884,4,2,59,101,10351,10354,3,8923,65024,115,59,1,10900,114,59,3,55349,56612,4,2,59,103,10369,10371,1,8811,59,1,8921,109,101,108,59,1,8503,99,121,59,1,1107,4,4,59,69,97,106,10395,10397,10400,10403,1,8823,59,1,10898,59,1,10917,59,1,10916,4,4,69,97,101,115,10416,10419,10434,10453,59,1,8809,112,4,2,59,112,10426,10428,1,10890,114,111,120,59,1,10890,4,2,59,113,10440,10442,1,10888,4,2,59,113,10448,10450,1,10888,59,1,8809,105,109,59,1,8935,112,102,59,3,55349,56664,97,118,101,59,1,96,4,2,99,105,10476,10480,114,59,1,8458,109,4,3,59,101,108,10489,10491,10494,1,8819,59,1,10894,59,1,10896,5,62,6,59,99,100,108,113,114,10512,10514,10527,10532,10538,10545,1,62,4,2,99,105,10520,10523,59,1,10919,114,59,1,10874,111,116,59,1,8919,80,97,114,59,1,10645,117,101,115,116,59,1,10876,4,5,97,100,101,108,115,10557,10574,10579,10599,10605,4,2,112,114,10563,10570,112,114,111,120,59,1,10886,114,59,1,10616,111,116,59,1,8919,113,4,2,108,113,10586,10592,101,115,115,59,1,8923,108,101,115,115,59,1,10892,101,115,115,59,1,8823,105,109,59,1,8819,4,2,101,110,10616,10626,114,116,110,101,113,113,59,3,8809,65024,69,59,3,8809,65024,4,10,65,97,98,99,101,102,107,111,115,121,10653,10658,10713,10718,10724,10760,10765,10786,10850,10875,114,114,59,1,8660,4,4,105,108,109,114,10668,10674,10678,10684,114,115,112,59,1,8202,102,59,1,189,105,108,116,59,1,8459,4,2,100,114,10690,10695,99,121,59,1,1098,4,3,59,99,119,10703,10705,10710,1,8596,105,114,59,1,10568,59,1,8621,97,114,59,1,8463,105,114,99,59,1,293,4,3,97,108,114,10732,10748,10754,114,116,115,4,2,59,117,10741,10743,1,9829,105,116,59,1,9829,108,105,112,59,1,8230,99,111,110,59,1,8889,114,59,3,55349,56613,115,4,2,101,119,10772,10779,97,114,111,119,59,1,10533,97,114,111,119,59,1,10534,4,5,97,109,111,112,114,10798,10803,10809,10839,10844,114,114,59,1,8703,116,104,116,59,1,8763,107,4,2,108,114,10816,10827,101,102,116,97,114,114,111,119,59,1,8617,105,103,104,116,97,114,114,111,119,59,1,8618,102,59,3,55349,56665,98,97,114,59,1,8213,4,3,99,108,116,10858,10863,10869,114,59,3,55349,56509,97,115,104,59,1,8463,114,111,107,59,1,295,4,2,98,112,10881,10887,117,108,108,59,1,8259,104,101,110,59,1,8208,4,15,97,99,101,102,103,105,106,109,110,111,112,113,115,116,117,10925,10936,10958,10977,10990,11001,11039,11045,11101,11192,11220,11226,11237,11285,11299,99,117,116,101,5,237,1,59,10934,1,237,4,3,59,105,121,10944,10946,10955,1,8291,114,99,5,238,1,59,10953,1,238,59,1,1080,4,2,99,120,10964,10968,121,59,1,1077,99,108,5,161,1,59,10975,1,161,4,2,102,114,10983,10986,59,1,8660,59,3,55349,56614,114,97,118,101,5,236,1,59,10999,1,236,4,4,59,105,110,111,11011,11013,11028,11034,1,8520,4,2,105,110,11019,11024,110,116,59,1,10764,116,59,1,8749,102,105,110,59,1,10716,116,97,59,1,8489,108,105,103,59,1,307,4,3,97,111,112,11053,11092,11096,4,3,99,103,116,11061,11065,11088,114,59,1,299,4,3,101,108,112,11073,11076,11082,59,1,8465,105,110,101,59,1,8464,97,114,116,59,1,8465,104,59,1,305,102,59,1,8887,101,100,59,1,437,4,5,59,99,102,111,116,11113,11115,11121,11136,11142,1,8712,97,114,101,59,1,8453,105,110,4,2,59,116,11129,11131,1,8734,105,101,59,1,10717,100,111,116,59,1,305,4,5,59,99,101,108,112,11154,11156,11161,11179,11186,1,8747,97,108,59,1,8890,4,2,103,114,11167,11173,101,114,115,59,1,8484,99,97,108,59,1,8890,97,114,104,107,59,1,10775,114,111,100,59,1,10812,4,4,99,103,112,116,11202,11206,11211,11216,121,59,1,1105,111,110,59,1,303,102,59,3,55349,56666,97,59,1,953,114,111,100,59,1,10812,117,101,115,116,5,191,1,59,11235,1,191,4,2,99,105,11243,11248,114,59,3,55349,56510,110,4,5,59,69,100,115,118,11261,11263,11266,11271,11282,1,8712,59,1,8953,111,116,59,1,8949,4,2,59,118,11277,11279,1,8948,59,1,8947,59,1,8712,4,2,59,105,11291,11293,1,8290,108,100,101,59,1,297,4,2,107,109,11305,11310,99,121,59,1,1110,108,5,239,1,59,11316,1,239,4,6,99,102,109,111,115,117,11332,11346,11351,11357,11363,11380,4,2,105,121,11338,11343,114,99,59,1,309,59,1,1081,114,59,3,55349,56615,97,116,104,59,1,567,112,102,59,3,55349,56667,4,2,99,101,11369,11374,114,59,3,55349,56511,114,99,121,59,1,1112,107,99,121,59,1,1108,4,8,97,99,102,103,104,106,111,115,11404,11418,11433,11438,11445,11450,11455,11461,112,112,97,4,2,59,118,11413,11415,1,954,59,1,1008,4,2,101,121,11424,11430,100,105,108,59,1,311,59,1,1082,114,59,3,55349,56616,114,101,101,110,59,1,312,99,121,59,1,1093,99,121,59,1,1116,112,102,59,3,55349,56668,99,114,59,3,55349,56512,4,23,65,66,69,72,97,98,99,100,101,102,103,104,106,108,109,110,111,112,114,115,116,117,118,11515,11538,11544,11555,11560,11721,11780,11818,11868,12136,12160,12171,12203,12208,12246,12275,12327,12509,12523,12569,12641,12732,12752,4,3,97,114,116,11523,11528,11532,114,114,59,1,8666,114,59,1,8656,97,105,108,59,1,10523,97,114,114,59,1,10510,4,2,59,103,11550,11552,1,8806,59,1,10891,97,114,59,1,10594,4,9,99,101,103,109,110,112,113,114,116,11580,11586,11594,11600,11606,11624,11627,11636,11694,117,116,101,59,1,314,109,112,116,121,118,59,1,10676,114,97,110,59,1,8466,98,100,97,59,1,955,103,4,3,59,100,108,11615,11617,11620,1,10216,59,1,10641,101,59,1,10216,59,1,10885,117,111,5,171,1,59,11634,1,171,114,4,8,59,98,102,104,108,112,115,116,11655,11657,11669,11673,11677,11681,11685,11690,1,8592,4,2,59,102,11663,11665,1,8676,115,59,1,10527,115,59,1,10525,107,59,1,8617,112,59,1,8619,108,59,1,10553,105,109,59,1,10611,108,59,1,8610,4,3,59,97,101,11702,11704,11709,1,10923,105,108,59,1,10521,4,2,59,115,11715,11717,1,10925,59,3,10925,65024,4,3,97,98,114,11729,11734,11739,114,114,59,1,10508,114,107,59,1,10098,4,2,97,107,11745,11758,99,4,2,101,107,11752,11755,59,1,123,59,1,91,4,2,101,115,11764,11767,59,1,10635,108,4,2,100,117,11774,11777,59,1,10639,59,1,10637,4,4,97,101,117,121,11790,11796,11811,11815,114,111,110,59,1,318,4,2,100,105,11802,11807,105,108,59,1,316,108,59,1,8968,98,59,1,123,59,1,1083,4,4,99,113,114,115,11828,11832,11845,11864,97,59,1,10550,117,111,4,2,59,114,11840,11842,1,8220,59,1,8222,4,2,100,117,11851,11857,104,97,114,59,1,10599,115,104,97,114,59,1,10571,104,59,1,8626,4,5,59,102,103,113,115,11880,11882,12008,12011,12031,1,8804,116,4,5,97,104,108,114,116,11895,11913,11935,11947,11996,114,114,111,119,4,2,59,116,11905,11907,1,8592,97,105,108,59,1,8610,97,114,112,111,111,110,4,2,100,117,11925,11931,111,119,110,59,1,8637,112,59,1,8636,101,102,116,97,114,114,111,119,115,59,1,8647,105,103,104,116,4,3,97,104,115,11959,11974,11984,114,114,111,119,4,2,59,115,11969,11971,1,8596,59,1,8646,97,114,112,111,111,110,115,59,1,8651,113,117,105,103,97,114,114,111,119,59,1,8621,104,114,101,101,116,105,109,101,115,59,1,8907,59,1,8922,4,3,59,113,115,12019,12021,12024,1,8804,59,1,8806,108,97,110,116,59,1,10877,4,5,59,99,100,103,115,12043,12045,12049,12070,12083,1,10877,99,59,1,10920,111,116,4,2,59,111,12057,12059,1,10879,4,2,59,114,12065,12067,1,10881,59,1,10883,4,2,59,101,12076,12079,3,8922,65024,115,59,1,10899,4,5,97,100,101,103,115,12095,12103,12108,12126,12131,112,112,114,111,120,59,1,10885,111,116,59,1,8918,113,4,2,103,113,12115,12120,116,114,59,1,8922,103,116,114,59,1,10891,116,114,59,1,8822,105,109,59,1,8818,4,3,105,108,114,12144,12150,12156,115,104,116,59,1,10620,111,111,114,59,1,8970,59,3,55349,56617,4,2,59,69,12166,12168,1,8822,59,1,10897,4,2,97,98,12177,12198,114,4,2,100,117,12184,12187,59,1,8637,4,2,59,108,12193,12195,1,8636,59,1,10602,108,107,59,1,9604,99,121,59,1,1113,4,5,59,97,99,104,116,12220,12222,12227,12235,12241,1,8810,114,114,59,1,8647,111,114,110,101,114,59,1,8990,97,114,100,59,1,10603,114,105,59,1,9722,4,2,105,111,12252,12258,100,111,116,59,1,320,117,115,116,4,2,59,97,12267,12269,1,9136,99,104,101,59,1,9136,4,4,69,97,101,115,12285,12288,12303,12322,59,1,8808,112,4,2,59,112,12295,12297,1,10889,114,111,120,59,1,10889,4,2,59,113,12309,12311,1,10887,4,2,59,113,12317,12319,1,10887,59,1,8808,105,109,59,1,8934,4,8,97,98,110,111,112,116,119,122,12345,12359,12364,12421,12446,12467,12474,12490,4,2,110,114,12351,12355,103,59,1,10220,114,59,1,8701,114,107,59,1,10214,103,4,3,108,109,114,12373,12401,12409,101,102,116,4,2,97,114,12382,12389,114,114,111,119,59,1,10229,105,103,104,116,97,114,114,111,119,59,1,10231,97,112,115,116,111,59,1,10236,105,103,104,116,97,114,114,111,119,59,1,10230,112,97,114,114,111,119,4,2,108,114,12433,12439,101,102,116,59,1,8619,105,103,104,116,59,1,8620,4,3,97,102,108,12454,12458,12462,114,59,1,10629,59,3,55349,56669,117,115,59,1,10797,105,109,101,115,59,1,10804,4,2,97,98,12480,12485,115,116,59,1,8727,97,114,59,1,95,4,3,59,101,102,12498,12500,12506,1,9674,110,103,101,59,1,9674,59,1,10731,97,114,4,2,59,108,12517,12519,1,40,116,59,1,10643,4,5,97,99,104,109,116,12535,12540,12548,12561,12564,114,114,59,1,8646,111,114,110,101,114,59,1,8991,97,114,4,2,59,100,12556,12558,1,8651,59,1,10605,59,1,8206,114,105,59,1,8895,4,6,97,99,104,105,113,116,12583,12589,12594,12597,12614,12635,113,117,111,59,1,8249,114,59,3,55349,56513,59,1,8624,109,4,3,59,101,103,12606,12608,12611,1,8818,59,1,10893,59,1,10895,4,2,98,117,12620,12623,59,1,91,111,4,2,59,114,12630,12632,1,8216,59,1,8218,114,111,107,59,1,322,5,60,8,59,99,100,104,105,108,113,114,12660,12662,12675,12680,12686,12692,12698,12705,1,60,4,2,99,105,12668,12671,59,1,10918,114,59,1,10873,111,116,59,1,8918,114,101,101,59,1,8907,109,101,115,59,1,8905,97,114,114,59,1,10614,117,101,115,116,59,1,10875,4,2,80,105,12711,12716,97,114,59,1,10646,4,3,59,101,102,12724,12726,12729,1,9667,59,1,8884,59,1,9666,114,4,2,100,117,12739,12746,115,104,97,114,59,1,10570,104,97,114,59,1,10598,4,2,101,110,12758,12768,114,116,110,101,113,113,59,3,8808,65024,69,59,3,8808,65024,4,14,68,97,99,100,101,102,104,105,108,110,111,112,115,117,12803,12809,12893,12908,12914,12928,12933,12937,13011,13025,13032,13049,13052,13069,68,111,116,59,1,8762,4,4,99,108,112,114,12819,12827,12849,12887,114,5,175,1,59,12825,1,175,4,2,101,116,12833,12836,59,1,9794,4,2,59,101,12842,12844,1,10016,115,101,59,1,10016,4,2,59,115,12855,12857,1,8614,116,111,4,4,59,100,108,117,12869,12871,12877,12883,1,8614,111,119,110,59,1,8615,101,102,116,59,1,8612,112,59,1,8613,107,101,114,59,1,9646,4,2,111,121,12899,12905,109,109,97,59,1,10793,59,1,1084,97,115,104,59,1,8212,97,115,117,114,101,100,97,110,103,108,101,59,1,8737,114,59,3,55349,56618,111,59,1,8487,4,3,99,100,110,12945,12954,12985,114,111,5,181,1,59,12952,1,181,4,4,59,97,99,100,12964,12966,12971,12976,1,8739,115,116,59,1,42,105,114,59,1,10992,111,116,5,183,1,59,12983,1,183,117,115,4,3,59,98,100,12995,12997,13000,1,8722,59,1,8863,4,2,59,117,13006,13008,1,8760,59,1,10794,4,2,99,100,13017,13021,112,59,1,10971,114,59,1,8230,112,108,117,115,59,1,8723,4,2,100,112,13038,13044,101,108,115,59,1,8871,102,59,3,55349,56670,59,1,8723,4,2,99,116,13058,13063,114,59,3,55349,56514,112,111,115,59,1,8766,4,3,59,108,109,13077,13079,13087,1,956,116,105,109,97,112,59,1,8888,97,112,59,1,8888,4,24,71,76,82,86,97,98,99,100,101,102,103,104,105,106,108,109,111,112,114,115,116,117,118,119,13142,13165,13217,13229,13247,13330,13359,13414,13420,13508,13513,13579,13602,13626,13631,13762,13767,13855,13936,13995,14214,14285,14312,14432,4,2,103,116,13148,13152,59,3,8921,824,4,2,59,118,13158,13161,3,8811,8402,59,3,8811,824,4,3,101,108,116,13173,13200,13204,102,116,4,2,97,114,13181,13188,114,114,111,119,59,1,8653,105,103,104,116,97,114,114,111,119,59,1,8654,59,3,8920,824,4,2,59,118,13210,13213,3,8810,8402,59,3,8810,824,105,103,104,116,97,114,114,111,119,59,1,8655,4,2,68,100,13235,13241,97,115,104,59,1,8879,97,115,104,59,1,8878,4,5,98,99,110,112,116,13259,13264,13270,13275,13308,108,97,59,1,8711,117,116,101,59,1,324,103,59,3,8736,8402,4,5,59,69,105,111,112,13287,13289,13293,13298,13302,1,8777,59,3,10864,824,100,59,3,8779,824,115,59,1,329,114,111,120,59,1,8777,117,114,4,2,59,97,13316,13318,1,9838,108,4,2,59,115,13325,13327,1,9838,59,1,8469,4,2,115,117,13336,13344,112,5,160,1,59,13342,1,160,109,112,4,2,59,101,13352,13355,3,8782,824,59,3,8783,824,4,5,97,101,111,117,121,13371,13385,13391,13407,13411,4,2,112,114,13377,13380,59,1,10819,111,110,59,1,328,100,105,108,59,1,326,110,103,4,2,59,100,13399,13401,1,8775,111,116,59,3,10861,824,112,59,1,10818,59,1,1085,97,115,104,59,1,8211,4,7,59,65,97,100,113,115,120,13436,13438,13443,13466,13472,13478,13494,1,8800,114,114,59,1,8663,114,4,2,104,114,13450,13454,107,59,1,10532,4,2,59,111,13460,13462,1,8599,119,59,1,8599,111,116,59,3,8784,824,117,105,118,59,1,8802,4,2,101,105,13484,13489,97,114,59,1,10536,109,59,3,8770,824,105,115,116,4,2,59,115,13503,13505,1,8708,59,1,8708,114,59,3,55349,56619,4,4,69,101,115,116,13523,13527,13563,13568,59,3,8807,824,4,3,59,113,115,13535,13537,13559,1,8817,4,3,59,113,115,13545,13547,13551,1,8817,59,3,8807,824,108,97,110,116,59,3,10878,824,59,3,10878,824,105,109,59,1,8821,4,2,59,114,13574,13576,1,8815,59,1,8815,4,3,65,97,112,13587,13592,13597,114,114,59,1,8654,114,114,59,1,8622,97,114,59,1,10994,4,3,59,115,118,13610,13612,13623,1,8715,4,2,59,100,13618,13620,1,8956,59,1,8954,59,1,8715,99,121,59,1,1114,4,7,65,69,97,100,101,115,116,13647,13652,13656,13661,13665,13737,13742,114,114,59,1,8653,59,3,8806,824,114,114,59,1,8602,114,59,1,8229,4,4,59,102,113,115,13675,13677,13703,13725,1,8816,116,4,2,97,114,13684,13691,114,114,111,119,59,1,8602,105,103,104,116,97,114,114,111,119,59,1,8622,4,3,59,113,115,13711,13713,13717,1,8816,59,3,8806,824,108,97,110,116,59,3,10877,824,4,2,59,115,13731,13734,3,10877,824,59,1,8814,105,109,59,1,8820,4,2,59,114,13748,13750,1,8814,105,4,2,59,101,13757,13759,1,8938,59,1,8940,105,100,59,1,8740,4,2,112,116,13773,13778,102,59,3,55349,56671,5,172,3,59,105,110,13787,13789,13829,1,172,110,4,4,59,69,100,118,13800,13802,13806,13812,1,8713,59,3,8953,824,111,116,59,3,8949,824,4,3,97,98,99,13820,13823,13826,59,1,8713,59,1,8951,59,1,8950,105,4,2,59,118,13836,13838,1,8716,4,3,97,98,99,13846,13849,13852,59,1,8716,59,1,8958,59,1,8957,4,3,97,111,114,13863,13892,13899,114,4,4,59,97,115,116,13874,13876,13883,13888,1,8742,108,108,101,108,59,1,8742,108,59,3,11005,8421,59,3,8706,824,108,105,110,116,59,1,10772,4,3,59,99,101,13907,13909,13914,1,8832,117,101,59,1,8928,4,2,59,99,13920,13923,3,10927,824,4,2,59,101,13929,13931,1,8832,113,59,3,10927,824,4,4,65,97,105,116,13946,13951,13971,13982,114,114,59,1,8655,114,114,4,3,59,99,119,13961,13963,13967,1,8603,59,3,10547,824,59,3,8605,824,103,104,116,97,114,114,111,119,59,1,8603,114,105,4,2,59,101,13990,13992,1,8939,59,1,8941,4,7,99,104,105,109,112,113,117,14011,14036,14060,14080,14085,14090,14106,4,4,59,99,101,114,14021,14023,14028,14032,1,8833,117,101,59,1,8929,59,3,10928,824,59,3,55349,56515,111,114,116,4,2,109,112,14045,14050,105,100,59,1,8740,97,114,97,108,108,101,108,59,1,8742,109,4,2,59,101,14067,14069,1,8769,4,2,59,113,14075,14077,1,8772,59,1,8772,105,100,59,1,8740,97,114,59,1,8742,115,117,4,2,98,112,14098,14102,101,59,1,8930,101,59,1,8931,4,3,98,99,112,14114,14157,14171,4,4,59,69,101,115,14124,14126,14130,14133,1,8836,59,3,10949,824,59,1,8840,101,116,4,2,59,101,14141,14144,3,8834,8402,113,4,2,59,113,14151,14153,1,8840,59,3,10949,824,99,4,2,59,101,14164,14166,1,8833,113,59,3,10928,824,4,4,59,69,101,115,14181,14183,14187,14190,1,8837,59,3,10950,824,59,1,8841,101,116,4,2,59,101,14198,14201,3,8835,8402,113,4,2,59,113,14208,14210,1,8841,59,3,10950,824,4,4,103,105,108,114,14224,14228,14238,14242,108,59,1,8825,108,100,101,5,241,1,59,14236,1,241,103,59,1,8824,105,97,110,103,108,101,4,2,108,114,14254,14269,101,102,116,4,2,59,101,14263,14265,1,8938,113,59,1,8940,105,103,104,116,4,2,59,101,14279,14281,1,8939,113,59,1,8941,4,2,59,109,14291,14293,1,957,4,3,59,101,115,14301,14303,14308,1,35,114,111,59,1,8470,112,59,1,8199,4,9,68,72,97,100,103,105,108,114,115,14332,14338,14344,14349,14355,14369,14376,14408,14426,97,115,104,59,1,8877,97,114,114,59,1,10500,112,59,3,8781,8402,97,115,104,59,1,8876,4,2,101,116,14361,14365,59,3,8805,8402,59,3,62,8402,110,102,105,110,59,1,10718,4,3,65,101,116,14384,14389,14393,114,114,59,1,10498,59,3,8804,8402,4,2,59,114,14399,14402,3,60,8402,105,101,59,3,8884,8402,4,2,65,116,14414,14419,114,114,59,1,10499,114,105,101,59,3,8885,8402,105,109,59,3,8764,8402,4,3,65,97,110,14440,14445,14468,114,114,59,1,8662,114,4,2,104,114,14452,14456,107,59,1,10531,4,2,59,111,14462,14464,1,8598,119,59,1,8598,101,97,114,59,1,10535,4,18,83,97,99,100,101,102,103,104,105,108,109,111,112,114,115,116,117,118,14512,14515,14535,14560,14597,14603,14618,14643,14657,14662,14701,14741,14747,14769,14851,14877,14907,14916,59,1,9416,4,2,99,115,14521,14531,117,116,101,5,243,1,59,14529,1,243,116,59,1,8859,4,2,105,121,14541,14557,114,4,2,59,99,14548,14550,1,8858,5,244,1,59,14555,1,244,59,1,1086,4,5,97,98,105,111,115,14572,14577,14583,14587,14591,115,104,59,1,8861,108,97,99,59,1,337,118,59,1,10808,116,59,1,8857,111,108,100,59,1,10684,108,105,103,59,1,339,4,2,99,114,14609,14614,105,114,59,1,10687,59,3,55349,56620,4,3,111,114,116,14626,14630,14640,110,59,1,731,97,118,101,5,242,1,59,14638,1,242,59,1,10689,4,2,98,109,14649,14654,97,114,59,1,10677,59,1,937,110,116,59,1,8750,4,4,97,99,105,116,14672,14677,14693,14698,114,114,59,1,8634,4,2,105,114,14683,14687,114,59,1,10686,111,115,115,59,1,10683,110,101,59,1,8254,59,1,10688,4,3,97,101,105,14709,14714,14719,99,114,59,1,333,103,97,59,1,969,4,3,99,100,110,14727,14733,14736,114,111,110,59,1,959,59,1,10678,117,115,59,1,8854,112,102,59,3,55349,56672,4,3,97,101,108,14755,14759,14764,114,59,1,10679,114,112,59,1,10681,117,115,59,1,8853,4,7,59,97,100,105,111,115,118,14785,14787,14792,14831,14837,14841,14848,1,8744,114,114,59,1,8635,4,4,59,101,102,109,14802,14804,14817,14824,1,10845,114,4,2,59,111,14811,14813,1,8500,102,59,1,8500,5,170,1,59,14822,1,170,5,186,1,59,14829,1,186,103,111,102,59,1,8886,114,59,1,10838,108,111,112,101,59,1,10839,59,1,10843,4,3,99,108,111,14859,14863,14873,114,59,1,8500,97,115,104,5,248,1,59,14871,1,248,108,59,1,8856,105,4,2,108,109,14884,14893,100,101,5,245,1,59,14891,1,245,101,115,4,2,59,97,14901,14903,1,8855,115,59,1,10806,109,108,5,246,1,59,14914,1,246,98,97,114,59,1,9021,4,12,97,99,101,102,104,105,108,109,111,114,115,117,14948,14992,14996,15033,15038,15068,15090,15189,15192,15222,15427,15441,114,4,4,59,97,115,116,14959,14961,14976,14989,1,8741,5,182,2,59,108,14968,14970,1,182,108,101,108,59,1,8741,4,2,105,108,14982,14986,109,59,1,10995,59,1,11005,59,1,8706,121,59,1,1087,114,4,5,99,105,109,112,116,15009,15014,15019,15024,15027,110,116,59,1,37,111,100,59,1,46,105,108,59,1,8240,59,1,8869,101,110,107,59,1,8241,114,59,3,55349,56621,4,3,105,109,111,15046,15057,15063,4,2,59,118,15052,15054,1,966,59,1,981,109,97,116,59,1,8499,110,101,59,1,9742,4,3,59,116,118,15076,15078,15087,1,960,99,104,102,111,114,107,59,1,8916,59,1,982,4,2,97,117,15096,15119,110,4,2,99,107,15103,15115,107,4,2,59,104,15110,15112,1,8463,59,1,8462,118,59,1,8463,115,4,9,59,97,98,99,100,101,109,115,116,15140,15142,15148,15151,15156,15168,15171,15179,15184,1,43,99,105,114,59,1,10787,59,1,8862,105,114,59,1,10786,4,2,111,117,15162,15165,59,1,8724,59,1,10789,59,1,10866,110,5,177,1,59,15177,1,177,105,109,59,1,10790,119,111,59,1,10791,59,1,177,4,3,105,112,117,15200,15208,15213,110,116,105,110,116,59,1,10773,102,59,3,55349,56673,110,100,5,163,1,59,15220,1,163,4,10,59,69,97,99,101,105,110,111,115,117,15244,15246,15249,15253,15258,15334,15347,15367,15416,15421,1,8826,59,1,10931,112,59,1,10935,117,101,59,1,8828,4,2,59,99,15264,15266,1,10927,4,6,59,97,99,101,110,115,15280,15282,15290,15299,15303,15329,1,8826,112,112,114,111,120,59,1,10935,117,114,108,121,101,113,59,1,8828,113,59,1,10927,4,3,97,101,115,15311,15319,15324,112,112,114,111,120,59,1,10937,113,113,59,1,10933,105,109,59,1,8936,105,109,59,1,8830,109,101,4,2,59,115,15342,15344,1,8242,59,1,8473,4,3,69,97,115,15355,15358,15362,59,1,10933,112,59,1,10937,105,109,59,1,8936,4,3,100,102,112,15375,15378,15404,59,1,8719,4,3,97,108,115,15386,15392,15398,108,97,114,59,1,9006,105,110,101,59,1,8978,117,114,102,59,1,8979,4,2,59,116,15410,15412,1,8733,111,59,1,8733,105,109,59,1,8830,114,101,108,59,1,8880,4,2,99,105,15433,15438,114,59,3,55349,56517,59,1,968,110,99,115,112,59,1,8200,4,6,102,105,111,112,115,117,15462,15467,15472,15478,15485,15491,114,59,3,55349,56622,110,116,59,1,10764,112,102,59,3,55349,56674,114,105,109,101,59,1,8279,99,114,59,3,55349,56518,4,3,97,101,111,15499,15520,15534,116,4,2,101,105,15506,15515,114,110,105,111,110,115,59,1,8461,110,116,59,1,10774,115,116,4,2,59,101,15528,15530,1,63,113,59,1,8799,116,5,34,1,59,15540,1,34,4,21,65,66,72,97,98,99,100,101,102,104,105,108,109,110,111,112,114,115,116,117,120,15586,15609,15615,15620,15796,15855,15893,15931,15977,16001,16039,16183,16204,16222,16228,16285,16312,16318,16363,16408,16416,4,3,97,114,116,15594,15599,15603,114,114,59,1,8667,114,59,1,8658,97,105,108,59,1,10524,97,114,114,59,1,10511,97,114,59,1,10596,4,7,99,100,101,110,113,114,116,15636,15651,15656,15664,15687,15696,15770,4,2,101,117,15642,15646,59,3,8765,817,116,101,59,1,341,105,99,59,1,8730,109,112,116,121,118,59,1,10675,103,4,4,59,100,101,108,15675,15677,15680,15683,1,10217,59,1,10642,59,1,10661,101,59,1,10217,117,111,5,187,1,59,15694,1,187,114,4,11,59,97,98,99,102,104,108,112,115,116,119,15721,15723,15727,15739,15742,15746,15750,15754,15758,15763,15767,1,8594,112,59,1,10613,4,2,59,102,15733,15735,1,8677,115,59,1,10528,59,1,10547,115,59,1,10526,107,59,1,8618,112,59,1,8620,108,59,1,10565,105,109,59,1,10612,108,59,1,8611,59,1,8605,4,2,97,105,15776,15781,105,108,59,1,10522,111,4,2,59,110,15788,15790,1,8758,97,108,115,59,1,8474,4,3,97,98,114,15804,15809,15814,114,114,59,1,10509,114,107,59,1,10099,4,2,97,107,15820,15833,99,4,2,101,107,15827,15830,59,1,125,59,1,93,4,2,101,115,15839,15842,59,1,10636,108,4,2,100,117,15849,15852,59,1,10638,59,1,10640,4,4,97,101,117,121,15865,15871,15886,15890,114,111,110,59,1,345,4,2,100,105,15877,15882,105,108,59,1,343,108,59,1,8969,98,59,1,125,59,1,1088,4,4,99,108,113,115,15903,15907,15914,15927,97,59,1,10551,100,104,97,114,59,1,10601,117,111,4,2,59,114,15922,15924,1,8221,59,1,8221,104,59,1,8627,4,3,97,99,103,15939,15966,15970,108,4,4,59,105,112,115,15950,15952,15957,15963,1,8476,110,101,59,1,8475,97,114,116,59,1,8476,59,1,8477,116,59,1,9645,5,174,1,59,15975,1,174,4,3,105,108,114,15985,15991,15997,115,104,116,59,1,10621,111,111,114,59,1,8971,59,3,55349,56623,4,2,97,111,16007,16028,114,4,2,100,117,16014,16017,59,1,8641,4,2,59,108,16023,16025,1,8640,59,1,10604,4,2,59,118,16034,16036,1,961,59,1,1009,4,3,103,110,115,16047,16167,16171,104,116,4,6,97,104,108,114,115,116,16063,16081,16103,16130,16143,16155,114,114,111,119,4,2,59,116,16073,16075,1,8594,97,105,108,59,1,8611,97,114,112,111,111,110,4,2,100,117,16093,16099,111,119,110,59,1,8641,112,59,1,8640,101,102,116,4,2,97,104,16112,16120,114,114,111,119,115,59,1,8644,97,114,112,111,111,110,115,59,1,8652,105,103,104,116,97,114,114,111,119,115,59,1,8649,113,117,105,103,97,114,114,111,119,59,1,8605,104,114,101,101,116,105,109,101,115,59,1,8908,103,59,1,730,105,110,103,100,111,116,115,101,113,59,1,8787,4,3,97,104,109,16191,16196,16201,114,114,59,1,8644,97,114,59,1,8652,59,1,8207,111,117,115,116,4,2,59,97,16214,16216,1,9137,99,104,101,59,1,9137,109,105,100,59,1,10990,4,4,97,98,112,116,16238,16252,16257,16278,4,2,110,114,16244,16248,103,59,1,10221,114,59,1,8702,114,107,59,1,10215,4,3,97,102,108,16265,16269,16273,114,59,1,10630,59,3,55349,56675,117,115,59,1,10798,105,109,101,115,59,1,10805,4,2,97,112,16291,16304,114,4,2,59,103,16298,16300,1,41,116,59,1,10644,111,108,105,110,116,59,1,10770,97,114,114,59,1,8649,4,4,97,99,104,113,16328,16334,16339,16342,113,117,111,59,1,8250,114,59,3,55349,56519,59,1,8625,4,2,98,117,16348,16351,59,1,93,111,4,2,59,114,16358,16360,1,8217,59,1,8217,4,3,104,105,114,16371,16377,16383,114,101,101,59,1,8908,109,101,115,59,1,8906,105,4,4,59,101,102,108,16394,16396,16399,16402,1,9657,59,1,8885,59,1,9656,116,114,105,59,1,10702,108,117,104,97,114,59,1,10600,59,1,8478,4,19,97,98,99,100,101,102,104,105,108,109,111,112,113,114,115,116,117,119,122,16459,16466,16472,16572,16590,16672,16687,16746,16844,16850,16924,16963,16988,17115,17121,17154,17206,17614,17656,99,117,116,101,59,1,347,113,117,111,59,1,8218,4,10,59,69,97,99,101,105,110,112,115,121,16494,16496,16499,16513,16518,16531,16536,16556,16564,16569,1,8827,59,1,10932,4,2,112,114,16505,16508,59,1,10936,111,110,59,1,353,117,101,59,1,8829,4,2,59,100,16524,16526,1,10928,105,108,59,1,351,114,99,59,1,349,4,3,69,97,115,16544,16547,16551,59,1,10934,112,59,1,10938,105,109,59,1,8937,111,108,105,110,116,59,1,10771,105,109,59,1,8831,59,1,1089,111,116,4,3,59,98,101,16582,16584,16587,1,8901,59,1,8865,59,1,10854,4,7,65,97,99,109,115,116,120,16606,16611,16634,16642,16646,16652,16668,114,114,59,1,8664,114,4,2,104,114,16618,16622,107,59,1,10533,4,2,59,111,16628,16630,1,8600,119,59,1,8600,116,5,167,1,59,16640,1,167,105,59,1,59,119,97,114,59,1,10537,109,4,2,105,110,16659,16665,110,117,115,59,1,8726,59,1,8726,116,59,1,10038,114,4,2,59,111,16679,16682,3,55349,56624,119,110,59,1,8994,4,4,97,99,111,121,16697,16702,16716,16739,114,112,59,1,9839,4,2,104,121,16708,16713,99,121,59,1,1097,59,1,1096,114,116,4,2,109,112,16724,16729,105,100,59,1,8739,97,114,97,108,108,101,108,59,1,8741,5,173,1,59,16744,1,173,4,2,103,109,16752,16770,109,97,4,3,59,102,118,16762,16764,16767,1,963,59,1,962,59,1,962,4,8,59,100,101,103,108,110,112,114,16788,16790,16795,16806,16817,16828,16832,16838,1,8764,111,116,59,1,10858,4,2,59,113,16801,16803,1,8771,59,1,8771,4,2,59,69,16812,16814,1,10910,59,1,10912,4,2,59,69,16823,16825,1,10909,59,1,10911,101,59,1,8774,108,117,115,59,1,10788,97,114,114,59,1,10610,97,114,114,59,1,8592,4,4,97,101,105,116,16860,16883,16891,16904,4,2,108,115,16866,16878,108,115,101,116,109,105,110,117,115,59,1,8726,104,112,59,1,10803,112,97,114,115,108,59,1,10724,4,2,100,108,16897,16900,59,1,8739,101,59,1,8995,4,2,59,101,16910,16912,1,10922,4,2,59,115,16918,16920,1,10924,59,3,10924,65024,4,3,102,108,112,16932,16938,16958,116,99,121,59,1,1100,4,2,59,98,16944,16946,1,47,4,2,59,97,16952,16954,1,10692,114,59,1,9023,102,59,3,55349,56676,97,4,2,100,114,16970,16985,101,115,4,2,59,117,16978,16980,1,9824,105,116,59,1,9824,59,1,8741,4,3,99,115,117,16996,17028,17089,4,2,97,117,17002,17015,112,4,2,59,115,17009,17011,1,8851,59,3,8851,65024,112,4,2,59,115,17022,17024,1,8852,59,3,8852,65024,117,4,2,98,112,17035,17062,4,3,59,101,115,17043,17045,17048,1,8847,59,1,8849,101,116,4,2,59,101,17056,17058,1,8847,113,59,1,8849,4,3,59,101,115,17070,17072,17075,1,8848,59,1,8850,101,116,4,2,59,101,17083,17085,1,8848,113,59,1,8850,4,3,59,97,102,17097,17099,17112,1,9633,114,4,2,101,102,17106,17109,59,1,9633,59,1,9642,59,1,9642,97,114,114,59,1,8594,4,4,99,101,109,116,17131,17136,17142,17148,114,59,3,55349,56520,116,109,110,59,1,8726,105,108,101,59,1,8995,97,114,102,59,1,8902,4,2,97,114,17160,17172,114,4,2,59,102,17167,17169,1,9734,59,1,9733,4,2,97,110,17178,17202,105,103,104,116,4,2,101,112,17188,17197,112,115,105,108,111,110,59,1,1013,104,105,59,1,981,115,59,1,175,4,5,98,99,109,110,112,17218,17351,17420,17423,17427,4,9,59,69,100,101,109,110,112,114,115,17238,17240,17243,17248,17261,17267,17279,17285,17291,1,8834,59,1,10949,111,116,59,1,10941,4,2,59,100,17254,17256,1,8838,111,116,59,1,10947,117,108,116,59,1,10945,4,2,69,101,17273,17276,59,1,10955,59,1,8842,108,117,115,59,1,10943,97,114,114,59,1,10617,4,3,101,105,117,17299,17335,17339,116,4,3,59,101,110,17308,17310,17322,1,8834,113,4,2,59,113,17317,17319,1,8838,59,1,10949,101,113,4,2,59,113,17330,17332,1,8842,59,1,10955,109,59,1,10951,4,2,98,112,17345,17348,59,1,10965,59,1,10963,99,4,6,59,97,99,101,110,115,17366,17368,17376,17385,17389,17415,1,8827,112,112,114,111,120,59,1,10936,117,114,108,121,101,113,59,1,8829,113,59,1,10928,4,3,97,101,115,17397,17405,17410,112,112,114,111,120,59,1,10938,113,113,59,1,10934,105,109,59,1,8937,105,109,59,1,8831,59,1,8721,103,59,1,9834,4,13,49,50,51,59,69,100,101,104,108,109,110,112,115,17455,17462,17469,17476,17478,17481,17496,17509,17524,17530,17536,17548,17554,5,185,1,59,17460,1,185,5,178,1,59,17467,1,178,5,179,1,59,17474,1,179,1,8835,59,1,10950,4,2,111,115,17487,17491,116,59,1,10942,117,98,59,1,10968,4,2,59,100,17502,17504,1,8839,111,116,59,1,10948,115,4,2,111,117,17516,17520,108,59,1,10185,98,59,1,10967,97,114,114,59,1,10619,117,108,116,59,1,10946,4,2,69,101,17542,17545,59,1,10956,59,1,8843,108,117,115,59,1,10944,4,3,101,105,117,17562,17598,17602,116,4,3,59,101,110,17571,17573,17585,1,8835,113,4,2,59,113,17580,17582,1,8839,59,1,10950,101,113,4,2,59,113,17593,17595,1,8843,59,1,10956,109,59,1,10952,4,2,98,112,17608,17611,59,1,10964,59,1,10966,4,3,65,97,110,17622,17627,17650,114,114,59,1,8665,114,4,2,104,114,17634,17638,107,59,1,10534,4,2,59,111,17644,17646,1,8601,119,59,1,8601,119,97,114,59,1,10538,108,105,103,5,223,1,59,17664,1,223,4,13,97,98,99,100,101,102,104,105,111,112,114,115,119,17694,17709,17714,17737,17742,17749,17754,17860,17905,17957,17964,18090,18122,4,2,114,117,17700,17706,103,101,116,59,1,8982,59,1,964,114,107,59,1,9140,4,3,97,101,121,17722,17728,17734,114,111,110,59,1,357,100,105,108,59,1,355,59,1,1090,111,116,59,1,8411,108,114,101,99,59,1,8981,114,59,3,55349,56625,4,4,101,105,107,111,17764,17805,17836,17851,4,2,114,116,17770,17786,101,4,2,52,102,17777,17780,59,1,8756,111,114,101,59,1,8756,97,4,3,59,115,118,17795,17797,17802,1,952,121,109,59,1,977,59,1,977,4,2,99,110,17811,17831,107,4,2,97,115,17818,17826,112,112,114,111,120,59,1,8776,105,109,59,1,8764,115,112,59,1,8201,4,2,97,115,17842,17846,112,59,1,8776,105,109,59,1,8764,114,110,5,254,1,59,17858,1,254,4,3,108,109,110,17868,17873,17901,100,101,59,1,732,101,115,5,215,3,59,98,100,17884,17886,17898,1,215,4,2,59,97,17892,17894,1,8864,114,59,1,10801,59,1,10800,116,59,1,8749,4,3,101,112,115,17913,17917,17953,97,59,1,10536,4,4,59,98,99,102,17927,17929,17934,17939,1,8868,111,116,59,1,9014,105,114,59,1,10993,4,2,59,111,17945,17948,3,55349,56677,114,107,59,1,10970,97,59,1,10537,114,105,109,101,59,1,8244,4,3,97,105,112,17972,17977,18082,100,101,59,1,8482,4,7,97,100,101,109,112,115,116,17993,18051,18056,18059,18066,18072,18076,110,103,108,101,4,5,59,100,108,113,114,18009,18011,18017,18032,18035,1,9653,111,119,110,59,1,9663,101,102,116,4,2,59,101,18026,18028,1,9667,113,59,1,8884,59,1,8796,105,103,104,116,4,2,59,101,18045,18047,1,9657,113,59,1,8885,111,116,59,1,9708,59,1,8796,105,110,117,115,59,1,10810,108,117,115,59,1,10809,98,59,1,10701,105,109,101,59,1,10811,101,122,105,117,109,59,1,9186,4,3,99,104,116,18098,18111,18116,4,2,114,121,18104,18108,59,3,55349,56521,59,1,1094,99,121,59,1,1115,114,111,107,59,1,359,4,2,105,111,18128,18133,120,116,59,1,8812,104,101,97,100,4,2,108,114,18143,18154,101,102,116,97,114,114,111,119,59,1,8606,105,103,104,116,97,114,114,111,119,59,1,8608,4,18,65,72,97,98,99,100,102,103,104,108,109,111,112,114,115,116,117,119,18204,18209,18214,18234,18250,18268,18292,18308,18319,18343,18379,18397,18413,18504,18547,18553,18584,18603,114,114,59,1,8657,97,114,59,1,10595,4,2,99,114,18220,18230,117,116,101,5,250,1,59,18228,1,250,114,59,1,8593,114,4,2,99,101,18241,18245,121,59,1,1118,118,101,59,1,365,4,2,105,121,18256,18265,114,99,5,251,1,59,18263,1,251,59,1,1091,4,3,97,98,104,18276,18281,18287,114,114,59,1,8645,108,97,99,59,1,369,97,114,59,1,10606,4,2,105,114,18298,18304,115,104,116,59,1,10622,59,3,55349,56626,114,97,118,101,5,249,1,59,18317,1,249,4,2,97,98,18325,18338,114,4,2,108,114,18332,18335,59,1,8639,59,1,8638,108,107,59,1,9600,4,2,99,116,18349,18374,4,2,111,114,18355,18369,114,110,4,2,59,101,18363,18365,1,8988,114,59,1,8988,111,112,59,1,8975,114,105,59,1,9720,4,2,97,108,18385,18390,99,114,59,1,363,5,168,1,59,18395,1,168,4,2,103,112,18403,18408,111,110,59,1,371,102,59,3,55349,56678,4,6,97,100,104,108,115,117,18427,18434,18445,18470,18475,18494,114,114,111,119,59,1,8593,111,119,110,97,114,114,111,119,59,1,8597,97,114,112,111,111,110,4,2,108,114,18457,18463,101,102,116,59,1,8639,105,103,104,116,59,1,8638,117,115,59,1,8846,105,4,3,59,104,108,18484,18486,18489,1,965,59,1,978,111,110,59,1,965,112,97,114,114,111,119,115,59,1,8648,4,3,99,105,116,18512,18537,18542,4,2,111,114,18518,18532,114,110,4,2,59,101,18526,18528,1,8989,114,59,1,8989,111,112,59,1,8974,110,103,59,1,367,114,105,59,1,9721,99,114,59,3,55349,56522,4,3,100,105,114,18561,18566,18572,111,116,59,1,8944,108,100,101,59,1,361,105,4,2,59,102,18579,18581,1,9653,59,1,9652,4,2,97,109,18590,18595,114,114,59,1,8648,108,5,252,1,59,18601,1,252,97,110,103,108,101,59,1,10663,4,15,65,66,68,97,99,100,101,102,108,110,111,112,114,115,122,18643,18648,18661,18667,18847,18851,18857,18904,18909,18915,18931,18937,18943,18949,18996,114,114,59,1,8661,97,114,4,2,59,118,18656,18658,1,10984,59,1,10985,97,115,104,59,1,8872,4,2,110,114,18673,18679,103,114,116,59,1,10652,4,7,101,107,110,112,114,115,116,18695,18704,18711,18720,18742,18754,18810,112,115,105,108,111,110,59,1,1013,97,112,112,97,59,1,1008,111,116,104,105,110,103,59,1,8709,4,3,104,105,114,18728,18732,18735,105,59,1,981,59,1,982,111,112,116,111,59,1,8733,4,2,59,104,18748,18750,1,8597,111,59,1,1009,4,2,105,117,18760,18766,103,109,97,59,1,962,4,2,98,112,18772,18791,115,101,116,110,101,113,4,2,59,113,18784,18787,3,8842,65024,59,3,10955,65024,115,101,116,110,101,113,4,2,59,113,18803,18806,3,8843,65024,59,3,10956,65024,4,2,104,114,18816,18822,101,116,97,59,1,977,105,97,110,103,108,101,4,2,108,114,18834,18840,101,102,116,59,1,8882,105,103,104,116,59,1,8883,121,59,1,1074,97,115,104,59,1,8866,4,3,101,108,114,18865,18884,18890,4,3,59,98,101,18873,18875,18880,1,8744,97,114,59,1,8891,113,59,1,8794,108,105,112,59,1,8942,4,2,98,116,18896,18901,97,114,59,1,124,59,1,124,114,59,3,55349,56627,116,114,105,59,1,8882,115,117,4,2,98,112,18923,18927,59,3,8834,8402,59,3,8835,8402,112,102,59,3,55349,56679,114,111,112,59,1,8733,116,114,105,59,1,8883,4,2,99,117,18955,18960,114,59,3,55349,56523,4,2,98,112,18966,18981,110,4,2,69,101,18973,18977,59,3,10955,65024,59,3,8842,65024,110,4,2,69,101,18988,18992,59,3,10956,65024,59,3,8843,65024,105,103,122,97,103,59,1,10650,4,7,99,101,102,111,112,114,115,19020,19026,19061,19066,19072,19075,19089,105,114,99,59,1,373,4,2,100,105,19032,19055,4,2,98,103,19038,19043,97,114,59,1,10847,101,4,2,59,113,19050,19052,1,8743,59,1,8793,101,114,112,59,1,8472,114,59,3,55349,56628,112,102,59,3,55349,56680,59,1,8472,4,2,59,101,19081,19083,1,8768,97,116,104,59,1,8768,99,114,59,3,55349,56524,4,14,99,100,102,104,105,108,109,110,111,114,115,117,118,119,19125,19146,19152,19157,19173,19176,19192,19197,19202,19236,19252,19269,19286,19291,4,3,97,105,117,19133,19137,19142,112,59,1,8898,114,99,59,1,9711,112,59,1,8899,116,114,105,59,1,9661,114,59,3,55349,56629,4,2,65,97,19163,19168,114,114,59,1,10234,114,114,59,1,10231,59,1,958,4,2,65,97,19182,19187,114,114,59,1,10232,114,114,59,1,10229,97,112,59,1,10236,105,115,59,1,8955,4,3,100,112,116,19210,19215,19230,111,116,59,1,10752,4,2,102,108,19221,19225,59,3,55349,56681,117,115,59,1,10753,105,109,101,59,1,10754,4,2,65,97,19242,19247,114,114,59,1,10233,114,114,59,1,10230,4,2,99,113,19258,19263,114,59,3,55349,56525,99,117,112,59,1,10758,4,2,112,116,19275,19281,108,117,115,59,1,10756,114,105,59,1,9651,101,101,59,1,8897,101,100,103,101,59,1,8896,4,8,97,99,101,102,105,111,115,117,19316,19335,19349,19357,19362,19367,19373,19379,99,4,2,117,121,19323,19332,116,101,5,253,1,59,19330,1,253,59,1,1103,4,2,105,121,19341,19346,114,99,59,1,375,59,1,1099,110,5,165,1,59,19355,1,165,114,59,3,55349,56630,99,121,59,1,1111,112,102,59,3,55349,56682,99,114,59,3,55349,56526,4,2,99,109,19385,19389,121,59,1,1102,108,5,255,1,59,19395,1,255,4,10,97,99,100,101,102,104,105,111,115,119,19419,19426,19441,19446,19462,19467,19472,19480,19486,19492,99,117,116,101,59,1,378,4,2,97,121,19432,19438,114,111,110,59,1,382,59,1,1079,111,116,59,1,380,4,2,101,116,19452,19458,116,114,102,59,1,8488,97,59,1,950,114,59,3,55349,56631,99,121,59,1,1078,103,114,97,114,114,59,1,8669,112,102,59,3,55349,56683,99,114,59,3,55349,56527,4,2,106,110,19498,19501,59,1,8205,106,59,1,8204]);
	return namedEntityData$1;
}

var tokenizer$1;
var hasRequiredTokenizer$1;

function requireTokenizer$1 () {
	if (hasRequiredTokenizer$1) return tokenizer$1;
	hasRequiredTokenizer$1 = 1;

	const Preprocessor = requirePreprocessor$1();
	const unicode = requireUnicode$1();
	const neTree = requireNamedEntityData$1();
	const ERR = requireErrorCodes$1();

	//Aliases
	const $ = unicode.CODE_POINTS;
	const $$ = unicode.CODE_POINT_SEQUENCES;

	//C1 Unicode control character reference replacements
	const C1_CONTROLS_REFERENCE_REPLACEMENTS = {
	    0x80: 0x20ac,
	    0x82: 0x201a,
	    0x83: 0x0192,
	    0x84: 0x201e,
	    0x85: 0x2026,
	    0x86: 0x2020,
	    0x87: 0x2021,
	    0x88: 0x02c6,
	    0x89: 0x2030,
	    0x8a: 0x0160,
	    0x8b: 0x2039,
	    0x8c: 0x0152,
	    0x8e: 0x017d,
	    0x91: 0x2018,
	    0x92: 0x2019,
	    0x93: 0x201c,
	    0x94: 0x201d,
	    0x95: 0x2022,
	    0x96: 0x2013,
	    0x97: 0x2014,
	    0x98: 0x02dc,
	    0x99: 0x2122,
	    0x9a: 0x0161,
	    0x9b: 0x203a,
	    0x9c: 0x0153,
	    0x9e: 0x017e,
	    0x9f: 0x0178
	};

	// Named entity tree flags
	const HAS_DATA_FLAG = 1 << 0;
	const DATA_DUPLET_FLAG = 1 << 1;
	const HAS_BRANCHES_FLAG = 1 << 2;
	const MAX_BRANCH_MARKER_VALUE = HAS_DATA_FLAG | DATA_DUPLET_FLAG | HAS_BRANCHES_FLAG;

	//States
	const DATA_STATE = 'DATA_STATE';
	const RCDATA_STATE = 'RCDATA_STATE';
	const RAWTEXT_STATE = 'RAWTEXT_STATE';
	const SCRIPT_DATA_STATE = 'SCRIPT_DATA_STATE';
	const PLAINTEXT_STATE = 'PLAINTEXT_STATE';
	const TAG_OPEN_STATE = 'TAG_OPEN_STATE';
	const END_TAG_OPEN_STATE = 'END_TAG_OPEN_STATE';
	const TAG_NAME_STATE = 'TAG_NAME_STATE';
	const RCDATA_LESS_THAN_SIGN_STATE = 'RCDATA_LESS_THAN_SIGN_STATE';
	const RCDATA_END_TAG_OPEN_STATE = 'RCDATA_END_TAG_OPEN_STATE';
	const RCDATA_END_TAG_NAME_STATE = 'RCDATA_END_TAG_NAME_STATE';
	const RAWTEXT_LESS_THAN_SIGN_STATE = 'RAWTEXT_LESS_THAN_SIGN_STATE';
	const RAWTEXT_END_TAG_OPEN_STATE = 'RAWTEXT_END_TAG_OPEN_STATE';
	const RAWTEXT_END_TAG_NAME_STATE = 'RAWTEXT_END_TAG_NAME_STATE';
	const SCRIPT_DATA_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_LESS_THAN_SIGN_STATE';
	const SCRIPT_DATA_END_TAG_OPEN_STATE = 'SCRIPT_DATA_END_TAG_OPEN_STATE';
	const SCRIPT_DATA_END_TAG_NAME_STATE = 'SCRIPT_DATA_END_TAG_NAME_STATE';
	const SCRIPT_DATA_ESCAPE_START_STATE = 'SCRIPT_DATA_ESCAPE_START_STATE';
	const SCRIPT_DATA_ESCAPE_START_DASH_STATE = 'SCRIPT_DATA_ESCAPE_START_DASH_STATE';
	const SCRIPT_DATA_ESCAPED_STATE = 'SCRIPT_DATA_ESCAPED_STATE';
	const SCRIPT_DATA_ESCAPED_DASH_STATE = 'SCRIPT_DATA_ESCAPED_DASH_STATE';
	const SCRIPT_DATA_ESCAPED_DASH_DASH_STATE = 'SCRIPT_DATA_ESCAPED_DASH_DASH_STATE';
	const SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE';
	const SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE = 'SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE';
	const SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE = 'SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE';
	const SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE';
	const SCRIPT_DATA_DOUBLE_ESCAPED_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_STATE';
	const SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE';
	const SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE';
	const SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE';
	const SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE';
	const BEFORE_ATTRIBUTE_NAME_STATE = 'BEFORE_ATTRIBUTE_NAME_STATE';
	const ATTRIBUTE_NAME_STATE = 'ATTRIBUTE_NAME_STATE';
	const AFTER_ATTRIBUTE_NAME_STATE = 'AFTER_ATTRIBUTE_NAME_STATE';
	const BEFORE_ATTRIBUTE_VALUE_STATE = 'BEFORE_ATTRIBUTE_VALUE_STATE';
	const ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE = 'ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE';
	const ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE = 'ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE';
	const ATTRIBUTE_VALUE_UNQUOTED_STATE = 'ATTRIBUTE_VALUE_UNQUOTED_STATE';
	const AFTER_ATTRIBUTE_VALUE_QUOTED_STATE = 'AFTER_ATTRIBUTE_VALUE_QUOTED_STATE';
	const SELF_CLOSING_START_TAG_STATE = 'SELF_CLOSING_START_TAG_STATE';
	const BOGUS_COMMENT_STATE = 'BOGUS_COMMENT_STATE';
	const MARKUP_DECLARATION_OPEN_STATE = 'MARKUP_DECLARATION_OPEN_STATE';
	const COMMENT_START_STATE = 'COMMENT_START_STATE';
	const COMMENT_START_DASH_STATE = 'COMMENT_START_DASH_STATE';
	const COMMENT_STATE = 'COMMENT_STATE';
	const COMMENT_LESS_THAN_SIGN_STATE = 'COMMENT_LESS_THAN_SIGN_STATE';
	const COMMENT_LESS_THAN_SIGN_BANG_STATE = 'COMMENT_LESS_THAN_SIGN_BANG_STATE';
	const COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE = 'COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE';
	const COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE = 'COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE';
	const COMMENT_END_DASH_STATE = 'COMMENT_END_DASH_STATE';
	const COMMENT_END_STATE = 'COMMENT_END_STATE';
	const COMMENT_END_BANG_STATE = 'COMMENT_END_BANG_STATE';
	const DOCTYPE_STATE = 'DOCTYPE_STATE';
	const BEFORE_DOCTYPE_NAME_STATE = 'BEFORE_DOCTYPE_NAME_STATE';
	const DOCTYPE_NAME_STATE = 'DOCTYPE_NAME_STATE';
	const AFTER_DOCTYPE_NAME_STATE = 'AFTER_DOCTYPE_NAME_STATE';
	const AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE = 'AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE';
	const BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE = 'BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE';
	const DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE = 'DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE';
	const DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE = 'DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE';
	const AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE = 'AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE';
	const BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE = 'BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE';
	const AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE = 'AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE';
	const BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE = 'BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE';
	const DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE = 'DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE';
	const DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE = 'DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE';
	const AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE = 'AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE';
	const BOGUS_DOCTYPE_STATE = 'BOGUS_DOCTYPE_STATE';
	const CDATA_SECTION_STATE = 'CDATA_SECTION_STATE';
	const CDATA_SECTION_BRACKET_STATE = 'CDATA_SECTION_BRACKET_STATE';
	const CDATA_SECTION_END_STATE = 'CDATA_SECTION_END_STATE';
	const CHARACTER_REFERENCE_STATE = 'CHARACTER_REFERENCE_STATE';
	const NAMED_CHARACTER_REFERENCE_STATE = 'NAMED_CHARACTER_REFERENCE_STATE';
	const AMBIGUOUS_AMPERSAND_STATE = 'AMBIGUOS_AMPERSAND_STATE';
	const NUMERIC_CHARACTER_REFERENCE_STATE = 'NUMERIC_CHARACTER_REFERENCE_STATE';
	const HEXADEMICAL_CHARACTER_REFERENCE_START_STATE = 'HEXADEMICAL_CHARACTER_REFERENCE_START_STATE';
	const DECIMAL_CHARACTER_REFERENCE_START_STATE = 'DECIMAL_CHARACTER_REFERENCE_START_STATE';
	const HEXADEMICAL_CHARACTER_REFERENCE_STATE = 'HEXADEMICAL_CHARACTER_REFERENCE_STATE';
	const DECIMAL_CHARACTER_REFERENCE_STATE = 'DECIMAL_CHARACTER_REFERENCE_STATE';
	const NUMERIC_CHARACTER_REFERENCE_END_STATE = 'NUMERIC_CHARACTER_REFERENCE_END_STATE';

	//Utils

	//OPTIMIZATION: these utility functions should not be moved out of this module. V8 Crankshaft will not inline
	//this functions if they will be situated in another module due to context switch.
	//Always perform inlining check before modifying this functions ('node --trace-inlining').
	function isWhitespace(cp) {
	    return cp === $.SPACE || cp === $.LINE_FEED || cp === $.TABULATION || cp === $.FORM_FEED;
	}

	function isAsciiDigit(cp) {
	    return cp >= $.DIGIT_0 && cp <= $.DIGIT_9;
	}

	function isAsciiUpper(cp) {
	    return cp >= $.LATIN_CAPITAL_A && cp <= $.LATIN_CAPITAL_Z;
	}

	function isAsciiLower(cp) {
	    return cp >= $.LATIN_SMALL_A && cp <= $.LATIN_SMALL_Z;
	}

	function isAsciiLetter(cp) {
	    return isAsciiLower(cp) || isAsciiUpper(cp);
	}

	function isAsciiAlphaNumeric(cp) {
	    return isAsciiLetter(cp) || isAsciiDigit(cp);
	}

	function isAsciiUpperHexDigit(cp) {
	    return cp >= $.LATIN_CAPITAL_A && cp <= $.LATIN_CAPITAL_F;
	}

	function isAsciiLowerHexDigit(cp) {
	    return cp >= $.LATIN_SMALL_A && cp <= $.LATIN_SMALL_F;
	}

	function isAsciiHexDigit(cp) {
	    return isAsciiDigit(cp) || isAsciiUpperHexDigit(cp) || isAsciiLowerHexDigit(cp);
	}

	function toAsciiLowerCodePoint(cp) {
	    return cp + 0x0020;
	}

	//NOTE: String.fromCharCode() function can handle only characters from BMP subset.
	//So, we need to workaround this manually.
	//(see: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/fromCharCode#Getting_it_to_work_with_higher_values)
	function toChar(cp) {
	    if (cp <= 0xffff) {
	        return String.fromCharCode(cp);
	    }

	    cp -= 0x10000;
	    return String.fromCharCode(((cp >>> 10) & 0x3ff) | 0xd800) + String.fromCharCode(0xdc00 | (cp & 0x3ff));
	}

	function toAsciiLowerChar(cp) {
	    return String.fromCharCode(toAsciiLowerCodePoint(cp));
	}

	function findNamedEntityTreeBranch(nodeIx, cp) {
	    const branchCount = neTree[++nodeIx];
	    let lo = ++nodeIx;
	    let hi = lo + branchCount - 1;

	    while (lo <= hi) {
	        const mid = (lo + hi) >>> 1;
	        const midCp = neTree[mid];

	        if (midCp < cp) {
	            lo = mid + 1;
	        } else if (midCp > cp) {
	            hi = mid - 1;
	        } else {
	            return neTree[mid + branchCount];
	        }
	    }

	    return -1;
	}

	//Tokenizer
	class Tokenizer {
	    constructor() {
	        this.preprocessor = new Preprocessor();

	        this.tokenQueue = [];

	        this.allowCDATA = false;

	        this.state = DATA_STATE;
	        this.returnState = '';

	        this.charRefCode = -1;
	        this.tempBuff = [];
	        this.lastStartTagName = '';

	        this.consumedAfterSnapshot = -1;
	        this.active = false;

	        this.currentCharacterToken = null;
	        this.currentToken = null;
	        this.currentAttr = null;
	    }

	    //Errors
	    _err() {
	        // NOTE: err reporting is noop by default. Enabled by mixin.
	    }

	    _errOnNextCodePoint(err) {
	        this._consume();
	        this._err(err);
	        this._unconsume();
	    }

	    //API
	    getNextToken() {
	        while (!this.tokenQueue.length && this.active) {
	            this.consumedAfterSnapshot = 0;

	            const cp = this._consume();

	            if (!this._ensureHibernation()) {
	                this[this.state](cp);
	            }
	        }

	        return this.tokenQueue.shift();
	    }

	    write(chunk, isLastChunk) {
	        this.active = true;
	        this.preprocessor.write(chunk, isLastChunk);
	    }

	    insertHtmlAtCurrentPos(chunk) {
	        this.active = true;
	        this.preprocessor.insertHtmlAtCurrentPos(chunk);
	    }

	    //Hibernation
	    _ensureHibernation() {
	        if (this.preprocessor.endOfChunkHit) {
	            for (; this.consumedAfterSnapshot > 0; this.consumedAfterSnapshot--) {
	                this.preprocessor.retreat();
	            }

	            this.active = false;
	            this.tokenQueue.push({ type: Tokenizer.HIBERNATION_TOKEN });

	            return true;
	        }

	        return false;
	    }

	    //Consumption
	    _consume() {
	        this.consumedAfterSnapshot++;
	        return this.preprocessor.advance();
	    }

	    _unconsume() {
	        this.consumedAfterSnapshot--;
	        this.preprocessor.retreat();
	    }

	    _reconsumeInState(state) {
	        this.state = state;
	        this._unconsume();
	    }

	    _consumeSequenceIfMatch(pattern, startCp, caseSensitive) {
	        let consumedCount = 0;
	        let isMatch = true;
	        const patternLength = pattern.length;
	        let patternPos = 0;
	        let cp = startCp;
	        let patternCp = void 0;

	        for (; patternPos < patternLength; patternPos++) {
	            if (patternPos > 0) {
	                cp = this._consume();
	                consumedCount++;
	            }

	            if (cp === $.EOF) {
	                isMatch = false;
	                break;
	            }

	            patternCp = pattern[patternPos];

	            if (cp !== patternCp && (caseSensitive || cp !== toAsciiLowerCodePoint(patternCp))) {
	                isMatch = false;
	                break;
	            }
	        }

	        if (!isMatch) {
	            while (consumedCount--) {
	                this._unconsume();
	            }
	        }

	        return isMatch;
	    }

	    //Temp buffer
	    _isTempBufferEqualToScriptString() {
	        if (this.tempBuff.length !== $$.SCRIPT_STRING.length) {
	            return false;
	        }

	        for (let i = 0; i < this.tempBuff.length; i++) {
	            if (this.tempBuff[i] !== $$.SCRIPT_STRING[i]) {
	                return false;
	            }
	        }

	        return true;
	    }

	    //Token creation
	    _createStartTagToken() {
	        this.currentToken = {
	            type: Tokenizer.START_TAG_TOKEN,
	            tagName: '',
	            selfClosing: false,
	            ackSelfClosing: false,
	            attrs: []
	        };
	    }

	    _createEndTagToken() {
	        this.currentToken = {
	            type: Tokenizer.END_TAG_TOKEN,
	            tagName: '',
	            selfClosing: false,
	            attrs: []
	        };
	    }

	    _createCommentToken() {
	        this.currentToken = {
	            type: Tokenizer.COMMENT_TOKEN,
	            data: ''
	        };
	    }

	    _createDoctypeToken(initialName) {
	        this.currentToken = {
	            type: Tokenizer.DOCTYPE_TOKEN,
	            name: initialName,
	            forceQuirks: false,
	            publicId: null,
	            systemId: null
	        };
	    }

	    _createCharacterToken(type, ch) {
	        this.currentCharacterToken = {
	            type: type,
	            chars: ch
	        };
	    }

	    _createEOFToken() {
	        this.currentToken = { type: Tokenizer.EOF_TOKEN };
	    }

	    //Tag attributes
	    _createAttr(attrNameFirstCh) {
	        this.currentAttr = {
	            name: attrNameFirstCh,
	            value: ''
	        };
	    }

	    _leaveAttrName(toState) {
	        if (Tokenizer.getTokenAttr(this.currentToken, this.currentAttr.name) === null) {
	            this.currentToken.attrs.push(this.currentAttr);
	        } else {
	            this._err(ERR.duplicateAttribute);
	        }

	        this.state = toState;
	    }

	    _leaveAttrValue(toState) {
	        this.state = toState;
	    }

	    //Token emission
	    _emitCurrentToken() {
	        this._emitCurrentCharacterToken();

	        const ct = this.currentToken;

	        this.currentToken = null;

	        //NOTE: store emited start tag's tagName to determine is the following end tag token is appropriate.
	        if (ct.type === Tokenizer.START_TAG_TOKEN) {
	            this.lastStartTagName = ct.tagName;
	        } else if (ct.type === Tokenizer.END_TAG_TOKEN) {
	            if (ct.attrs.length > 0) {
	                this._err(ERR.endTagWithAttributes);
	            }

	            if (ct.selfClosing) {
	                this._err(ERR.endTagWithTrailingSolidus);
	            }
	        }

	        this.tokenQueue.push(ct);
	    }

	    _emitCurrentCharacterToken() {
	        if (this.currentCharacterToken) {
	            this.tokenQueue.push(this.currentCharacterToken);
	            this.currentCharacterToken = null;
	        }
	    }

	    _emitEOFToken() {
	        this._createEOFToken();
	        this._emitCurrentToken();
	    }

	    //Characters emission

	    //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
	    //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
	    //If we have a sequence of characters that belong to the same group, parser can process it
	    //as a single solid character token.
	    //So, there are 3 types of character tokens in parse5:
	    //1)NULL_CHARACTER_TOKEN - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
	    //2)WHITESPACE_CHARACTER_TOKEN - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
	    //3)CHARACTER_TOKEN - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
	    _appendCharToCurrentCharacterToken(type, ch) {
	        if (this.currentCharacterToken && this.currentCharacterToken.type !== type) {
	            this._emitCurrentCharacterToken();
	        }

	        if (this.currentCharacterToken) {
	            this.currentCharacterToken.chars += ch;
	        } else {
	            this._createCharacterToken(type, ch);
	        }
	    }

	    _emitCodePoint(cp) {
	        let type = Tokenizer.CHARACTER_TOKEN;

	        if (isWhitespace(cp)) {
	            type = Tokenizer.WHITESPACE_CHARACTER_TOKEN;
	        } else if (cp === $.NULL) {
	            type = Tokenizer.NULL_CHARACTER_TOKEN;
	        }

	        this._appendCharToCurrentCharacterToken(type, toChar(cp));
	    }

	    _emitSeveralCodePoints(codePoints) {
	        for (let i = 0; i < codePoints.length; i++) {
	            this._emitCodePoint(codePoints[i]);
	        }
	    }

	    //NOTE: used then we emit character explicitly. This is always a non-whitespace and a non-null character.
	    //So we can avoid additional checks here.
	    _emitChars(ch) {
	        this._appendCharToCurrentCharacterToken(Tokenizer.CHARACTER_TOKEN, ch);
	    }

	    // Character reference helpers
	    _matchNamedCharacterReference(startCp) {
	        let result = null;
	        let excess = 1;
	        let i = findNamedEntityTreeBranch(0, startCp);

	        this.tempBuff.push(startCp);

	        while (i > -1) {
	            const current = neTree[i];
	            const inNode = current < MAX_BRANCH_MARKER_VALUE;
	            const nodeWithData = inNode && current & HAS_DATA_FLAG;

	            if (nodeWithData) {
	                //NOTE: we use greedy search, so we continue lookup at this point
	                result = current & DATA_DUPLET_FLAG ? [neTree[++i], neTree[++i]] : [neTree[++i]];
	                excess = 0;
	            }

	            const cp = this._consume();

	            this.tempBuff.push(cp);
	            excess++;

	            if (cp === $.EOF) {
	                break;
	            }

	            if (inNode) {
	                i = current & HAS_BRANCHES_FLAG ? findNamedEntityTreeBranch(i, cp) : -1;
	            } else {
	                i = cp === current ? ++i : -1;
	            }
	        }

	        while (excess--) {
	            this.tempBuff.pop();
	            this._unconsume();
	        }

	        return result;
	    }

	    _isCharacterReferenceInAttribute() {
	        return (
	            this.returnState === ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE ||
	            this.returnState === ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE ||
	            this.returnState === ATTRIBUTE_VALUE_UNQUOTED_STATE
	        );
	    }

	    _isCharacterReferenceAttributeQuirk(withSemicolon) {
	        if (!withSemicolon && this._isCharacterReferenceInAttribute()) {
	            const nextCp = this._consume();

	            this._unconsume();

	            return nextCp === $.EQUALS_SIGN || isAsciiAlphaNumeric(nextCp);
	        }

	        return false;
	    }

	    _flushCodePointsConsumedAsCharacterReference() {
	        if (this._isCharacterReferenceInAttribute()) {
	            for (let i = 0; i < this.tempBuff.length; i++) {
	                this.currentAttr.value += toChar(this.tempBuff[i]);
	            }
	        } else {
	            this._emitSeveralCodePoints(this.tempBuff);
	        }

	        this.tempBuff = [];
	    }

	    // State machine

	    // Data state
	    //------------------------------------------------------------------
	    [DATA_STATE](cp) {
	        this.preprocessor.dropParsedChunk();

	        if (cp === $.LESS_THAN_SIGN) {
	            this.state = TAG_OPEN_STATE;
	        } else if (cp === $.AMPERSAND) {
	            this.returnState = DATA_STATE;
	            this.state = CHARACTER_REFERENCE_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this._emitCodePoint(cp);
	        } else if (cp === $.EOF) {
	            this._emitEOFToken();
	        } else {
	            this._emitCodePoint(cp);
	        }
	    }

	    //  RCDATA state
	    //------------------------------------------------------------------
	    [RCDATA_STATE](cp) {
	        this.preprocessor.dropParsedChunk();

	        if (cp === $.AMPERSAND) {
	            this.returnState = RCDATA_STATE;
	            this.state = CHARACTER_REFERENCE_STATE;
	        } else if (cp === $.LESS_THAN_SIGN) {
	            this.state = RCDATA_LESS_THAN_SIGN_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this._emitChars(unicode.REPLACEMENT_CHARACTER);
	        } else if (cp === $.EOF) {
	            this._emitEOFToken();
	        } else {
	            this._emitCodePoint(cp);
	        }
	    }

	    // RAWTEXT state
	    //------------------------------------------------------------------
	    [RAWTEXT_STATE](cp) {
	        this.preprocessor.dropParsedChunk();

	        if (cp === $.LESS_THAN_SIGN) {
	            this.state = RAWTEXT_LESS_THAN_SIGN_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this._emitChars(unicode.REPLACEMENT_CHARACTER);
	        } else if (cp === $.EOF) {
	            this._emitEOFToken();
	        } else {
	            this._emitCodePoint(cp);
	        }
	    }

	    // Script data state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_STATE](cp) {
	        this.preprocessor.dropParsedChunk();

	        if (cp === $.LESS_THAN_SIGN) {
	            this.state = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this._emitChars(unicode.REPLACEMENT_CHARACTER);
	        } else if (cp === $.EOF) {
	            this._emitEOFToken();
	        } else {
	            this._emitCodePoint(cp);
	        }
	    }

	    // PLAINTEXT state
	    //------------------------------------------------------------------
	    [PLAINTEXT_STATE](cp) {
	        this.preprocessor.dropParsedChunk();

	        if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this._emitChars(unicode.REPLACEMENT_CHARACTER);
	        } else if (cp === $.EOF) {
	            this._emitEOFToken();
	        } else {
	            this._emitCodePoint(cp);
	        }
	    }

	    // Tag open state
	    //------------------------------------------------------------------
	    [TAG_OPEN_STATE](cp) {
	        if (cp === $.EXCLAMATION_MARK) {
	            this.state = MARKUP_DECLARATION_OPEN_STATE;
	        } else if (cp === $.SOLIDUS) {
	            this.state = END_TAG_OPEN_STATE;
	        } else if (isAsciiLetter(cp)) {
	            this._createStartTagToken();
	            this._reconsumeInState(TAG_NAME_STATE);
	        } else if (cp === $.QUESTION_MARK) {
	            this._err(ERR.unexpectedQuestionMarkInsteadOfTagName);
	            this._createCommentToken();
	            this._reconsumeInState(BOGUS_COMMENT_STATE);
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofBeforeTagName);
	            this._emitChars('<');
	            this._emitEOFToken();
	        } else {
	            this._err(ERR.invalidFirstCharacterOfTagName);
	            this._emitChars('<');
	            this._reconsumeInState(DATA_STATE);
	        }
	    }

	    // End tag open state
	    //------------------------------------------------------------------
	    [END_TAG_OPEN_STATE](cp) {
	        if (isAsciiLetter(cp)) {
	            this._createEndTagToken();
	            this._reconsumeInState(TAG_NAME_STATE);
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.missingEndTagName);
	            this.state = DATA_STATE;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofBeforeTagName);
	            this._emitChars('</');
	            this._emitEOFToken();
	        } else {
	            this._err(ERR.invalidFirstCharacterOfTagName);
	            this._createCommentToken();
	            this._reconsumeInState(BOGUS_COMMENT_STATE);
	        }
	    }

	    // Tag name state
	    //------------------------------------------------------------------
	    [TAG_NAME_STATE](cp) {
	        if (isWhitespace(cp)) {
	            this.state = BEFORE_ATTRIBUTE_NAME_STATE;
	        } else if (cp === $.SOLIDUS) {
	            this.state = SELF_CLOSING_START_TAG_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (isAsciiUpper(cp)) {
	            this.currentToken.tagName += toAsciiLowerChar(cp);
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.currentToken.tagName += unicode.REPLACEMENT_CHARACTER;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInTag);
	            this._emitEOFToken();
	        } else {
	            this.currentToken.tagName += toChar(cp);
	        }
	    }

	    // RCDATA less-than sign state
	    //------------------------------------------------------------------
	    [RCDATA_LESS_THAN_SIGN_STATE](cp) {
	        if (cp === $.SOLIDUS) {
	            this.tempBuff = [];
	            this.state = RCDATA_END_TAG_OPEN_STATE;
	        } else {
	            this._emitChars('<');
	            this._reconsumeInState(RCDATA_STATE);
	        }
	    }

	    // RCDATA end tag open state
	    //------------------------------------------------------------------
	    [RCDATA_END_TAG_OPEN_STATE](cp) {
	        if (isAsciiLetter(cp)) {
	            this._createEndTagToken();
	            this._reconsumeInState(RCDATA_END_TAG_NAME_STATE);
	        } else {
	            this._emitChars('</');
	            this._reconsumeInState(RCDATA_STATE);
	        }
	    }

	    // RCDATA end tag name state
	    //------------------------------------------------------------------
	    [RCDATA_END_TAG_NAME_STATE](cp) {
	        if (isAsciiUpper(cp)) {
	            this.currentToken.tagName += toAsciiLowerChar(cp);
	            this.tempBuff.push(cp);
	        } else if (isAsciiLower(cp)) {
	            this.currentToken.tagName += toChar(cp);
	            this.tempBuff.push(cp);
	        } else {
	            if (this.lastStartTagName === this.currentToken.tagName) {
	                if (isWhitespace(cp)) {
	                    this.state = BEFORE_ATTRIBUTE_NAME_STATE;
	                    return;
	                }

	                if (cp === $.SOLIDUS) {
	                    this.state = SELF_CLOSING_START_TAG_STATE;
	                    return;
	                }

	                if (cp === $.GREATER_THAN_SIGN) {
	                    this.state = DATA_STATE;
	                    this._emitCurrentToken();
	                    return;
	                }
	            }

	            this._emitChars('</');
	            this._emitSeveralCodePoints(this.tempBuff);
	            this._reconsumeInState(RCDATA_STATE);
	        }
	    }

	    // RAWTEXT less-than sign state
	    //------------------------------------------------------------------
	    [RAWTEXT_LESS_THAN_SIGN_STATE](cp) {
	        if (cp === $.SOLIDUS) {
	            this.tempBuff = [];
	            this.state = RAWTEXT_END_TAG_OPEN_STATE;
	        } else {
	            this._emitChars('<');
	            this._reconsumeInState(RAWTEXT_STATE);
	        }
	    }

	    // RAWTEXT end tag open state
	    //------------------------------------------------------------------
	    [RAWTEXT_END_TAG_OPEN_STATE](cp) {
	        if (isAsciiLetter(cp)) {
	            this._createEndTagToken();
	            this._reconsumeInState(RAWTEXT_END_TAG_NAME_STATE);
	        } else {
	            this._emitChars('</');
	            this._reconsumeInState(RAWTEXT_STATE);
	        }
	    }

	    // RAWTEXT end tag name state
	    //------------------------------------------------------------------
	    [RAWTEXT_END_TAG_NAME_STATE](cp) {
	        if (isAsciiUpper(cp)) {
	            this.currentToken.tagName += toAsciiLowerChar(cp);
	            this.tempBuff.push(cp);
	        } else if (isAsciiLower(cp)) {
	            this.currentToken.tagName += toChar(cp);
	            this.tempBuff.push(cp);
	        } else {
	            if (this.lastStartTagName === this.currentToken.tagName) {
	                if (isWhitespace(cp)) {
	                    this.state = BEFORE_ATTRIBUTE_NAME_STATE;
	                    return;
	                }

	                if (cp === $.SOLIDUS) {
	                    this.state = SELF_CLOSING_START_TAG_STATE;
	                    return;
	                }

	                if (cp === $.GREATER_THAN_SIGN) {
	                    this._emitCurrentToken();
	                    this.state = DATA_STATE;
	                    return;
	                }
	            }

	            this._emitChars('</');
	            this._emitSeveralCodePoints(this.tempBuff);
	            this._reconsumeInState(RAWTEXT_STATE);
	        }
	    }

	    // Script data less-than sign state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_LESS_THAN_SIGN_STATE](cp) {
	        if (cp === $.SOLIDUS) {
	            this.tempBuff = [];
	            this.state = SCRIPT_DATA_END_TAG_OPEN_STATE;
	        } else if (cp === $.EXCLAMATION_MARK) {
	            this.state = SCRIPT_DATA_ESCAPE_START_STATE;
	            this._emitChars('<!');
	        } else {
	            this._emitChars('<');
	            this._reconsumeInState(SCRIPT_DATA_STATE);
	        }
	    }

	    // Script data end tag open state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_END_TAG_OPEN_STATE](cp) {
	        if (isAsciiLetter(cp)) {
	            this._createEndTagToken();
	            this._reconsumeInState(SCRIPT_DATA_END_TAG_NAME_STATE);
	        } else {
	            this._emitChars('</');
	            this._reconsumeInState(SCRIPT_DATA_STATE);
	        }
	    }

	    // Script data end tag name state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_END_TAG_NAME_STATE](cp) {
	        if (isAsciiUpper(cp)) {
	            this.currentToken.tagName += toAsciiLowerChar(cp);
	            this.tempBuff.push(cp);
	        } else if (isAsciiLower(cp)) {
	            this.currentToken.tagName += toChar(cp);
	            this.tempBuff.push(cp);
	        } else {
	            if (this.lastStartTagName === this.currentToken.tagName) {
	                if (isWhitespace(cp)) {
	                    this.state = BEFORE_ATTRIBUTE_NAME_STATE;
	                    return;
	                } else if (cp === $.SOLIDUS) {
	                    this.state = SELF_CLOSING_START_TAG_STATE;
	                    return;
	                } else if (cp === $.GREATER_THAN_SIGN) {
	                    this._emitCurrentToken();
	                    this.state = DATA_STATE;
	                    return;
	                }
	            }

	            this._emitChars('</');
	            this._emitSeveralCodePoints(this.tempBuff);
	            this._reconsumeInState(SCRIPT_DATA_STATE);
	        }
	    }

	    // Script data escape start state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_ESCAPE_START_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.state = SCRIPT_DATA_ESCAPE_START_DASH_STATE;
	            this._emitChars('-');
	        } else {
	            this._reconsumeInState(SCRIPT_DATA_STATE);
	        }
	    }

	    // Script data escape start dash state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_ESCAPE_START_DASH_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
	            this._emitChars('-');
	        } else {
	            this._reconsumeInState(SCRIPT_DATA_STATE);
	        }
	    }

	    // Script data escaped state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_ESCAPED_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.state = SCRIPT_DATA_ESCAPED_DASH_STATE;
	            this._emitChars('-');
	        } else if (cp === $.LESS_THAN_SIGN) {
	            this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this._emitChars(unicode.REPLACEMENT_CHARACTER);
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInScriptHtmlCommentLikeText);
	            this._emitEOFToken();
	        } else {
	            this._emitCodePoint(cp);
	        }
	    }

	    // Script data escaped dash state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_ESCAPED_DASH_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
	            this._emitChars('-');
	        } else if (cp === $.LESS_THAN_SIGN) {
	            this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.state = SCRIPT_DATA_ESCAPED_STATE;
	            this._emitChars(unicode.REPLACEMENT_CHARACTER);
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInScriptHtmlCommentLikeText);
	            this._emitEOFToken();
	        } else {
	            this.state = SCRIPT_DATA_ESCAPED_STATE;
	            this._emitCodePoint(cp);
	        }
	    }

	    // Script data escaped dash dash state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_ESCAPED_DASH_DASH_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this._emitChars('-');
	        } else if (cp === $.LESS_THAN_SIGN) {
	            this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this.state = SCRIPT_DATA_STATE;
	            this._emitChars('>');
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.state = SCRIPT_DATA_ESCAPED_STATE;
	            this._emitChars(unicode.REPLACEMENT_CHARACTER);
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInScriptHtmlCommentLikeText);
	            this._emitEOFToken();
	        } else {
	            this.state = SCRIPT_DATA_ESCAPED_STATE;
	            this._emitCodePoint(cp);
	        }
	    }

	    // Script data escaped less-than sign state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE](cp) {
	        if (cp === $.SOLIDUS) {
	            this.tempBuff = [];
	            this.state = SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE;
	        } else if (isAsciiLetter(cp)) {
	            this.tempBuff = [];
	            this._emitChars('<');
	            this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE);
	        } else {
	            this._emitChars('<');
	            this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
	        }
	    }

	    // Script data escaped end tag open state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE](cp) {
	        if (isAsciiLetter(cp)) {
	            this._createEndTagToken();
	            this._reconsumeInState(SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE);
	        } else {
	            this._emitChars('</');
	            this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
	        }
	    }

	    // Script data escaped end tag name state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE](cp) {
	        if (isAsciiUpper(cp)) {
	            this.currentToken.tagName += toAsciiLowerChar(cp);
	            this.tempBuff.push(cp);
	        } else if (isAsciiLower(cp)) {
	            this.currentToken.tagName += toChar(cp);
	            this.tempBuff.push(cp);
	        } else {
	            if (this.lastStartTagName === this.currentToken.tagName) {
	                if (isWhitespace(cp)) {
	                    this.state = BEFORE_ATTRIBUTE_NAME_STATE;
	                    return;
	                }

	                if (cp === $.SOLIDUS) {
	                    this.state = SELF_CLOSING_START_TAG_STATE;
	                    return;
	                }

	                if (cp === $.GREATER_THAN_SIGN) {
	                    this._emitCurrentToken();
	                    this.state = DATA_STATE;
	                    return;
	                }
	            }

	            this._emitChars('</');
	            this._emitSeveralCodePoints(this.tempBuff);
	            this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
	        }
	    }

	    // Script data double escape start state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE](cp) {
	        if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN) {
	            this.state = this._isTempBufferEqualToScriptString()
	                ? SCRIPT_DATA_DOUBLE_ESCAPED_STATE
	                : SCRIPT_DATA_ESCAPED_STATE;
	            this._emitCodePoint(cp);
	        } else if (isAsciiUpper(cp)) {
	            this.tempBuff.push(toAsciiLowerCodePoint(cp));
	            this._emitCodePoint(cp);
	        } else if (isAsciiLower(cp)) {
	            this.tempBuff.push(cp);
	            this._emitCodePoint(cp);
	        } else {
	            this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
	        }
	    }

	    // Script data double escaped state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_DOUBLE_ESCAPED_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;
	            this._emitChars('-');
	        } else if (cp === $.LESS_THAN_SIGN) {
	            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
	            this._emitChars('<');
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this._emitChars(unicode.REPLACEMENT_CHARACTER);
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInScriptHtmlCommentLikeText);
	            this._emitEOFToken();
	        } else {
	            this._emitCodePoint(cp);
	        }
	    }

	    // Script data double escaped dash state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE;
	            this._emitChars('-');
	        } else if (cp === $.LESS_THAN_SIGN) {
	            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
	            this._emitChars('<');
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
	            this._emitChars(unicode.REPLACEMENT_CHARACTER);
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInScriptHtmlCommentLikeText);
	            this._emitEOFToken();
	        } else {
	            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
	            this._emitCodePoint(cp);
	        }
	    }

	    // Script data double escaped dash dash state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this._emitChars('-');
	        } else if (cp === $.LESS_THAN_SIGN) {
	            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
	            this._emitChars('<');
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this.state = SCRIPT_DATA_STATE;
	            this._emitChars('>');
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
	            this._emitChars(unicode.REPLACEMENT_CHARACTER);
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInScriptHtmlCommentLikeText);
	            this._emitEOFToken();
	        } else {
	            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
	            this._emitCodePoint(cp);
	        }
	    }

	    // Script data double escaped less-than sign state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE](cp) {
	        if (cp === $.SOLIDUS) {
	            this.tempBuff = [];
	            this.state = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;
	            this._emitChars('/');
	        } else {
	            this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
	        }
	    }

	    // Script data double escape end state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE](cp) {
	        if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN) {
	            this.state = this._isTempBufferEqualToScriptString()
	                ? SCRIPT_DATA_ESCAPED_STATE
	                : SCRIPT_DATA_DOUBLE_ESCAPED_STATE;

	            this._emitCodePoint(cp);
	        } else if (isAsciiUpper(cp)) {
	            this.tempBuff.push(toAsciiLowerCodePoint(cp));
	            this._emitCodePoint(cp);
	        } else if (isAsciiLower(cp)) {
	            this.tempBuff.push(cp);
	            this._emitCodePoint(cp);
	        } else {
	            this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
	        }
	    }

	    // Before attribute name state
	    //------------------------------------------------------------------
	    [BEFORE_ATTRIBUTE_NAME_STATE](cp) {
	        if (isWhitespace(cp)) {
	            return;
	        }

	        if (cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN || cp === $.EOF) {
	            this._reconsumeInState(AFTER_ATTRIBUTE_NAME_STATE);
	        } else if (cp === $.EQUALS_SIGN) {
	            this._err(ERR.unexpectedEqualsSignBeforeAttributeName);
	            this._createAttr('=');
	            this.state = ATTRIBUTE_NAME_STATE;
	        } else {
	            this._createAttr('');
	            this._reconsumeInState(ATTRIBUTE_NAME_STATE);
	        }
	    }

	    // Attribute name state
	    //------------------------------------------------------------------
	    [ATTRIBUTE_NAME_STATE](cp) {
	        if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN || cp === $.EOF) {
	            this._leaveAttrName(AFTER_ATTRIBUTE_NAME_STATE);
	            this._unconsume();
	        } else if (cp === $.EQUALS_SIGN) {
	            this._leaveAttrName(BEFORE_ATTRIBUTE_VALUE_STATE);
	        } else if (isAsciiUpper(cp)) {
	            this.currentAttr.name += toAsciiLowerChar(cp);
	        } else if (cp === $.QUOTATION_MARK || cp === $.APOSTROPHE || cp === $.LESS_THAN_SIGN) {
	            this._err(ERR.unexpectedCharacterInAttributeName);
	            this.currentAttr.name += toChar(cp);
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.currentAttr.name += unicode.REPLACEMENT_CHARACTER;
	        } else {
	            this.currentAttr.name += toChar(cp);
	        }
	    }

	    // After attribute name state
	    //------------------------------------------------------------------
	    [AFTER_ATTRIBUTE_NAME_STATE](cp) {
	        if (isWhitespace(cp)) {
	            return;
	        }

	        if (cp === $.SOLIDUS) {
	            this.state = SELF_CLOSING_START_TAG_STATE;
	        } else if (cp === $.EQUALS_SIGN) {
	            this.state = BEFORE_ATTRIBUTE_VALUE_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInTag);
	            this._emitEOFToken();
	        } else {
	            this._createAttr('');
	            this._reconsumeInState(ATTRIBUTE_NAME_STATE);
	        }
	    }

	    // Before attribute value state
	    //------------------------------------------------------------------
	    [BEFORE_ATTRIBUTE_VALUE_STATE](cp) {
	        if (isWhitespace(cp)) {
	            return;
	        }

	        if (cp === $.QUOTATION_MARK) {
	            this.state = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
	        } else if (cp === $.APOSTROPHE) {
	            this.state = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.missingAttributeValue);
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else {
	            this._reconsumeInState(ATTRIBUTE_VALUE_UNQUOTED_STATE);
	        }
	    }

	    // Attribute value (double-quoted) state
	    //------------------------------------------------------------------
	    [ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE](cp) {
	        if (cp === $.QUOTATION_MARK) {
	            this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
	        } else if (cp === $.AMPERSAND) {
	            this.returnState = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
	            this.state = CHARACTER_REFERENCE_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.currentAttr.value += unicode.REPLACEMENT_CHARACTER;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInTag);
	            this._emitEOFToken();
	        } else {
	            this.currentAttr.value += toChar(cp);
	        }
	    }

	    // Attribute value (single-quoted) state
	    //------------------------------------------------------------------
	    [ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE](cp) {
	        if (cp === $.APOSTROPHE) {
	            this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
	        } else if (cp === $.AMPERSAND) {
	            this.returnState = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
	            this.state = CHARACTER_REFERENCE_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.currentAttr.value += unicode.REPLACEMENT_CHARACTER;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInTag);
	            this._emitEOFToken();
	        } else {
	            this.currentAttr.value += toChar(cp);
	        }
	    }

	    // Attribute value (unquoted) state
	    //------------------------------------------------------------------
	    [ATTRIBUTE_VALUE_UNQUOTED_STATE](cp) {
	        if (isWhitespace(cp)) {
	            this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);
	        } else if (cp === $.AMPERSAND) {
	            this.returnState = ATTRIBUTE_VALUE_UNQUOTED_STATE;
	            this.state = CHARACTER_REFERENCE_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._leaveAttrValue(DATA_STATE);
	            this._emitCurrentToken();
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.currentAttr.value += unicode.REPLACEMENT_CHARACTER;
	        } else if (
	            cp === $.QUOTATION_MARK ||
	            cp === $.APOSTROPHE ||
	            cp === $.LESS_THAN_SIGN ||
	            cp === $.EQUALS_SIGN ||
	            cp === $.GRAVE_ACCENT
	        ) {
	            this._err(ERR.unexpectedCharacterInUnquotedAttributeValue);
	            this.currentAttr.value += toChar(cp);
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInTag);
	            this._emitEOFToken();
	        } else {
	            this.currentAttr.value += toChar(cp);
	        }
	    }

	    // After attribute value (quoted) state
	    //------------------------------------------------------------------
	    [AFTER_ATTRIBUTE_VALUE_QUOTED_STATE](cp) {
	        if (isWhitespace(cp)) {
	            this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);
	        } else if (cp === $.SOLIDUS) {
	            this._leaveAttrValue(SELF_CLOSING_START_TAG_STATE);
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._leaveAttrValue(DATA_STATE);
	            this._emitCurrentToken();
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInTag);
	            this._emitEOFToken();
	        } else {
	            this._err(ERR.missingWhitespaceBetweenAttributes);
	            this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
	        }
	    }

	    // Self-closing start tag state
	    //------------------------------------------------------------------
	    [SELF_CLOSING_START_TAG_STATE](cp) {
	        if (cp === $.GREATER_THAN_SIGN) {
	            this.currentToken.selfClosing = true;
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInTag);
	            this._emitEOFToken();
	        } else {
	            this._err(ERR.unexpectedSolidusInTag);
	            this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
	        }
	    }

	    // Bogus comment state
	    //------------------------------------------------------------------
	    [BOGUS_COMMENT_STATE](cp) {
	        if (cp === $.GREATER_THAN_SIGN) {
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (cp === $.EOF) {
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.currentToken.data += unicode.REPLACEMENT_CHARACTER;
	        } else {
	            this.currentToken.data += toChar(cp);
	        }
	    }

	    // Markup declaration open state
	    //------------------------------------------------------------------
	    [MARKUP_DECLARATION_OPEN_STATE](cp) {
	        if (this._consumeSequenceIfMatch($$.DASH_DASH_STRING, cp, true)) {
	            this._createCommentToken();
	            this.state = COMMENT_START_STATE;
	        } else if (this._consumeSequenceIfMatch($$.DOCTYPE_STRING, cp, false)) {
	            this.state = DOCTYPE_STATE;
	        } else if (this._consumeSequenceIfMatch($$.CDATA_START_STRING, cp, true)) {
	            if (this.allowCDATA) {
	                this.state = CDATA_SECTION_STATE;
	            } else {
	                this._err(ERR.cdataInHtmlContent);
	                this._createCommentToken();
	                this.currentToken.data = '[CDATA[';
	                this.state = BOGUS_COMMENT_STATE;
	            }
	        }

	        //NOTE: sequence lookup can be abrupted by hibernation. In that case lookup
	        //results are no longer valid and we will need to start over.
	        else if (!this._ensureHibernation()) {
	            this._err(ERR.incorrectlyOpenedComment);
	            this._createCommentToken();
	            this._reconsumeInState(BOGUS_COMMENT_STATE);
	        }
	    }

	    // Comment start state
	    //------------------------------------------------------------------
	    [COMMENT_START_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.state = COMMENT_START_DASH_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.abruptClosingOfEmptyComment);
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else {
	            this._reconsumeInState(COMMENT_STATE);
	        }
	    }

	    // Comment start dash state
	    //------------------------------------------------------------------
	    [COMMENT_START_DASH_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.state = COMMENT_END_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.abruptClosingOfEmptyComment);
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInComment);
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this.currentToken.data += '-';
	            this._reconsumeInState(COMMENT_STATE);
	        }
	    }

	    // Comment state
	    //------------------------------------------------------------------
	    [COMMENT_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.state = COMMENT_END_DASH_STATE;
	        } else if (cp === $.LESS_THAN_SIGN) {
	            this.currentToken.data += '<';
	            this.state = COMMENT_LESS_THAN_SIGN_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.currentToken.data += unicode.REPLACEMENT_CHARACTER;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInComment);
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this.currentToken.data += toChar(cp);
	        }
	    }

	    // Comment less-than sign state
	    //------------------------------------------------------------------
	    [COMMENT_LESS_THAN_SIGN_STATE](cp) {
	        if (cp === $.EXCLAMATION_MARK) {
	            this.currentToken.data += '!';
	            this.state = COMMENT_LESS_THAN_SIGN_BANG_STATE;
	        } else if (cp === $.LESS_THAN_SIGN) {
	            this.currentToken.data += '!';
	        } else {
	            this._reconsumeInState(COMMENT_STATE);
	        }
	    }

	    // Comment less-than sign bang state
	    //------------------------------------------------------------------
	    [COMMENT_LESS_THAN_SIGN_BANG_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE;
	        } else {
	            this._reconsumeInState(COMMENT_STATE);
	        }
	    }

	    // Comment less-than sign bang dash state
	    //------------------------------------------------------------------
	    [COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE;
	        } else {
	            this._reconsumeInState(COMMENT_END_DASH_STATE);
	        }
	    }

	    // Comment less-than sign bang dash dash state
	    //------------------------------------------------------------------
	    [COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE](cp) {
	        if (cp !== $.GREATER_THAN_SIGN && cp !== $.EOF) {
	            this._err(ERR.nestedComment);
	        }

	        this._reconsumeInState(COMMENT_END_STATE);
	    }

	    // Comment end dash state
	    //------------------------------------------------------------------
	    [COMMENT_END_DASH_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.state = COMMENT_END_STATE;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInComment);
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this.currentToken.data += '-';
	            this._reconsumeInState(COMMENT_STATE);
	        }
	    }

	    // Comment end state
	    //------------------------------------------------------------------
	    [COMMENT_END_STATE](cp) {
	        if (cp === $.GREATER_THAN_SIGN) {
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (cp === $.EXCLAMATION_MARK) {
	            this.state = COMMENT_END_BANG_STATE;
	        } else if (cp === $.HYPHEN_MINUS) {
	            this.currentToken.data += '-';
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInComment);
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this.currentToken.data += '--';
	            this._reconsumeInState(COMMENT_STATE);
	        }
	    }

	    // Comment end bang state
	    //------------------------------------------------------------------
	    [COMMENT_END_BANG_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.currentToken.data += '--!';
	            this.state = COMMENT_END_DASH_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.incorrectlyClosedComment);
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInComment);
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this.currentToken.data += '--!';
	            this._reconsumeInState(COMMENT_STATE);
	        }
	    }

	    // DOCTYPE state
	    //------------------------------------------------------------------
	    [DOCTYPE_STATE](cp) {
	        if (isWhitespace(cp)) {
	            this.state = BEFORE_DOCTYPE_NAME_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this._createDoctypeToken(null);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this._err(ERR.missingWhitespaceBeforeDoctypeName);
	            this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);
	        }
	    }

	    // Before DOCTYPE name state
	    //------------------------------------------------------------------
	    [BEFORE_DOCTYPE_NAME_STATE](cp) {
	        if (isWhitespace(cp)) {
	            return;
	        }

	        if (isAsciiUpper(cp)) {
	            this._createDoctypeToken(toAsciiLowerChar(cp));
	            this.state = DOCTYPE_NAME_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this._createDoctypeToken(unicode.REPLACEMENT_CHARACTER);
	            this.state = DOCTYPE_NAME_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.missingDoctypeName);
	            this._createDoctypeToken(null);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this.state = DATA_STATE;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this._createDoctypeToken(null);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this._createDoctypeToken(toChar(cp));
	            this.state = DOCTYPE_NAME_STATE;
	        }
	    }

	    // DOCTYPE name state
	    //------------------------------------------------------------------
	    [DOCTYPE_NAME_STATE](cp) {
	        if (isWhitespace(cp)) {
	            this.state = AFTER_DOCTYPE_NAME_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (isAsciiUpper(cp)) {
	            this.currentToken.name += toAsciiLowerChar(cp);
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.currentToken.name += unicode.REPLACEMENT_CHARACTER;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this.currentToken.name += toChar(cp);
	        }
	    }

	    // After DOCTYPE name state
	    //------------------------------------------------------------------
	    [AFTER_DOCTYPE_NAME_STATE](cp) {
	        if (isWhitespace(cp)) {
	            return;
	        }

	        if (cp === $.GREATER_THAN_SIGN) {
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else if (this._consumeSequenceIfMatch($$.PUBLIC_STRING, cp, false)) {
	            this.state = AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE;
	        } else if (this._consumeSequenceIfMatch($$.SYSTEM_STRING, cp, false)) {
	            this.state = AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE;
	        }
	        //NOTE: sequence lookup can be abrupted by hibernation. In that case lookup
	        //results are no longer valid and we will need to start over.
	        else if (!this._ensureHibernation()) {
	            this._err(ERR.invalidCharacterSequenceAfterDoctypeName);
	            this.currentToken.forceQuirks = true;
	            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
	        }
	    }

	    // After DOCTYPE public keyword state
	    //------------------------------------------------------------------
	    [AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE](cp) {
	        if (isWhitespace(cp)) {
	            this.state = BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
	        } else if (cp === $.QUOTATION_MARK) {
	            this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
	            this.currentToken.publicId = '';
	            this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
	        } else if (cp === $.APOSTROPHE) {
	            this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
	            this.currentToken.publicId = '';
	            this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.missingDoctypePublicIdentifier);
	            this.currentToken.forceQuirks = true;
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
	            this.currentToken.forceQuirks = true;
	            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
	        }
	    }

	    // Before DOCTYPE public identifier state
	    //------------------------------------------------------------------
	    [BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE](cp) {
	        if (isWhitespace(cp)) {
	            return;
	        }

	        if (cp === $.QUOTATION_MARK) {
	            this.currentToken.publicId = '';
	            this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
	        } else if (cp === $.APOSTROPHE) {
	            this.currentToken.publicId = '';
	            this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.missingDoctypePublicIdentifier);
	            this.currentToken.forceQuirks = true;
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
	            this.currentToken.forceQuirks = true;
	            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
	        }
	    }

	    // DOCTYPE public identifier (double-quoted) state
	    //------------------------------------------------------------------
	    [DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE](cp) {
	        if (cp === $.QUOTATION_MARK) {
	            this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.currentToken.publicId += unicode.REPLACEMENT_CHARACTER;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.abruptDoctypePublicIdentifier);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this.state = DATA_STATE;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this.currentToken.publicId += toChar(cp);
	        }
	    }

	    // DOCTYPE public identifier (single-quoted) state
	    //------------------------------------------------------------------
	    [DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE](cp) {
	        if (cp === $.APOSTROPHE) {
	            this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.currentToken.publicId += unicode.REPLACEMENT_CHARACTER;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.abruptDoctypePublicIdentifier);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this.state = DATA_STATE;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this.currentToken.publicId += toChar(cp);
	        }
	    }

	    // After DOCTYPE public identifier state
	    //------------------------------------------------------------------
	    [AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE](cp) {
	        if (isWhitespace(cp)) {
	            this.state = BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (cp === $.QUOTATION_MARK) {
	            this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
	            this.currentToken.systemId = '';
	            this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
	        } else if (cp === $.APOSTROPHE) {
	            this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
	            this.currentToken.systemId = '';
	            this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
	            this.currentToken.forceQuirks = true;
	            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
	        }
	    }

	    // Between DOCTYPE public and system identifiers state
	    //------------------------------------------------------------------
	    [BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE](cp) {
	        if (isWhitespace(cp)) {
	            return;
	        }

	        if (cp === $.GREATER_THAN_SIGN) {
	            this._emitCurrentToken();
	            this.state = DATA_STATE;
	        } else if (cp === $.QUOTATION_MARK) {
	            this.currentToken.systemId = '';
	            this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
	        } else if (cp === $.APOSTROPHE) {
	            this.currentToken.systemId = '';
	            this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
	            this.currentToken.forceQuirks = true;
	            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
	        }
	    }

	    // After DOCTYPE system keyword state
	    //------------------------------------------------------------------
	    [AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE](cp) {
	        if (isWhitespace(cp)) {
	            this.state = BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
	        } else if (cp === $.QUOTATION_MARK) {
	            this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
	            this.currentToken.systemId = '';
	            this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
	        } else if (cp === $.APOSTROPHE) {
	            this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
	            this.currentToken.systemId = '';
	            this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.missingDoctypeSystemIdentifier);
	            this.currentToken.forceQuirks = true;
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
	            this.currentToken.forceQuirks = true;
	            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
	        }
	    }

	    // Before DOCTYPE system identifier state
	    //------------------------------------------------------------------
	    [BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE](cp) {
	        if (isWhitespace(cp)) {
	            return;
	        }

	        if (cp === $.QUOTATION_MARK) {
	            this.currentToken.systemId = '';
	            this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
	        } else if (cp === $.APOSTROPHE) {
	            this.currentToken.systemId = '';
	            this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.missingDoctypeSystemIdentifier);
	            this.currentToken.forceQuirks = true;
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
	            this.currentToken.forceQuirks = true;
	            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
	        }
	    }

	    // DOCTYPE system identifier (double-quoted) state
	    //------------------------------------------------------------------
	    [DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE](cp) {
	        if (cp === $.QUOTATION_MARK) {
	            this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.currentToken.systemId += unicode.REPLACEMENT_CHARACTER;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.abruptDoctypeSystemIdentifier);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this.state = DATA_STATE;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this.currentToken.systemId += toChar(cp);
	        }
	    }

	    // DOCTYPE system identifier (single-quoted) state
	    //------------------------------------------------------------------
	    [DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE](cp) {
	        if (cp === $.APOSTROPHE) {
	            this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.currentToken.systemId += unicode.REPLACEMENT_CHARACTER;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.abruptDoctypeSystemIdentifier);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this.state = DATA_STATE;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this.currentToken.systemId += toChar(cp);
	        }
	    }

	    // After DOCTYPE system identifier state
	    //------------------------------------------------------------------
	    [AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE](cp) {
	        if (isWhitespace(cp)) {
	            return;
	        }

	        if (cp === $.GREATER_THAN_SIGN) {
	            this._emitCurrentToken();
	            this.state = DATA_STATE;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this._err(ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);
	            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
	        }
	    }

	    // Bogus DOCTYPE state
	    //------------------------------------------------------------------
	    [BOGUS_DOCTYPE_STATE](cp) {
	        if (cp === $.GREATER_THAN_SIGN) {
	            this._emitCurrentToken();
	            this.state = DATA_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	        } else if (cp === $.EOF) {
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        }
	    }

	    // CDATA section state
	    //------------------------------------------------------------------
	    [CDATA_SECTION_STATE](cp) {
	        if (cp === $.RIGHT_SQUARE_BRACKET) {
	            this.state = CDATA_SECTION_BRACKET_STATE;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInCdata);
	            this._emitEOFToken();
	        } else {
	            this._emitCodePoint(cp);
	        }
	    }

	    // CDATA section bracket state
	    //------------------------------------------------------------------
	    [CDATA_SECTION_BRACKET_STATE](cp) {
	        if (cp === $.RIGHT_SQUARE_BRACKET) {
	            this.state = CDATA_SECTION_END_STATE;
	        } else {
	            this._emitChars(']');
	            this._reconsumeInState(CDATA_SECTION_STATE);
	        }
	    }

	    // CDATA section end state
	    //------------------------------------------------------------------
	    [CDATA_SECTION_END_STATE](cp) {
	        if (cp === $.GREATER_THAN_SIGN) {
	            this.state = DATA_STATE;
	        } else if (cp === $.RIGHT_SQUARE_BRACKET) {
	            this._emitChars(']');
	        } else {
	            this._emitChars(']]');
	            this._reconsumeInState(CDATA_SECTION_STATE);
	        }
	    }

	    // Character reference state
	    //------------------------------------------------------------------
	    [CHARACTER_REFERENCE_STATE](cp) {
	        this.tempBuff = [$.AMPERSAND];

	        if (cp === $.NUMBER_SIGN) {
	            this.tempBuff.push(cp);
	            this.state = NUMERIC_CHARACTER_REFERENCE_STATE;
	        } else if (isAsciiAlphaNumeric(cp)) {
	            this._reconsumeInState(NAMED_CHARACTER_REFERENCE_STATE);
	        } else {
	            this._flushCodePointsConsumedAsCharacterReference();
	            this._reconsumeInState(this.returnState);
	        }
	    }

	    // Named character reference state
	    //------------------------------------------------------------------
	    [NAMED_CHARACTER_REFERENCE_STATE](cp) {
	        const matchResult = this._matchNamedCharacterReference(cp);

	        //NOTE: matching can be abrupted by hibernation. In that case match
	        //results are no longer valid and we will need to start over.
	        if (this._ensureHibernation()) {
	            this.tempBuff = [$.AMPERSAND];
	        } else if (matchResult) {
	            const withSemicolon = this.tempBuff[this.tempBuff.length - 1] === $.SEMICOLON;

	            if (!this._isCharacterReferenceAttributeQuirk(withSemicolon)) {
	                if (!withSemicolon) {
	                    this._errOnNextCodePoint(ERR.missingSemicolonAfterCharacterReference);
	                }

	                this.tempBuff = matchResult;
	            }

	            this._flushCodePointsConsumedAsCharacterReference();
	            this.state = this.returnState;
	        } else {
	            this._flushCodePointsConsumedAsCharacterReference();
	            this.state = AMBIGUOUS_AMPERSAND_STATE;
	        }
	    }

	    // Ambiguos ampersand state
	    //------------------------------------------------------------------
	    [AMBIGUOUS_AMPERSAND_STATE](cp) {
	        if (isAsciiAlphaNumeric(cp)) {
	            if (this._isCharacterReferenceInAttribute()) {
	                this.currentAttr.value += toChar(cp);
	            } else {
	                this._emitCodePoint(cp);
	            }
	        } else {
	            if (cp === $.SEMICOLON) {
	                this._err(ERR.unknownNamedCharacterReference);
	            }

	            this._reconsumeInState(this.returnState);
	        }
	    }

	    // Numeric character reference state
	    //------------------------------------------------------------------
	    [NUMERIC_CHARACTER_REFERENCE_STATE](cp) {
	        this.charRefCode = 0;

	        if (cp === $.LATIN_SMALL_X || cp === $.LATIN_CAPITAL_X) {
	            this.tempBuff.push(cp);
	            this.state = HEXADEMICAL_CHARACTER_REFERENCE_START_STATE;
	        } else {
	            this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_START_STATE);
	        }
	    }

	    // Hexademical character reference start state
	    //------------------------------------------------------------------
	    [HEXADEMICAL_CHARACTER_REFERENCE_START_STATE](cp) {
	        if (isAsciiHexDigit(cp)) {
	            this._reconsumeInState(HEXADEMICAL_CHARACTER_REFERENCE_STATE);
	        } else {
	            this._err(ERR.absenceOfDigitsInNumericCharacterReference);
	            this._flushCodePointsConsumedAsCharacterReference();
	            this._reconsumeInState(this.returnState);
	        }
	    }

	    // Decimal character reference start state
	    //------------------------------------------------------------------
	    [DECIMAL_CHARACTER_REFERENCE_START_STATE](cp) {
	        if (isAsciiDigit(cp)) {
	            this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_STATE);
	        } else {
	            this._err(ERR.absenceOfDigitsInNumericCharacterReference);
	            this._flushCodePointsConsumedAsCharacterReference();
	            this._reconsumeInState(this.returnState);
	        }
	    }

	    // Hexademical character reference state
	    //------------------------------------------------------------------
	    [HEXADEMICAL_CHARACTER_REFERENCE_STATE](cp) {
	        if (isAsciiUpperHexDigit(cp)) {
	            this.charRefCode = this.charRefCode * 16 + cp - 0x37;
	        } else if (isAsciiLowerHexDigit(cp)) {
	            this.charRefCode = this.charRefCode * 16 + cp - 0x57;
	        } else if (isAsciiDigit(cp)) {
	            this.charRefCode = this.charRefCode * 16 + cp - 0x30;
	        } else if (cp === $.SEMICOLON) {
	            this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;
	        } else {
	            this._err(ERR.missingSemicolonAfterCharacterReference);
	            this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);
	        }
	    }

	    // Decimal character reference state
	    //------------------------------------------------------------------
	    [DECIMAL_CHARACTER_REFERENCE_STATE](cp) {
	        if (isAsciiDigit(cp)) {
	            this.charRefCode = this.charRefCode * 10 + cp - 0x30;
	        } else if (cp === $.SEMICOLON) {
	            this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;
	        } else {
	            this._err(ERR.missingSemicolonAfterCharacterReference);
	            this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);
	        }
	    }

	    // Numeric character reference end state
	    //------------------------------------------------------------------
	    [NUMERIC_CHARACTER_REFERENCE_END_STATE]() {
	        if (this.charRefCode === $.NULL) {
	            this._err(ERR.nullCharacterReference);
	            this.charRefCode = $.REPLACEMENT_CHARACTER;
	        } else if (this.charRefCode > 0x10ffff) {
	            this._err(ERR.characterReferenceOutsideUnicodeRange);
	            this.charRefCode = $.REPLACEMENT_CHARACTER;
	        } else if (unicode.isSurrogate(this.charRefCode)) {
	            this._err(ERR.surrogateCharacterReference);
	            this.charRefCode = $.REPLACEMENT_CHARACTER;
	        } else if (unicode.isUndefinedCodePoint(this.charRefCode)) {
	            this._err(ERR.noncharacterCharacterReference);
	        } else if (unicode.isControlCodePoint(this.charRefCode) || this.charRefCode === $.CARRIAGE_RETURN) {
	            this._err(ERR.controlCharacterReference);

	            const replacement = C1_CONTROLS_REFERENCE_REPLACEMENTS[this.charRefCode];

	            if (replacement) {
	                this.charRefCode = replacement;
	            }
	        }

	        this.tempBuff = [this.charRefCode];

	        this._flushCodePointsConsumedAsCharacterReference();
	        this._reconsumeInState(this.returnState);
	    }
	}

	//Token types
	Tokenizer.CHARACTER_TOKEN = 'CHARACTER_TOKEN';
	Tokenizer.NULL_CHARACTER_TOKEN = 'NULL_CHARACTER_TOKEN';
	Tokenizer.WHITESPACE_CHARACTER_TOKEN = 'WHITESPACE_CHARACTER_TOKEN';
	Tokenizer.START_TAG_TOKEN = 'START_TAG_TOKEN';
	Tokenizer.END_TAG_TOKEN = 'END_TAG_TOKEN';
	Tokenizer.COMMENT_TOKEN = 'COMMENT_TOKEN';
	Tokenizer.DOCTYPE_TOKEN = 'DOCTYPE_TOKEN';
	Tokenizer.EOF_TOKEN = 'EOF_TOKEN';
	Tokenizer.HIBERNATION_TOKEN = 'HIBERNATION_TOKEN';

	//Tokenizer initial states for different modes
	Tokenizer.MODE = {
	    DATA: DATA_STATE,
	    RCDATA: RCDATA_STATE,
	    RAWTEXT: RAWTEXT_STATE,
	    SCRIPT_DATA: SCRIPT_DATA_STATE,
	    PLAINTEXT: PLAINTEXT_STATE
	};

	//Static
	Tokenizer.getTokenAttr = function(token, attrName) {
	    for (let i = token.attrs.length - 1; i >= 0; i--) {
	        if (token.attrs[i].name === attrName) {
	            return token.attrs[i].value;
	        }
	    }

	    return null;
	};

	tokenizer$1 = Tokenizer;
	return tokenizer$1;
}

var html$2 = {};

var hasRequiredHtml$2;

function requireHtml$2 () {
	if (hasRequiredHtml$2) return html$2;
	hasRequiredHtml$2 = 1;

	const NS = (html$2.NAMESPACES = {
	    HTML: 'http://www.w3.org/1999/xhtml',
	    MATHML: 'http://www.w3.org/1998/Math/MathML',
	    SVG: 'http://www.w3.org/2000/svg',
	    XLINK: 'http://www.w3.org/1999/xlink',
	    XML: 'http://www.w3.org/XML/1998/namespace',
	    XMLNS: 'http://www.w3.org/2000/xmlns/'
	});

	html$2.ATTRS = {
	    TYPE: 'type',
	    ACTION: 'action',
	    ENCODING: 'encoding',
	    PROMPT: 'prompt',
	    NAME: 'name',
	    COLOR: 'color',
	    FACE: 'face',
	    SIZE: 'size'
	};

	html$2.DOCUMENT_MODE = {
	    NO_QUIRKS: 'no-quirks',
	    QUIRKS: 'quirks',
	    LIMITED_QUIRKS: 'limited-quirks'
	};

	const $ = (html$2.TAG_NAMES = {
	    A: 'a',
	    ADDRESS: 'address',
	    ANNOTATION_XML: 'annotation-xml',
	    APPLET: 'applet',
	    AREA: 'area',
	    ARTICLE: 'article',
	    ASIDE: 'aside',

	    B: 'b',
	    BASE: 'base',
	    BASEFONT: 'basefont',
	    BGSOUND: 'bgsound',
	    BIG: 'big',
	    BLOCKQUOTE: 'blockquote',
	    BODY: 'body',
	    BR: 'br',
	    BUTTON: 'button',

	    CAPTION: 'caption',
	    CENTER: 'center',
	    CODE: 'code',
	    COL: 'col',
	    COLGROUP: 'colgroup',

	    DD: 'dd',
	    DESC: 'desc',
	    DETAILS: 'details',
	    DIALOG: 'dialog',
	    DIR: 'dir',
	    DIV: 'div',
	    DL: 'dl',
	    DT: 'dt',

	    EM: 'em',
	    EMBED: 'embed',

	    FIELDSET: 'fieldset',
	    FIGCAPTION: 'figcaption',
	    FIGURE: 'figure',
	    FONT: 'font',
	    FOOTER: 'footer',
	    FOREIGN_OBJECT: 'foreignObject',
	    FORM: 'form',
	    FRAME: 'frame',
	    FRAMESET: 'frameset',

	    H1: 'h1',
	    H2: 'h2',
	    H3: 'h3',
	    H4: 'h4',
	    H5: 'h5',
	    H6: 'h6',
	    HEAD: 'head',
	    HEADER: 'header',
	    HGROUP: 'hgroup',
	    HR: 'hr',
	    HTML: 'html',

	    I: 'i',
	    IMG: 'img',
	    IMAGE: 'image',
	    INPUT: 'input',
	    IFRAME: 'iframe',

	    KEYGEN: 'keygen',

	    LABEL: 'label',
	    LI: 'li',
	    LINK: 'link',
	    LISTING: 'listing',

	    MAIN: 'main',
	    MALIGNMARK: 'malignmark',
	    MARQUEE: 'marquee',
	    MATH: 'math',
	    MENU: 'menu',
	    META: 'meta',
	    MGLYPH: 'mglyph',
	    MI: 'mi',
	    MO: 'mo',
	    MN: 'mn',
	    MS: 'ms',
	    MTEXT: 'mtext',

	    NAV: 'nav',
	    NOBR: 'nobr',
	    NOFRAMES: 'noframes',
	    NOEMBED: 'noembed',
	    NOSCRIPT: 'noscript',

	    OBJECT: 'object',
	    OL: 'ol',
	    OPTGROUP: 'optgroup',
	    OPTION: 'option',

	    P: 'p',
	    PARAM: 'param',
	    PLAINTEXT: 'plaintext',
	    PRE: 'pre',

	    RB: 'rb',
	    RP: 'rp',
	    RT: 'rt',
	    RTC: 'rtc',
	    RUBY: 'ruby',

	    S: 's',
	    SCRIPT: 'script',
	    SECTION: 'section',
	    SELECT: 'select',
	    SOURCE: 'source',
	    SMALL: 'small',
	    SPAN: 'span',
	    STRIKE: 'strike',
	    STRONG: 'strong',
	    STYLE: 'style',
	    SUB: 'sub',
	    SUMMARY: 'summary',
	    SUP: 'sup',

	    TABLE: 'table',
	    TBODY: 'tbody',
	    TEMPLATE: 'template',
	    TEXTAREA: 'textarea',
	    TFOOT: 'tfoot',
	    TD: 'td',
	    TH: 'th',
	    THEAD: 'thead',
	    TITLE: 'title',
	    TR: 'tr',
	    TRACK: 'track',
	    TT: 'tt',

	    U: 'u',
	    UL: 'ul',

	    SVG: 'svg',

	    VAR: 'var',

	    WBR: 'wbr',

	    XMP: 'xmp'
	});

	html$2.SPECIAL_ELEMENTS = {
	    [NS.HTML]: {
	        [$.ADDRESS]: true,
	        [$.APPLET]: true,
	        [$.AREA]: true,
	        [$.ARTICLE]: true,
	        [$.ASIDE]: true,
	        [$.BASE]: true,
	        [$.BASEFONT]: true,
	        [$.BGSOUND]: true,
	        [$.BLOCKQUOTE]: true,
	        [$.BODY]: true,
	        [$.BR]: true,
	        [$.BUTTON]: true,
	        [$.CAPTION]: true,
	        [$.CENTER]: true,
	        [$.COL]: true,
	        [$.COLGROUP]: true,
	        [$.DD]: true,
	        [$.DETAILS]: true,
	        [$.DIR]: true,
	        [$.DIV]: true,
	        [$.DL]: true,
	        [$.DT]: true,
	        [$.EMBED]: true,
	        [$.FIELDSET]: true,
	        [$.FIGCAPTION]: true,
	        [$.FIGURE]: true,
	        [$.FOOTER]: true,
	        [$.FORM]: true,
	        [$.FRAME]: true,
	        [$.FRAMESET]: true,
	        [$.H1]: true,
	        [$.H2]: true,
	        [$.H3]: true,
	        [$.H4]: true,
	        [$.H5]: true,
	        [$.H6]: true,
	        [$.HEAD]: true,
	        [$.HEADER]: true,
	        [$.HGROUP]: true,
	        [$.HR]: true,
	        [$.HTML]: true,
	        [$.IFRAME]: true,
	        [$.IMG]: true,
	        [$.INPUT]: true,
	        [$.LI]: true,
	        [$.LINK]: true,
	        [$.LISTING]: true,
	        [$.MAIN]: true,
	        [$.MARQUEE]: true,
	        [$.MENU]: true,
	        [$.META]: true,
	        [$.NAV]: true,
	        [$.NOEMBED]: true,
	        [$.NOFRAMES]: true,
	        [$.NOSCRIPT]: true,
	        [$.OBJECT]: true,
	        [$.OL]: true,
	        [$.P]: true,
	        [$.PARAM]: true,
	        [$.PLAINTEXT]: true,
	        [$.PRE]: true,
	        [$.SCRIPT]: true,
	        [$.SECTION]: true,
	        [$.SELECT]: true,
	        [$.SOURCE]: true,
	        [$.STYLE]: true,
	        [$.SUMMARY]: true,
	        [$.TABLE]: true,
	        [$.TBODY]: true,
	        [$.TD]: true,
	        [$.TEMPLATE]: true,
	        [$.TEXTAREA]: true,
	        [$.TFOOT]: true,
	        [$.TH]: true,
	        [$.THEAD]: true,
	        [$.TITLE]: true,
	        [$.TR]: true,
	        [$.TRACK]: true,
	        [$.UL]: true,
	        [$.WBR]: true,
	        [$.XMP]: true
	    },
	    [NS.MATHML]: {
	        [$.MI]: true,
	        [$.MO]: true,
	        [$.MN]: true,
	        [$.MS]: true,
	        [$.MTEXT]: true,
	        [$.ANNOTATION_XML]: true
	    },
	    [NS.SVG]: {
	        [$.TITLE]: true,
	        [$.FOREIGN_OBJECT]: true,
	        [$.DESC]: true
	    }
	};
	return html$2;
}

var openElementStack$1;
var hasRequiredOpenElementStack$1;

function requireOpenElementStack$1 () {
	if (hasRequiredOpenElementStack$1) return openElementStack$1;
	hasRequiredOpenElementStack$1 = 1;

	const HTML = requireHtml$2();

	//Aliases
	const $ = HTML.TAG_NAMES;
	const NS = HTML.NAMESPACES;

	//Element utils

	//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.
	//It's faster than using dictionary.
	function isImpliedEndTagRequired(tn) {
	    switch (tn.length) {
	        case 1:
	            return tn === $.P;

	        case 2:
	            return tn === $.RB || tn === $.RP || tn === $.RT || tn === $.DD || tn === $.DT || tn === $.LI;

	        case 3:
	            return tn === $.RTC;

	        case 6:
	            return tn === $.OPTION;

	        case 8:
	            return tn === $.OPTGROUP;
	    }

	    return false;
	}

	function isImpliedEndTagRequiredThoroughly(tn) {
	    switch (tn.length) {
	        case 1:
	            return tn === $.P;

	        case 2:
	            return (
	                tn === $.RB ||
	                tn === $.RP ||
	                tn === $.RT ||
	                tn === $.DD ||
	                tn === $.DT ||
	                tn === $.LI ||
	                tn === $.TD ||
	                tn === $.TH ||
	                tn === $.TR
	            );

	        case 3:
	            return tn === $.RTC;

	        case 5:
	            return tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD;

	        case 6:
	            return tn === $.OPTION;

	        case 7:
	            return tn === $.CAPTION;

	        case 8:
	            return tn === $.OPTGROUP || tn === $.COLGROUP;
	    }

	    return false;
	}

	function isScopingElement(tn, ns) {
	    switch (tn.length) {
	        case 2:
	            if (tn === $.TD || tn === $.TH) {
	                return ns === NS.HTML;
	            } else if (tn === $.MI || tn === $.MO || tn === $.MN || tn === $.MS) {
	                return ns === NS.MATHML;
	            }

	            break;

	        case 4:
	            if (tn === $.HTML) {
	                return ns === NS.HTML;
	            } else if (tn === $.DESC) {
	                return ns === NS.SVG;
	            }

	            break;

	        case 5:
	            if (tn === $.TABLE) {
	                return ns === NS.HTML;
	            } else if (tn === $.MTEXT) {
	                return ns === NS.MATHML;
	            } else if (tn === $.TITLE) {
	                return ns === NS.SVG;
	            }

	            break;

	        case 6:
	            return (tn === $.APPLET || tn === $.OBJECT) && ns === NS.HTML;

	        case 7:
	            return (tn === $.CAPTION || tn === $.MARQUEE) && ns === NS.HTML;

	        case 8:
	            return tn === $.TEMPLATE && ns === NS.HTML;

	        case 13:
	            return tn === $.FOREIGN_OBJECT && ns === NS.SVG;

	        case 14:
	            return tn === $.ANNOTATION_XML && ns === NS.MATHML;
	    }

	    return false;
	}

	//Stack of open elements
	class OpenElementStack {
	    constructor(document, treeAdapter) {
	        this.stackTop = -1;
	        this.items = [];
	        this.current = document;
	        this.currentTagName = null;
	        this.currentTmplContent = null;
	        this.tmplCount = 0;
	        this.treeAdapter = treeAdapter;
	    }

	    //Index of element
	    _indexOf(element) {
	        let idx = -1;

	        for (let i = this.stackTop; i >= 0; i--) {
	            if (this.items[i] === element) {
	                idx = i;
	                break;
	            }
	        }
	        return idx;
	    }

	    //Update current element
	    _isInTemplate() {
	        return this.currentTagName === $.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS.HTML;
	    }

	    _updateCurrentElement() {
	        this.current = this.items[this.stackTop];
	        this.currentTagName = this.current && this.treeAdapter.getTagName(this.current);

	        this.currentTmplContent = this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : null;
	    }

	    //Mutations
	    push(element) {
	        this.items[++this.stackTop] = element;
	        this._updateCurrentElement();

	        if (this._isInTemplate()) {
	            this.tmplCount++;
	        }
	    }

	    pop() {
	        this.stackTop--;

	        if (this.tmplCount > 0 && this._isInTemplate()) {
	            this.tmplCount--;
	        }

	        this._updateCurrentElement();
	    }

	    replace(oldElement, newElement) {
	        const idx = this._indexOf(oldElement);

	        this.items[idx] = newElement;

	        if (idx === this.stackTop) {
	            this._updateCurrentElement();
	        }
	    }

	    insertAfter(referenceElement, newElement) {
	        const insertionIdx = this._indexOf(referenceElement) + 1;

	        this.items.splice(insertionIdx, 0, newElement);

	        if (insertionIdx === ++this.stackTop) {
	            this._updateCurrentElement();
	        }
	    }

	    popUntilTagNamePopped(tagName) {
	        while (this.stackTop > -1) {
	            const tn = this.currentTagName;
	            const ns = this.treeAdapter.getNamespaceURI(this.current);

	            this.pop();

	            if (tn === tagName && ns === NS.HTML) {
	                break;
	            }
	        }
	    }

	    popUntilElementPopped(element) {
	        while (this.stackTop > -1) {
	            const poppedElement = this.current;

	            this.pop();

	            if (poppedElement === element) {
	                break;
	            }
	        }
	    }

	    popUntilNumberedHeaderPopped() {
	        while (this.stackTop > -1) {
	            const tn = this.currentTagName;
	            const ns = this.treeAdapter.getNamespaceURI(this.current);

	            this.pop();

	            if (
	                tn === $.H1 ||
	                tn === $.H2 ||
	                tn === $.H3 ||
	                tn === $.H4 ||
	                tn === $.H5 ||
	                (tn === $.H6 && ns === NS.HTML)
	            ) {
	                break;
	            }
	        }
	    }

	    popUntilTableCellPopped() {
	        while (this.stackTop > -1) {
	            const tn = this.currentTagName;
	            const ns = this.treeAdapter.getNamespaceURI(this.current);

	            this.pop();

	            if (tn === $.TD || (tn === $.TH && ns === NS.HTML)) {
	                break;
	            }
	        }
	    }

	    popAllUpToHtmlElement() {
	        //NOTE: here we assume that root <html> element is always first in the open element stack, so
	        //we perform this fast stack clean up.
	        this.stackTop = 0;
	        this._updateCurrentElement();
	    }

	    clearBackToTableContext() {
	        while (
	            (this.currentTagName !== $.TABLE && this.currentTagName !== $.TEMPLATE && this.currentTagName !== $.HTML) ||
	            this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML
	        ) {
	            this.pop();
	        }
	    }

	    clearBackToTableBodyContext() {
	        while (
	            (this.currentTagName !== $.TBODY &&
	                this.currentTagName !== $.TFOOT &&
	                this.currentTagName !== $.THEAD &&
	                this.currentTagName !== $.TEMPLATE &&
	                this.currentTagName !== $.HTML) ||
	            this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML
	        ) {
	            this.pop();
	        }
	    }

	    clearBackToTableRowContext() {
	        while (
	            (this.currentTagName !== $.TR && this.currentTagName !== $.TEMPLATE && this.currentTagName !== $.HTML) ||
	            this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML
	        ) {
	            this.pop();
	        }
	    }

	    remove(element) {
	        for (let i = this.stackTop; i >= 0; i--) {
	            if (this.items[i] === element) {
	                this.items.splice(i, 1);
	                this.stackTop--;
	                this._updateCurrentElement();
	                break;
	            }
	        }
	    }

	    //Search
	    tryPeekProperlyNestedBodyElement() {
	        //Properly nested <body> element (should be second element in stack).
	        const element = this.items[1];

	        return element && this.treeAdapter.getTagName(element) === $.BODY ? element : null;
	    }

	    contains(element) {
	        return this._indexOf(element) > -1;
	    }

	    getCommonAncestor(element) {
	        let elementIdx = this._indexOf(element);

	        return --elementIdx >= 0 ? this.items[elementIdx] : null;
	    }

	    isRootHtmlElementCurrent() {
	        return this.stackTop === 0 && this.currentTagName === $.HTML;
	    }

	    //Element in scope
	    hasInScope(tagName) {
	        for (let i = this.stackTop; i >= 0; i--) {
	            const tn = this.treeAdapter.getTagName(this.items[i]);
	            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

	            if (tn === tagName && ns === NS.HTML) {
	                return true;
	            }

	            if (isScopingElement(tn, ns)) {
	                return false;
	            }
	        }

	        return true;
	    }

	    hasNumberedHeaderInScope() {
	        for (let i = this.stackTop; i >= 0; i--) {
	            const tn = this.treeAdapter.getTagName(this.items[i]);
	            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

	            if (
	                (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) &&
	                ns === NS.HTML
	            ) {
	                return true;
	            }

	            if (isScopingElement(tn, ns)) {
	                return false;
	            }
	        }

	        return true;
	    }

	    hasInListItemScope(tagName) {
	        for (let i = this.stackTop; i >= 0; i--) {
	            const tn = this.treeAdapter.getTagName(this.items[i]);
	            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

	            if (tn === tagName && ns === NS.HTML) {
	                return true;
	            }

	            if (((tn === $.UL || tn === $.OL) && ns === NS.HTML) || isScopingElement(tn, ns)) {
	                return false;
	            }
	        }

	        return true;
	    }

	    hasInButtonScope(tagName) {
	        for (let i = this.stackTop; i >= 0; i--) {
	            const tn = this.treeAdapter.getTagName(this.items[i]);
	            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

	            if (tn === tagName && ns === NS.HTML) {
	                return true;
	            }

	            if ((tn === $.BUTTON && ns === NS.HTML) || isScopingElement(tn, ns)) {
	                return false;
	            }
	        }

	        return true;
	    }

	    hasInTableScope(tagName) {
	        for (let i = this.stackTop; i >= 0; i--) {
	            const tn = this.treeAdapter.getTagName(this.items[i]);
	            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

	            if (ns !== NS.HTML) {
	                continue;
	            }

	            if (tn === tagName) {
	                return true;
	            }

	            if (tn === $.TABLE || tn === $.TEMPLATE || tn === $.HTML) {
	                return false;
	            }
	        }

	        return true;
	    }

	    hasTableBodyContextInTableScope() {
	        for (let i = this.stackTop; i >= 0; i--) {
	            const tn = this.treeAdapter.getTagName(this.items[i]);
	            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

	            if (ns !== NS.HTML) {
	                continue;
	            }

	            if (tn === $.TBODY || tn === $.THEAD || tn === $.TFOOT) {
	                return true;
	            }

	            if (tn === $.TABLE || tn === $.HTML) {
	                return false;
	            }
	        }

	        return true;
	    }

	    hasInSelectScope(tagName) {
	        for (let i = this.stackTop; i >= 0; i--) {
	            const tn = this.treeAdapter.getTagName(this.items[i]);
	            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

	            if (ns !== NS.HTML) {
	                continue;
	            }

	            if (tn === tagName) {
	                return true;
	            }

	            if (tn !== $.OPTION && tn !== $.OPTGROUP) {
	                return false;
	            }
	        }

	        return true;
	    }

	    //Implied end tags
	    generateImpliedEndTags() {
	        while (isImpliedEndTagRequired(this.currentTagName)) {
	            this.pop();
	        }
	    }

	    generateImpliedEndTagsThoroughly() {
	        while (isImpliedEndTagRequiredThoroughly(this.currentTagName)) {
	            this.pop();
	        }
	    }

	    generateImpliedEndTagsWithExclusion(exclusionTagName) {
	        while (isImpliedEndTagRequired(this.currentTagName) && this.currentTagName !== exclusionTagName) {
	            this.pop();
	        }
	    }
	}

	openElementStack$1 = OpenElementStack;
	return openElementStack$1;
}

var formattingElementList$1;
var hasRequiredFormattingElementList$1;

function requireFormattingElementList$1 () {
	if (hasRequiredFormattingElementList$1) return formattingElementList$1;
	hasRequiredFormattingElementList$1 = 1;

	//Const
	const NOAH_ARK_CAPACITY = 3;

	//List of formatting elements
	class FormattingElementList {
	    constructor(treeAdapter) {
	        this.length = 0;
	        this.entries = [];
	        this.treeAdapter = treeAdapter;
	        this.bookmark = null;
	    }

	    //Noah Ark's condition
	    //OPTIMIZATION: at first we try to find possible candidates for exclusion using
	    //lightweight heuristics without thorough attributes check.
	    _getNoahArkConditionCandidates(newElement) {
	        const candidates = [];

	        if (this.length >= NOAH_ARK_CAPACITY) {
	            const neAttrsLength = this.treeAdapter.getAttrList(newElement).length;
	            const neTagName = this.treeAdapter.getTagName(newElement);
	            const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);

	            for (let i = this.length - 1; i >= 0; i--) {
	                const entry = this.entries[i];

	                if (entry.type === FormattingElementList.MARKER_ENTRY) {
	                    break;
	                }

	                const element = entry.element;
	                const elementAttrs = this.treeAdapter.getAttrList(element);

	                const isCandidate =
	                    this.treeAdapter.getTagName(element) === neTagName &&
	                    this.treeAdapter.getNamespaceURI(element) === neNamespaceURI &&
	                    elementAttrs.length === neAttrsLength;

	                if (isCandidate) {
	                    candidates.push({ idx: i, attrs: elementAttrs });
	                }
	            }
	        }

	        return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;
	    }

	    _ensureNoahArkCondition(newElement) {
	        const candidates = this._getNoahArkConditionCandidates(newElement);
	        let cLength = candidates.length;

	        if (cLength) {
	            const neAttrs = this.treeAdapter.getAttrList(newElement);
	            const neAttrsLength = neAttrs.length;
	            const neAttrsMap = Object.create(null);

	            //NOTE: build attrs map for the new element so we can perform fast lookups
	            for (let i = 0; i < neAttrsLength; i++) {
	                const neAttr = neAttrs[i];

	                neAttrsMap[neAttr.name] = neAttr.value;
	            }

	            for (let i = 0; i < neAttrsLength; i++) {
	                for (let j = 0; j < cLength; j++) {
	                    const cAttr = candidates[j].attrs[i];

	                    if (neAttrsMap[cAttr.name] !== cAttr.value) {
	                        candidates.splice(j, 1);
	                        cLength--;
	                    }

	                    if (candidates.length < NOAH_ARK_CAPACITY) {
	                        return;
	                    }
	                }
	            }

	            //NOTE: remove bottommost candidates until Noah's Ark condition will not be met
	            for (let i = cLength - 1; i >= NOAH_ARK_CAPACITY - 1; i--) {
	                this.entries.splice(candidates[i].idx, 1);
	                this.length--;
	            }
	        }
	    }

	    //Mutations
	    insertMarker() {
	        this.entries.push({ type: FormattingElementList.MARKER_ENTRY });
	        this.length++;
	    }

	    pushElement(element, token) {
	        this._ensureNoahArkCondition(element);

	        this.entries.push({
	            type: FormattingElementList.ELEMENT_ENTRY,
	            element: element,
	            token: token
	        });

	        this.length++;
	    }

	    insertElementAfterBookmark(element, token) {
	        let bookmarkIdx = this.length - 1;

	        for (; bookmarkIdx >= 0; bookmarkIdx--) {
	            if (this.entries[bookmarkIdx] === this.bookmark) {
	                break;
	            }
	        }

	        this.entries.splice(bookmarkIdx + 1, 0, {
	            type: FormattingElementList.ELEMENT_ENTRY,
	            element: element,
	            token: token
	        });

	        this.length++;
	    }

	    removeEntry(entry) {
	        for (let i = this.length - 1; i >= 0; i--) {
	            if (this.entries[i] === entry) {
	                this.entries.splice(i, 1);
	                this.length--;
	                break;
	            }
	        }
	    }

	    clearToLastMarker() {
	        while (this.length) {
	            const entry = this.entries.pop();

	            this.length--;

	            if (entry.type === FormattingElementList.MARKER_ENTRY) {
	                break;
	            }
	        }
	    }

	    //Search
	    getElementEntryInScopeWithTagName(tagName) {
	        for (let i = this.length - 1; i >= 0; i--) {
	            const entry = this.entries[i];

	            if (entry.type === FormattingElementList.MARKER_ENTRY) {
	                return null;
	            }

	            if (this.treeAdapter.getTagName(entry.element) === tagName) {
	                return entry;
	            }
	        }

	        return null;
	    }

	    getElementEntry(element) {
	        for (let i = this.length - 1; i >= 0; i--) {
	            const entry = this.entries[i];

	            if (entry.type === FormattingElementList.ELEMENT_ENTRY && entry.element === element) {
	                return entry;
	            }
	        }

	        return null;
	    }
	}

	//Entry types
	FormattingElementList.MARKER_ENTRY = 'MARKER_ENTRY';
	FormattingElementList.ELEMENT_ENTRY = 'ELEMENT_ENTRY';

	formattingElementList$1 = FormattingElementList;
	return formattingElementList$1;
}

var mixin$1;
var hasRequiredMixin$1;

function requireMixin$1 () {
	if (hasRequiredMixin$1) return mixin$1;
	hasRequiredMixin$1 = 1;

	class Mixin {
	    constructor(host) {
	        const originalMethods = {};
	        const overriddenMethods = this._getOverriddenMethods(this, originalMethods);

	        for (const key of Object.keys(overriddenMethods)) {
	            if (typeof overriddenMethods[key] === 'function') {
	                originalMethods[key] = host[key];
	                host[key] = overriddenMethods[key];
	            }
	        }
	    }

	    _getOverriddenMethods() {
	        throw new Error('Not implemented');
	    }
	}

	Mixin.install = function(host, Ctor, opts) {
	    if (!host.__mixins) {
	        host.__mixins = [];
	    }

	    for (let i = 0; i < host.__mixins.length; i++) {
	        if (host.__mixins[i].constructor === Ctor) {
	            return host.__mixins[i];
	        }
	    }

	    const mixin = new Ctor(host, opts);

	    host.__mixins.push(mixin);

	    return mixin;
	};

	mixin$1 = Mixin;
	return mixin$1;
}

var preprocessorMixin$3;
var hasRequiredPreprocessorMixin$3;

function requirePreprocessorMixin$3 () {
	if (hasRequiredPreprocessorMixin$3) return preprocessorMixin$3;
	hasRequiredPreprocessorMixin$3 = 1;

	const Mixin = requireMixin$1();

	class PositionTrackingPreprocessorMixin extends Mixin {
	    constructor(preprocessor) {
	        super(preprocessor);

	        this.preprocessor = preprocessor;
	        this.isEol = false;
	        this.lineStartPos = 0;
	        this.droppedBufferSize = 0;

	        this.offset = 0;
	        this.col = 0;
	        this.line = 1;
	    }

	    _getOverriddenMethods(mxn, orig) {
	        return {
	            advance() {
	                const pos = this.pos + 1;
	                const ch = this.html[pos];

	                //NOTE: LF should be in the last column of the line
	                if (mxn.isEol) {
	                    mxn.isEol = false;
	                    mxn.line++;
	                    mxn.lineStartPos = pos;
	                }

	                if (ch === '\n' || (ch === '\r' && this.html[pos + 1] !== '\n')) {
	                    mxn.isEol = true;
	                }

	                mxn.col = pos - mxn.lineStartPos + 1;
	                mxn.offset = mxn.droppedBufferSize + pos;

	                return orig.advance.call(this);
	            },

	            retreat() {
	                orig.retreat.call(this);

	                mxn.isEol = false;
	                mxn.col = this.pos - mxn.lineStartPos + 1;
	            },

	            dropParsedChunk() {
	                const prevPos = this.pos;

	                orig.dropParsedChunk.call(this);

	                const reduction = prevPos - this.pos;

	                mxn.lineStartPos -= reduction;
	                mxn.droppedBufferSize += reduction;
	                mxn.offset = mxn.droppedBufferSize + this.pos;
	            }
	        };
	    }
	}

	preprocessorMixin$3 = PositionTrackingPreprocessorMixin;
	return preprocessorMixin$3;
}

var tokenizerMixin$3;
var hasRequiredTokenizerMixin$3;

function requireTokenizerMixin$3 () {
	if (hasRequiredTokenizerMixin$3) return tokenizerMixin$3;
	hasRequiredTokenizerMixin$3 = 1;

	const Mixin = requireMixin$1();
	const Tokenizer = requireTokenizer$1();
	const PositionTrackingPreprocessorMixin = requirePreprocessorMixin$3();

	class LocationInfoTokenizerMixin extends Mixin {
	    constructor(tokenizer) {
	        super(tokenizer);

	        this.tokenizer = tokenizer;
	        this.posTracker = Mixin.install(tokenizer.preprocessor, PositionTrackingPreprocessorMixin);
	        this.currentAttrLocation = null;
	        this.ctLoc = null;
	    }

	    _getCurrentLocation() {
	        return {
	            startLine: this.posTracker.line,
	            startCol: this.posTracker.col,
	            startOffset: this.posTracker.offset,
	            endLine: -1,
	            endCol: -1,
	            endOffset: -1
	        };
	    }

	    _attachCurrentAttrLocationInfo() {
	        this.currentAttrLocation.endLine = this.posTracker.line;
	        this.currentAttrLocation.endCol = this.posTracker.col;
	        this.currentAttrLocation.endOffset = this.posTracker.offset;

	        const currentToken = this.tokenizer.currentToken;
	        const currentAttr = this.tokenizer.currentAttr;

	        if (!currentToken.location.attrs) {
	            currentToken.location.attrs = Object.create(null);
	        }

	        currentToken.location.attrs[currentAttr.name] = this.currentAttrLocation;
	    }

	    _getOverriddenMethods(mxn, orig) {
	        const methods = {
	            _createStartTagToken() {
	                orig._createStartTagToken.call(this);
	                this.currentToken.location = mxn.ctLoc;
	            },

	            _createEndTagToken() {
	                orig._createEndTagToken.call(this);
	                this.currentToken.location = mxn.ctLoc;
	            },

	            _createCommentToken() {
	                orig._createCommentToken.call(this);
	                this.currentToken.location = mxn.ctLoc;
	            },

	            _createDoctypeToken(initialName) {
	                orig._createDoctypeToken.call(this, initialName);
	                this.currentToken.location = mxn.ctLoc;
	            },

	            _createCharacterToken(type, ch) {
	                orig._createCharacterToken.call(this, type, ch);
	                this.currentCharacterToken.location = mxn.ctLoc;
	            },

	            _createEOFToken() {
	                orig._createEOFToken.call(this);
	                this.currentToken.location = mxn._getCurrentLocation();
	            },

	            _createAttr(attrNameFirstCh) {
	                orig._createAttr.call(this, attrNameFirstCh);
	                mxn.currentAttrLocation = mxn._getCurrentLocation();
	            },

	            _leaveAttrName(toState) {
	                orig._leaveAttrName.call(this, toState);
	                mxn._attachCurrentAttrLocationInfo();
	            },

	            _leaveAttrValue(toState) {
	                orig._leaveAttrValue.call(this, toState);
	                mxn._attachCurrentAttrLocationInfo();
	            },

	            _emitCurrentToken() {
	                const ctLoc = this.currentToken.location;

	                //NOTE: if we have pending character token make it's end location equal to the
	                //current token's start location.
	                if (this.currentCharacterToken) {
	                    this.currentCharacterToken.location.endLine = ctLoc.startLine;
	                    this.currentCharacterToken.location.endCol = ctLoc.startCol;
	                    this.currentCharacterToken.location.endOffset = ctLoc.startOffset;
	                }

	                if (this.currentToken.type === Tokenizer.EOF_TOKEN) {
	                    ctLoc.endLine = ctLoc.startLine;
	                    ctLoc.endCol = ctLoc.startCol;
	                    ctLoc.endOffset = ctLoc.startOffset;
	                } else {
	                    ctLoc.endLine = mxn.posTracker.line;
	                    ctLoc.endCol = mxn.posTracker.col + 1;
	                    ctLoc.endOffset = mxn.posTracker.offset + 1;
	                }

	                orig._emitCurrentToken.call(this);
	            },

	            _emitCurrentCharacterToken() {
	                const ctLoc = this.currentCharacterToken && this.currentCharacterToken.location;

	                //NOTE: if we have character token and it's location wasn't set in the _emitCurrentToken(),
	                //then set it's location at the current preprocessor position.
	                //We don't need to increment preprocessor position, since character token
	                //emission is always forced by the start of the next character token here.
	                //So, we already have advanced position.
	                if (ctLoc && ctLoc.endOffset === -1) {
	                    ctLoc.endLine = mxn.posTracker.line;
	                    ctLoc.endCol = mxn.posTracker.col;
	                    ctLoc.endOffset = mxn.posTracker.offset;
	                }

	                orig._emitCurrentCharacterToken.call(this);
	            }
	        };

	        //NOTE: patch initial states for each mode to obtain token start position
	        Object.keys(Tokenizer.MODE).forEach(modeName => {
	            const state = Tokenizer.MODE[modeName];

	            methods[state] = function(cp) {
	                mxn.ctLoc = mxn._getCurrentLocation();
	                orig[state].call(this, cp);
	            };
	        });

	        return methods;
	    }
	}

	tokenizerMixin$3 = LocationInfoTokenizerMixin;
	return tokenizerMixin$3;
}

var openElementStackMixin$1;
var hasRequiredOpenElementStackMixin$1;

function requireOpenElementStackMixin$1 () {
	if (hasRequiredOpenElementStackMixin$1) return openElementStackMixin$1;
	hasRequiredOpenElementStackMixin$1 = 1;

	const Mixin = requireMixin$1();

	class LocationInfoOpenElementStackMixin extends Mixin {
	    constructor(stack, opts) {
	        super(stack);

	        this.onItemPop = opts.onItemPop;
	    }

	    _getOverriddenMethods(mxn, orig) {
	        return {
	            pop() {
	                mxn.onItemPop(this.current);
	                orig.pop.call(this);
	            },

	            popAllUpToHtmlElement() {
	                for (let i = this.stackTop; i > 0; i--) {
	                    mxn.onItemPop(this.items[i]);
	                }

	                orig.popAllUpToHtmlElement.call(this);
	            },

	            remove(element) {
	                mxn.onItemPop(this.current);
	                orig.remove.call(this, element);
	            }
	        };
	    }
	}

	openElementStackMixin$1 = LocationInfoOpenElementStackMixin;
	return openElementStackMixin$1;
}

var parserMixin$3;
var hasRequiredParserMixin$3;

function requireParserMixin$3 () {
	if (hasRequiredParserMixin$3) return parserMixin$3;
	hasRequiredParserMixin$3 = 1;

	const Mixin = requireMixin$1();
	const Tokenizer = requireTokenizer$1();
	const LocationInfoTokenizerMixin = requireTokenizerMixin$3();
	const LocationInfoOpenElementStackMixin = requireOpenElementStackMixin$1();
	const HTML = requireHtml$2();

	//Aliases
	const $ = HTML.TAG_NAMES;

	class LocationInfoParserMixin extends Mixin {
	    constructor(parser) {
	        super(parser);

	        this.parser = parser;
	        this.treeAdapter = this.parser.treeAdapter;
	        this.posTracker = null;
	        this.lastStartTagToken = null;
	        this.lastFosterParentingLocation = null;
	        this.currentToken = null;
	    }

	    _setStartLocation(element) {
	        let loc = null;

	        if (this.lastStartTagToken) {
	            loc = Object.assign({}, this.lastStartTagToken.location);
	            loc.startTag = this.lastStartTagToken.location;
	        }

	        this.treeAdapter.setNodeSourceCodeLocation(element, loc);
	    }

	    _setEndLocation(element, closingToken) {
	        const loc = this.treeAdapter.getNodeSourceCodeLocation(element);

	        if (loc) {
	            if (closingToken.location) {
	                const ctLoc = closingToken.location;
	                const tn = this.treeAdapter.getTagName(element);

	                // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
	                // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
	                const isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;

	                if (isClosingEndTag) {
	                    loc.endTag = Object.assign({}, ctLoc);
	                    loc.endLine = ctLoc.endLine;
	                    loc.endCol = ctLoc.endCol;
	                    loc.endOffset = ctLoc.endOffset;
	                } else {
	                    loc.endLine = ctLoc.startLine;
	                    loc.endCol = ctLoc.startCol;
	                    loc.endOffset = ctLoc.startOffset;
	                }
	            }
	        }
	    }

	    _getOverriddenMethods(mxn, orig) {
	        return {
	            _bootstrap(document, fragmentContext) {
	                orig._bootstrap.call(this, document, fragmentContext);

	                mxn.lastStartTagToken = null;
	                mxn.lastFosterParentingLocation = null;
	                mxn.currentToken = null;

	                const tokenizerMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);

	                mxn.posTracker = tokenizerMixin.posTracker;

	                Mixin.install(this.openElements, LocationInfoOpenElementStackMixin, {
	                    onItemPop: function(element) {
	                        mxn._setEndLocation(element, mxn.currentToken);
	                    }
	                });
	            },

	            _runParsingLoop(scriptHandler) {
	                orig._runParsingLoop.call(this, scriptHandler);

	                // NOTE: generate location info for elements
	                // that remains on open element stack
	                for (let i = this.openElements.stackTop; i >= 0; i--) {
	                    mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);
	                }
	            },

	            //Token processing
	            _processTokenInForeignContent(token) {
	                mxn.currentToken = token;
	                orig._processTokenInForeignContent.call(this, token);
	            },

	            _processToken(token) {
	                mxn.currentToken = token;
	                orig._processToken.call(this, token);

	                //NOTE: <body> and <html> are never popped from the stack, so we need to updated
	                //their end location explicitly.
	                const requireExplicitUpdate =
	                    token.type === Tokenizer.END_TAG_TOKEN &&
	                    (token.tagName === $.HTML || (token.tagName === $.BODY && this.openElements.hasInScope($.BODY)));

	                if (requireExplicitUpdate) {
	                    for (let i = this.openElements.stackTop; i >= 0; i--) {
	                        const element = this.openElements.items[i];

	                        if (this.treeAdapter.getTagName(element) === token.tagName) {
	                            mxn._setEndLocation(element, token);
	                            break;
	                        }
	                    }
	                }
	            },

	            //Doctype
	            _setDocumentType(token) {
	                orig._setDocumentType.call(this, token);

	                const documentChildren = this.treeAdapter.getChildNodes(this.document);
	                const cnLength = documentChildren.length;

	                for (let i = 0; i < cnLength; i++) {
	                    const node = documentChildren[i];

	                    if (this.treeAdapter.isDocumentTypeNode(node)) {
	                        this.treeAdapter.setNodeSourceCodeLocation(node, token.location);
	                        break;
	                    }
	                }
	            },

	            //Elements
	            _attachElementToTree(element) {
	                //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.
	                //So we will use token location stored in this methods for the element.
	                mxn._setStartLocation(element);
	                mxn.lastStartTagToken = null;
	                orig._attachElementToTree.call(this, element);
	            },

	            _appendElement(token, namespaceURI) {
	                mxn.lastStartTagToken = token;
	                orig._appendElement.call(this, token, namespaceURI);
	            },

	            _insertElement(token, namespaceURI) {
	                mxn.lastStartTagToken = token;
	                orig._insertElement.call(this, token, namespaceURI);
	            },

	            _insertTemplate(token) {
	                mxn.lastStartTagToken = token;
	                orig._insertTemplate.call(this, token);

	                const tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);

	                this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);
	            },

	            _insertFakeRootElement() {
	                orig._insertFakeRootElement.call(this);
	                this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);
	            },

	            //Comments
	            _appendCommentNode(token, parent) {
	                orig._appendCommentNode.call(this, token, parent);

	                const children = this.treeAdapter.getChildNodes(parent);
	                const commentNode = children[children.length - 1];

	                this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
	            },

	            //Text
	            _findFosterParentingLocation() {
	                //NOTE: store last foster parenting location, so we will be able to find inserted text
	                //in case of foster parenting
	                mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);

	                return mxn.lastFosterParentingLocation;
	            },

	            _insertCharacters(token) {
	                orig._insertCharacters.call(this, token);

	                const hasFosterParent = this._shouldFosterParentOnInsertion();

	                const parent =
	                    (hasFosterParent && mxn.lastFosterParentingLocation.parent) ||
	                    this.openElements.currentTmplContent ||
	                    this.openElements.current;

	                const siblings = this.treeAdapter.getChildNodes(parent);

	                const textNodeIdx =
	                    hasFosterParent && mxn.lastFosterParentingLocation.beforeElement
	                        ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1
	                        : siblings.length - 1;

	                const textNode = siblings[textNodeIdx];

	                //NOTE: if we have location assigned by another token, then just update end position
	                const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);

	                if (tnLoc) {
	                    tnLoc.endLine = token.location.endLine;
	                    tnLoc.endCol = token.location.endCol;
	                    tnLoc.endOffset = token.location.endOffset;
	                } else {
	                    this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
	                }
	            }
	        };
	    }
	}

	parserMixin$3 = LocationInfoParserMixin;
	return parserMixin$3;
}

var mixinBase$1;
var hasRequiredMixinBase$1;

function requireMixinBase$1 () {
	if (hasRequiredMixinBase$1) return mixinBase$1;
	hasRequiredMixinBase$1 = 1;

	const Mixin = requireMixin$1();

	class ErrorReportingMixinBase extends Mixin {
	    constructor(host, opts) {
	        super(host);

	        this.posTracker = null;
	        this.onParseError = opts.onParseError;
	    }

	    _setErrorLocation(err) {
	        err.startLine = err.endLine = this.posTracker.line;
	        err.startCol = err.endCol = this.posTracker.col;
	        err.startOffset = err.endOffset = this.posTracker.offset;
	    }

	    _reportError(code) {
	        const err = {
	            code: code,
	            startLine: -1,
	            startCol: -1,
	            startOffset: -1,
	            endLine: -1,
	            endCol: -1,
	            endOffset: -1
	        };

	        this._setErrorLocation(err);
	        this.onParseError(err);
	    }

	    _getOverriddenMethods(mxn) {
	        return {
	            _err(code) {
	                mxn._reportError(code);
	            }
	        };
	    }
	}

	mixinBase$1 = ErrorReportingMixinBase;
	return mixinBase$1;
}

var preprocessorMixin$2;
var hasRequiredPreprocessorMixin$2;

function requirePreprocessorMixin$2 () {
	if (hasRequiredPreprocessorMixin$2) return preprocessorMixin$2;
	hasRequiredPreprocessorMixin$2 = 1;

	const ErrorReportingMixinBase = requireMixinBase$1();
	const PositionTrackingPreprocessorMixin = requirePreprocessorMixin$3();
	const Mixin = requireMixin$1();

	class ErrorReportingPreprocessorMixin extends ErrorReportingMixinBase {
	    constructor(preprocessor, opts) {
	        super(preprocessor, opts);

	        this.posTracker = Mixin.install(preprocessor, PositionTrackingPreprocessorMixin);
	        this.lastErrOffset = -1;
	    }

	    _reportError(code) {
	        //NOTE: avoid reporting error twice on advance/retreat
	        if (this.lastErrOffset !== this.posTracker.offset) {
	            this.lastErrOffset = this.posTracker.offset;
	            super._reportError(code);
	        }
	    }
	}

	preprocessorMixin$2 = ErrorReportingPreprocessorMixin;
	return preprocessorMixin$2;
}

var tokenizerMixin$2;
var hasRequiredTokenizerMixin$2;

function requireTokenizerMixin$2 () {
	if (hasRequiredTokenizerMixin$2) return tokenizerMixin$2;
	hasRequiredTokenizerMixin$2 = 1;

	const ErrorReportingMixinBase = requireMixinBase$1();
	const ErrorReportingPreprocessorMixin = requirePreprocessorMixin$2();
	const Mixin = requireMixin$1();

	class ErrorReportingTokenizerMixin extends ErrorReportingMixinBase {
	    constructor(tokenizer, opts) {
	        super(tokenizer, opts);

	        const preprocessorMixin = Mixin.install(tokenizer.preprocessor, ErrorReportingPreprocessorMixin, opts);

	        this.posTracker = preprocessorMixin.posTracker;
	    }
	}

	tokenizerMixin$2 = ErrorReportingTokenizerMixin;
	return tokenizerMixin$2;
}

var parserMixin$2;
var hasRequiredParserMixin$2;

function requireParserMixin$2 () {
	if (hasRequiredParserMixin$2) return parserMixin$2;
	hasRequiredParserMixin$2 = 1;

	const ErrorReportingMixinBase = requireMixinBase$1();
	const ErrorReportingTokenizerMixin = requireTokenizerMixin$2();
	const LocationInfoTokenizerMixin = requireTokenizerMixin$3();
	const Mixin = requireMixin$1();

	class ErrorReportingParserMixin extends ErrorReportingMixinBase {
	    constructor(parser, opts) {
	        super(parser, opts);

	        this.opts = opts;
	        this.ctLoc = null;
	        this.locBeforeToken = false;
	    }

	    _setErrorLocation(err) {
	        if (this.ctLoc) {
	            err.startLine = this.ctLoc.startLine;
	            err.startCol = this.ctLoc.startCol;
	            err.startOffset = this.ctLoc.startOffset;

	            err.endLine = this.locBeforeToken ? this.ctLoc.startLine : this.ctLoc.endLine;
	            err.endCol = this.locBeforeToken ? this.ctLoc.startCol : this.ctLoc.endCol;
	            err.endOffset = this.locBeforeToken ? this.ctLoc.startOffset : this.ctLoc.endOffset;
	        }
	    }

	    _getOverriddenMethods(mxn, orig) {
	        return {
	            _bootstrap(document, fragmentContext) {
	                orig._bootstrap.call(this, document, fragmentContext);

	                Mixin.install(this.tokenizer, ErrorReportingTokenizerMixin, mxn.opts);
	                Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);
	            },

	            _processInputToken(token) {
	                mxn.ctLoc = token.location;

	                orig._processInputToken.call(this, token);
	            },

	            _err(code, options) {
	                mxn.locBeforeToken = options && options.beforeToken;
	                mxn._reportError(code);
	            }
	        };
	    }
	}

	parserMixin$2 = ErrorReportingParserMixin;
	return parserMixin$2;
}

var _default$1 = {};

var hasRequired_default$1;

function require_default$1 () {
	if (hasRequired_default$1) return _default$1;
	hasRequired_default$1 = 1;

	const { DOCUMENT_MODE } = requireHtml$2();

	//Node construction
	_default$1.createDocument = function() {
	    return {
	        nodeName: '#document',
	        mode: DOCUMENT_MODE.NO_QUIRKS,
	        childNodes: []
	    };
	};

	_default$1.createDocumentFragment = function() {
	    return {
	        nodeName: '#document-fragment',
	        childNodes: []
	    };
	};

	_default$1.createElement = function(tagName, namespaceURI, attrs) {
	    return {
	        nodeName: tagName,
	        tagName: tagName,
	        attrs: attrs,
	        namespaceURI: namespaceURI,
	        childNodes: [],
	        parentNode: null
	    };
	};

	_default$1.createCommentNode = function(data) {
	    return {
	        nodeName: '#comment',
	        data: data,
	        parentNode: null
	    };
	};

	const createTextNode = function(value) {
	    return {
	        nodeName: '#text',
	        value: value,
	        parentNode: null
	    };
	};

	//Tree mutation
	const appendChild = (_default$1.appendChild = function(parentNode, newNode) {
	    parentNode.childNodes.push(newNode);
	    newNode.parentNode = parentNode;
	});

	const insertBefore = (_default$1.insertBefore = function(parentNode, newNode, referenceNode) {
	    const insertionIdx = parentNode.childNodes.indexOf(referenceNode);

	    parentNode.childNodes.splice(insertionIdx, 0, newNode);
	    newNode.parentNode = parentNode;
	});

	_default$1.setTemplateContent = function(templateElement, contentElement) {
	    templateElement.content = contentElement;
	};

	_default$1.getTemplateContent = function(templateElement) {
	    return templateElement.content;
	};

	_default$1.setDocumentType = function(document, name, publicId, systemId) {
	    let doctypeNode = null;

	    for (let i = 0; i < document.childNodes.length; i++) {
	        if (document.childNodes[i].nodeName === '#documentType') {
	            doctypeNode = document.childNodes[i];
	            break;
	        }
	    }

	    if (doctypeNode) {
	        doctypeNode.name = name;
	        doctypeNode.publicId = publicId;
	        doctypeNode.systemId = systemId;
	    } else {
	        appendChild(document, {
	            nodeName: '#documentType',
	            name: name,
	            publicId: publicId,
	            systemId: systemId
	        });
	    }
	};

	_default$1.setDocumentMode = function(document, mode) {
	    document.mode = mode;
	};

	_default$1.getDocumentMode = function(document) {
	    return document.mode;
	};

	_default$1.detachNode = function(node) {
	    if (node.parentNode) {
	        const idx = node.parentNode.childNodes.indexOf(node);

	        node.parentNode.childNodes.splice(idx, 1);
	        node.parentNode = null;
	    }
	};

	_default$1.insertText = function(parentNode, text) {
	    if (parentNode.childNodes.length) {
	        const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];

	        if (prevNode.nodeName === '#text') {
	            prevNode.value += text;
	            return;
	        }
	    }

	    appendChild(parentNode, createTextNode(text));
	};

	_default$1.insertTextBefore = function(parentNode, text, referenceNode) {
	    const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];

	    if (prevNode && prevNode.nodeName === '#text') {
	        prevNode.value += text;
	    } else {
	        insertBefore(parentNode, createTextNode(text), referenceNode);
	    }
	};

	_default$1.adoptAttributes = function(recipient, attrs) {
	    const recipientAttrsMap = [];

	    for (let i = 0; i < recipient.attrs.length; i++) {
	        recipientAttrsMap.push(recipient.attrs[i].name);
	    }

	    for (let j = 0; j < attrs.length; j++) {
	        if (recipientAttrsMap.indexOf(attrs[j].name) === -1) {
	            recipient.attrs.push(attrs[j]);
	        }
	    }
	};

	//Tree traversing
	_default$1.getFirstChild = function(node) {
	    return node.childNodes[0];
	};

	_default$1.getChildNodes = function(node) {
	    return node.childNodes;
	};

	_default$1.getParentNode = function(node) {
	    return node.parentNode;
	};

	_default$1.getAttrList = function(element) {
	    return element.attrs;
	};

	//Node data
	_default$1.getTagName = function(element) {
	    return element.tagName;
	};

	_default$1.getNamespaceURI = function(element) {
	    return element.namespaceURI;
	};

	_default$1.getTextNodeContent = function(textNode) {
	    return textNode.value;
	};

	_default$1.getCommentNodeContent = function(commentNode) {
	    return commentNode.data;
	};

	_default$1.getDocumentTypeNodeName = function(doctypeNode) {
	    return doctypeNode.name;
	};

	_default$1.getDocumentTypeNodePublicId = function(doctypeNode) {
	    return doctypeNode.publicId;
	};

	_default$1.getDocumentTypeNodeSystemId = function(doctypeNode) {
	    return doctypeNode.systemId;
	};

	//Node types
	_default$1.isTextNode = function(node) {
	    return node.nodeName === '#text';
	};

	_default$1.isCommentNode = function(node) {
	    return node.nodeName === '#comment';
	};

	_default$1.isDocumentTypeNode = function(node) {
	    return node.nodeName === '#documentType';
	};

	_default$1.isElementNode = function(node) {
	    return !!node.tagName;
	};

	// Source code location
	_default$1.setNodeSourceCodeLocation = function(node, location) {
	    node.sourceCodeLocation = location;
	};

	_default$1.getNodeSourceCodeLocation = function(node) {
	    return node.sourceCodeLocation;
	};
	return _default$1;
}

var mergeOptions$1;
var hasRequiredMergeOptions$1;

function requireMergeOptions$1 () {
	if (hasRequiredMergeOptions$1) return mergeOptions$1;
	hasRequiredMergeOptions$1 = 1;

	mergeOptions$1 = function mergeOptions(defaults, options) {
	    options = options || Object.create(null);

	    return [defaults, options].reduce((merged, optObj) => {
	        Object.keys(optObj).forEach(key => {
	            merged[key] = optObj[key];
	        });

	        return merged;
	    }, Object.create(null));
	};
	return mergeOptions$1;
}

var doctype$2 = {};

var hasRequiredDoctype$2;

function requireDoctype$2 () {
	if (hasRequiredDoctype$2) return doctype$2;
	hasRequiredDoctype$2 = 1;

	const { DOCUMENT_MODE } = requireHtml$2();

	//Const
	const VALID_DOCTYPE_NAME = 'html';
	const VALID_SYSTEM_ID = 'about:legacy-compat';
	const QUIRKS_MODE_SYSTEM_ID = 'http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd';

	const QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
	    '+//silmaril//dtd html pro v0r11 19970101//',
	    '-//as//dtd html 3.0 aswedit + extensions//',
	    '-//advasoft ltd//dtd html 3.0 aswedit + extensions//',
	    '-//ietf//dtd html 2.0 level 1//',
	    '-//ietf//dtd html 2.0 level 2//',
	    '-//ietf//dtd html 2.0 strict level 1//',
	    '-//ietf//dtd html 2.0 strict level 2//',
	    '-//ietf//dtd html 2.0 strict//',
	    '-//ietf//dtd html 2.0//',
	    '-//ietf//dtd html 2.1e//',
	    '-//ietf//dtd html 3.0//',
	    '-//ietf//dtd html 3.2 final//',
	    '-//ietf//dtd html 3.2//',
	    '-//ietf//dtd html 3//',
	    '-//ietf//dtd html level 0//',
	    '-//ietf//dtd html level 1//',
	    '-//ietf//dtd html level 2//',
	    '-//ietf//dtd html level 3//',
	    '-//ietf//dtd html strict level 0//',
	    '-//ietf//dtd html strict level 1//',
	    '-//ietf//dtd html strict level 2//',
	    '-//ietf//dtd html strict level 3//',
	    '-//ietf//dtd html strict//',
	    '-//ietf//dtd html//',
	    '-//metrius//dtd metrius presentational//',
	    '-//microsoft//dtd internet explorer 2.0 html strict//',
	    '-//microsoft//dtd internet explorer 2.0 html//',
	    '-//microsoft//dtd internet explorer 2.0 tables//',
	    '-//microsoft//dtd internet explorer 3.0 html strict//',
	    '-//microsoft//dtd internet explorer 3.0 html//',
	    '-//microsoft//dtd internet explorer 3.0 tables//',
	    '-//netscape comm. corp.//dtd html//',
	    '-//netscape comm. corp.//dtd strict html//',
	    "-//o'reilly and associates//dtd html 2.0//",
	    "-//o'reilly and associates//dtd html extended 1.0//",
	    "-//o'reilly and associates//dtd html extended relaxed 1.0//",
	    '-//sq//dtd html 2.0 hotmetal + extensions//',
	    '-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//',
	    '-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//',
	    '-//spyglass//dtd html 2.0 extended//',
	    '-//sun microsystems corp.//dtd hotjava html//',
	    '-//sun microsystems corp.//dtd hotjava strict html//',
	    '-//w3c//dtd html 3 1995-03-24//',
	    '-//w3c//dtd html 3.2 draft//',
	    '-//w3c//dtd html 3.2 final//',
	    '-//w3c//dtd html 3.2//',
	    '-//w3c//dtd html 3.2s draft//',
	    '-//w3c//dtd html 4.0 frameset//',
	    '-//w3c//dtd html 4.0 transitional//',
	    '-//w3c//dtd html experimental 19960712//',
	    '-//w3c//dtd html experimental 970421//',
	    '-//w3c//dtd w3 html//',
	    '-//w3o//dtd w3 html 3.0//',
	    '-//webtechs//dtd mozilla html 2.0//',
	    '-//webtechs//dtd mozilla html//'
	];

	const QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = QUIRKS_MODE_PUBLIC_ID_PREFIXES.concat([
	    '-//w3c//dtd html 4.01 frameset//',
	    '-//w3c//dtd html 4.01 transitional//'
	]);

	const QUIRKS_MODE_PUBLIC_IDS = ['-//w3o//dtd w3 html strict 3.0//en//', '-/w3c/dtd html 4.0 transitional/en', 'html'];
	const LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ['-//w3c//dtd xhtml 1.0 frameset//', '-//w3c//dtd xhtml 1.0 transitional//'];

	const LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = LIMITED_QUIRKS_PUBLIC_ID_PREFIXES.concat([
	    '-//w3c//dtd html 4.01 frameset//',
	    '-//w3c//dtd html 4.01 transitional//'
	]);

	//Utils
	function enquoteDoctypeId(id) {
	    const quote = id.indexOf('"') !== -1 ? "'" : '"';

	    return quote + id + quote;
	}

	function hasPrefix(publicId, prefixes) {
	    for (let i = 0; i < prefixes.length; i++) {
	        if (publicId.indexOf(prefixes[i]) === 0) {
	            return true;
	        }
	    }

	    return false;
	}

	//API
	doctype$2.isConforming = function(token) {
	    return (
	        token.name === VALID_DOCTYPE_NAME &&
	        token.publicId === null &&
	        (token.systemId === null || token.systemId === VALID_SYSTEM_ID)
	    );
	};

	doctype$2.getDocumentMode = function(token) {
	    if (token.name !== VALID_DOCTYPE_NAME) {
	        return DOCUMENT_MODE.QUIRKS;
	    }

	    const systemId = token.systemId;

	    if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
	        return DOCUMENT_MODE.QUIRKS;
	    }

	    let publicId = token.publicId;

	    if (publicId !== null) {
	        publicId = publicId.toLowerCase();

	        if (QUIRKS_MODE_PUBLIC_IDS.indexOf(publicId) > -1) {
	            return DOCUMENT_MODE.QUIRKS;
	        }

	        let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;

	        if (hasPrefix(publicId, prefixes)) {
	            return DOCUMENT_MODE.QUIRKS;
	        }

	        prefixes =
	            systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;

	        if (hasPrefix(publicId, prefixes)) {
	            return DOCUMENT_MODE.LIMITED_QUIRKS;
	        }
	    }

	    return DOCUMENT_MODE.NO_QUIRKS;
	};

	doctype$2.serializeContent = function(name, publicId, systemId) {
	    let str = '!DOCTYPE ';

	    if (name) {
	        str += name;
	    }

	    if (publicId) {
	        str += ' PUBLIC ' + enquoteDoctypeId(publicId);
	    } else if (systemId) {
	        str += ' SYSTEM';
	    }

	    if (systemId !== null) {
	        str += ' ' + enquoteDoctypeId(systemId);
	    }

	    return str;
	};
	return doctype$2;
}

var foreignContent$1 = {};

var hasRequiredForeignContent$1;

function requireForeignContent$1 () {
	if (hasRequiredForeignContent$1) return foreignContent$1;
	hasRequiredForeignContent$1 = 1;

	const Tokenizer = requireTokenizer$1();
	const HTML = requireHtml$2();

	//Aliases
	const $ = HTML.TAG_NAMES;
	const NS = HTML.NAMESPACES;
	const ATTRS = HTML.ATTRS;

	//MIME types
	const MIME_TYPES = {
	    TEXT_HTML: 'text/html',
	    APPLICATION_XML: 'application/xhtml+xml'
	};

	//Attributes
	const DEFINITION_URL_ATTR = 'definitionurl';
	const ADJUSTED_DEFINITION_URL_ATTR = 'definitionURL';
	const SVG_ATTRS_ADJUSTMENT_MAP = {
	    attributename: 'attributeName',
	    attributetype: 'attributeType',
	    basefrequency: 'baseFrequency',
	    baseprofile: 'baseProfile',
	    calcmode: 'calcMode',
	    clippathunits: 'clipPathUnits',
	    diffuseconstant: 'diffuseConstant',
	    edgemode: 'edgeMode',
	    filterunits: 'filterUnits',
	    glyphref: 'glyphRef',
	    gradienttransform: 'gradientTransform',
	    gradientunits: 'gradientUnits',
	    kernelmatrix: 'kernelMatrix',
	    kernelunitlength: 'kernelUnitLength',
	    keypoints: 'keyPoints',
	    keysplines: 'keySplines',
	    keytimes: 'keyTimes',
	    lengthadjust: 'lengthAdjust',
	    limitingconeangle: 'limitingConeAngle',
	    markerheight: 'markerHeight',
	    markerunits: 'markerUnits',
	    markerwidth: 'markerWidth',
	    maskcontentunits: 'maskContentUnits',
	    maskunits: 'maskUnits',
	    numoctaves: 'numOctaves',
	    pathlength: 'pathLength',
	    patterncontentunits: 'patternContentUnits',
	    patterntransform: 'patternTransform',
	    patternunits: 'patternUnits',
	    pointsatx: 'pointsAtX',
	    pointsaty: 'pointsAtY',
	    pointsatz: 'pointsAtZ',
	    preservealpha: 'preserveAlpha',
	    preserveaspectratio: 'preserveAspectRatio',
	    primitiveunits: 'primitiveUnits',
	    refx: 'refX',
	    refy: 'refY',
	    repeatcount: 'repeatCount',
	    repeatdur: 'repeatDur',
	    requiredextensions: 'requiredExtensions',
	    requiredfeatures: 'requiredFeatures',
	    specularconstant: 'specularConstant',
	    specularexponent: 'specularExponent',
	    spreadmethod: 'spreadMethod',
	    startoffset: 'startOffset',
	    stddeviation: 'stdDeviation',
	    stitchtiles: 'stitchTiles',
	    surfacescale: 'surfaceScale',
	    systemlanguage: 'systemLanguage',
	    tablevalues: 'tableValues',
	    targetx: 'targetX',
	    targety: 'targetY',
	    textlength: 'textLength',
	    viewbox: 'viewBox',
	    viewtarget: 'viewTarget',
	    xchannelselector: 'xChannelSelector',
	    ychannelselector: 'yChannelSelector',
	    zoomandpan: 'zoomAndPan'
	};

	const XML_ATTRS_ADJUSTMENT_MAP = {
	    'xlink:actuate': { prefix: 'xlink', name: 'actuate', namespace: NS.XLINK },
	    'xlink:arcrole': { prefix: 'xlink', name: 'arcrole', namespace: NS.XLINK },
	    'xlink:href': { prefix: 'xlink', name: 'href', namespace: NS.XLINK },
	    'xlink:role': { prefix: 'xlink', name: 'role', namespace: NS.XLINK },
	    'xlink:show': { prefix: 'xlink', name: 'show', namespace: NS.XLINK },
	    'xlink:title': { prefix: 'xlink', name: 'title', namespace: NS.XLINK },
	    'xlink:type': { prefix: 'xlink', name: 'type', namespace: NS.XLINK },
	    'xml:base': { prefix: 'xml', name: 'base', namespace: NS.XML },
	    'xml:lang': { prefix: 'xml', name: 'lang', namespace: NS.XML },
	    'xml:space': { prefix: 'xml', name: 'space', namespace: NS.XML },
	    xmlns: { prefix: '', name: 'xmlns', namespace: NS.XMLNS },
	    'xmlns:xlink': { prefix: 'xmlns', name: 'xlink', namespace: NS.XMLNS }
	};

	//SVG tag names adjustment map
	const SVG_TAG_NAMES_ADJUSTMENT_MAP = (foreignContent$1.SVG_TAG_NAMES_ADJUSTMENT_MAP = {
	    altglyph: 'altGlyph',
	    altglyphdef: 'altGlyphDef',
	    altglyphitem: 'altGlyphItem',
	    animatecolor: 'animateColor',
	    animatemotion: 'animateMotion',
	    animatetransform: 'animateTransform',
	    clippath: 'clipPath',
	    feblend: 'feBlend',
	    fecolormatrix: 'feColorMatrix',
	    fecomponenttransfer: 'feComponentTransfer',
	    fecomposite: 'feComposite',
	    feconvolvematrix: 'feConvolveMatrix',
	    fediffuselighting: 'feDiffuseLighting',
	    fedisplacementmap: 'feDisplacementMap',
	    fedistantlight: 'feDistantLight',
	    feflood: 'feFlood',
	    fefunca: 'feFuncA',
	    fefuncb: 'feFuncB',
	    fefuncg: 'feFuncG',
	    fefuncr: 'feFuncR',
	    fegaussianblur: 'feGaussianBlur',
	    feimage: 'feImage',
	    femerge: 'feMerge',
	    femergenode: 'feMergeNode',
	    femorphology: 'feMorphology',
	    feoffset: 'feOffset',
	    fepointlight: 'fePointLight',
	    fespecularlighting: 'feSpecularLighting',
	    fespotlight: 'feSpotLight',
	    fetile: 'feTile',
	    feturbulence: 'feTurbulence',
	    foreignobject: 'foreignObject',
	    glyphref: 'glyphRef',
	    lineargradient: 'linearGradient',
	    radialgradient: 'radialGradient',
	    textpath: 'textPath'
	});

	//Tags that causes exit from foreign content
	const EXITS_FOREIGN_CONTENT = {
	    [$.B]: true,
	    [$.BIG]: true,
	    [$.BLOCKQUOTE]: true,
	    [$.BODY]: true,
	    [$.BR]: true,
	    [$.CENTER]: true,
	    [$.CODE]: true,
	    [$.DD]: true,
	    [$.DIV]: true,
	    [$.DL]: true,
	    [$.DT]: true,
	    [$.EM]: true,
	    [$.EMBED]: true,
	    [$.H1]: true,
	    [$.H2]: true,
	    [$.H3]: true,
	    [$.H4]: true,
	    [$.H5]: true,
	    [$.H6]: true,
	    [$.HEAD]: true,
	    [$.HR]: true,
	    [$.I]: true,
	    [$.IMG]: true,
	    [$.LI]: true,
	    [$.LISTING]: true,
	    [$.MENU]: true,
	    [$.META]: true,
	    [$.NOBR]: true,
	    [$.OL]: true,
	    [$.P]: true,
	    [$.PRE]: true,
	    [$.RUBY]: true,
	    [$.S]: true,
	    [$.SMALL]: true,
	    [$.SPAN]: true,
	    [$.STRONG]: true,
	    [$.STRIKE]: true,
	    [$.SUB]: true,
	    [$.SUP]: true,
	    [$.TABLE]: true,
	    [$.TT]: true,
	    [$.U]: true,
	    [$.UL]: true,
	    [$.VAR]: true
	};

	//Check exit from foreign content
	foreignContent$1.causesExit = function(startTagToken) {
	    const tn = startTagToken.tagName;
	    const isFontWithAttrs =
	        tn === $.FONT &&
	        (Tokenizer.getTokenAttr(startTagToken, ATTRS.COLOR) !== null ||
	            Tokenizer.getTokenAttr(startTagToken, ATTRS.SIZE) !== null ||
	            Tokenizer.getTokenAttr(startTagToken, ATTRS.FACE) !== null);

	    return isFontWithAttrs ? true : EXITS_FOREIGN_CONTENT[tn];
	};

	//Token adjustments
	foreignContent$1.adjustTokenMathMLAttrs = function(token) {
	    for (let i = 0; i < token.attrs.length; i++) {
	        if (token.attrs[i].name === DEFINITION_URL_ATTR) {
	            token.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR;
	            break;
	        }
	    }
	};

	foreignContent$1.adjustTokenSVGAttrs = function(token) {
	    for (let i = 0; i < token.attrs.length; i++) {
	        const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP[token.attrs[i].name];

	        if (adjustedAttrName) {
	            token.attrs[i].name = adjustedAttrName;
	        }
	    }
	};

	foreignContent$1.adjustTokenXMLAttrs = function(token) {
	    for (let i = 0; i < token.attrs.length; i++) {
	        const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP[token.attrs[i].name];

	        if (adjustedAttrEntry) {
	            token.attrs[i].prefix = adjustedAttrEntry.prefix;
	            token.attrs[i].name = adjustedAttrEntry.name;
	            token.attrs[i].namespace = adjustedAttrEntry.namespace;
	        }
	    }
	};

	foreignContent$1.adjustTokenSVGTagName = function(token) {
	    const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP[token.tagName];

	    if (adjustedTagName) {
	        token.tagName = adjustedTagName;
	    }
	};

	//Integration points
	function isMathMLTextIntegrationPoint(tn, ns) {
	    return ns === NS.MATHML && (tn === $.MI || tn === $.MO || tn === $.MN || tn === $.MS || tn === $.MTEXT);
	}

	function isHtmlIntegrationPoint(tn, ns, attrs) {
	    if (ns === NS.MATHML && tn === $.ANNOTATION_XML) {
	        for (let i = 0; i < attrs.length; i++) {
	            if (attrs[i].name === ATTRS.ENCODING) {
	                const value = attrs[i].value.toLowerCase();

	                return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
	            }
	        }
	    }

	    return ns === NS.SVG && (tn === $.FOREIGN_OBJECT || tn === $.DESC || tn === $.TITLE);
	}

	foreignContent$1.isIntegrationPoint = function(tn, ns, attrs, foreignNS) {
	    if ((!foreignNS || foreignNS === NS.HTML) && isHtmlIntegrationPoint(tn, ns, attrs)) {
	        return true;
	    }

	    if ((!foreignNS || foreignNS === NS.MATHML) && isMathMLTextIntegrationPoint(tn, ns)) {
	        return true;
	    }

	    return false;
	};
	return foreignContent$1;
}

var parser$1;
var hasRequiredParser$1;

function requireParser$1 () {
	if (hasRequiredParser$1) return parser$1;
	hasRequiredParser$1 = 1;

	const Tokenizer = requireTokenizer$1();
	const OpenElementStack = requireOpenElementStack$1();
	const FormattingElementList = requireFormattingElementList$1();
	const LocationInfoParserMixin = requireParserMixin$3();
	const ErrorReportingParserMixin = requireParserMixin$2();
	const Mixin = requireMixin$1();
	const defaultTreeAdapter = require_default$1();
	const mergeOptions = requireMergeOptions$1();
	const doctype = requireDoctype$2();
	const foreignContent = requireForeignContent$1();
	const ERR = requireErrorCodes$1();
	const unicode = requireUnicode$1();
	const HTML = requireHtml$2();

	//Aliases
	const $ = HTML.TAG_NAMES;
	const NS = HTML.NAMESPACES;
	const ATTRS = HTML.ATTRS;

	const DEFAULT_OPTIONS = {
	    scriptingEnabled: true,
	    sourceCodeLocationInfo: false,
	    onParseError: null,
	    treeAdapter: defaultTreeAdapter
	};

	//Misc constants
	const HIDDEN_INPUT_TYPE = 'hidden';

	//Adoption agency loops iteration count
	const AA_OUTER_LOOP_ITER = 8;
	const AA_INNER_LOOP_ITER = 3;

	//Insertion modes
	const INITIAL_MODE = 'INITIAL_MODE';
	const BEFORE_HTML_MODE = 'BEFORE_HTML_MODE';
	const BEFORE_HEAD_MODE = 'BEFORE_HEAD_MODE';
	const IN_HEAD_MODE = 'IN_HEAD_MODE';
	const IN_HEAD_NO_SCRIPT_MODE = 'IN_HEAD_NO_SCRIPT_MODE';
	const AFTER_HEAD_MODE = 'AFTER_HEAD_MODE';
	const IN_BODY_MODE = 'IN_BODY_MODE';
	const TEXT_MODE = 'TEXT_MODE';
	const IN_TABLE_MODE = 'IN_TABLE_MODE';
	const IN_TABLE_TEXT_MODE = 'IN_TABLE_TEXT_MODE';
	const IN_CAPTION_MODE = 'IN_CAPTION_MODE';
	const IN_COLUMN_GROUP_MODE = 'IN_COLUMN_GROUP_MODE';
	const IN_TABLE_BODY_MODE = 'IN_TABLE_BODY_MODE';
	const IN_ROW_MODE = 'IN_ROW_MODE';
	const IN_CELL_MODE = 'IN_CELL_MODE';
	const IN_SELECT_MODE = 'IN_SELECT_MODE';
	const IN_SELECT_IN_TABLE_MODE = 'IN_SELECT_IN_TABLE_MODE';
	const IN_TEMPLATE_MODE = 'IN_TEMPLATE_MODE';
	const AFTER_BODY_MODE = 'AFTER_BODY_MODE';
	const IN_FRAMESET_MODE = 'IN_FRAMESET_MODE';
	const AFTER_FRAMESET_MODE = 'AFTER_FRAMESET_MODE';
	const AFTER_AFTER_BODY_MODE = 'AFTER_AFTER_BODY_MODE';
	const AFTER_AFTER_FRAMESET_MODE = 'AFTER_AFTER_FRAMESET_MODE';

	//Insertion mode reset map
	const INSERTION_MODE_RESET_MAP = {
	    [$.TR]: IN_ROW_MODE,
	    [$.TBODY]: IN_TABLE_BODY_MODE,
	    [$.THEAD]: IN_TABLE_BODY_MODE,
	    [$.TFOOT]: IN_TABLE_BODY_MODE,
	    [$.CAPTION]: IN_CAPTION_MODE,
	    [$.COLGROUP]: IN_COLUMN_GROUP_MODE,
	    [$.TABLE]: IN_TABLE_MODE,
	    [$.BODY]: IN_BODY_MODE,
	    [$.FRAMESET]: IN_FRAMESET_MODE
	};

	//Template insertion mode switch map
	const TEMPLATE_INSERTION_MODE_SWITCH_MAP = {
	    [$.CAPTION]: IN_TABLE_MODE,
	    [$.COLGROUP]: IN_TABLE_MODE,
	    [$.TBODY]: IN_TABLE_MODE,
	    [$.TFOOT]: IN_TABLE_MODE,
	    [$.THEAD]: IN_TABLE_MODE,
	    [$.COL]: IN_COLUMN_GROUP_MODE,
	    [$.TR]: IN_TABLE_BODY_MODE,
	    [$.TD]: IN_ROW_MODE,
	    [$.TH]: IN_ROW_MODE
	};

	//Token handlers map for insertion modes
	const TOKEN_HANDLERS = {
	    [INITIAL_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: tokenInInitialMode,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInInitialMode,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: doctypeInInitialMode,
	        [Tokenizer.START_TAG_TOKEN]: tokenInInitialMode,
	        [Tokenizer.END_TAG_TOKEN]: tokenInInitialMode,
	        [Tokenizer.EOF_TOKEN]: tokenInInitialMode
	    },
	    [BEFORE_HTML_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHtml,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHtml,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagBeforeHtml,
	        [Tokenizer.END_TAG_TOKEN]: endTagBeforeHtml,
	        [Tokenizer.EOF_TOKEN]: tokenBeforeHtml
	    },
	    [BEFORE_HEAD_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHead,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHead,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
	        [Tokenizer.START_TAG_TOKEN]: startTagBeforeHead,
	        [Tokenizer.END_TAG_TOKEN]: endTagBeforeHead,
	        [Tokenizer.EOF_TOKEN]: tokenBeforeHead
	    },
	    [IN_HEAD_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: tokenInHead,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHead,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
	        [Tokenizer.START_TAG_TOKEN]: startTagInHead,
	        [Tokenizer.END_TAG_TOKEN]: endTagInHead,
	        [Tokenizer.EOF_TOKEN]: tokenInHead
	    },
	    [IN_HEAD_NO_SCRIPT_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: tokenInHeadNoScript,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHeadNoScript,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
	        [Tokenizer.START_TAG_TOKEN]: startTagInHeadNoScript,
	        [Tokenizer.END_TAG_TOKEN]: endTagInHeadNoScript,
	        [Tokenizer.EOF_TOKEN]: tokenInHeadNoScript
	    },
	    [AFTER_HEAD_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: tokenAfterHead,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterHead,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
	        [Tokenizer.START_TAG_TOKEN]: startTagAfterHead,
	        [Tokenizer.END_TAG_TOKEN]: endTagAfterHead,
	        [Tokenizer.EOF_TOKEN]: tokenAfterHead
	    },
	    [IN_BODY_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: characterInBody,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagInBody,
	        [Tokenizer.END_TAG_TOKEN]: endTagInBody,
	        [Tokenizer.EOF_TOKEN]: eofInBody
	    },
	    [TEXT_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.COMMENT_TOKEN]: ignoreToken,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: ignoreToken,
	        [Tokenizer.END_TAG_TOKEN]: endTagInText,
	        [Tokenizer.EOF_TOKEN]: eofInText
	    },
	    [IN_TABLE_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: characterInTable,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagInTable,
	        [Tokenizer.END_TAG_TOKEN]: endTagInTable,
	        [Tokenizer.EOF_TOKEN]: eofInBody
	    },
	    [IN_TABLE_TEXT_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: characterInTableText,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInTableText,
	        [Tokenizer.COMMENT_TOKEN]: tokenInTableText,
	        [Tokenizer.DOCTYPE_TOKEN]: tokenInTableText,
	        [Tokenizer.START_TAG_TOKEN]: tokenInTableText,
	        [Tokenizer.END_TAG_TOKEN]: tokenInTableText,
	        [Tokenizer.EOF_TOKEN]: tokenInTableText
	    },
	    [IN_CAPTION_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: characterInBody,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagInCaption,
	        [Tokenizer.END_TAG_TOKEN]: endTagInCaption,
	        [Tokenizer.EOF_TOKEN]: eofInBody
	    },
	    [IN_COLUMN_GROUP_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: tokenInColumnGroup,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInColumnGroup,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagInColumnGroup,
	        [Tokenizer.END_TAG_TOKEN]: endTagInColumnGroup,
	        [Tokenizer.EOF_TOKEN]: eofInBody
	    },
	    [IN_TABLE_BODY_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: characterInTable,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagInTableBody,
	        [Tokenizer.END_TAG_TOKEN]: endTagInTableBody,
	        [Tokenizer.EOF_TOKEN]: eofInBody
	    },
	    [IN_ROW_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: characterInTable,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagInRow,
	        [Tokenizer.END_TAG_TOKEN]: endTagInRow,
	        [Tokenizer.EOF_TOKEN]: eofInBody
	    },
	    [IN_CELL_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: characterInBody,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagInCell,
	        [Tokenizer.END_TAG_TOKEN]: endTagInCell,
	        [Tokenizer.EOF_TOKEN]: eofInBody
	    },
	    [IN_SELECT_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagInSelect,
	        [Tokenizer.END_TAG_TOKEN]: endTagInSelect,
	        [Tokenizer.EOF_TOKEN]: eofInBody
	    },
	    [IN_SELECT_IN_TABLE_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagInSelectInTable,
	        [Tokenizer.END_TAG_TOKEN]: endTagInSelectInTable,
	        [Tokenizer.EOF_TOKEN]: eofInBody
	    },
	    [IN_TEMPLATE_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: characterInBody,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagInTemplate,
	        [Tokenizer.END_TAG_TOKEN]: endTagInTemplate,
	        [Tokenizer.EOF_TOKEN]: eofInTemplate
	    },
	    [AFTER_BODY_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: tokenAfterBody,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterBody,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
	        [Tokenizer.COMMENT_TOKEN]: appendCommentToRootHtmlElement,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagAfterBody,
	        [Tokenizer.END_TAG_TOKEN]: endTagAfterBody,
	        [Tokenizer.EOF_TOKEN]: stopParsing
	    },
	    [IN_FRAMESET_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagInFrameset,
	        [Tokenizer.END_TAG_TOKEN]: endTagInFrameset,
	        [Tokenizer.EOF_TOKEN]: stopParsing
	    },
	    [AFTER_FRAMESET_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagAfterFrameset,
	        [Tokenizer.END_TAG_TOKEN]: endTagAfterFrameset,
	        [Tokenizer.EOF_TOKEN]: stopParsing
	    },
	    [AFTER_AFTER_BODY_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: tokenAfterAfterBody,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterAfterBody,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
	        [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterBody,
	        [Tokenizer.END_TAG_TOKEN]: tokenAfterAfterBody,
	        [Tokenizer.EOF_TOKEN]: stopParsing
	    },
	    [AFTER_AFTER_FRAMESET_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
	        [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterFrameset,
	        [Tokenizer.END_TAG_TOKEN]: ignoreToken,
	        [Tokenizer.EOF_TOKEN]: stopParsing
	    }
	};

	//Parser
	class Parser {
	    constructor(options) {
	        this.options = mergeOptions(DEFAULT_OPTIONS, options);

	        this.treeAdapter = this.options.treeAdapter;
	        this.pendingScript = null;

	        if (this.options.sourceCodeLocationInfo) {
	            Mixin.install(this, LocationInfoParserMixin);
	        }

	        if (this.options.onParseError) {
	            Mixin.install(this, ErrorReportingParserMixin, { onParseError: this.options.onParseError });
	        }
	    }

	    // API
	    parse(html) {
	        const document = this.treeAdapter.createDocument();

	        this._bootstrap(document, null);
	        this.tokenizer.write(html, true);
	        this._runParsingLoop(null);

	        return document;
	    }

	    parseFragment(html, fragmentContext) {
	        //NOTE: use <template> element as a fragment context if context element was not provided,
	        //so we will parse in "forgiving" manner
	        if (!fragmentContext) {
	            fragmentContext = this.treeAdapter.createElement($.TEMPLATE, NS.HTML, []);
	        }

	        //NOTE: create fake element which will be used as 'document' for fragment parsing.
	        //This is important for jsdom there 'document' can't be recreated, therefore
	        //fragment parsing causes messing of the main `document`.
	        const documentMock = this.treeAdapter.createElement('documentmock', NS.HTML, []);

	        this._bootstrap(documentMock, fragmentContext);

	        if (this.treeAdapter.getTagName(fragmentContext) === $.TEMPLATE) {
	            this._pushTmplInsertionMode(IN_TEMPLATE_MODE);
	        }

	        this._initTokenizerForFragmentParsing();
	        this._insertFakeRootElement();
	        this._resetInsertionMode();
	        this._findFormInFragmentContext();
	        this.tokenizer.write(html, true);
	        this._runParsingLoop(null);

	        const rootElement = this.treeAdapter.getFirstChild(documentMock);
	        const fragment = this.treeAdapter.createDocumentFragment();

	        this._adoptNodes(rootElement, fragment);

	        return fragment;
	    }

	    //Bootstrap parser
	    _bootstrap(document, fragmentContext) {
	        this.tokenizer = new Tokenizer(this.options);

	        this.stopped = false;

	        this.insertionMode = INITIAL_MODE;
	        this.originalInsertionMode = '';

	        this.document = document;
	        this.fragmentContext = fragmentContext;

	        this.headElement = null;
	        this.formElement = null;

	        this.openElements = new OpenElementStack(this.document, this.treeAdapter);
	        this.activeFormattingElements = new FormattingElementList(this.treeAdapter);

	        this.tmplInsertionModeStack = [];
	        this.tmplInsertionModeStackTop = -1;
	        this.currentTmplInsertionMode = null;

	        this.pendingCharacterTokens = [];
	        this.hasNonWhitespacePendingCharacterToken = false;

	        this.framesetOk = true;
	        this.skipNextNewLine = false;
	        this.fosterParentingEnabled = false;
	    }

	    //Errors
	    _err() {
	        // NOTE: err reporting is noop by default. Enabled by mixin.
	    }

	    //Parsing loop
	    _runParsingLoop(scriptHandler) {
	        while (!this.stopped) {
	            this._setupTokenizerCDATAMode();

	            const token = this.tokenizer.getNextToken();

	            if (token.type === Tokenizer.HIBERNATION_TOKEN) {
	                break;
	            }

	            if (this.skipNextNewLine) {
	                this.skipNextNewLine = false;

	                if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN && token.chars[0] === '\n') {
	                    if (token.chars.length === 1) {
	                        continue;
	                    }

	                    token.chars = token.chars.substr(1);
	                }
	            }

	            this._processInputToken(token);

	            if (scriptHandler && this.pendingScript) {
	                break;
	            }
	        }
	    }

	    runParsingLoopForCurrentChunk(writeCallback, scriptHandler) {
	        this._runParsingLoop(scriptHandler);

	        if (scriptHandler && this.pendingScript) {
	            const script = this.pendingScript;

	            this.pendingScript = null;

	            scriptHandler(script);

	            return;
	        }

	        if (writeCallback) {
	            writeCallback();
	        }
	    }

	    //Text parsing
	    _setupTokenizerCDATAMode() {
	        const current = this._getAdjustedCurrentElement();

	        this.tokenizer.allowCDATA =
	            current &&
	            current !== this.document &&
	            this.treeAdapter.getNamespaceURI(current) !== NS.HTML &&
	            !this._isIntegrationPoint(current);
	    }

	    _switchToTextParsing(currentToken, nextTokenizerState) {
	        this._insertElement(currentToken, NS.HTML);
	        this.tokenizer.state = nextTokenizerState;
	        this.originalInsertionMode = this.insertionMode;
	        this.insertionMode = TEXT_MODE;
	    }

	    switchToPlaintextParsing() {
	        this.insertionMode = TEXT_MODE;
	        this.originalInsertionMode = IN_BODY_MODE;
	        this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
	    }

	    //Fragment parsing
	    _getAdjustedCurrentElement() {
	        return this.openElements.stackTop === 0 && this.fragmentContext
	            ? this.fragmentContext
	            : this.openElements.current;
	    }

	    _findFormInFragmentContext() {
	        let node = this.fragmentContext;

	        do {
	            if (this.treeAdapter.getTagName(node) === $.FORM) {
	                this.formElement = node;
	                break;
	            }

	            node = this.treeAdapter.getParentNode(node);
	        } while (node);
	    }

	    _initTokenizerForFragmentParsing() {
	        if (this.treeAdapter.getNamespaceURI(this.fragmentContext) === NS.HTML) {
	            const tn = this.treeAdapter.getTagName(this.fragmentContext);

	            if (tn === $.TITLE || tn === $.TEXTAREA) {
	                this.tokenizer.state = Tokenizer.MODE.RCDATA;
	            } else if (
	                tn === $.STYLE ||
	                tn === $.XMP ||
	                tn === $.IFRAME ||
	                tn === $.NOEMBED ||
	                tn === $.NOFRAMES ||
	                tn === $.NOSCRIPT
	            ) {
	                this.tokenizer.state = Tokenizer.MODE.RAWTEXT;
	            } else if (tn === $.SCRIPT) {
	                this.tokenizer.state = Tokenizer.MODE.SCRIPT_DATA;
	            } else if (tn === $.PLAINTEXT) {
	                this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
	            }
	        }
	    }

	    //Tree mutation
	    _setDocumentType(token) {
	        const name = token.name || '';
	        const publicId = token.publicId || '';
	        const systemId = token.systemId || '';

	        this.treeAdapter.setDocumentType(this.document, name, publicId, systemId);
	    }

	    _attachElementToTree(element) {
	        if (this._shouldFosterParentOnInsertion()) {
	            this._fosterParentElement(element);
	        } else {
	            const parent = this.openElements.currentTmplContent || this.openElements.current;

	            this.treeAdapter.appendChild(parent, element);
	        }
	    }

	    _appendElement(token, namespaceURI) {
	        const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);

	        this._attachElementToTree(element);
	    }

	    _insertElement(token, namespaceURI) {
	        const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);

	        this._attachElementToTree(element);
	        this.openElements.push(element);
	    }

	    _insertFakeElement(tagName) {
	        const element = this.treeAdapter.createElement(tagName, NS.HTML, []);

	        this._attachElementToTree(element);
	        this.openElements.push(element);
	    }

	    _insertTemplate(token) {
	        const tmpl = this.treeAdapter.createElement(token.tagName, NS.HTML, token.attrs);
	        const content = this.treeAdapter.createDocumentFragment();

	        this.treeAdapter.setTemplateContent(tmpl, content);
	        this._attachElementToTree(tmpl);
	        this.openElements.push(tmpl);
	    }

	    _insertFakeRootElement() {
	        const element = this.treeAdapter.createElement($.HTML, NS.HTML, []);

	        this.treeAdapter.appendChild(this.openElements.current, element);
	        this.openElements.push(element);
	    }

	    _appendCommentNode(token, parent) {
	        const commentNode = this.treeAdapter.createCommentNode(token.data);

	        this.treeAdapter.appendChild(parent, commentNode);
	    }

	    _insertCharacters(token) {
	        if (this._shouldFosterParentOnInsertion()) {
	            this._fosterParentText(token.chars);
	        } else {
	            const parent = this.openElements.currentTmplContent || this.openElements.current;

	            this.treeAdapter.insertText(parent, token.chars);
	        }
	    }

	    _adoptNodes(donor, recipient) {
	        for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
	            this.treeAdapter.detachNode(child);
	            this.treeAdapter.appendChild(recipient, child);
	        }
	    }

	    //Token processing
	    _shouldProcessTokenInForeignContent(token) {
	        const current = this._getAdjustedCurrentElement();

	        if (!current || current === this.document) {
	            return false;
	        }

	        const ns = this.treeAdapter.getNamespaceURI(current);

	        if (ns === NS.HTML) {
	            return false;
	        }

	        if (
	            this.treeAdapter.getTagName(current) === $.ANNOTATION_XML &&
	            ns === NS.MATHML &&
	            token.type === Tokenizer.START_TAG_TOKEN &&
	            token.tagName === $.SVG
	        ) {
	            return false;
	        }

	        const isCharacterToken =
	            token.type === Tokenizer.CHARACTER_TOKEN ||
	            token.type === Tokenizer.NULL_CHARACTER_TOKEN ||
	            token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN;

	        const isMathMLTextStartTag =
	            token.type === Tokenizer.START_TAG_TOKEN && token.tagName !== $.MGLYPH && token.tagName !== $.MALIGNMARK;

	        if ((isMathMLTextStartTag || isCharacterToken) && this._isIntegrationPoint(current, NS.MATHML)) {
	            return false;
	        }

	        if (
	            (token.type === Tokenizer.START_TAG_TOKEN || isCharacterToken) &&
	            this._isIntegrationPoint(current, NS.HTML)
	        ) {
	            return false;
	        }

	        return token.type !== Tokenizer.EOF_TOKEN;
	    }

	    _processToken(token) {
	        TOKEN_HANDLERS[this.insertionMode][token.type](this, token);
	    }

	    _processTokenInBodyMode(token) {
	        TOKEN_HANDLERS[IN_BODY_MODE][token.type](this, token);
	    }

	    _processTokenInForeignContent(token) {
	        if (token.type === Tokenizer.CHARACTER_TOKEN) {
	            characterInForeignContent(this, token);
	        } else if (token.type === Tokenizer.NULL_CHARACTER_TOKEN) {
	            nullCharacterInForeignContent(this, token);
	        } else if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN) {
	            insertCharacters(this, token);
	        } else if (token.type === Tokenizer.COMMENT_TOKEN) {
	            appendComment(this, token);
	        } else if (token.type === Tokenizer.START_TAG_TOKEN) {
	            startTagInForeignContent(this, token);
	        } else if (token.type === Tokenizer.END_TAG_TOKEN) {
	            endTagInForeignContent(this, token);
	        }
	    }

	    _processInputToken(token) {
	        if (this._shouldProcessTokenInForeignContent(token)) {
	            this._processTokenInForeignContent(token);
	        } else {
	            this._processToken(token);
	        }

	        if (token.type === Tokenizer.START_TAG_TOKEN && token.selfClosing && !token.ackSelfClosing) {
	            this._err(ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
	        }
	    }

	    //Integration points
	    _isIntegrationPoint(element, foreignNS) {
	        const tn = this.treeAdapter.getTagName(element);
	        const ns = this.treeAdapter.getNamespaceURI(element);
	        const attrs = this.treeAdapter.getAttrList(element);

	        return foreignContent.isIntegrationPoint(tn, ns, attrs, foreignNS);
	    }

	    //Active formatting elements reconstruction
	    _reconstructActiveFormattingElements() {
	        const listLength = this.activeFormattingElements.length;

	        if (listLength) {
	            let unopenIdx = listLength;
	            let entry = null;

	            do {
	                unopenIdx--;
	                entry = this.activeFormattingElements.entries[unopenIdx];

	                if (entry.type === FormattingElementList.MARKER_ENTRY || this.openElements.contains(entry.element)) {
	                    unopenIdx++;
	                    break;
	                }
	            } while (unopenIdx > 0);

	            for (let i = unopenIdx; i < listLength; i++) {
	                entry = this.activeFormattingElements.entries[i];
	                this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
	                entry.element = this.openElements.current;
	            }
	        }
	    }

	    //Close elements
	    _closeTableCell() {
	        this.openElements.generateImpliedEndTags();
	        this.openElements.popUntilTableCellPopped();
	        this.activeFormattingElements.clearToLastMarker();
	        this.insertionMode = IN_ROW_MODE;
	    }

	    _closePElement() {
	        this.openElements.generateImpliedEndTagsWithExclusion($.P);
	        this.openElements.popUntilTagNamePopped($.P);
	    }

	    //Insertion modes
	    _resetInsertionMode() {
	        for (let i = this.openElements.stackTop, last = false; i >= 0; i--) {
	            let element = this.openElements.items[i];

	            if (i === 0) {
	                last = true;

	                if (this.fragmentContext) {
	                    element = this.fragmentContext;
	                }
	            }

	            const tn = this.treeAdapter.getTagName(element);
	            const newInsertionMode = INSERTION_MODE_RESET_MAP[tn];

	            if (newInsertionMode) {
	                this.insertionMode = newInsertionMode;
	                break;
	            } else if (!last && (tn === $.TD || tn === $.TH)) {
	                this.insertionMode = IN_CELL_MODE;
	                break;
	            } else if (!last && tn === $.HEAD) {
	                this.insertionMode = IN_HEAD_MODE;
	                break;
	            } else if (tn === $.SELECT) {
	                this._resetInsertionModeForSelect(i);
	                break;
	            } else if (tn === $.TEMPLATE) {
	                this.insertionMode = this.currentTmplInsertionMode;
	                break;
	            } else if (tn === $.HTML) {
	                this.insertionMode = this.headElement ? AFTER_HEAD_MODE : BEFORE_HEAD_MODE;
	                break;
	            } else if (last) {
	                this.insertionMode = IN_BODY_MODE;
	                break;
	            }
	        }
	    }

	    _resetInsertionModeForSelect(selectIdx) {
	        if (selectIdx > 0) {
	            for (let i = selectIdx - 1; i > 0; i--) {
	                const ancestor = this.openElements.items[i];
	                const tn = this.treeAdapter.getTagName(ancestor);

	                if (tn === $.TEMPLATE) {
	                    break;
	                } else if (tn === $.TABLE) {
	                    this.insertionMode = IN_SELECT_IN_TABLE_MODE;
	                    return;
	                }
	            }
	        }

	        this.insertionMode = IN_SELECT_MODE;
	    }

	    _pushTmplInsertionMode(mode) {
	        this.tmplInsertionModeStack.push(mode);
	        this.tmplInsertionModeStackTop++;
	        this.currentTmplInsertionMode = mode;
	    }

	    _popTmplInsertionMode() {
	        this.tmplInsertionModeStack.pop();
	        this.tmplInsertionModeStackTop--;
	        this.currentTmplInsertionMode = this.tmplInsertionModeStack[this.tmplInsertionModeStackTop];
	    }

	    //Foster parenting
	    _isElementCausesFosterParenting(element) {
	        const tn = this.treeAdapter.getTagName(element);

	        return tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR;
	    }

	    _shouldFosterParentOnInsertion() {
	        return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.current);
	    }

	    _findFosterParentingLocation() {
	        const location = {
	            parent: null,
	            beforeElement: null
	        };

	        for (let i = this.openElements.stackTop; i >= 0; i--) {
	            const openElement = this.openElements.items[i];
	            const tn = this.treeAdapter.getTagName(openElement);
	            const ns = this.treeAdapter.getNamespaceURI(openElement);

	            if (tn === $.TEMPLATE && ns === NS.HTML) {
	                location.parent = this.treeAdapter.getTemplateContent(openElement);
	                break;
	            } else if (tn === $.TABLE) {
	                location.parent = this.treeAdapter.getParentNode(openElement);

	                if (location.parent) {
	                    location.beforeElement = openElement;
	                } else {
	                    location.parent = this.openElements.items[i - 1];
	                }

	                break;
	            }
	        }

	        if (!location.parent) {
	            location.parent = this.openElements.items[0];
	        }

	        return location;
	    }

	    _fosterParentElement(element) {
	        const location = this._findFosterParentingLocation();

	        if (location.beforeElement) {
	            this.treeAdapter.insertBefore(location.parent, element, location.beforeElement);
	        } else {
	            this.treeAdapter.appendChild(location.parent, element);
	        }
	    }

	    _fosterParentText(chars) {
	        const location = this._findFosterParentingLocation();

	        if (location.beforeElement) {
	            this.treeAdapter.insertTextBefore(location.parent, chars, location.beforeElement);
	        } else {
	            this.treeAdapter.insertText(location.parent, chars);
	        }
	    }

	    //Special elements
	    _isSpecialElement(element) {
	        const tn = this.treeAdapter.getTagName(element);
	        const ns = this.treeAdapter.getNamespaceURI(element);

	        return HTML.SPECIAL_ELEMENTS[ns][tn];
	    }
	}

	parser$1 = Parser;

	//Adoption agency algorithm
	//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#adoptionAgency)
	//------------------------------------------------------------------

	//Steps 5-8 of the algorithm
	function aaObtainFormattingElementEntry(p, token) {
	    let formattingElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);

	    if (formattingElementEntry) {
	        if (!p.openElements.contains(formattingElementEntry.element)) {
	            p.activeFormattingElements.removeEntry(formattingElementEntry);
	            formattingElementEntry = null;
	        } else if (!p.openElements.hasInScope(token.tagName)) {
	            formattingElementEntry = null;
	        }
	    } else {
	        genericEndTagInBody(p, token);
	    }

	    return formattingElementEntry;
	}

	//Steps 9 and 10 of the algorithm
	function aaObtainFurthestBlock(p, formattingElementEntry) {
	    let furthestBlock = null;

	    for (let i = p.openElements.stackTop; i >= 0; i--) {
	        const element = p.openElements.items[i];

	        if (element === formattingElementEntry.element) {
	            break;
	        }

	        if (p._isSpecialElement(element)) {
	            furthestBlock = element;
	        }
	    }

	    if (!furthestBlock) {
	        p.openElements.popUntilElementPopped(formattingElementEntry.element);
	        p.activeFormattingElements.removeEntry(formattingElementEntry);
	    }

	    return furthestBlock;
	}

	//Step 13 of the algorithm
	function aaInnerLoop(p, furthestBlock, formattingElement) {
	    let lastElement = furthestBlock;
	    let nextElement = p.openElements.getCommonAncestor(furthestBlock);

	    for (let i = 0, element = nextElement; element !== formattingElement; i++, element = nextElement) {
	        //NOTE: store next element for the next loop iteration (it may be deleted from the stack by step 9.5)
	        nextElement = p.openElements.getCommonAncestor(element);

	        const elementEntry = p.activeFormattingElements.getElementEntry(element);
	        const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER;
	        const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;

	        if (shouldRemoveFromOpenElements) {
	            if (counterOverflow) {
	                p.activeFormattingElements.removeEntry(elementEntry);
	            }

	            p.openElements.remove(element);
	        } else {
	            element = aaRecreateElementFromEntry(p, elementEntry);

	            if (lastElement === furthestBlock) {
	                p.activeFormattingElements.bookmark = elementEntry;
	            }

	            p.treeAdapter.detachNode(lastElement);
	            p.treeAdapter.appendChild(element, lastElement);
	            lastElement = element;
	        }
	    }

	    return lastElement;
	}

	//Step 13.7 of the algorithm
	function aaRecreateElementFromEntry(p, elementEntry) {
	    const ns = p.treeAdapter.getNamespaceURI(elementEntry.element);
	    const newElement = p.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);

	    p.openElements.replace(elementEntry.element, newElement);
	    elementEntry.element = newElement;

	    return newElement;
	}

	//Step 14 of the algorithm
	function aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement) {
	    if (p._isElementCausesFosterParenting(commonAncestor)) {
	        p._fosterParentElement(lastElement);
	    } else {
	        const tn = p.treeAdapter.getTagName(commonAncestor);
	        const ns = p.treeAdapter.getNamespaceURI(commonAncestor);

	        if (tn === $.TEMPLATE && ns === NS.HTML) {
	            commonAncestor = p.treeAdapter.getTemplateContent(commonAncestor);
	        }

	        p.treeAdapter.appendChild(commonAncestor, lastElement);
	    }
	}

	//Steps 15-19 of the algorithm
	function aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry) {
	    const ns = p.treeAdapter.getNamespaceURI(formattingElementEntry.element);
	    const token = formattingElementEntry.token;
	    const newElement = p.treeAdapter.createElement(token.tagName, ns, token.attrs);

	    p._adoptNodes(furthestBlock, newElement);
	    p.treeAdapter.appendChild(furthestBlock, newElement);

	    p.activeFormattingElements.insertElementAfterBookmark(newElement, formattingElementEntry.token);
	    p.activeFormattingElements.removeEntry(formattingElementEntry);

	    p.openElements.remove(formattingElementEntry.element);
	    p.openElements.insertAfter(furthestBlock, newElement);
	}

	//Algorithm entry point
	function callAdoptionAgency(p, token) {
	    let formattingElementEntry;

	    for (let i = 0; i < AA_OUTER_LOOP_ITER; i++) {
	        formattingElementEntry = aaObtainFormattingElementEntry(p, token);

	        if (!formattingElementEntry) {
	            break;
	        }

	        const furthestBlock = aaObtainFurthestBlock(p, formattingElementEntry);

	        if (!furthestBlock) {
	            break;
	        }

	        p.activeFormattingElements.bookmark = formattingElementEntry;

	        const lastElement = aaInnerLoop(p, furthestBlock, formattingElementEntry.element);
	        const commonAncestor = p.openElements.getCommonAncestor(formattingElementEntry.element);

	        p.treeAdapter.detachNode(lastElement);
	        aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement);
	        aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry);
	    }
	}

	//Generic token handlers
	//------------------------------------------------------------------
	function ignoreToken() {
	    //NOTE: do nothing =)
	}

	function misplacedDoctype(p) {
	    p._err(ERR.misplacedDoctype);
	}

	function appendComment(p, token) {
	    p._appendCommentNode(token, p.openElements.currentTmplContent || p.openElements.current);
	}

	function appendCommentToRootHtmlElement(p, token) {
	    p._appendCommentNode(token, p.openElements.items[0]);
	}

	function appendCommentToDocument(p, token) {
	    p._appendCommentNode(token, p.document);
	}

	function insertCharacters(p, token) {
	    p._insertCharacters(token);
	}

	function stopParsing(p) {
	    p.stopped = true;
	}

	// The "initial" insertion mode
	//------------------------------------------------------------------
	function doctypeInInitialMode(p, token) {
	    p._setDocumentType(token);

	    const mode = token.forceQuirks ? HTML.DOCUMENT_MODE.QUIRKS : doctype.getDocumentMode(token);

	    if (!doctype.isConforming(token)) {
	        p._err(ERR.nonConformingDoctype);
	    }

	    p.treeAdapter.setDocumentMode(p.document, mode);

	    p.insertionMode = BEFORE_HTML_MODE;
	}

	function tokenInInitialMode(p, token) {
	    p._err(ERR.missingDoctype, { beforeToken: true });
	    p.treeAdapter.setDocumentMode(p.document, HTML.DOCUMENT_MODE.QUIRKS);
	    p.insertionMode = BEFORE_HTML_MODE;
	    p._processToken(token);
	}

	// The "before html" insertion mode
	//------------------------------------------------------------------
	function startTagBeforeHtml(p, token) {
	    if (token.tagName === $.HTML) {
	        p._insertElement(token, NS.HTML);
	        p.insertionMode = BEFORE_HEAD_MODE;
	    } else {
	        tokenBeforeHtml(p, token);
	    }
	}

	function endTagBeforeHtml(p, token) {
	    const tn = token.tagName;

	    if (tn === $.HTML || tn === $.HEAD || tn === $.BODY || tn === $.BR) {
	        tokenBeforeHtml(p, token);
	    }
	}

	function tokenBeforeHtml(p, token) {
	    p._insertFakeRootElement();
	    p.insertionMode = BEFORE_HEAD_MODE;
	    p._processToken(token);
	}

	// The "before head" insertion mode
	//------------------------------------------------------------------
	function startTagBeforeHead(p, token) {
	    const tn = token.tagName;

	    if (tn === $.HTML) {
	        startTagInBody(p, token);
	    } else if (tn === $.HEAD) {
	        p._insertElement(token, NS.HTML);
	        p.headElement = p.openElements.current;
	        p.insertionMode = IN_HEAD_MODE;
	    } else {
	        tokenBeforeHead(p, token);
	    }
	}

	function endTagBeforeHead(p, token) {
	    const tn = token.tagName;

	    if (tn === $.HEAD || tn === $.BODY || tn === $.HTML || tn === $.BR) {
	        tokenBeforeHead(p, token);
	    } else {
	        p._err(ERR.endTagWithoutMatchingOpenElement);
	    }
	}

	function tokenBeforeHead(p, token) {
	    p._insertFakeElement($.HEAD);
	    p.headElement = p.openElements.current;
	    p.insertionMode = IN_HEAD_MODE;
	    p._processToken(token);
	}

	// The "in head" insertion mode
	//------------------------------------------------------------------
	function startTagInHead(p, token) {
	    const tn = token.tagName;

	    if (tn === $.HTML) {
	        startTagInBody(p, token);
	    } else if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META) {
	        p._appendElement(token, NS.HTML);
	        token.ackSelfClosing = true;
	    } else if (tn === $.TITLE) {
	        p._switchToTextParsing(token, Tokenizer.MODE.RCDATA);
	    } else if (tn === $.NOSCRIPT) {
	        if (p.options.scriptingEnabled) {
	            p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
	        } else {
	            p._insertElement(token, NS.HTML);
	            p.insertionMode = IN_HEAD_NO_SCRIPT_MODE;
	        }
	    } else if (tn === $.NOFRAMES || tn === $.STYLE) {
	        p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
	    } else if (tn === $.SCRIPT) {
	        p._switchToTextParsing(token, Tokenizer.MODE.SCRIPT_DATA);
	    } else if (tn === $.TEMPLATE) {
	        p._insertTemplate(token, NS.HTML);
	        p.activeFormattingElements.insertMarker();
	        p.framesetOk = false;
	        p.insertionMode = IN_TEMPLATE_MODE;
	        p._pushTmplInsertionMode(IN_TEMPLATE_MODE);
	    } else if (tn === $.HEAD) {
	        p._err(ERR.misplacedStartTagForHeadElement);
	    } else {
	        tokenInHead(p, token);
	    }
	}

	function endTagInHead(p, token) {
	    const tn = token.tagName;

	    if (tn === $.HEAD) {
	        p.openElements.pop();
	        p.insertionMode = AFTER_HEAD_MODE;
	    } else if (tn === $.BODY || tn === $.BR || tn === $.HTML) {
	        tokenInHead(p, token);
	    } else if (tn === $.TEMPLATE) {
	        if (p.openElements.tmplCount > 0) {
	            p.openElements.generateImpliedEndTagsThoroughly();

	            if (p.openElements.currentTagName !== $.TEMPLATE) {
	                p._err(ERR.closingOfElementWithOpenChildElements);
	            }

	            p.openElements.popUntilTagNamePopped($.TEMPLATE);
	            p.activeFormattingElements.clearToLastMarker();
	            p._popTmplInsertionMode();
	            p._resetInsertionMode();
	        } else {
	            p._err(ERR.endTagWithoutMatchingOpenElement);
	        }
	    } else {
	        p._err(ERR.endTagWithoutMatchingOpenElement);
	    }
	}

	function tokenInHead(p, token) {
	    p.openElements.pop();
	    p.insertionMode = AFTER_HEAD_MODE;
	    p._processToken(token);
	}

	// The "in head no script" insertion mode
	//------------------------------------------------------------------
	function startTagInHeadNoScript(p, token) {
	    const tn = token.tagName;

	    if (tn === $.HTML) {
	        startTagInBody(p, token);
	    } else if (
	        tn === $.BASEFONT ||
	        tn === $.BGSOUND ||
	        tn === $.HEAD ||
	        tn === $.LINK ||
	        tn === $.META ||
	        tn === $.NOFRAMES ||
	        tn === $.STYLE
	    ) {
	        startTagInHead(p, token);
	    } else if (tn === $.NOSCRIPT) {
	        p._err(ERR.nestedNoscriptInHead);
	    } else {
	        tokenInHeadNoScript(p, token);
	    }
	}

	function endTagInHeadNoScript(p, token) {
	    const tn = token.tagName;

	    if (tn === $.NOSCRIPT) {
	        p.openElements.pop();
	        p.insertionMode = IN_HEAD_MODE;
	    } else if (tn === $.BR) {
	        tokenInHeadNoScript(p, token);
	    } else {
	        p._err(ERR.endTagWithoutMatchingOpenElement);
	    }
	}

	function tokenInHeadNoScript(p, token) {
	    const errCode =
	        token.type === Tokenizer.EOF_TOKEN ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;

	    p._err(errCode);
	    p.openElements.pop();
	    p.insertionMode = IN_HEAD_MODE;
	    p._processToken(token);
	}

	// The "after head" insertion mode
	//------------------------------------------------------------------
	function startTagAfterHead(p, token) {
	    const tn = token.tagName;

	    if (tn === $.HTML) {
	        startTagInBody(p, token);
	    } else if (tn === $.BODY) {
	        p._insertElement(token, NS.HTML);
	        p.framesetOk = false;
	        p.insertionMode = IN_BODY_MODE;
	    } else if (tn === $.FRAMESET) {
	        p._insertElement(token, NS.HTML);
	        p.insertionMode = IN_FRAMESET_MODE;
	    } else if (
	        tn === $.BASE ||
	        tn === $.BASEFONT ||
	        tn === $.BGSOUND ||
	        tn === $.LINK ||
	        tn === $.META ||
	        tn === $.NOFRAMES ||
	        tn === $.SCRIPT ||
	        tn === $.STYLE ||
	        tn === $.TEMPLATE ||
	        tn === $.TITLE
	    ) {
	        p._err(ERR.abandonedHeadElementChild);
	        p.openElements.push(p.headElement);
	        startTagInHead(p, token);
	        p.openElements.remove(p.headElement);
	    } else if (tn === $.HEAD) {
	        p._err(ERR.misplacedStartTagForHeadElement);
	    } else {
	        tokenAfterHead(p, token);
	    }
	}

	function endTagAfterHead(p, token) {
	    const tn = token.tagName;

	    if (tn === $.BODY || tn === $.HTML || tn === $.BR) {
	        tokenAfterHead(p, token);
	    } else if (tn === $.TEMPLATE) {
	        endTagInHead(p, token);
	    } else {
	        p._err(ERR.endTagWithoutMatchingOpenElement);
	    }
	}

	function tokenAfterHead(p, token) {
	    p._insertFakeElement($.BODY);
	    p.insertionMode = IN_BODY_MODE;
	    p._processToken(token);
	}

	// The "in body" insertion mode
	//------------------------------------------------------------------
	function whitespaceCharacterInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    p._insertCharacters(token);
	}

	function characterInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    p._insertCharacters(token);
	    p.framesetOk = false;
	}

	function htmlStartTagInBody(p, token) {
	    if (p.openElements.tmplCount === 0) {
	        p.treeAdapter.adoptAttributes(p.openElements.items[0], token.attrs);
	    }
	}

	function bodyStartTagInBody(p, token) {
	    const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();

	    if (bodyElement && p.openElements.tmplCount === 0) {
	        p.framesetOk = false;
	        p.treeAdapter.adoptAttributes(bodyElement, token.attrs);
	    }
	}

	function framesetStartTagInBody(p, token) {
	    const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();

	    if (p.framesetOk && bodyElement) {
	        p.treeAdapter.detachNode(bodyElement);
	        p.openElements.popAllUpToHtmlElement();
	        p._insertElement(token, NS.HTML);
	        p.insertionMode = IN_FRAMESET_MODE;
	    }
	}

	function addressStartTagInBody(p, token) {
	    if (p.openElements.hasInButtonScope($.P)) {
	        p._closePElement();
	    }

	    p._insertElement(token, NS.HTML);
	}

	function numberedHeaderStartTagInBody(p, token) {
	    if (p.openElements.hasInButtonScope($.P)) {
	        p._closePElement();
	    }

	    const tn = p.openElements.currentTagName;

	    if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {
	        p.openElements.pop();
	    }

	    p._insertElement(token, NS.HTML);
	}

	function preStartTagInBody(p, token) {
	    if (p.openElements.hasInButtonScope($.P)) {
	        p._closePElement();
	    }

	    p._insertElement(token, NS.HTML);
	    //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move
	    //on to the next one. (Newlines at the start of pre blocks are ignored as an authoring convenience.)
	    p.skipNextNewLine = true;
	    p.framesetOk = false;
	}

	function formStartTagInBody(p, token) {
	    const inTemplate = p.openElements.tmplCount > 0;

	    if (!p.formElement || inTemplate) {
	        if (p.openElements.hasInButtonScope($.P)) {
	            p._closePElement();
	        }

	        p._insertElement(token, NS.HTML);

	        if (!inTemplate) {
	            p.formElement = p.openElements.current;
	        }
	    }
	}

	function listItemStartTagInBody(p, token) {
	    p.framesetOk = false;

	    const tn = token.tagName;

	    for (let i = p.openElements.stackTop; i >= 0; i--) {
	        const element = p.openElements.items[i];
	        const elementTn = p.treeAdapter.getTagName(element);
	        let closeTn = null;

	        if (tn === $.LI && elementTn === $.LI) {
	            closeTn = $.LI;
	        } else if ((tn === $.DD || tn === $.DT) && (elementTn === $.DD || elementTn === $.DT)) {
	            closeTn = elementTn;
	        }

	        if (closeTn) {
	            p.openElements.generateImpliedEndTagsWithExclusion(closeTn);
	            p.openElements.popUntilTagNamePopped(closeTn);
	            break;
	        }

	        if (elementTn !== $.ADDRESS && elementTn !== $.DIV && elementTn !== $.P && p._isSpecialElement(element)) {
	            break;
	        }
	    }

	    if (p.openElements.hasInButtonScope($.P)) {
	        p._closePElement();
	    }

	    p._insertElement(token, NS.HTML);
	}

	function plaintextStartTagInBody(p, token) {
	    if (p.openElements.hasInButtonScope($.P)) {
	        p._closePElement();
	    }

	    p._insertElement(token, NS.HTML);
	    p.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
	}

	function buttonStartTagInBody(p, token) {
	    if (p.openElements.hasInScope($.BUTTON)) {
	        p.openElements.generateImpliedEndTags();
	        p.openElements.popUntilTagNamePopped($.BUTTON);
	    }

	    p._reconstructActiveFormattingElements();
	    p._insertElement(token, NS.HTML);
	    p.framesetOk = false;
	}

	function aStartTagInBody(p, token) {
	    const activeElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName($.A);

	    if (activeElementEntry) {
	        callAdoptionAgency(p, token);
	        p.openElements.remove(activeElementEntry.element);
	        p.activeFormattingElements.removeEntry(activeElementEntry);
	    }

	    p._reconstructActiveFormattingElements();
	    p._insertElement(token, NS.HTML);
	    p.activeFormattingElements.pushElement(p.openElements.current, token);
	}

	function bStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    p._insertElement(token, NS.HTML);
	    p.activeFormattingElements.pushElement(p.openElements.current, token);
	}

	function nobrStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();

	    if (p.openElements.hasInScope($.NOBR)) {
	        callAdoptionAgency(p, token);
	        p._reconstructActiveFormattingElements();
	    }

	    p._insertElement(token, NS.HTML);
	    p.activeFormattingElements.pushElement(p.openElements.current, token);
	}

	function appletStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    p._insertElement(token, NS.HTML);
	    p.activeFormattingElements.insertMarker();
	    p.framesetOk = false;
	}

	function tableStartTagInBody(p, token) {
	    if (
	        p.treeAdapter.getDocumentMode(p.document) !== HTML.DOCUMENT_MODE.QUIRKS &&
	        p.openElements.hasInButtonScope($.P)
	    ) {
	        p._closePElement();
	    }

	    p._insertElement(token, NS.HTML);
	    p.framesetOk = false;
	    p.insertionMode = IN_TABLE_MODE;
	}

	function areaStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    p._appendElement(token, NS.HTML);
	    p.framesetOk = false;
	    token.ackSelfClosing = true;
	}

	function inputStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    p._appendElement(token, NS.HTML);

	    const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);

	    if (!inputType || inputType.toLowerCase() !== HIDDEN_INPUT_TYPE) {
	        p.framesetOk = false;
	    }

	    token.ackSelfClosing = true;
	}

	function paramStartTagInBody(p, token) {
	    p._appendElement(token, NS.HTML);
	    token.ackSelfClosing = true;
	}

	function hrStartTagInBody(p, token) {
	    if (p.openElements.hasInButtonScope($.P)) {
	        p._closePElement();
	    }

	    p._appendElement(token, NS.HTML);
	    p.framesetOk = false;
	    p.ackSelfClosing = true;
	}

	function imageStartTagInBody(p, token) {
	    token.tagName = $.IMG;
	    areaStartTagInBody(p, token);
	}

	function textareaStartTagInBody(p, token) {
	    p._insertElement(token, NS.HTML);
	    //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move
	    //on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)
	    p.skipNextNewLine = true;
	    p.tokenizer.state = Tokenizer.MODE.RCDATA;
	    p.originalInsertionMode = p.insertionMode;
	    p.framesetOk = false;
	    p.insertionMode = TEXT_MODE;
	}

	function xmpStartTagInBody(p, token) {
	    if (p.openElements.hasInButtonScope($.P)) {
	        p._closePElement();
	    }

	    p._reconstructActiveFormattingElements();
	    p.framesetOk = false;
	    p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
	}

	function iframeStartTagInBody(p, token) {
	    p.framesetOk = false;
	    p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
	}

	//NOTE: here we assume that we always act as an user agent with enabled plugins, so we parse
	//<noembed> as a rawtext.
	function noembedStartTagInBody(p, token) {
	    p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
	}

	function selectStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    p._insertElement(token, NS.HTML);
	    p.framesetOk = false;

	    if (
	        p.insertionMode === IN_TABLE_MODE ||
	        p.insertionMode === IN_CAPTION_MODE ||
	        p.insertionMode === IN_TABLE_BODY_MODE ||
	        p.insertionMode === IN_ROW_MODE ||
	        p.insertionMode === IN_CELL_MODE
	    ) {
	        p.insertionMode = IN_SELECT_IN_TABLE_MODE;
	    } else {
	        p.insertionMode = IN_SELECT_MODE;
	    }
	}

	function optgroupStartTagInBody(p, token) {
	    if (p.openElements.currentTagName === $.OPTION) {
	        p.openElements.pop();
	    }

	    p._reconstructActiveFormattingElements();
	    p._insertElement(token, NS.HTML);
	}

	function rbStartTagInBody(p, token) {
	    if (p.openElements.hasInScope($.RUBY)) {
	        p.openElements.generateImpliedEndTags();
	    }

	    p._insertElement(token, NS.HTML);
	}

	function rtStartTagInBody(p, token) {
	    if (p.openElements.hasInScope($.RUBY)) {
	        p.openElements.generateImpliedEndTagsWithExclusion($.RTC);
	    }

	    p._insertElement(token, NS.HTML);
	}

	function menuStartTagInBody(p, token) {
	    if (p.openElements.hasInButtonScope($.P)) {
	        p._closePElement();
	    }

	    p._insertElement(token, NS.HTML);
	}

	function mathStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();

	    foreignContent.adjustTokenMathMLAttrs(token);
	    foreignContent.adjustTokenXMLAttrs(token);

	    if (token.selfClosing) {
	        p._appendElement(token, NS.MATHML);
	    } else {
	        p._insertElement(token, NS.MATHML);
	    }

	    token.ackSelfClosing = true;
	}

	function svgStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();

	    foreignContent.adjustTokenSVGAttrs(token);
	    foreignContent.adjustTokenXMLAttrs(token);

	    if (token.selfClosing) {
	        p._appendElement(token, NS.SVG);
	    } else {
	        p._insertElement(token, NS.SVG);
	    }

	    token.ackSelfClosing = true;
	}

	function genericStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    p._insertElement(token, NS.HTML);
	}

	//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.
	//It's faster than using dictionary.
	function startTagInBody(p, token) {
	    const tn = token.tagName;

	    switch (tn.length) {
	        case 1:
	            if (tn === $.I || tn === $.S || tn === $.B || tn === $.U) {
	                bStartTagInBody(p, token);
	            } else if (tn === $.P) {
	                addressStartTagInBody(p, token);
	            } else if (tn === $.A) {
	                aStartTagInBody(p, token);
	            } else {
	                genericStartTagInBody(p, token);
	            }

	            break;

	        case 2:
	            if (tn === $.DL || tn === $.OL || tn === $.UL) {
	                addressStartTagInBody(p, token);
	            } else if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {
	                numberedHeaderStartTagInBody(p, token);
	            } else if (tn === $.LI || tn === $.DD || tn === $.DT) {
	                listItemStartTagInBody(p, token);
	            } else if (tn === $.EM || tn === $.TT) {
	                bStartTagInBody(p, token);
	            } else if (tn === $.BR) {
	                areaStartTagInBody(p, token);
	            } else if (tn === $.HR) {
	                hrStartTagInBody(p, token);
	            } else if (tn === $.RB) {
	                rbStartTagInBody(p, token);
	            } else if (tn === $.RT || tn === $.RP) {
	                rtStartTagInBody(p, token);
	            } else if (tn !== $.TH && tn !== $.TD && tn !== $.TR) {
	                genericStartTagInBody(p, token);
	            }

	            break;

	        case 3:
	            if (tn === $.DIV || tn === $.DIR || tn === $.NAV) {
	                addressStartTagInBody(p, token);
	            } else if (tn === $.PRE) {
	                preStartTagInBody(p, token);
	            } else if (tn === $.BIG) {
	                bStartTagInBody(p, token);
	            } else if (tn === $.IMG || tn === $.WBR) {
	                areaStartTagInBody(p, token);
	            } else if (tn === $.XMP) {
	                xmpStartTagInBody(p, token);
	            } else if (tn === $.SVG) {
	                svgStartTagInBody(p, token);
	            } else if (tn === $.RTC) {
	                rbStartTagInBody(p, token);
	            } else if (tn !== $.COL) {
	                genericStartTagInBody(p, token);
	            }

	            break;

	        case 4:
	            if (tn === $.HTML) {
	                htmlStartTagInBody(p, token);
	            } else if (tn === $.BASE || tn === $.LINK || tn === $.META) {
	                startTagInHead(p, token);
	            } else if (tn === $.BODY) {
	                bodyStartTagInBody(p, token);
	            } else if (tn === $.MAIN || tn === $.MENU) {
	                addressStartTagInBody(p, token);
	            } else if (tn === $.FORM) {
	                formStartTagInBody(p, token);
	            } else if (tn === $.CODE || tn === $.FONT) {
	                bStartTagInBody(p, token);
	            } else if (tn === $.NOBR) {
	                nobrStartTagInBody(p, token);
	            } else if (tn === $.AREA) {
	                areaStartTagInBody(p, token);
	            } else if (tn === $.MATH) {
	                mathStartTagInBody(p, token);
	            } else if (tn === $.MENU) {
	                menuStartTagInBody(p, token);
	            } else if (tn !== $.HEAD) {
	                genericStartTagInBody(p, token);
	            }

	            break;

	        case 5:
	            if (tn === $.STYLE || tn === $.TITLE) {
	                startTagInHead(p, token);
	            } else if (tn === $.ASIDE) {
	                addressStartTagInBody(p, token);
	            } else if (tn === $.SMALL) {
	                bStartTagInBody(p, token);
	            } else if (tn === $.TABLE) {
	                tableStartTagInBody(p, token);
	            } else if (tn === $.EMBED) {
	                areaStartTagInBody(p, token);
	            } else if (tn === $.INPUT) {
	                inputStartTagInBody(p, token);
	            } else if (tn === $.PARAM || tn === $.TRACK) {
	                paramStartTagInBody(p, token);
	            } else if (tn === $.IMAGE) {
	                imageStartTagInBody(p, token);
	            } else if (tn !== $.FRAME && tn !== $.TBODY && tn !== $.TFOOT && tn !== $.THEAD) {
	                genericStartTagInBody(p, token);
	            }

	            break;

	        case 6:
	            if (tn === $.SCRIPT) {
	                startTagInHead(p, token);
	            } else if (
	                tn === $.CENTER ||
	                tn === $.FIGURE ||
	                tn === $.FOOTER ||
	                tn === $.HEADER ||
	                tn === $.HGROUP ||
	                tn === $.DIALOG
	            ) {
	                addressStartTagInBody(p, token);
	            } else if (tn === $.BUTTON) {
	                buttonStartTagInBody(p, token);
	            } else if (tn === $.STRIKE || tn === $.STRONG) {
	                bStartTagInBody(p, token);
	            } else if (tn === $.APPLET || tn === $.OBJECT) {
	                appletStartTagInBody(p, token);
	            } else if (tn === $.KEYGEN) {
	                areaStartTagInBody(p, token);
	            } else if (tn === $.SOURCE) {
	                paramStartTagInBody(p, token);
	            } else if (tn === $.IFRAME) {
	                iframeStartTagInBody(p, token);
	            } else if (tn === $.SELECT) {
	                selectStartTagInBody(p, token);
	            } else if (tn === $.OPTION) {
	                optgroupStartTagInBody(p, token);
	            } else {
	                genericStartTagInBody(p, token);
	            }

	            break;

	        case 7:
	            if (tn === $.BGSOUND) {
	                startTagInHead(p, token);
	            } else if (
	                tn === $.DETAILS ||
	                tn === $.ADDRESS ||
	                tn === $.ARTICLE ||
	                tn === $.SECTION ||
	                tn === $.SUMMARY
	            ) {
	                addressStartTagInBody(p, token);
	            } else if (tn === $.LISTING) {
	                preStartTagInBody(p, token);
	            } else if (tn === $.MARQUEE) {
	                appletStartTagInBody(p, token);
	            } else if (tn === $.NOEMBED) {
	                noembedStartTagInBody(p, token);
	            } else if (tn !== $.CAPTION) {
	                genericStartTagInBody(p, token);
	            }

	            break;

	        case 8:
	            if (tn === $.BASEFONT) {
	                startTagInHead(p, token);
	            } else if (tn === $.FRAMESET) {
	                framesetStartTagInBody(p, token);
	            } else if (tn === $.FIELDSET) {
	                addressStartTagInBody(p, token);
	            } else if (tn === $.TEXTAREA) {
	                textareaStartTagInBody(p, token);
	            } else if (tn === $.TEMPLATE) {
	                startTagInHead(p, token);
	            } else if (tn === $.NOSCRIPT) {
	                if (p.options.scriptingEnabled) {
	                    noembedStartTagInBody(p, token);
	                } else {
	                    genericStartTagInBody(p, token);
	                }
	            } else if (tn === $.OPTGROUP) {
	                optgroupStartTagInBody(p, token);
	            } else if (tn !== $.COLGROUP) {
	                genericStartTagInBody(p, token);
	            }

	            break;

	        case 9:
	            if (tn === $.PLAINTEXT) {
	                plaintextStartTagInBody(p, token);
	            } else {
	                genericStartTagInBody(p, token);
	            }

	            break;

	        case 10:
	            if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION) {
	                addressStartTagInBody(p, token);
	            } else {
	                genericStartTagInBody(p, token);
	            }

	            break;

	        default:
	            genericStartTagInBody(p, token);
	    }
	}

	function bodyEndTagInBody(p) {
	    if (p.openElements.hasInScope($.BODY)) {
	        p.insertionMode = AFTER_BODY_MODE;
	    }
	}

	function htmlEndTagInBody(p, token) {
	    if (p.openElements.hasInScope($.BODY)) {
	        p.insertionMode = AFTER_BODY_MODE;
	        p._processToken(token);
	    }
	}

	function addressEndTagInBody(p, token) {
	    const tn = token.tagName;

	    if (p.openElements.hasInScope(tn)) {
	        p.openElements.generateImpliedEndTags();
	        p.openElements.popUntilTagNamePopped(tn);
	    }
	}

	function formEndTagInBody(p) {
	    const inTemplate = p.openElements.tmplCount > 0;
	    const formElement = p.formElement;

	    if (!inTemplate) {
	        p.formElement = null;
	    }

	    if ((formElement || inTemplate) && p.openElements.hasInScope($.FORM)) {
	        p.openElements.generateImpliedEndTags();

	        if (inTemplate) {
	            p.openElements.popUntilTagNamePopped($.FORM);
	        } else {
	            p.openElements.remove(formElement);
	        }
	    }
	}

	function pEndTagInBody(p) {
	    if (!p.openElements.hasInButtonScope($.P)) {
	        p._insertFakeElement($.P);
	    }

	    p._closePElement();
	}

	function liEndTagInBody(p) {
	    if (p.openElements.hasInListItemScope($.LI)) {
	        p.openElements.generateImpliedEndTagsWithExclusion($.LI);
	        p.openElements.popUntilTagNamePopped($.LI);
	    }
	}

	function ddEndTagInBody(p, token) {
	    const tn = token.tagName;

	    if (p.openElements.hasInScope(tn)) {
	        p.openElements.generateImpliedEndTagsWithExclusion(tn);
	        p.openElements.popUntilTagNamePopped(tn);
	    }
	}

	function numberedHeaderEndTagInBody(p) {
	    if (p.openElements.hasNumberedHeaderInScope()) {
	        p.openElements.generateImpliedEndTags();
	        p.openElements.popUntilNumberedHeaderPopped();
	    }
	}

	function appletEndTagInBody(p, token) {
	    const tn = token.tagName;

	    if (p.openElements.hasInScope(tn)) {
	        p.openElements.generateImpliedEndTags();
	        p.openElements.popUntilTagNamePopped(tn);
	        p.activeFormattingElements.clearToLastMarker();
	    }
	}

	function brEndTagInBody(p) {
	    p._reconstructActiveFormattingElements();
	    p._insertFakeElement($.BR);
	    p.openElements.pop();
	    p.framesetOk = false;
	}

	function genericEndTagInBody(p, token) {
	    const tn = token.tagName;

	    for (let i = p.openElements.stackTop; i > 0; i--) {
	        const element = p.openElements.items[i];

	        if (p.treeAdapter.getTagName(element) === tn) {
	            p.openElements.generateImpliedEndTagsWithExclusion(tn);
	            p.openElements.popUntilElementPopped(element);
	            break;
	        }

	        if (p._isSpecialElement(element)) {
	            break;
	        }
	    }
	}

	//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.
	//It's faster than using dictionary.
	function endTagInBody(p, token) {
	    const tn = token.tagName;

	    switch (tn.length) {
	        case 1:
	            if (tn === $.A || tn === $.B || tn === $.I || tn === $.S || tn === $.U) {
	                callAdoptionAgency(p, token);
	            } else if (tn === $.P) {
	                pEndTagInBody(p);
	            } else {
	                genericEndTagInBody(p, token);
	            }

	            break;

	        case 2:
	            if (tn === $.DL || tn === $.UL || tn === $.OL) {
	                addressEndTagInBody(p, token);
	            } else if (tn === $.LI) {
	                liEndTagInBody(p);
	            } else if (tn === $.DD || tn === $.DT) {
	                ddEndTagInBody(p, token);
	            } else if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {
	                numberedHeaderEndTagInBody(p);
	            } else if (tn === $.BR) {
	                brEndTagInBody(p);
	            } else if (tn === $.EM || tn === $.TT) {
	                callAdoptionAgency(p, token);
	            } else {
	                genericEndTagInBody(p, token);
	            }

	            break;

	        case 3:
	            if (tn === $.BIG) {
	                callAdoptionAgency(p, token);
	            } else if (tn === $.DIR || tn === $.DIV || tn === $.NAV || tn === $.PRE) {
	                addressEndTagInBody(p, token);
	            } else {
	                genericEndTagInBody(p, token);
	            }

	            break;

	        case 4:
	            if (tn === $.BODY) {
	                bodyEndTagInBody(p);
	            } else if (tn === $.HTML) {
	                htmlEndTagInBody(p, token);
	            } else if (tn === $.FORM) {
	                formEndTagInBody(p);
	            } else if (tn === $.CODE || tn === $.FONT || tn === $.NOBR) {
	                callAdoptionAgency(p, token);
	            } else if (tn === $.MAIN || tn === $.MENU) {
	                addressEndTagInBody(p, token);
	            } else {
	                genericEndTagInBody(p, token);
	            }

	            break;

	        case 5:
	            if (tn === $.ASIDE) {
	                addressEndTagInBody(p, token);
	            } else if (tn === $.SMALL) {
	                callAdoptionAgency(p, token);
	            } else {
	                genericEndTagInBody(p, token);
	            }

	            break;

	        case 6:
	            if (
	                tn === $.CENTER ||
	                tn === $.FIGURE ||
	                tn === $.FOOTER ||
	                tn === $.HEADER ||
	                tn === $.HGROUP ||
	                tn === $.DIALOG
	            ) {
	                addressEndTagInBody(p, token);
	            } else if (tn === $.APPLET || tn === $.OBJECT) {
	                appletEndTagInBody(p, token);
	            } else if (tn === $.STRIKE || tn === $.STRONG) {
	                callAdoptionAgency(p, token);
	            } else {
	                genericEndTagInBody(p, token);
	            }

	            break;

	        case 7:
	            if (
	                tn === $.ADDRESS ||
	                tn === $.ARTICLE ||
	                tn === $.DETAILS ||
	                tn === $.SECTION ||
	                tn === $.SUMMARY ||
	                tn === $.LISTING
	            ) {
	                addressEndTagInBody(p, token);
	            } else if (tn === $.MARQUEE) {
	                appletEndTagInBody(p, token);
	            } else {
	                genericEndTagInBody(p, token);
	            }

	            break;

	        case 8:
	            if (tn === $.FIELDSET) {
	                addressEndTagInBody(p, token);
	            } else if (tn === $.TEMPLATE) {
	                endTagInHead(p, token);
	            } else {
	                genericEndTagInBody(p, token);
	            }

	            break;

	        case 10:
	            if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION) {
	                addressEndTagInBody(p, token);
	            } else {
	                genericEndTagInBody(p, token);
	            }

	            break;

	        default:
	            genericEndTagInBody(p, token);
	    }
	}

	function eofInBody(p, token) {
	    if (p.tmplInsertionModeStackTop > -1) {
	        eofInTemplate(p, token);
	    } else {
	        p.stopped = true;
	    }
	}

	// The "text" insertion mode
	//------------------------------------------------------------------
	function endTagInText(p, token) {
	    if (token.tagName === $.SCRIPT) {
	        p.pendingScript = p.openElements.current;
	    }

	    p.openElements.pop();
	    p.insertionMode = p.originalInsertionMode;
	}

	function eofInText(p, token) {
	    p._err(ERR.eofInElementThatCanContainOnlyText);
	    p.openElements.pop();
	    p.insertionMode = p.originalInsertionMode;
	    p._processToken(token);
	}

	// The "in table" insertion mode
	//------------------------------------------------------------------
	function characterInTable(p, token) {
	    const curTn = p.openElements.currentTagName;

	    if (curTn === $.TABLE || curTn === $.TBODY || curTn === $.TFOOT || curTn === $.THEAD || curTn === $.TR) {
	        p.pendingCharacterTokens = [];
	        p.hasNonWhitespacePendingCharacterToken = false;
	        p.originalInsertionMode = p.insertionMode;
	        p.insertionMode = IN_TABLE_TEXT_MODE;
	        p._processToken(token);
	    } else {
	        tokenInTable(p, token);
	    }
	}

	function captionStartTagInTable(p, token) {
	    p.openElements.clearBackToTableContext();
	    p.activeFormattingElements.insertMarker();
	    p._insertElement(token, NS.HTML);
	    p.insertionMode = IN_CAPTION_MODE;
	}

	function colgroupStartTagInTable(p, token) {
	    p.openElements.clearBackToTableContext();
	    p._insertElement(token, NS.HTML);
	    p.insertionMode = IN_COLUMN_GROUP_MODE;
	}

	function colStartTagInTable(p, token) {
	    p.openElements.clearBackToTableContext();
	    p._insertFakeElement($.COLGROUP);
	    p.insertionMode = IN_COLUMN_GROUP_MODE;
	    p._processToken(token);
	}

	function tbodyStartTagInTable(p, token) {
	    p.openElements.clearBackToTableContext();
	    p._insertElement(token, NS.HTML);
	    p.insertionMode = IN_TABLE_BODY_MODE;
	}

	function tdStartTagInTable(p, token) {
	    p.openElements.clearBackToTableContext();
	    p._insertFakeElement($.TBODY);
	    p.insertionMode = IN_TABLE_BODY_MODE;
	    p._processToken(token);
	}

	function tableStartTagInTable(p, token) {
	    if (p.openElements.hasInTableScope($.TABLE)) {
	        p.openElements.popUntilTagNamePopped($.TABLE);
	        p._resetInsertionMode();
	        p._processToken(token);
	    }
	}

	function inputStartTagInTable(p, token) {
	    const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);

	    if (inputType && inputType.toLowerCase() === HIDDEN_INPUT_TYPE) {
	        p._appendElement(token, NS.HTML);
	    } else {
	        tokenInTable(p, token);
	    }

	    token.ackSelfClosing = true;
	}

	function formStartTagInTable(p, token) {
	    if (!p.formElement && p.openElements.tmplCount === 0) {
	        p._insertElement(token, NS.HTML);
	        p.formElement = p.openElements.current;
	        p.openElements.pop();
	    }
	}

	function startTagInTable(p, token) {
	    const tn = token.tagName;

	    switch (tn.length) {
	        case 2:
	            if (tn === $.TD || tn === $.TH || tn === $.TR) {
	                tdStartTagInTable(p, token);
	            } else {
	                tokenInTable(p, token);
	            }

	            break;

	        case 3:
	            if (tn === $.COL) {
	                colStartTagInTable(p, token);
	            } else {
	                tokenInTable(p, token);
	            }

	            break;

	        case 4:
	            if (tn === $.FORM) {
	                formStartTagInTable(p, token);
	            } else {
	                tokenInTable(p, token);
	            }

	            break;

	        case 5:
	            if (tn === $.TABLE) {
	                tableStartTagInTable(p, token);
	            } else if (tn === $.STYLE) {
	                startTagInHead(p, token);
	            } else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
	                tbodyStartTagInTable(p, token);
	            } else if (tn === $.INPUT) {
	                inputStartTagInTable(p, token);
	            } else {
	                tokenInTable(p, token);
	            }

	            break;

	        case 6:
	            if (tn === $.SCRIPT) {
	                startTagInHead(p, token);
	            } else {
	                tokenInTable(p, token);
	            }

	            break;

	        case 7:
	            if (tn === $.CAPTION) {
	                captionStartTagInTable(p, token);
	            } else {
	                tokenInTable(p, token);
	            }

	            break;

	        case 8:
	            if (tn === $.COLGROUP) {
	                colgroupStartTagInTable(p, token);
	            } else if (tn === $.TEMPLATE) {
	                startTagInHead(p, token);
	            } else {
	                tokenInTable(p, token);
	            }

	            break;

	        default:
	            tokenInTable(p, token);
	    }
	}

	function endTagInTable(p, token) {
	    const tn = token.tagName;

	    if (tn === $.TABLE) {
	        if (p.openElements.hasInTableScope($.TABLE)) {
	            p.openElements.popUntilTagNamePopped($.TABLE);
	            p._resetInsertionMode();
	        }
	    } else if (tn === $.TEMPLATE) {
	        endTagInHead(p, token);
	    } else if (
	        tn !== $.BODY &&
	        tn !== $.CAPTION &&
	        tn !== $.COL &&
	        tn !== $.COLGROUP &&
	        tn !== $.HTML &&
	        tn !== $.TBODY &&
	        tn !== $.TD &&
	        tn !== $.TFOOT &&
	        tn !== $.TH &&
	        tn !== $.THEAD &&
	        tn !== $.TR
	    ) {
	        tokenInTable(p, token);
	    }
	}

	function tokenInTable(p, token) {
	    const savedFosterParentingState = p.fosterParentingEnabled;

	    p.fosterParentingEnabled = true;
	    p._processTokenInBodyMode(token);
	    p.fosterParentingEnabled = savedFosterParentingState;
	}

	// The "in table text" insertion mode
	//------------------------------------------------------------------
	function whitespaceCharacterInTableText(p, token) {
	    p.pendingCharacterTokens.push(token);
	}

	function characterInTableText(p, token) {
	    p.pendingCharacterTokens.push(token);
	    p.hasNonWhitespacePendingCharacterToken = true;
	}

	function tokenInTableText(p, token) {
	    let i = 0;

	    if (p.hasNonWhitespacePendingCharacterToken) {
	        for (; i < p.pendingCharacterTokens.length; i++) {
	            tokenInTable(p, p.pendingCharacterTokens[i]);
	        }
	    } else {
	        for (; i < p.pendingCharacterTokens.length; i++) {
	            p._insertCharacters(p.pendingCharacterTokens[i]);
	        }
	    }

	    p.insertionMode = p.originalInsertionMode;
	    p._processToken(token);
	}

	// The "in caption" insertion mode
	//------------------------------------------------------------------
	function startTagInCaption(p, token) {
	    const tn = token.tagName;

	    if (
	        tn === $.CAPTION ||
	        tn === $.COL ||
	        tn === $.COLGROUP ||
	        tn === $.TBODY ||
	        tn === $.TD ||
	        tn === $.TFOOT ||
	        tn === $.TH ||
	        tn === $.THEAD ||
	        tn === $.TR
	    ) {
	        if (p.openElements.hasInTableScope($.CAPTION)) {
	            p.openElements.generateImpliedEndTags();
	            p.openElements.popUntilTagNamePopped($.CAPTION);
	            p.activeFormattingElements.clearToLastMarker();
	            p.insertionMode = IN_TABLE_MODE;
	            p._processToken(token);
	        }
	    } else {
	        startTagInBody(p, token);
	    }
	}

	function endTagInCaption(p, token) {
	    const tn = token.tagName;

	    if (tn === $.CAPTION || tn === $.TABLE) {
	        if (p.openElements.hasInTableScope($.CAPTION)) {
	            p.openElements.generateImpliedEndTags();
	            p.openElements.popUntilTagNamePopped($.CAPTION);
	            p.activeFormattingElements.clearToLastMarker();
	            p.insertionMode = IN_TABLE_MODE;

	            if (tn === $.TABLE) {
	                p._processToken(token);
	            }
	        }
	    } else if (
	        tn !== $.BODY &&
	        tn !== $.COL &&
	        tn !== $.COLGROUP &&
	        tn !== $.HTML &&
	        tn !== $.TBODY &&
	        tn !== $.TD &&
	        tn !== $.TFOOT &&
	        tn !== $.TH &&
	        tn !== $.THEAD &&
	        tn !== $.TR
	    ) {
	        endTagInBody(p, token);
	    }
	}

	// The "in column group" insertion mode
	//------------------------------------------------------------------
	function startTagInColumnGroup(p, token) {
	    const tn = token.tagName;

	    if (tn === $.HTML) {
	        startTagInBody(p, token);
	    } else if (tn === $.COL) {
	        p._appendElement(token, NS.HTML);
	        token.ackSelfClosing = true;
	    } else if (tn === $.TEMPLATE) {
	        startTagInHead(p, token);
	    } else {
	        tokenInColumnGroup(p, token);
	    }
	}

	function endTagInColumnGroup(p, token) {
	    const tn = token.tagName;

	    if (tn === $.COLGROUP) {
	        if (p.openElements.currentTagName === $.COLGROUP) {
	            p.openElements.pop();
	            p.insertionMode = IN_TABLE_MODE;
	        }
	    } else if (tn === $.TEMPLATE) {
	        endTagInHead(p, token);
	    } else if (tn !== $.COL) {
	        tokenInColumnGroup(p, token);
	    }
	}

	function tokenInColumnGroup(p, token) {
	    if (p.openElements.currentTagName === $.COLGROUP) {
	        p.openElements.pop();
	        p.insertionMode = IN_TABLE_MODE;
	        p._processToken(token);
	    }
	}

	// The "in table body" insertion mode
	//------------------------------------------------------------------
	function startTagInTableBody(p, token) {
	    const tn = token.tagName;

	    if (tn === $.TR) {
	        p.openElements.clearBackToTableBodyContext();
	        p._insertElement(token, NS.HTML);
	        p.insertionMode = IN_ROW_MODE;
	    } else if (tn === $.TH || tn === $.TD) {
	        p.openElements.clearBackToTableBodyContext();
	        p._insertFakeElement($.TR);
	        p.insertionMode = IN_ROW_MODE;
	        p._processToken(token);
	    } else if (
	        tn === $.CAPTION ||
	        tn === $.COL ||
	        tn === $.COLGROUP ||
	        tn === $.TBODY ||
	        tn === $.TFOOT ||
	        tn === $.THEAD
	    ) {
	        if (p.openElements.hasTableBodyContextInTableScope()) {
	            p.openElements.clearBackToTableBodyContext();
	            p.openElements.pop();
	            p.insertionMode = IN_TABLE_MODE;
	            p._processToken(token);
	        }
	    } else {
	        startTagInTable(p, token);
	    }
	}

	function endTagInTableBody(p, token) {
	    const tn = token.tagName;

	    if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
	        if (p.openElements.hasInTableScope(tn)) {
	            p.openElements.clearBackToTableBodyContext();
	            p.openElements.pop();
	            p.insertionMode = IN_TABLE_MODE;
	        }
	    } else if (tn === $.TABLE) {
	        if (p.openElements.hasTableBodyContextInTableScope()) {
	            p.openElements.clearBackToTableBodyContext();
	            p.openElements.pop();
	            p.insertionMode = IN_TABLE_MODE;
	            p._processToken(token);
	        }
	    } else if (
	        (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP) ||
	        (tn !== $.HTML && tn !== $.TD && tn !== $.TH && tn !== $.TR)
	    ) {
	        endTagInTable(p, token);
	    }
	}

	// The "in row" insertion mode
	//------------------------------------------------------------------
	function startTagInRow(p, token) {
	    const tn = token.tagName;

	    if (tn === $.TH || tn === $.TD) {
	        p.openElements.clearBackToTableRowContext();
	        p._insertElement(token, NS.HTML);
	        p.insertionMode = IN_CELL_MODE;
	        p.activeFormattingElements.insertMarker();
	    } else if (
	        tn === $.CAPTION ||
	        tn === $.COL ||
	        tn === $.COLGROUP ||
	        tn === $.TBODY ||
	        tn === $.TFOOT ||
	        tn === $.THEAD ||
	        tn === $.TR
	    ) {
	        if (p.openElements.hasInTableScope($.TR)) {
	            p.openElements.clearBackToTableRowContext();
	            p.openElements.pop();
	            p.insertionMode = IN_TABLE_BODY_MODE;
	            p._processToken(token);
	        }
	    } else {
	        startTagInTable(p, token);
	    }
	}

	function endTagInRow(p, token) {
	    const tn = token.tagName;

	    if (tn === $.TR) {
	        if (p.openElements.hasInTableScope($.TR)) {
	            p.openElements.clearBackToTableRowContext();
	            p.openElements.pop();
	            p.insertionMode = IN_TABLE_BODY_MODE;
	        }
	    } else if (tn === $.TABLE) {
	        if (p.openElements.hasInTableScope($.TR)) {
	            p.openElements.clearBackToTableRowContext();
	            p.openElements.pop();
	            p.insertionMode = IN_TABLE_BODY_MODE;
	            p._processToken(token);
	        }
	    } else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
	        if (p.openElements.hasInTableScope(tn) || p.openElements.hasInTableScope($.TR)) {
	            p.openElements.clearBackToTableRowContext();
	            p.openElements.pop();
	            p.insertionMode = IN_TABLE_BODY_MODE;
	            p._processToken(token);
	        }
	    } else if (
	        (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP) ||
	        (tn !== $.HTML && tn !== $.TD && tn !== $.TH)
	    ) {
	        endTagInTable(p, token);
	    }
	}

	// The "in cell" insertion mode
	//------------------------------------------------------------------
	function startTagInCell(p, token) {
	    const tn = token.tagName;

	    if (
	        tn === $.CAPTION ||
	        tn === $.COL ||
	        tn === $.COLGROUP ||
	        tn === $.TBODY ||
	        tn === $.TD ||
	        tn === $.TFOOT ||
	        tn === $.TH ||
	        tn === $.THEAD ||
	        tn === $.TR
	    ) {
	        if (p.openElements.hasInTableScope($.TD) || p.openElements.hasInTableScope($.TH)) {
	            p._closeTableCell();
	            p._processToken(token);
	        }
	    } else {
	        startTagInBody(p, token);
	    }
	}

	function endTagInCell(p, token) {
	    const tn = token.tagName;

	    if (tn === $.TD || tn === $.TH) {
	        if (p.openElements.hasInTableScope(tn)) {
	            p.openElements.generateImpliedEndTags();
	            p.openElements.popUntilTagNamePopped(tn);
	            p.activeFormattingElements.clearToLastMarker();
	            p.insertionMode = IN_ROW_MODE;
	        }
	    } else if (tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR) {
	        if (p.openElements.hasInTableScope(tn)) {
	            p._closeTableCell();
	            p._processToken(token);
	        }
	    } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML) {
	        endTagInBody(p, token);
	    }
	}

	// The "in select" insertion mode
	//------------------------------------------------------------------
	function startTagInSelect(p, token) {
	    const tn = token.tagName;

	    if (tn === $.HTML) {
	        startTagInBody(p, token);
	    } else if (tn === $.OPTION) {
	        if (p.openElements.currentTagName === $.OPTION) {
	            p.openElements.pop();
	        }

	        p._insertElement(token, NS.HTML);
	    } else if (tn === $.OPTGROUP) {
	        if (p.openElements.currentTagName === $.OPTION) {
	            p.openElements.pop();
	        }

	        if (p.openElements.currentTagName === $.OPTGROUP) {
	            p.openElements.pop();
	        }

	        p._insertElement(token, NS.HTML);
	    } else if (tn === $.INPUT || tn === $.KEYGEN || tn === $.TEXTAREA || tn === $.SELECT) {
	        if (p.openElements.hasInSelectScope($.SELECT)) {
	            p.openElements.popUntilTagNamePopped($.SELECT);
	            p._resetInsertionMode();

	            if (tn !== $.SELECT) {
	                p._processToken(token);
	            }
	        }
	    } else if (tn === $.SCRIPT || tn === $.TEMPLATE) {
	        startTagInHead(p, token);
	    }
	}

	function endTagInSelect(p, token) {
	    const tn = token.tagName;

	    if (tn === $.OPTGROUP) {
	        const prevOpenElement = p.openElements.items[p.openElements.stackTop - 1];
	        const prevOpenElementTn = prevOpenElement && p.treeAdapter.getTagName(prevOpenElement);

	        if (p.openElements.currentTagName === $.OPTION && prevOpenElementTn === $.OPTGROUP) {
	            p.openElements.pop();
	        }

	        if (p.openElements.currentTagName === $.OPTGROUP) {
	            p.openElements.pop();
	        }
	    } else if (tn === $.OPTION) {
	        if (p.openElements.currentTagName === $.OPTION) {
	            p.openElements.pop();
	        }
	    } else if (tn === $.SELECT && p.openElements.hasInSelectScope($.SELECT)) {
	        p.openElements.popUntilTagNamePopped($.SELECT);
	        p._resetInsertionMode();
	    } else if (tn === $.TEMPLATE) {
	        endTagInHead(p, token);
	    }
	}

	//12.2.5.4.17 The "in select in table" insertion mode
	//------------------------------------------------------------------
	function startTagInSelectInTable(p, token) {
	    const tn = token.tagName;

	    if (
	        tn === $.CAPTION ||
	        tn === $.TABLE ||
	        tn === $.TBODY ||
	        tn === $.TFOOT ||
	        tn === $.THEAD ||
	        tn === $.TR ||
	        tn === $.TD ||
	        tn === $.TH
	    ) {
	        p.openElements.popUntilTagNamePopped($.SELECT);
	        p._resetInsertionMode();
	        p._processToken(token);
	    } else {
	        startTagInSelect(p, token);
	    }
	}

	function endTagInSelectInTable(p, token) {
	    const tn = token.tagName;

	    if (
	        tn === $.CAPTION ||
	        tn === $.TABLE ||
	        tn === $.TBODY ||
	        tn === $.TFOOT ||
	        tn === $.THEAD ||
	        tn === $.TR ||
	        tn === $.TD ||
	        tn === $.TH
	    ) {
	        if (p.openElements.hasInTableScope(tn)) {
	            p.openElements.popUntilTagNamePopped($.SELECT);
	            p._resetInsertionMode();
	            p._processToken(token);
	        }
	    } else {
	        endTagInSelect(p, token);
	    }
	}

	// The "in template" insertion mode
	//------------------------------------------------------------------
	function startTagInTemplate(p, token) {
	    const tn = token.tagName;

	    if (
	        tn === $.BASE ||
	        tn === $.BASEFONT ||
	        tn === $.BGSOUND ||
	        tn === $.LINK ||
	        tn === $.META ||
	        tn === $.NOFRAMES ||
	        tn === $.SCRIPT ||
	        tn === $.STYLE ||
	        tn === $.TEMPLATE ||
	        tn === $.TITLE
	    ) {
	        startTagInHead(p, token);
	    } else {
	        const newInsertionMode = TEMPLATE_INSERTION_MODE_SWITCH_MAP[tn] || IN_BODY_MODE;

	        p._popTmplInsertionMode();
	        p._pushTmplInsertionMode(newInsertionMode);
	        p.insertionMode = newInsertionMode;
	        p._processToken(token);
	    }
	}

	function endTagInTemplate(p, token) {
	    if (token.tagName === $.TEMPLATE) {
	        endTagInHead(p, token);
	    }
	}

	function eofInTemplate(p, token) {
	    if (p.openElements.tmplCount > 0) {
	        p.openElements.popUntilTagNamePopped($.TEMPLATE);
	        p.activeFormattingElements.clearToLastMarker();
	        p._popTmplInsertionMode();
	        p._resetInsertionMode();
	        p._processToken(token);
	    } else {
	        p.stopped = true;
	    }
	}

	// The "after body" insertion mode
	//------------------------------------------------------------------
	function startTagAfterBody(p, token) {
	    if (token.tagName === $.HTML) {
	        startTagInBody(p, token);
	    } else {
	        tokenAfterBody(p, token);
	    }
	}

	function endTagAfterBody(p, token) {
	    if (token.tagName === $.HTML) {
	        if (!p.fragmentContext) {
	            p.insertionMode = AFTER_AFTER_BODY_MODE;
	        }
	    } else {
	        tokenAfterBody(p, token);
	    }
	}

	function tokenAfterBody(p, token) {
	    p.insertionMode = IN_BODY_MODE;
	    p._processToken(token);
	}

	// The "in frameset" insertion mode
	//------------------------------------------------------------------
	function startTagInFrameset(p, token) {
	    const tn = token.tagName;

	    if (tn === $.HTML) {
	        startTagInBody(p, token);
	    } else if (tn === $.FRAMESET) {
	        p._insertElement(token, NS.HTML);
	    } else if (tn === $.FRAME) {
	        p._appendElement(token, NS.HTML);
	        token.ackSelfClosing = true;
	    } else if (tn === $.NOFRAMES) {
	        startTagInHead(p, token);
	    }
	}

	function endTagInFrameset(p, token) {
	    if (token.tagName === $.FRAMESET && !p.openElements.isRootHtmlElementCurrent()) {
	        p.openElements.pop();

	        if (!p.fragmentContext && p.openElements.currentTagName !== $.FRAMESET) {
	            p.insertionMode = AFTER_FRAMESET_MODE;
	        }
	    }
	}

	// The "after frameset" insertion mode
	//------------------------------------------------------------------
	function startTagAfterFrameset(p, token) {
	    const tn = token.tagName;

	    if (tn === $.HTML) {
	        startTagInBody(p, token);
	    } else if (tn === $.NOFRAMES) {
	        startTagInHead(p, token);
	    }
	}

	function endTagAfterFrameset(p, token) {
	    if (token.tagName === $.HTML) {
	        p.insertionMode = AFTER_AFTER_FRAMESET_MODE;
	    }
	}

	// The "after after body" insertion mode
	//------------------------------------------------------------------
	function startTagAfterAfterBody(p, token) {
	    if (token.tagName === $.HTML) {
	        startTagInBody(p, token);
	    } else {
	        tokenAfterAfterBody(p, token);
	    }
	}

	function tokenAfterAfterBody(p, token) {
	    p.insertionMode = IN_BODY_MODE;
	    p._processToken(token);
	}

	// The "after after frameset" insertion mode
	//------------------------------------------------------------------
	function startTagAfterAfterFrameset(p, token) {
	    const tn = token.tagName;

	    if (tn === $.HTML) {
	        startTagInBody(p, token);
	    } else if (tn === $.NOFRAMES) {
	        startTagInHead(p, token);
	    }
	}

	// The rules for parsing tokens in foreign content
	//------------------------------------------------------------------
	function nullCharacterInForeignContent(p, token) {
	    token.chars = unicode.REPLACEMENT_CHARACTER;
	    p._insertCharacters(token);
	}

	function characterInForeignContent(p, token) {
	    p._insertCharacters(token);
	    p.framesetOk = false;
	}

	function startTagInForeignContent(p, token) {
	    if (foreignContent.causesExit(token) && !p.fragmentContext) {
	        while (
	            p.treeAdapter.getNamespaceURI(p.openElements.current) !== NS.HTML &&
	            !p._isIntegrationPoint(p.openElements.current)
	        ) {
	            p.openElements.pop();
	        }

	        p._processToken(token);
	    } else {
	        const current = p._getAdjustedCurrentElement();
	        const currentNs = p.treeAdapter.getNamespaceURI(current);

	        if (currentNs === NS.MATHML) {
	            foreignContent.adjustTokenMathMLAttrs(token);
	        } else if (currentNs === NS.SVG) {
	            foreignContent.adjustTokenSVGTagName(token);
	            foreignContent.adjustTokenSVGAttrs(token);
	        }

	        foreignContent.adjustTokenXMLAttrs(token);

	        if (token.selfClosing) {
	            p._appendElement(token, currentNs);
	        } else {
	            p._insertElement(token, currentNs);
	        }

	        token.ackSelfClosing = true;
	    }
	}

	function endTagInForeignContent(p, token) {
	    for (let i = p.openElements.stackTop; i > 0; i--) {
	        const element = p.openElements.items[i];

	        if (p.treeAdapter.getNamespaceURI(element) === NS.HTML) {
	            p._processToken(token);
	            break;
	        }

	        if (p.treeAdapter.getTagName(element).toLowerCase() === token.tagName) {
	            p.openElements.popUntilElementPopped(element);
	            break;
	        }
	    }
	}
	return parser$1;
}

const abandonedHeadElementChild = {
	reason: "Unexpected metadata element after head",
	description: "Unexpected element after head. Expected the element before `</head>`",
	url: false
};
const abruptClosingOfEmptyComment = {
	reason: "Unexpected abruptly closed empty comment",
	description: "Unexpected `>` or `->`. Expected `-->` to close comments"
};
const abruptDoctypePublicIdentifier = {
	reason: "Unexpected abruptly closed public identifier",
	description: "Unexpected `>`. Expected a closing `\"` or `'` after the public identifier"
};
const abruptDoctypeSystemIdentifier = {
	reason: "Unexpected abruptly closed system identifier",
	description: "Unexpected `>`. Expected a closing `\"` or `'` after the identifier identifier"
};
const absenceOfDigitsInNumericCharacterReference = {
	reason: "Unexpected non-digit at start of numeric character reference",
	description: "Unexpected `%c`. Expected `[0-9]` for decimal references or `[0-9a-fA-F]` for hexadecimal references"
};
const cdataInHtmlContent = {
	reason: "Unexpected CDATA section in HTML",
	description: "Unexpected `<![CDATA[` in HTML. Remove it, use a comment, or encode special characters instead"
};
const characterReferenceOutsideUnicodeRange = {
	reason: "Unexpected too big numeric character reference",
	description: "Unexpectedly high character reference. Expected character references to be at most hexadecimal 10ffff (or decimal 1114111)"
};
const closingOfElementWithOpenChildElements = {
	reason: "Unexpected closing tag with open child elements",
	description: "Unexpectedly closing tag. Expected other tags to be closed first",
	url: false
};
const controlCharacterInInputStream = {
	reason: "Unexpected control character",
	description: "Unexpected control character `%x`. Expected a non-control code point, 0x00, or ASCII whitespace"
};
const controlCharacterReference = {
	reason: "Unexpected control character reference",
	description: "Unexpectedly control character in reference. Expected a non-control code point, 0x00, or ASCII whitespace"
};
const disallowedContentInNoscriptInHead = {
	reason: "Disallowed content inside `<noscript>` in `<head>`",
	description: "Unexpected text character `%c`. Only use text in `<noscript>`s in `<body>`",
	url: false
};
const duplicateAttribute = {
	reason: "Unexpected duplicate attribute",
	description: "Unexpectedly double attribute. Expected attributes to occur only once"
};
const endTagWithAttributes = {
	reason: "Unexpected attribute on closing tag",
	description: "Unexpected attribute. Expected `>` instead"
};
const endTagWithTrailingSolidus = {
	reason: "Unexpected slash at end of closing tag",
	description: "Unexpected `%c-1`. Expected `>` instead"
};
const endTagWithoutMatchingOpenElement = {
	reason: "Unexpected unopened end tag",
	description: "Unexpected end tag. Expected no end tag or another end tag",
	url: false
};
const eofBeforeTagName = {
	reason: "Unexpected end of file",
	description: "Unexpected end of file. Expected tag name instead"
};
const eofInCdata = {
	reason: "Unexpected end of file in CDATA",
	description: "Unexpected end of file. Expected `]]>` to close the CDATA"
};
const eofInComment = {
	reason: "Unexpected end of file in comment",
	description: "Unexpected end of file. Expected `-->` to close the comment"
};
const eofInDoctype = {
	reason: "Unexpected end of file in doctype",
	description: "Unexpected end of file. Expected a valid doctype (such as `<!doctype html>`)"
};
const eofInElementThatCanContainOnlyText = {
	reason: "Unexpected end of file in element that can only contain text",
	description: "Unexpected end of file. Expected text or a closing tag",
	url: false
};
const eofInScriptHtmlCommentLikeText = {
	reason: "Unexpected end of file in comment inside script",
	description: "Unexpected end of file. Expected `-->` to close the comment"
};
const eofInTag = {
	reason: "Unexpected end of file in tag",
	description: "Unexpected end of file. Expected `>` to close the tag"
};
const incorrectlyClosedComment = {
	reason: "Incorrectly closed comment",
	description: "Unexpected `%c-1`. Expected `-->` to close the comment"
};
const incorrectlyOpenedComment = {
	reason: "Incorrectly opened comment",
	description: "Unexpected `%c`. Expected `<!--` to open the comment"
};
const invalidCharacterSequenceAfterDoctypeName = {
	reason: "Invalid sequence after doctype name",
	description: "Unexpected sequence at `%c`. Expected `public` or `system`"
};
const invalidFirstCharacterOfTagName = {
	reason: "Invalid first character in tag name",
	description: "Unexpected `%c`. Expected an ASCII letter instead"
};
const misplacedDoctype = {
	reason: "Misplaced doctype",
	description: "Unexpected doctype. Expected doctype before head",
	url: false
};
const misplacedStartTagForHeadElement = {
	reason: "Misplaced `<head>` start tag",
	description: "Unexpected start tag `<head>`. Expected `<head>` directly after doctype",
	url: false
};
const missingAttributeValue = {
	reason: "Missing attribute value",
	description: "Unexpected `%c-1`. Expected an attribute value or no `%c-1` instead"
};
const missingDoctype = {
	reason: "Missing doctype before other content",
	description: "Expected a `<!doctype html>` before anything else",
	url: false
};
const missingDoctypeName = {
	reason: "Missing doctype name",
	description: "Unexpected doctype end at `%c`. Expected `html` instead"
};
const missingDoctypePublicIdentifier = {
	reason: "Missing public identifier in doctype",
	description: "Unexpected `%c`. Expected identifier for `public` instead"
};
const missingDoctypeSystemIdentifier = {
	reason: "Missing system identifier in doctype",
	description: "Unexpected `%c`. Expected identifier for `system` instead (suggested: `\"about:legacy-compat\"`)"
};
const missingEndTagName = {
	reason: "Missing name in end tag",
	description: "Unexpected `%c`. Expected an ASCII letter instead"
};
const missingQuoteBeforeDoctypePublicIdentifier = {
	reason: "Missing quote before public identifier in doctype",
	description: "Unexpected `%c`. Expected `\"` or `'` instead"
};
const missingQuoteBeforeDoctypeSystemIdentifier = {
	reason: "Missing quote before system identifier in doctype",
	description: "Unexpected `%c`. Expected `\"` or `'` instead"
};
const missingSemicolonAfterCharacterReference = {
	reason: "Missing semicolon after character reference",
	description: "Unexpected `%c`. Expected `;` instead"
};
const missingWhitespaceAfterDoctypePublicKeyword = {
	reason: "Missing whitespace after public identifier in doctype",
	description: "Unexpected `%c`. Expected ASCII whitespace instead"
};
const missingWhitespaceAfterDoctypeSystemKeyword = {
	reason: "Missing whitespace after system identifier in doctype",
	description: "Unexpected `%c`. Expected ASCII whitespace instead"
};
const missingWhitespaceBeforeDoctypeName = {
	reason: "Missing whitespace before doctype name",
	description: "Unexpected `%c`. Expected ASCII whitespace instead"
};
const missingWhitespaceBetweenAttributes = {
	reason: "Missing whitespace between attributes",
	description: "Unexpected `%c`. Expected ASCII whitespace instead"
};
const missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = {
	reason: "Missing whitespace between public and system identifiers in doctype",
	description: "Unexpected `%c`. Expected ASCII whitespace instead"
};
const nestedComment = {
	reason: "Unexpected nested comment",
	description: "Unexpected `<!--`. Expected `-->`"
};
const nestedNoscriptInHead = {
	reason: "Unexpected nested `<noscript>` in `<head>`",
	description: "Unexpected `<noscript>`. Expected a closing tag or a meta element",
	url: false
};
const nonConformingDoctype = {
	reason: "Unexpected non-conforming doctype declaration",
	description: "Expected `<!doctype html>` or `<!doctype html system \"about:legacy-compat\">`",
	url: false
};
const nonVoidHtmlElementStartTagWithTrailingSolidus = {
	reason: "Unexpected trailing slash on start tag of non-void element",
	description: "Unexpected `/`. Expected `>` instead"
};
const noncharacterCharacterReference = {
	reason: "Unexpected noncharacter code point referenced by character reference",
	description: "Unexpected code point. Do not use noncharacters in HTML"
};
const noncharacterInInputStream = {
	reason: "Unexpected noncharacter character",
	description: "Unexpected code point `%x`. Do not use noncharacters in HTML"
};
const nullCharacterReference = {
	reason: "Unexpected NULL character referenced by character reference",
	description: "Unexpected code point. Do not use NULL characters in HTML"
};
const openElementsLeftAfterEof = {
	reason: "Unexpected end of file",
	description: "Unexpected end of file. Expected closing tag instead",
	url: false
};
const surrogateCharacterReference = {
	reason: "Unexpected surrogate character referenced by character reference",
	description: "Unexpected code point. Do not use lone surrogate characters in HTML"
};
const surrogateInInputStream = {
	reason: "Unexpected surrogate character",
	description: "Unexpected code point `%x`. Do not use lone surrogate characters in HTML"
};
const unexpectedCharacterAfterDoctypeSystemIdentifier = {
	reason: "Invalid character after system identifier in doctype",
	description: "Unexpected character at `%c`. Expected `>`"
};
const unexpectedCharacterInAttributeName = {
	reason: "Unexpected character in attribute name",
	description: "Unexpected `%c`. Expected whitespace, `/`, `>`, `=`, or probably an ASCII letter"
};
const unexpectedCharacterInUnquotedAttributeValue = {
	reason: "Unexpected character in unquoted attribute value",
	description: "Unexpected `%c`. Quote the attribute value to include it"
};
const unexpectedEqualsSignBeforeAttributeName = {
	reason: "Unexpected equals sign before attribute name ",
	description: "Unexpected `%c`. Add an attribute name before it"
};
const unexpectedNullCharacter = {
	reason: "Unexpected NULL character",
	description: "Unexpected code point `%x`. Do not use NULL characters in HTML"
};
const unexpectedQuestionMarkInsteadOfTagName = {
	reason: "Unexpected question mark instead of tag name",
	description: "Unexpected `%c`. Expected an ASCII letter instead"
};
const unexpectedSolidusInTag = {
	reason: "Unexpected slash in tag",
	description: "Unexpected `%c-1`. Expected it followed by `>` or in a quoted attribute value"
};
const unknownNamedCharacterReference = {
	reason: "Unexpected unknown named character reference",
	description: "Unexpected character reference. Expected known named character references"
};
var require$$3$1 = {
	abandonedHeadElementChild: abandonedHeadElementChild,
	abruptClosingOfEmptyComment: abruptClosingOfEmptyComment,
	abruptDoctypePublicIdentifier: abruptDoctypePublicIdentifier,
	abruptDoctypeSystemIdentifier: abruptDoctypeSystemIdentifier,
	absenceOfDigitsInNumericCharacterReference: absenceOfDigitsInNumericCharacterReference,
	cdataInHtmlContent: cdataInHtmlContent,
	characterReferenceOutsideUnicodeRange: characterReferenceOutsideUnicodeRange,
	closingOfElementWithOpenChildElements: closingOfElementWithOpenChildElements,
	controlCharacterInInputStream: controlCharacterInInputStream,
	controlCharacterReference: controlCharacterReference,
	disallowedContentInNoscriptInHead: disallowedContentInNoscriptInHead,
	duplicateAttribute: duplicateAttribute,
	endTagWithAttributes: endTagWithAttributes,
	endTagWithTrailingSolidus: endTagWithTrailingSolidus,
	endTagWithoutMatchingOpenElement: endTagWithoutMatchingOpenElement,
	eofBeforeTagName: eofBeforeTagName,
	eofInCdata: eofInCdata,
	eofInComment: eofInComment,
	eofInDoctype: eofInDoctype,
	eofInElementThatCanContainOnlyText: eofInElementThatCanContainOnlyText,
	eofInScriptHtmlCommentLikeText: eofInScriptHtmlCommentLikeText,
	eofInTag: eofInTag,
	incorrectlyClosedComment: incorrectlyClosedComment,
	incorrectlyOpenedComment: incorrectlyOpenedComment,
	invalidCharacterSequenceAfterDoctypeName: invalidCharacterSequenceAfterDoctypeName,
	invalidFirstCharacterOfTagName: invalidFirstCharacterOfTagName,
	misplacedDoctype: misplacedDoctype,
	misplacedStartTagForHeadElement: misplacedStartTagForHeadElement,
	missingAttributeValue: missingAttributeValue,
	missingDoctype: missingDoctype,
	missingDoctypeName: missingDoctypeName,
	missingDoctypePublicIdentifier: missingDoctypePublicIdentifier,
	missingDoctypeSystemIdentifier: missingDoctypeSystemIdentifier,
	missingEndTagName: missingEndTagName,
	missingQuoteBeforeDoctypePublicIdentifier: missingQuoteBeforeDoctypePublicIdentifier,
	missingQuoteBeforeDoctypeSystemIdentifier: missingQuoteBeforeDoctypeSystemIdentifier,
	missingSemicolonAfterCharacterReference: missingSemicolonAfterCharacterReference,
	missingWhitespaceAfterDoctypePublicKeyword: missingWhitespaceAfterDoctypePublicKeyword,
	missingWhitespaceAfterDoctypeSystemKeyword: missingWhitespaceAfterDoctypeSystemKeyword,
	missingWhitespaceBeforeDoctypeName: missingWhitespaceBeforeDoctypeName,
	missingWhitespaceBetweenAttributes: missingWhitespaceBetweenAttributes,
	missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers: missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers,
	nestedComment: nestedComment,
	nestedNoscriptInHead: nestedNoscriptInHead,
	nonConformingDoctype: nonConformingDoctype,
	nonVoidHtmlElementStartTagWithTrailingSolidus: nonVoidHtmlElementStartTagWithTrailingSolidus,
	noncharacterCharacterReference: noncharacterCharacterReference,
	noncharacterInInputStream: noncharacterInInputStream,
	nullCharacterReference: nullCharacterReference,
	openElementsLeftAfterEof: openElementsLeftAfterEof,
	surrogateCharacterReference: surrogateCharacterReference,
	surrogateInInputStream: surrogateInInputStream,
	unexpectedCharacterAfterDoctypeSystemIdentifier: unexpectedCharacterAfterDoctypeSystemIdentifier,
	unexpectedCharacterInAttributeName: unexpectedCharacterInAttributeName,
	unexpectedCharacterInUnquotedAttributeValue: unexpectedCharacterInUnquotedAttributeValue,
	unexpectedEqualsSignBeforeAttributeName: unexpectedEqualsSignBeforeAttributeName,
	unexpectedNullCharacter: unexpectedNullCharacter,
	unexpectedQuestionMarkInsteadOfTagName: unexpectedQuestionMarkInsteadOfTagName,
	unexpectedSolidusInTag: unexpectedSolidusInTag,
	unknownNamedCharacterReference: unknownNamedCharacterReference
};

var rehypeParse;
var hasRequiredRehypeParse;

function requireRehypeParse () {
	if (hasRequiredRehypeParse) return rehypeParse;
	hasRequiredRehypeParse = 1;

	var fromParse5 = requireHastUtilFromParse5();
	var Parser5 = requireParser$1();
	var xtend = requireImmutable();
	var errors = require$$3$1;

	var base = 'https://html.spec.whatwg.org/multipage/parsing.html#parse-error-';

	var fatalities = {2: true, 1: false, 0: null};

	rehypeParse = parse;

	function parse(options) {
	  var settings = xtend(options, this.data('settings'));
	  var position = settings.position;

	  position = typeof position === 'boolean' ? position : true;

	  this.Parser = parser;

	  function parser(doc, file) {
	    var fn = settings.fragment ? 'parseFragment' : 'parse';
	    var onParseError = settings.emitParseErrors ? onerror : null;
	    var parse5 = new Parser5({
	      sourceCodeLocationInfo: position,
	      onParseError: onParseError,
	      scriptingEnabled: false
	    });

	    return fromParse5(parse5[fn](doc), {
	      space: settings.space,
	      file: file,
	      verbose: settings.verbose
	    })

	    function onerror(err) {
	      var code = err.code;
	      var name = camelcase(code);
	      var setting = settings[name];
	      var config = setting === undefined || setting === null ? true : setting;
	      var level = typeof config === 'number' ? config : config ? 1 : 0;
	      var start = {
	        line: err.startLine,
	        column: err.startCol,
	        offset: err.startOffset
	      };
	      var end = {line: err.endLine, column: err.endCol, offset: err.endOffset};
	      var info;
	      var message;

	      if (level) {
	        info = errors[name] || /* istanbul ignore next */ {
	          reason: '',
	          description: ''
	        };

	        message = file.message(format(info.reason), {start: start, end: end});
	        message.source = 'parse-error';
	        message.ruleId = code;
	        message.fatal = fatalities[level];
	        message.note = format(info.description);
	        message.url = info.url === false ? null : base + code;
	      }

	      function format(value) {
	        return value.replace(/%c(?:-(\d+))?/g, char).replace(/%x/g, encodedChar)
	      }

	      function char($0, $1) {
	        var offset = $1 ? -parseInt($1, 10) : 0;
	        var char = doc.charAt(err.startOffset + offset);
	        return char === '`' ? '` ` `' : char
	      }

	      function encodedChar() {
	        var char = doc
	          .charCodeAt(err.startOffset)
	          .toString(16)
	          .toUpperCase();

	        return '0x' + char
	      }
	    }
	  }
	}

	function camelcase(value) {
	  return value.replace(/-[a-z]/g, replacer)
	}

	function replacer($0) {
	  return $0.charAt(1).toUpperCase()
	}
	return rehypeParse;
}

var lib$2;
var hasRequiredLib$2;

function requireLib$2 () {
	if (hasRequiredLib$2) return lib$2;
	hasRequiredLib$2 = 1;
	// handles different types of whitespace
	const unified = requireUnified();
	const html = requireRehypeParse();
	const visit = requireUnistUtilVisit();

	const NEWLINE = "\n";

	// natively supported types
	const types = {
	  // aliases for infima color names
	  secondary: "note",
	  info: "important",
	  success: "tip",
	  danger: "warning",
	  // base types
	  note: {
	    ifmClass: "secondary",
	    keyword: "note",
	    emoji: "ℹ️", // '&#x2139;'
	    svg:
	      '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"/></svg>'
	  },
	  tip: {
	    ifmClass: "success",
	    keyword: "tip",
	    emoji: "💡", //'&#x1F4A1;'
	    svg:
	      '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"/></svg>'
	  },
	  warning: {
	    ifmClass: "danger",
	    keyword: "warning",
	    emoji: "🔥", //'&#x1F525;'
	    svg:
	      '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"/></svg>'
	  },
	  important: {
	    ifmClass: "info",
	    keyword: "important",
	    emoji: "❗️", //'&#x2757;'
	    svg:
	      '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"/></svg>'
	  },
	  caution: {
	    ifmClass: "warning",
	    keyword: "caution",
	    emoji: "⚠️", // '&#x26A0;&#xFE0F;'
	    svg:
	      '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"/></svg>'
	  }
	};

	// default options for plugin
	const defaultOptions = {
	  customTypes: [],
	  useDefaultTypes: true,
	  infima: true,
	  tag: ":::",
	  icons: "svg"
	};

	// override default options
	const configure = options => {
	  const { customTypes, ...baseOptions } = {
	    ...defaultOptions,
	    ...options
	  };

	  return {
	    ...baseOptions,
	    types: { ...types, ...customTypes }
	  };
	};

	// escape regex special characters
	function escapeRegExp(s) {
	  return s.replace(new RegExp(`[-[\\]{}()*+?.\\\\^$|/]`, "g"), "\\$&");
	}

	// helper: recursively replace nodes
	const _nodes = ({
	  tagName: hName,
	  properties: hProperties,
	  position,
	  children
	}) => {
	  return {
	    type: "admonitionHTML",
	    data: {
	      hName,
	      hProperties
	    },
	    position,
	    children: children.map(_nodes)
	  };
	};

	// convert HTML to MDAST (must be a single root element)
	const nodes = markup => {
	  return _nodes(
	    unified()
	      .use(html)
	      .parse(markup).children[0].children[1].children[0]
	  );
	};

	// create a simple text node
	const text = value => {
	  return {
	    type: "text",
	    value
	  };
	};

	// create a node that will compile to HTML
	const element = (tagName, classes = [], children = []) => {
	  return {
	    type: "admonitionHTML",
	    data: {
	      hName: tagName,
	      hProperties: classes.length
	        ? {
	            className: classes
	          }
	        : {}
	    },
	    children
	  };
	};

	// passed to unified.use()
	// you have to use a named function for access to `this` :(
	lib$2 = function attacher(options) {
	  const config = configure(options);

	  // match to determine if the line is an opening tag
	  const keywords = Object.keys(config.types)
	    .map(escapeRegExp)
	    .join("|");
	  const tag = escapeRegExp(config.tag);
	  const regex = new RegExp(`${tag}(${keywords})(?: *(.*))?\n`);
	  const escapeTag = new RegExp(escapeRegExp(`\\${config.tag}`), "g");

	  // the tokenizer is called on blocks to determine if there is an admonition present and create tags for it
	  function blockTokenizer(eat, value, silent) {
	    // stop if no match or match does not start at beginning of line
	    const match = regex.exec(value);
	    if (!match || match.index !== 0) return false;
	    // if silent return the match
	    if (silent) return true;

	    const now = eat.now();
	    const [opening, keyword, title] = match;
	    const food = [];
	    const content = [];

	    // consume lines until a closing tag
	    let idx = 0;
	    while ((idx = value.indexOf(NEWLINE)) !== -1) {
	      // grab this line and eat it
	      const next = value.indexOf(NEWLINE, idx + 1);
	      const line =
	        next !== -1 ? value.slice(idx + 1, next) : value.slice(idx + 1);
	      food.push(line);
	      value = value.slice(idx + 1);
	      // the closing tag is NOT part of the content
	      if (line.startsWith(config.tag)) break;
	      content.push(line);
	    }

	    // consume the processed tag and replace escape sequences
	    const contentString = content.join(NEWLINE).replace(escapeTag, config.tag);
	    const add = eat(opening + food.join(NEWLINE));

	    // parse the content in block mode
	    const exit = this.enterBlock();
	    const contentNodes = element(
	      "div",
	      "admonition-content",
	      this.tokenizeBlock(contentString, now)
	    );
	    exit();
	    // parse the title in inline mode
	    const titleNodes = this.tokenizeInline(title || keyword, now);
	    // create the nodes for the icon
	    const entry = config.types[keyword];
	    const settings = typeof entry === "string" ? config.types[entry] : entry;
	    const iconNodes =
	      config.icons === "svg" ? nodes(settings.svg) : text(settings.emoji);
	    const iconContainerNodes =
	      config.icons === "none"
	        ? []
	        : [element("span", "admonition-icon", [iconNodes])];

	    // build the nodes for the full markup
	    const admonition = element(
	      "div",
	      ["admonition", `admonition-${keyword}`].concat(
	        settings.ifmClass ? ["alert", `alert--${settings.ifmClass}`] : []
	      ),
	      [
	        element("div", "admonition-heading", [
	          element("h5", "", iconContainerNodes.concat(titleNodes))
	        ]),
	        contentNodes
	      ]
	    );

	    return add(admonition);
	  }

	  // add tokenizer to parser after fenced code blocks
	  const Parser = this.Parser.prototype;
	  Parser.blockTokenizers.admonition = blockTokenizer;
	  Parser.blockMethods.splice(
	    Parser.blockMethods.indexOf("fencedCode") + 1,
	    0,
	    "admonition"
	  );
	  Parser.interruptParagraph.splice(
	    Parser.interruptParagraph.indexOf("fencedCode") + 1,
	    0,
	    ["admonition"]
	  );
	  Parser.interruptList.splice(
	    Parser.interruptList.indexOf("fencedCode") + 1,
	    0,
	    ["admonition"]
	  );
	  Parser.interruptBlockquote.splice(
	    Parser.interruptBlockquote.indexOf("fencedCode") + 1,
	    0,
	    ["admonition"]
	  );

	  // TODO: add compiler rules for converting back to markdown

	  return function transformer(tree) {
	    // escape everything except admonitionHTML nodes
	    visit(
	      tree,
	      node => {
	        return node.type !== "admonitionHTML";
	      },
	      function visitor(node) {
	        if (node.value) node.value = node.value.replace(escapeTag, config.tag);
	        return node;
	      }
	    );
	  };
	};
	return lib$2;
}

var libExports = requireLib$2();
var admonitions = /*@__PURE__*/getDefaultExportFromCjs(libExports);

var unistBuilder;
var hasRequiredUnistBuilder;

function requireUnistBuilder () {
	if (hasRequiredUnistBuilder) return unistBuilder;
	hasRequiredUnistBuilder = 1;

	unistBuilder = u;

	function u(type, props, value) {
	  var node;

	  if (
	    (value === null || value === undefined) &&
	    (typeof props !== 'object' || Array.isArray(props))
	  ) {
	    value = props;
	    props = {};
	  }

	  node = Object.assign({type: String(type)}, props);

	  if (Array.isArray(value)) {
	    node.children = value;
	  } else if (value !== null && value !== undefined) {
	    node.value = String(value);
	  }

	  return node
	}
	return unistBuilder;
}

var unistUtilPosition;
var hasRequiredUnistUtilPosition;

function requireUnistUtilPosition () {
	if (hasRequiredUnistUtilPosition) return unistUtilPosition;
	hasRequiredUnistUtilPosition = 1;

	var start = factory('start');
	var end = factory('end');

	unistUtilPosition = position;

	position.start = start;
	position.end = end;

	function position(node) {
	  return {start: start(node), end: end(node)}
	}

	function factory(type) {
	  point.displayName = type;

	  return point

	  function point(node) {
	    var point = (node && node.position && node.position[type]) || {};

	    return {
	      line: point.line || null,
	      column: point.column || null,
	      offset: isNaN(point.offset) ? null : point.offset
	    }
	  }
	}
	return unistUtilPosition;
}

var unistUtilGenerated;
var hasRequiredUnistUtilGenerated;

function requireUnistUtilGenerated () {
	if (hasRequiredUnistUtilGenerated) return unistUtilGenerated;
	hasRequiredUnistUtilGenerated = 1;

	unistUtilGenerated = generated;

	function generated(node) {
	  var position = optional(optional(node).position);
	  var start = optional(position.start);
	  var end = optional(position.end);

	  return !start.line || !start.column || !end.line || !end.column
	}

	function optional(value) {
	  return value && typeof value === 'object' ? value : {}
	}
	return unistUtilGenerated;
}

var mdastUtilDefinitions;
var hasRequiredMdastUtilDefinitions;

function requireMdastUtilDefinitions () {
	if (hasRequiredMdastUtilDefinitions) return mdastUtilDefinitions;
	hasRequiredMdastUtilDefinitions = 1;

	var visit = requireUnistUtilVisit();

	mdastUtilDefinitions = getDefinitionFactory;

	var own = {}.hasOwnProperty;

	// Get a definition in `node` by `identifier`.
	function getDefinitionFactory(node, options) {
	  return getterFactory(gather(node, options))
	}

	// Gather all definitions in `node`
	function gather(node, options) {
	  var cache = {};

	  if (!node || !node.type) {
	    throw new Error('mdast-util-definitions expected node')
	  }

	  visit(node, 'definition', options && options.commonmark ? commonmark : normal);

	  return cache

	  function commonmark(definition) {
	    var id = normalise(definition.identifier);
	    if (!own.call(cache, id)) {
	      cache[id] = definition;
	    }
	  }

	  function normal(definition) {
	    cache[normalise(definition.identifier)] = definition;
	  }
	}

	// Factory to get a node from the given definition-cache.
	function getterFactory(cache) {
	  return getter

	  // Get a node from the bound definition-cache.
	  function getter(identifier) {
	    var id = identifier && normalise(identifier);
	    return id && own.call(cache, id) ? cache[id] : null
	  }
	}

	function normalise(identifier) {
	  return identifier.toUpperCase()
	}
	return mdastUtilDefinitions;
}

var all_1$1;
var hasRequiredAll$1;

function requireAll$1 () {
	if (hasRequiredAll$1) return all_1$1;
	hasRequiredAll$1 = 1;

	all_1$1 = all;

	var one = requireOne$1();

	function all(h, parent) {
	  var nodes = parent.children || [];
	  var length = nodes.length;
	  var values = [];
	  var index = -1;
	  var result;
	  var head;

	  while (++index < length) {
	    result = one(h, nodes[index], parent);

	    if (result) {
	      if (index && nodes[index - 1].type === 'break') {
	        if (result.value) {
	          result.value = result.value.replace(/^\s+/, '');
	        }

	        head = result.children && result.children[0];

	        if (head && head.value) {
	          head.value = head.value.replace(/^\s+/, '');
	        }
	      }

	      values = values.concat(result);
	    }
	  }

	  return values
	}
	return all_1$1;
}

var one_1;
var hasRequiredOne$1;

function requireOne$1 () {
	if (hasRequiredOne$1) return one_1;
	hasRequiredOne$1 = 1;

	one_1 = one;

	var u = requireUnistBuilder();
	var all = requireAll$1();

	var own = {}.hasOwnProperty;

	// Transform an unknown node.
	function unknown(h, node) {
	  if (text(node)) {
	    return h.augment(node, u('text', node.value))
	  }

	  return h(node, 'div', all(h, node))
	}

	// Visit a node.
	function one(h, node, parent) {
	  var type = node && node.type;
	  var fn = own.call(h.handlers, type) ? h.handlers[type] : h.unknownHandler;

	  // Fail on non-nodes.
	  if (!type) {
	    throw new Error('Expected node, got `' + node + '`')
	  }

	  return (typeof fn === 'function' ? fn : unknown)(h, node, parent)
	}

	// Check if the node should be renderered as a text node.
	function text(node) {
	  var data = node.data || {};

	  if (
	    own.call(data, 'hName') ||
	    own.call(data, 'hProperties') ||
	    own.call(data, 'hChildren')
	  ) {
	    return false
	  }

	  return 'value' in node
	}
	return one_1;
}

var thematicBreak_1;
var hasRequiredThematicBreak;

function requireThematicBreak () {
	if (hasRequiredThematicBreak) return thematicBreak_1;
	hasRequiredThematicBreak = 1;

	thematicBreak_1 = thematicBreak;

	function thematicBreak(h, node) {
	  return h(node, 'hr')
	}
	return thematicBreak_1;
}

var wrap_1;
var hasRequiredWrap;

function requireWrap () {
	if (hasRequiredWrap) return wrap_1;
	hasRequiredWrap = 1;

	wrap_1 = wrap;

	var u = requireUnistBuilder();

	// Wrap `nodes` with line feeds between each entry.
	// Optionally adds line feeds at the start and end.
	function wrap(nodes, loose) {
	  var result = [];
	  var index = -1;
	  var length = nodes.length;

	  if (loose) {
	    result.push(u('text', '\n'));
	  }

	  while (++index < length) {
	    if (index) {
	      result.push(u('text', '\n'));
	    }

	    result.push(nodes[index]);
	  }

	  if (loose && nodes.length !== 0) {
	    result.push(u('text', '\n'));
	  }

	  return result
	}
	return wrap_1;
}

var list_1;
var hasRequiredList;

function requireList () {
	if (hasRequiredList) return list_1;
	hasRequiredList = 1;

	list_1 = list;

	var wrap = requireWrap();
	var all = requireAll$1();

	function list(h, node) {
	  var props = {};
	  var name = node.ordered ? 'ol' : 'ul';
	  var items;
	  var index = -1;
	  var length;

	  if (typeof node.start === 'number' && node.start !== 1) {
	    props.start = node.start;
	  }

	  items = all(h, node);
	  length = items.length;

	  // Like GitHub, add a class for custom styling.
	  while (++index < length) {
	    if (
	      items[index].properties.className &&
	      items[index].properties.className.indexOf('task-list-item') !== -1
	    ) {
	      props.className = ['contains-task-list'];
	      break
	    }
	  }

	  return h(node, name, props, wrap(items, true))
	}
	return list_1;
}

var footer;
var hasRequiredFooter;

function requireFooter () {
	if (hasRequiredFooter) return footer;
	hasRequiredFooter = 1;

	footer = generateFootnotes;

	var thematicBreak = requireThematicBreak();
	var list = requireList();
	var wrap = requireWrap();

	function generateFootnotes(h) {
	  var footnoteById = h.footnoteById;
	  var footnoteOrder = h.footnoteOrder;
	  var length = footnoteOrder.length;
	  var index = -1;
	  var listItems = [];
	  var def;
	  var backReference;
	  var content;
	  var tail;

	  while (++index < length) {
	    def = footnoteById[footnoteOrder[index].toUpperCase()];

	    if (!def) {
	      continue
	    }

	    content = def.children.concat();
	    tail = content[content.length - 1];
	    backReference = {
	      type: 'link',
	      url: '#fnref-' + def.identifier,
	      data: {hProperties: {className: ['footnote-backref']}},
	      children: [{type: 'text', value: '↩'}]
	    };

	    if (!tail || tail.type !== 'paragraph') {
	      tail = {type: 'paragraph', children: []};
	      content.push(tail);
	    }

	    tail.children.push(backReference);

	    listItems.push({
	      type: 'listItem',
	      data: {hProperties: {id: 'fn-' + def.identifier}},
	      children: content,
	      position: def.position
	    });
	  }

	  if (listItems.length === 0) {
	    return null
	  }

	  return h(
	    null,
	    'div',
	    {className: ['footnotes']},
	    wrap(
	      [
	        thematicBreak(h),
	        list(h, {type: 'list', ordered: true, children: listItems})
	      ],
	      true
	    )
	  )
	}
	return footer;
}

var blockquote_1;
var hasRequiredBlockquote;

function requireBlockquote () {
	if (hasRequiredBlockquote) return blockquote_1;
	hasRequiredBlockquote = 1;

	blockquote_1 = blockquote;

	var wrap = requireWrap();
	var all = requireAll$1();

	function blockquote(h, node) {
	  return h(node, 'blockquote', wrap(all(h, node), true))
	}
	return blockquote_1;
}

var _break;
var hasRequired_break;

function require_break () {
	if (hasRequired_break) return _break;
	hasRequired_break = 1;

	_break = hardBreak;

	var u = requireUnistBuilder();

	function hardBreak(h, node) {
	  return [h(node, 'br'), u('text', '\n')]
	}
	return _break;
}

var detab_1;
var hasRequiredDetab;

function requireDetab () {
	if (hasRequiredDetab) return detab_1;
	hasRequiredDetab = 1;

	detab_1 = detab;

	var repeat = requireRepeatString();

	var tab = 0x09;
	var lineFeed = 0x0a;
	var carriageReturn = 0x0d;

	// Replace tabs with spaces, being smart about which column the tab is at and
	// which size should be used.
	function detab(value, size) {
	  var string = typeof value === 'string';
	  var length = string && value.length;
	  var start = 0;
	  var index = -1;
	  var column = -1;
	  var tabSize = size || 4;
	  var results = [];
	  var code;
	  var add;

	  if (!string) {
	    throw new Error('detab expected string')
	  }

	  while (++index < length) {
	    code = value.charCodeAt(index);

	    if (code === tab) {
	      add = tabSize - ((column + 1) % tabSize);
	      column += add;
	      results.push(value.slice(start, index) + repeat(' ', add));
	      start = index + 1;
	    } else if (code === lineFeed || code === carriageReturn) {
	      column = -1;
	    } else {
	      column++;
	    }
	  }

	  results.push(value.slice(start));

	  return results.join('')
	}
	return detab_1;
}

var code_1;
var hasRequiredCode;

function requireCode () {
	if (hasRequiredCode) return code_1;
	hasRequiredCode = 1;

	code_1 = code;

	var detab = requireDetab();
	var u = requireUnistBuilder();

	function code(h, node) {
	  var value = node.value ? detab(node.value + '\n') : '';
	  var lang = node.lang && node.lang.match(/^[^ \t]+(?=[ \t]|$)/);
	  var props = {};

	  if (lang) {
	    props.className = ['language-' + lang];
	  }

	  return h(node.position, 'pre', [h(node, 'code', props, [u('text', value)])])
	}
	return code_1;
}

var _delete;
var hasRequired_delete;

function require_delete () {
	if (hasRequired_delete) return _delete;
	hasRequired_delete = 1;

	_delete = strikethrough;

	var all = requireAll$1();

	function strikethrough(h, node) {
	  return h(node, 'del', all(h, node))
	}
	return _delete;
}

var emphasis_1;
var hasRequiredEmphasis;

function requireEmphasis () {
	if (hasRequiredEmphasis) return emphasis_1;
	hasRequiredEmphasis = 1;

	emphasis_1 = emphasis;

	var all = requireAll$1();

	function emphasis(h, node) {
	  return h(node, 'em', all(h, node))
	}
	return emphasis_1;
}

var footnoteReference_1;
var hasRequiredFootnoteReference;

function requireFootnoteReference () {
	if (hasRequiredFootnoteReference) return footnoteReference_1;
	hasRequiredFootnoteReference = 1;

	footnoteReference_1 = footnoteReference;

	var u = requireUnistBuilder();

	function footnoteReference(h, node) {
	  var footnoteOrder = h.footnoteOrder;
	  var identifier = String(node.identifier);

	  if (footnoteOrder.indexOf(identifier) === -1) {
	    footnoteOrder.push(identifier);
	  }

	  return h(node.position, 'sup', {id: 'fnref-' + identifier}, [
	    h(node, 'a', {href: '#fn-' + identifier, className: ['footnote-ref']}, [
	      u('text', node.label || identifier)
	    ])
	  ])
	}
	return footnoteReference_1;
}

var footnote_1;
var hasRequiredFootnote;

function requireFootnote () {
	if (hasRequiredFootnote) return footnote_1;
	hasRequiredFootnote = 1;

	footnote_1 = footnote;

	var footnoteReference = requireFootnoteReference();

	function footnote(h, node) {
	  var footnoteById = h.footnoteById;
	  var footnoteOrder = h.footnoteOrder;
	  var identifier = 1;

	  while (identifier in footnoteById) {
	    identifier++;
	  }

	  identifier = String(identifier);

	  // No need to check if `identifier` exists in `footnoteOrder`, it’s guaranteed
	  // to not exist because we just generated it.
	  footnoteOrder.push(identifier);

	  footnoteById[identifier] = {
	    type: 'footnoteDefinition',
	    identifier: identifier,
	    children: [{type: 'paragraph', children: node.children}],
	    position: node.position
	  };

	  return footnoteReference(h, {
	    type: 'footnoteReference',
	    identifier: identifier,
	    position: node.position
	  })
	}
	return footnote_1;
}

var heading_1;
var hasRequiredHeading;

function requireHeading () {
	if (hasRequiredHeading) return heading_1;
	hasRequiredHeading = 1;

	heading_1 = heading;

	var all = requireAll$1();

	function heading(h, node) {
	  return h(node, 'h' + node.depth, all(h, node))
	}
	return heading_1;
}

var html_1;
var hasRequiredHtml$1;

function requireHtml$1 () {
	if (hasRequiredHtml$1) return html_1;
	hasRequiredHtml$1 = 1;

	html_1 = html;

	var u = requireUnistBuilder();

	// Return either a `raw` node in dangerous mode, otherwise nothing.
	function html(h, node) {
	  return h.dangerous ? h.augment(node, u('raw', node.value)) : null
	}
	return html_1;
}

var encode_1;
var hasRequiredEncode;

function requireEncode () {
	if (hasRequiredEncode) return encode_1;
	hasRequiredEncode = 1;


	var encodeCache = {};


	// Create a lookup array where anything but characters in `chars` string
	// and alphanumeric chars is percent-encoded.
	//
	function getEncodeCache(exclude) {
	  var i, ch, cache = encodeCache[exclude];
	  if (cache) { return cache; }

	  cache = encodeCache[exclude] = [];

	  for (i = 0; i < 128; i++) {
	    ch = String.fromCharCode(i);

	    if (/^[0-9a-z]$/i.test(ch)) {
	      // always allow unencoded alphanumeric characters
	      cache.push(ch);
	    } else {
	      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
	    }
	  }

	  for (i = 0; i < exclude.length; i++) {
	    cache[exclude.charCodeAt(i)] = exclude[i];
	  }

	  return cache;
	}


	// Encode unsafe characters with percent-encoding, skipping already
	// encoded sequences.
	//
	//  - string       - string to encode
	//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
	//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
	//
	function encode(string, exclude, keepEscaped) {
	  var i, l, code, nextCode, cache,
	      result = '';

	  if (typeof exclude !== 'string') {
	    // encode(string, keepEscaped)
	    keepEscaped  = exclude;
	    exclude = encode.defaultChars;
	  }

	  if (typeof keepEscaped === 'undefined') {
	    keepEscaped = true;
	  }

	  cache = getEncodeCache(exclude);

	  for (i = 0, l = string.length; i < l; i++) {
	    code = string.charCodeAt(i);

	    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
	      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
	        result += string.slice(i, i + 3);
	        i += 2;
	        continue;
	      }
	    }

	    if (code < 128) {
	      result += cache[code];
	      continue;
	    }

	    if (code >= 0xD800 && code <= 0xDFFF) {
	      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
	        nextCode = string.charCodeAt(i + 1);
	        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
	          result += encodeURIComponent(string[i] + string[i + 1]);
	          i++;
	          continue;
	        }
	      }
	      result += '%EF%BF%BD';
	      continue;
	    }

	    result += encodeURIComponent(string[i]);
	  }

	  return result;
	}

	encode.defaultChars   = ";/?:@&=+$,-_.!~*'()#";
	encode.componentChars = "-_.!~*'()";


	encode_1 = encode;
	return encode_1;
}

var revert_1;
var hasRequiredRevert;

function requireRevert () {
	if (hasRequiredRevert) return revert_1;
	hasRequiredRevert = 1;

	revert_1 = revert;

	var u = requireUnistBuilder();
	var all = requireAll$1();

	// Return the content of a reference without definition as Markdown.
	function revert(h, node) {
	  var subtype = node.referenceType;
	  var suffix = ']';
	  var contents;
	  var head;
	  var tail;

	  if (subtype === 'collapsed') {
	    suffix += '[]';
	  } else if (subtype === 'full') {
	    suffix += '[' + (node.label || node.identifier) + ']';
	  }

	  if (node.type === 'imageReference') {
	    return u('text', '![' + node.alt + suffix)
	  }

	  contents = all(h, node);
	  head = contents[0];

	  if (head && head.type === 'text') {
	    head.value = '[' + head.value;
	  } else {
	    contents.unshift(u('text', '['));
	  }

	  tail = contents[contents.length - 1];

	  if (tail && tail.type === 'text') {
	    tail.value += suffix;
	  } else {
	    contents.push(u('text', suffix));
	  }

	  return contents
	}
	return revert_1;
}

var imageReference_1;
var hasRequiredImageReference;

function requireImageReference () {
	if (hasRequiredImageReference) return imageReference_1;
	hasRequiredImageReference = 1;

	imageReference_1 = imageReference;

	var normalize = requireEncode();
	var revert = requireRevert();

	function imageReference(h, node) {
	  var def = h.definition(node.identifier);
	  var props;

	  if (!def) {
	    return revert(h, node)
	  }

	  props = {src: normalize(def.url || ''), alt: node.alt};

	  if (def.title !== null && def.title !== undefined) {
	    props.title = def.title;
	  }

	  return h(node, 'img', props)
	}
	return imageReference_1;
}

var image_1;
var hasRequiredImage;

function requireImage () {
	if (hasRequiredImage) return image_1;
	hasRequiredImage = 1;

	var normalize = requireEncode();

	image_1 = image;

	function image(h, node) {
	  var props = {src: normalize(node.url), alt: node.alt};

	  if (node.title !== null && node.title !== undefined) {
	    props.title = node.title;
	  }

	  return h(node, 'img', props)
	}
	return image_1;
}

var inlineCode_1;
var hasRequiredInlineCode;

function requireInlineCode () {
	if (hasRequiredInlineCode) return inlineCode_1;
	hasRequiredInlineCode = 1;

	inlineCode_1 = inlineCode;

	var collapse = requireCollapseWhiteSpace();
	var u = requireUnistBuilder();

	function inlineCode(h, node) {
	  return h(node, 'code', [u('text', collapse(node.value))])
	}
	return inlineCode_1;
}

var linkReference_1;
var hasRequiredLinkReference;

function requireLinkReference () {
	if (hasRequiredLinkReference) return linkReference_1;
	hasRequiredLinkReference = 1;

	linkReference_1 = linkReference;

	var normalize = requireEncode();
	var revert = requireRevert();
	var all = requireAll$1();

	function linkReference(h, node) {
	  var def = h.definition(node.identifier);
	  var props;

	  if (!def) {
	    return revert(h, node)
	  }

	  props = {href: normalize(def.url || '')};

	  if (def.title !== null && def.title !== undefined) {
	    props.title = def.title;
	  }

	  return h(node, 'a', props, all(h, node))
	}
	return linkReference_1;
}

var link_1;
var hasRequiredLink;

function requireLink () {
	if (hasRequiredLink) return link_1;
	hasRequiredLink = 1;

	var normalize = requireEncode();
	var all = requireAll$1();

	link_1 = link;

	function link(h, node) {
	  var props = {href: normalize(node.url)};

	  if (node.title !== null && node.title !== undefined) {
	    props.title = node.title;
	  }

	  return h(node, 'a', props, all(h, node))
	}
	return link_1;
}

var listItem_1;
var hasRequiredListItem;

function requireListItem () {
	if (hasRequiredListItem) return listItem_1;
	hasRequiredListItem = 1;

	listItem_1 = listItem;

	var u = requireUnistBuilder();
	var wrap = requireWrap();
	var all = requireAll$1();

	function listItem(h, node, parent) {
	  var children = node.children;
	  var head = children[0];
	  var raw = all(h, node);
	  var loose = parent ? listLoose(parent) : listItemLoose(node);
	  var props = {};
	  var result;
	  var container;
	  var index;
	  var length;
	  var child;

	  // Tight lists should not render `paragraph` nodes as `p` elements.
	  if (loose) {
	    result = raw;
	  } else {
	    result = [];
	    length = raw.length;
	    index = -1;

	    while (++index < length) {
	      child = raw[index];

	      if (child.tagName === 'p') {
	        result = result.concat(child.children);
	      } else {
	        result.push(child);
	      }
	    }
	  }

	  if (typeof node.checked === 'boolean') {
	    if (loose && (!head || head.type !== 'paragraph')) {
	      result.unshift(h(null, 'p', []));
	    }

	    container = loose ? result[0].children : result;

	    if (container.length !== 0) {
	      container.unshift(u('text', ' '));
	    }

	    container.unshift(
	      h(null, 'input', {
	        type: 'checkbox',
	        checked: node.checked,
	        disabled: true
	      })
	    );

	    // According to github-markdown-css, this class hides bullet.
	    // See: <https://github.com/sindresorhus/github-markdown-css>.
	    props.className = ['task-list-item'];
	  }

	  if (loose && result.length !== 0) {
	    result = wrap(result, true);
	  }

	  return h(node, 'li', props, result)
	}

	function listLoose(node) {
	  var loose = node.spread;
	  var children = node.children;
	  var length = children.length;
	  var index = -1;

	  while (!loose && ++index < length) {
	    loose = listItemLoose(children[index]);
	  }

	  return loose
	}

	function listItemLoose(node) {
	  var spread = node.spread;

	  return spread === undefined || spread === null
	    ? node.children.length > 1
	    : spread
	}
	return listItem_1;
}

var paragraph_1;
var hasRequiredParagraph;

function requireParagraph () {
	if (hasRequiredParagraph) return paragraph_1;
	hasRequiredParagraph = 1;

	paragraph_1 = paragraph;

	var all = requireAll$1();

	function paragraph(h, node) {
	  return h(node, 'p', all(h, node))
	}
	return paragraph_1;
}

var root_1;
var hasRequiredRoot;

function requireRoot () {
	if (hasRequiredRoot) return root_1;
	hasRequiredRoot = 1;

	root_1 = root;

	var u = requireUnistBuilder();
	var wrap = requireWrap();
	var all = requireAll$1();

	function root(h, node) {
	  return h.augment(node, u('root', wrap(all(h, node))))
	}
	return root_1;
}

var strong_1;
var hasRequiredStrong;

function requireStrong () {
	if (hasRequiredStrong) return strong_1;
	hasRequiredStrong = 1;

	strong_1 = strong;

	var all = requireAll$1();

	function strong(h, node) {
	  return h(node, 'strong', all(h, node))
	}
	return strong_1;
}

var table_1;
var hasRequiredTable;

function requireTable () {
	if (hasRequiredTable) return table_1;
	hasRequiredTable = 1;

	table_1 = table;

	var position = requireUnistUtilPosition();
	var wrap = requireWrap();
	var all = requireAll$1();

	function table(h, node) {
	  var rows = node.children;
	  var index = rows.length;
	  var align = node.align;
	  var alignLength = align.length;
	  var result = [];
	  var pos;
	  var row;
	  var out;
	  var name;
	  var cell;

	  while (index--) {
	    row = rows[index].children;
	    name = index === 0 ? 'th' : 'td';
	    pos = alignLength;
	    out = [];

	    while (pos--) {
	      cell = row[pos];
	      out[pos] = h(cell, name, {align: align[pos]}, cell ? all(h, cell) : []);
	    }

	    result[index] = h(rows[index], 'tr', wrap(out, true));
	  }

	  return h(
	    node,
	    'table',
	    wrap(
	      [
	        h(result[0].position, 'thead', wrap([result[0]], true)),
	        h(
	          {
	            start: position.start(result[1]),
	            end: position.end(result[result.length - 1])
	          },
	          'tbody',
	          wrap(result.slice(1), true)
	        )
	      ],
	      true
	    )
	  )
	}
	return table_1;
}

var trimLines_1;
var hasRequiredTrimLines;

function requireTrimLines () {
	if (hasRequiredTrimLines) return trimLines_1;
	hasRequiredTrimLines = 1;

	trimLines_1 = trimLines;

	var ws = /[ \t]*\n+[ \t]*/g;
	var newline = '\n';

	function trimLines(value) {
	  return String(value).replace(ws, newline)
	}
	return trimLines_1;
}

var text_1;
var hasRequiredText$1;

function requireText$1 () {
	if (hasRequiredText$1) return text_1;
	hasRequiredText$1 = 1;

	text_1 = text;

	var u = requireUnistBuilder();
	var trimLines = requireTrimLines();

	function text(h, node) {
	  return h.augment(node, u('text', trimLines(node.value)))
	}
	return text_1;
}

var handlers;
var hasRequiredHandlers;

function requireHandlers () {
	if (hasRequiredHandlers) return handlers;
	hasRequiredHandlers = 1;

	handlers = {
	  blockquote: requireBlockquote(),
	  break: require_break(),
	  code: requireCode(),
	  delete: require_delete(),
	  emphasis: requireEmphasis(),
	  footnoteReference: requireFootnoteReference(),
	  footnote: requireFootnote(),
	  heading: requireHeading(),
	  html: requireHtml$1(),
	  imageReference: requireImageReference(),
	  image: requireImage(),
	  inlineCode: requireInlineCode(),
	  linkReference: requireLinkReference(),
	  link: requireLink(),
	  listItem: requireListItem(),
	  list: requireList(),
	  paragraph: requireParagraph(),
	  root: requireRoot(),
	  strong: requireStrong(),
	  table: requireTable(),
	  text: requireText$1(),
	  thematicBreak: requireThematicBreak(),
	  toml: ignore,
	  yaml: ignore,
	  definition: ignore,
	  footnoteDefinition: ignore
	};

	// Return nothing for nodes that are ignored.
	function ignore() {
	  return null
	}
	return handlers;
}

var lib$1;
var hasRequiredLib$1;

function requireLib$1 () {
	if (hasRequiredLib$1) return lib$1;
	hasRequiredLib$1 = 1;

	lib$1 = toHast;

	var u = requireUnistBuilder();
	var visit = requireUnistUtilVisit();
	var position = requireUnistUtilPosition();
	var generated = requireUnistUtilGenerated();
	var definitions = requireMdastUtilDefinitions();
	var one = requireOne$1();
	var footer = requireFooter();
	var handlers = requireHandlers();

	var own = {}.hasOwnProperty;

	var deprecationWarningIssued = false;

	// Factory to transform.
	function factory(tree, options) {
	  var settings = options || {};

	  // Issue a warning if the deprecated tag 'allowDangerousHTML' is used
	  if (settings.allowDangerousHTML !== undefined && !deprecationWarningIssued) {
	    deprecationWarningIssued = true;
	    console.warn(
	      'mdast-util-to-hast: deprecation: `allowDangerousHTML` is nonstandard, use `allowDangerousHtml` instead'
	    );
	  }

	  var dangerous = settings.allowDangerousHtml || settings.allowDangerousHTML;
	  var footnoteById = {};

	  h.dangerous = dangerous;
	  h.definition = definitions(tree, settings);
	  h.footnoteById = footnoteById;
	  h.footnoteOrder = [];
	  h.augment = augment;
	  h.handlers = Object.assign({}, handlers, settings.handlers);
	  h.unknownHandler = settings.unknownHandler;

	  visit(tree, 'footnoteDefinition', onfootnotedefinition);

	  return h

	  // Finalise the created `right`, a hast node, from `left`, an mdast node.
	  function augment(left, right) {
	    var data;
	    var ctx;

	    // Handle `data.hName`, `data.hProperties, `data.hChildren`.
	    if (left && 'data' in left) {
	      data = left.data;

	      if (right.type === 'element' && data.hName) {
	        right.tagName = data.hName;
	      }

	      if (right.type === 'element' && data.hProperties) {
	        right.properties = Object.assign({}, right.properties, data.hProperties);
	      }

	      if (right.children && data.hChildren) {
	        right.children = data.hChildren;
	      }
	    }

	    ctx = left && left.position ? left : {position: left};

	    if (!generated(ctx)) {
	      right.position = {
	        start: position.start(ctx),
	        end: position.end(ctx)
	      };
	    }

	    return right
	  }

	  // Create an element for `node`.
	  function h(node, tagName, props, children) {
	    if (
	      (children === undefined || children === null) &&
	      typeof props === 'object' &&
	      'length' in props
	    ) {
	      children = props;
	      props = {};
	    }

	    return augment(node, {
	      type: 'element',
	      tagName: tagName,
	      properties: props || {},
	      children: children || []
	    })
	  }

	  function onfootnotedefinition(definition) {
	    var id = String(definition.identifier).toUpperCase();

	    // Mimick CM behavior of link definitions.
	    // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/8d48e57/index.js#L26>.
	    if (!own.call(footnoteById, id)) {
	      footnoteById[id] = definition;
	    }
	  }
	}

	// Transform `tree`, which is an mdast node, to a hast node.
	function toHast(tree, options) {
	  var h = factory(tree, options);
	  var node = one(h, tree);
	  var foot = footer(h);

	  if (foot) {
	    node.children = node.children.concat(u('text', '\n'), foot);
	  }

	  return node
	}
	return lib$1;
}

var mdastUtilToHast;
var hasRequiredMdastUtilToHast;

function requireMdastUtilToHast () {
	if (hasRequiredMdastUtilToHast) return mdastUtilToHast;
	hasRequiredMdastUtilToHast = 1;
	mdastUtilToHast = requireLib$1();
	return mdastUtilToHast;
}

var remarkRehype;
var hasRequiredRemarkRehype;

function requireRemarkRehype () {
	if (hasRequiredRemarkRehype) return remarkRehype;
	hasRequiredRemarkRehype = 1;

	var mdast2hast = requireMdastUtilToHast();

	remarkRehype = remark2rehype;

	// Attacher.
	// If a destination is given, runs the destination with the new hast tree
	// (bridge mode).
	// Without destination, returns the tree: further plugins run on that tree
	// (mutate mode).
	function remark2rehype(destination, options) {
	  if (destination && !destination.process) {
	    options = destination;
	    destination = null;
	  }

	  return destination ? bridge(destination, options) : mutate(options)
	}

	// Bridge mode.
	// Runs the destination with the new hast tree.
	function bridge(destination, options) {
	  return transformer

	  function transformer(node, file, next) {
	    destination.run(mdast2hast(node, options), file, done);

	    function done(err) {
	      next(err);
	    }
	  }
	}

	// Mutate-mode.
	// Further transformers run on the hast tree.
	function mutate(options) {
	  return transformer

	  function transformer(node) {
	    return mdast2hast(node, options)
	  }
	}
	return remarkRehype;
}

var remarkRehypeExports = requireRemarkRehype();
var remark2rehype = /*@__PURE__*/getDefaultExportFromCjs(remarkRehypeExports);

var unicode = {};

var hasRequiredUnicode;

function requireUnicode () {
	if (hasRequiredUnicode) return unicode;
	hasRequiredUnicode = 1;

	const UNDEFINED_CODE_POINTS = [
	    0xfffe,
	    0xffff,
	    0x1fffe,
	    0x1ffff,
	    0x2fffe,
	    0x2ffff,
	    0x3fffe,
	    0x3ffff,
	    0x4fffe,
	    0x4ffff,
	    0x5fffe,
	    0x5ffff,
	    0x6fffe,
	    0x6ffff,
	    0x7fffe,
	    0x7ffff,
	    0x8fffe,
	    0x8ffff,
	    0x9fffe,
	    0x9ffff,
	    0xafffe,
	    0xaffff,
	    0xbfffe,
	    0xbffff,
	    0xcfffe,
	    0xcffff,
	    0xdfffe,
	    0xdffff,
	    0xefffe,
	    0xeffff,
	    0xffffe,
	    0xfffff,
	    0x10fffe,
	    0x10ffff
	];

	unicode.REPLACEMENT_CHARACTER = '\uFFFD';

	unicode.CODE_POINTS = {
	    EOF: -1,
	    NULL: 0x00,
	    TABULATION: 0x09,
	    CARRIAGE_RETURN: 0x0d,
	    LINE_FEED: 0x0a,
	    FORM_FEED: 0x0c,
	    SPACE: 0x20,
	    EXCLAMATION_MARK: 0x21,
	    QUOTATION_MARK: 0x22,
	    NUMBER_SIGN: 0x23,
	    AMPERSAND: 0x26,
	    APOSTROPHE: 0x27,
	    HYPHEN_MINUS: 0x2d,
	    SOLIDUS: 0x2f,
	    DIGIT_0: 0x30,
	    DIGIT_9: 0x39,
	    SEMICOLON: 0x3b,
	    LESS_THAN_SIGN: 0x3c,
	    EQUALS_SIGN: 0x3d,
	    GREATER_THAN_SIGN: 0x3e,
	    QUESTION_MARK: 0x3f,
	    LATIN_CAPITAL_A: 0x41,
	    LATIN_CAPITAL_F: 0x46,
	    LATIN_CAPITAL_X: 0x58,
	    LATIN_CAPITAL_Z: 0x5a,
	    RIGHT_SQUARE_BRACKET: 0x5d,
	    GRAVE_ACCENT: 0x60,
	    LATIN_SMALL_A: 0x61,
	    LATIN_SMALL_F: 0x66,
	    LATIN_SMALL_X: 0x78,
	    LATIN_SMALL_Z: 0x7a,
	    REPLACEMENT_CHARACTER: 0xfffd
	};

	unicode.CODE_POINT_SEQUENCES = {
	    DASH_DASH_STRING: [0x2d, 0x2d], //--
	    DOCTYPE_STRING: [0x44, 0x4f, 0x43, 0x54, 0x59, 0x50, 0x45], //DOCTYPE
	    CDATA_START_STRING: [0x5b, 0x43, 0x44, 0x41, 0x54, 0x41, 0x5b], //[CDATA[
	    SCRIPT_STRING: [0x73, 0x63, 0x72, 0x69, 0x70, 0x74], //script
	    PUBLIC_STRING: [0x50, 0x55, 0x42, 0x4c, 0x49, 0x43], //PUBLIC
	    SYSTEM_STRING: [0x53, 0x59, 0x53, 0x54, 0x45, 0x4d] //SYSTEM
	};

	//Surrogates
	unicode.isSurrogate = function(cp) {
	    return cp >= 0xd800 && cp <= 0xdfff;
	};

	unicode.isSurrogatePair = function(cp) {
	    return cp >= 0xdc00 && cp <= 0xdfff;
	};

	unicode.getSurrogatePairCodePoint = function(cp1, cp2) {
	    return (cp1 - 0xd800) * 0x400 + 0x2400 + cp2;
	};

	//NOTE: excluding NULL and ASCII whitespace
	unicode.isControlCodePoint = function(cp) {
	    return (
	        (cp !== 0x20 && cp !== 0x0a && cp !== 0x0d && cp !== 0x09 && cp !== 0x0c && cp >= 0x01 && cp <= 0x1f) ||
	        (cp >= 0x7f && cp <= 0x9f)
	    );
	};

	unicode.isUndefinedCodePoint = function(cp) {
	    return (cp >= 0xfdd0 && cp <= 0xfdef) || UNDEFINED_CODE_POINTS.indexOf(cp) > -1;
	};
	return unicode;
}

var errorCodes;
var hasRequiredErrorCodes;

function requireErrorCodes () {
	if (hasRequiredErrorCodes) return errorCodes;
	hasRequiredErrorCodes = 1;

	errorCodes = {
	    controlCharacterInInputStream: 'control-character-in-input-stream',
	    noncharacterInInputStream: 'noncharacter-in-input-stream',
	    surrogateInInputStream: 'surrogate-in-input-stream',
	    nonVoidHtmlElementStartTagWithTrailingSolidus: 'non-void-html-element-start-tag-with-trailing-solidus',
	    endTagWithAttributes: 'end-tag-with-attributes',
	    endTagWithTrailingSolidus: 'end-tag-with-trailing-solidus',
	    unexpectedSolidusInTag: 'unexpected-solidus-in-tag',
	    unexpectedNullCharacter: 'unexpected-null-character',
	    unexpectedQuestionMarkInsteadOfTagName: 'unexpected-question-mark-instead-of-tag-name',
	    invalidFirstCharacterOfTagName: 'invalid-first-character-of-tag-name',
	    unexpectedEqualsSignBeforeAttributeName: 'unexpected-equals-sign-before-attribute-name',
	    missingEndTagName: 'missing-end-tag-name',
	    unexpectedCharacterInAttributeName: 'unexpected-character-in-attribute-name',
	    unknownNamedCharacterReference: 'unknown-named-character-reference',
	    missingSemicolonAfterCharacterReference: 'missing-semicolon-after-character-reference',
	    unexpectedCharacterAfterDoctypeSystemIdentifier: 'unexpected-character-after-doctype-system-identifier',
	    unexpectedCharacterInUnquotedAttributeValue: 'unexpected-character-in-unquoted-attribute-value',
	    eofBeforeTagName: 'eof-before-tag-name',
	    eofInTag: 'eof-in-tag',
	    missingAttributeValue: 'missing-attribute-value',
	    missingWhitespaceBetweenAttributes: 'missing-whitespace-between-attributes',
	    missingWhitespaceAfterDoctypePublicKeyword: 'missing-whitespace-after-doctype-public-keyword',
	    missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers:
	        'missing-whitespace-between-doctype-public-and-system-identifiers',
	    missingWhitespaceAfterDoctypeSystemKeyword: 'missing-whitespace-after-doctype-system-keyword',
	    missingQuoteBeforeDoctypePublicIdentifier: 'missing-quote-before-doctype-public-identifier',
	    missingQuoteBeforeDoctypeSystemIdentifier: 'missing-quote-before-doctype-system-identifier',
	    missingDoctypePublicIdentifier: 'missing-doctype-public-identifier',
	    missingDoctypeSystemIdentifier: 'missing-doctype-system-identifier',
	    abruptDoctypePublicIdentifier: 'abrupt-doctype-public-identifier',
	    abruptDoctypeSystemIdentifier: 'abrupt-doctype-system-identifier',
	    cdataInHtmlContent: 'cdata-in-html-content',
	    incorrectlyOpenedComment: 'incorrectly-opened-comment',
	    eofInScriptHtmlCommentLikeText: 'eof-in-script-html-comment-like-text',
	    eofInDoctype: 'eof-in-doctype',
	    nestedComment: 'nested-comment',
	    abruptClosingOfEmptyComment: 'abrupt-closing-of-empty-comment',
	    eofInComment: 'eof-in-comment',
	    incorrectlyClosedComment: 'incorrectly-closed-comment',
	    eofInCdata: 'eof-in-cdata',
	    absenceOfDigitsInNumericCharacterReference: 'absence-of-digits-in-numeric-character-reference',
	    nullCharacterReference: 'null-character-reference',
	    surrogateCharacterReference: 'surrogate-character-reference',
	    characterReferenceOutsideUnicodeRange: 'character-reference-outside-unicode-range',
	    controlCharacterReference: 'control-character-reference',
	    noncharacterCharacterReference: 'noncharacter-character-reference',
	    missingWhitespaceBeforeDoctypeName: 'missing-whitespace-before-doctype-name',
	    missingDoctypeName: 'missing-doctype-name',
	    invalidCharacterSequenceAfterDoctypeName: 'invalid-character-sequence-after-doctype-name',
	    duplicateAttribute: 'duplicate-attribute',
	    nonConformingDoctype: 'non-conforming-doctype',
	    missingDoctype: 'missing-doctype',
	    misplacedDoctype: 'misplaced-doctype',
	    endTagWithoutMatchingOpenElement: 'end-tag-without-matching-open-element',
	    closingOfElementWithOpenChildElements: 'closing-of-element-with-open-child-elements',
	    disallowedContentInNoscriptInHead: 'disallowed-content-in-noscript-in-head',
	    openElementsLeftAfterEof: 'open-elements-left-after-eof',
	    abandonedHeadElementChild: 'abandoned-head-element-child',
	    misplacedStartTagForHeadElement: 'misplaced-start-tag-for-head-element',
	    nestedNoscriptInHead: 'nested-noscript-in-head',
	    eofInElementThatCanContainOnlyText: 'eof-in-element-that-can-contain-only-text'
	};
	return errorCodes;
}

var preprocessor;
var hasRequiredPreprocessor;

function requirePreprocessor () {
	if (hasRequiredPreprocessor) return preprocessor;
	hasRequiredPreprocessor = 1;

	const unicode = requireUnicode();
	const ERR = requireErrorCodes();

	//Aliases
	const $ = unicode.CODE_POINTS;

	//Const
	const DEFAULT_BUFFER_WATERLINE = 1 << 16;

	//Preprocessor
	//NOTE: HTML input preprocessing
	//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)
	class Preprocessor {
	    constructor() {
	        this.html = null;

	        this.pos = -1;
	        this.lastGapPos = -1;
	        this.lastCharPos = -1;

	        this.gapStack = [];

	        this.skipNextNewLine = false;

	        this.lastChunkWritten = false;
	        this.endOfChunkHit = false;
	        this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
	    }

	    _err() {
	        // NOTE: err reporting is noop by default. Enabled by mixin.
	    }

	    _addGap() {
	        this.gapStack.push(this.lastGapPos);
	        this.lastGapPos = this.pos;
	    }

	    _processSurrogate(cp) {
	        //NOTE: try to peek a surrogate pair
	        if (this.pos !== this.lastCharPos) {
	            const nextCp = this.html.charCodeAt(this.pos + 1);

	            if (unicode.isSurrogatePair(nextCp)) {
	                //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.
	                this.pos++;

	                //NOTE: add gap that should be avoided during retreat
	                this._addGap();

	                return unicode.getSurrogatePairCodePoint(cp, nextCp);
	            }
	        }

	        //NOTE: we are at the end of a chunk, therefore we can't infer surrogate pair yet.
	        else if (!this.lastChunkWritten) {
	            this.endOfChunkHit = true;
	            return $.EOF;
	        }

	        //NOTE: isolated surrogate
	        this._err(ERR.surrogateInInputStream);

	        return cp;
	    }

	    dropParsedChunk() {
	        if (this.pos > this.bufferWaterline) {
	            this.lastCharPos -= this.pos;
	            this.html = this.html.substring(this.pos);
	            this.pos = 0;
	            this.lastGapPos = -1;
	            this.gapStack = [];
	        }
	    }

	    write(chunk, isLastChunk) {
	        if (this.html) {
	            this.html += chunk;
	        } else {
	            this.html = chunk;
	        }

	        this.lastCharPos = this.html.length - 1;
	        this.endOfChunkHit = false;
	        this.lastChunkWritten = isLastChunk;
	    }

	    insertHtmlAtCurrentPos(chunk) {
	        this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1, this.html.length);

	        this.lastCharPos = this.html.length - 1;
	        this.endOfChunkHit = false;
	    }

	    advance() {
	        this.pos++;

	        if (this.pos > this.lastCharPos) {
	            this.endOfChunkHit = !this.lastChunkWritten;
	            return $.EOF;
	        }

	        let cp = this.html.charCodeAt(this.pos);

	        //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character
	        //must be ignored.
	        if (this.skipNextNewLine && cp === $.LINE_FEED) {
	            this.skipNextNewLine = false;
	            this._addGap();
	            return this.advance();
	        }

	        //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters
	        if (cp === $.CARRIAGE_RETURN) {
	            this.skipNextNewLine = true;
	            return $.LINE_FEED;
	        }

	        this.skipNextNewLine = false;

	        if (unicode.isSurrogate(cp)) {
	            cp = this._processSurrogate(cp);
	        }

	        //OPTIMIZATION: first check if code point is in the common allowed
	        //range (ASCII alphanumeric, whitespaces, big chunk of BMP)
	        //before going into detailed performance cost validation.
	        const isCommonValidRange =
	            (cp > 0x1f && cp < 0x7f) || cp === $.LINE_FEED || cp === $.CARRIAGE_RETURN || (cp > 0x9f && cp < 0xfdd0);

	        if (!isCommonValidRange) {
	            this._checkForProblematicCharacters(cp);
	        }

	        return cp;
	    }

	    _checkForProblematicCharacters(cp) {
	        if (unicode.isControlCodePoint(cp)) {
	            this._err(ERR.controlCharacterInInputStream);
	        } else if (unicode.isUndefinedCodePoint(cp)) {
	            this._err(ERR.noncharacterInInputStream);
	        }
	    }

	    retreat() {
	        if (this.pos === this.lastGapPos) {
	            this.lastGapPos = this.gapStack.pop();
	            this.pos--;
	        }

	        this.pos--;
	    }
	}

	preprocessor = Preprocessor;
	return preprocessor;
}

var namedEntityData;
var hasRequiredNamedEntityData;

function requireNamedEntityData () {
	if (hasRequiredNamedEntityData) return namedEntityData;
	hasRequiredNamedEntityData = 1;

	//NOTE: this file contains auto-generated array mapped radix tree that is used for the named entity references consumption
	//(details: https://github.com/inikulin/parse5/tree/master/scripts/generate-named-entity-data/README.md)
	namedEntityData = new Uint16Array([4,52,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,106,303,412,810,1432,1701,1796,1987,2114,2360,2420,2484,3170,3251,4140,4393,4575,4610,5106,5512,5728,6117,6274,6315,6345,6427,6516,7002,7910,8733,9323,9870,10170,10631,10893,11318,11386,11467,12773,13092,14474,14922,15448,15542,16419,17666,18166,18611,19004,19095,19298,19397,4,16,69,77,97,98,99,102,103,108,109,110,111,112,114,115,116,117,140,150,158,169,176,194,199,210,216,222,226,242,256,266,283,294,108,105,103,5,198,1,59,148,1,198,80,5,38,1,59,156,1,38,99,117,116,101,5,193,1,59,167,1,193,114,101,118,101,59,1,258,4,2,105,121,182,191,114,99,5,194,1,59,189,1,194,59,1,1040,114,59,3,55349,56580,114,97,118,101,5,192,1,59,208,1,192,112,104,97,59,1,913,97,99,114,59,1,256,100,59,1,10835,4,2,103,112,232,237,111,110,59,1,260,102,59,3,55349,56632,112,108,121,70,117,110,99,116,105,111,110,59,1,8289,105,110,103,5,197,1,59,264,1,197,4,2,99,115,272,277,114,59,3,55349,56476,105,103,110,59,1,8788,105,108,100,101,5,195,1,59,292,1,195,109,108,5,196,1,59,301,1,196,4,8,97,99,101,102,111,114,115,117,321,350,354,383,388,394,400,405,4,2,99,114,327,336,107,115,108,97,115,104,59,1,8726,4,2,118,119,342,345,59,1,10983,101,100,59,1,8966,121,59,1,1041,4,3,99,114,116,362,369,379,97,117,115,101,59,1,8757,110,111,117,108,108,105,115,59,1,8492,97,59,1,914,114,59,3,55349,56581,112,102,59,3,55349,56633,101,118,101,59,1,728,99,114,59,1,8492,109,112,101,113,59,1,8782,4,14,72,79,97,99,100,101,102,104,105,108,111,114,115,117,442,447,456,504,542,547,569,573,577,616,678,784,790,796,99,121,59,1,1063,80,89,5,169,1,59,454,1,169,4,3,99,112,121,464,470,497,117,116,101,59,1,262,4,2,59,105,476,478,1,8914,116,97,108,68,105,102,102,101,114,101,110,116,105,97,108,68,59,1,8517,108,101,121,115,59,1,8493,4,4,97,101,105,111,514,520,530,535,114,111,110,59,1,268,100,105,108,5,199,1,59,528,1,199,114,99,59,1,264,110,105,110,116,59,1,8752,111,116,59,1,266,4,2,100,110,553,560,105,108,108,97,59,1,184,116,101,114,68,111,116,59,1,183,114,59,1,8493,105,59,1,935,114,99,108,101,4,4,68,77,80,84,591,596,603,609,111,116,59,1,8857,105,110,117,115,59,1,8854,108,117,115,59,1,8853,105,109,101,115,59,1,8855,111,4,2,99,115,623,646,107,119,105,115,101,67,111,110,116,111,117,114,73,110,116,101,103,114,97,108,59,1,8754,101,67,117,114,108,121,4,2,68,81,658,671,111,117,98,108,101,81,117,111,116,101,59,1,8221,117,111,116,101,59,1,8217,4,4,108,110,112,117,688,701,736,753,111,110,4,2,59,101,696,698,1,8759,59,1,10868,4,3,103,105,116,709,717,722,114,117,101,110,116,59,1,8801,110,116,59,1,8751,111,117,114,73,110,116,101,103,114,97,108,59,1,8750,4,2,102,114,742,745,59,1,8450,111,100,117,99,116,59,1,8720,110,116,101,114,67,108,111,99,107,119,105,115,101,67,111,110,116,111,117,114,73,110,116,101,103,114,97,108,59,1,8755,111,115,115,59,1,10799,99,114,59,3,55349,56478,112,4,2,59,67,803,805,1,8915,97,112,59,1,8781,4,11,68,74,83,90,97,99,101,102,105,111,115,834,850,855,860,865,888,903,916,921,1011,1415,4,2,59,111,840,842,1,8517,116,114,97,104,100,59,1,10513,99,121,59,1,1026,99,121,59,1,1029,99,121,59,1,1039,4,3,103,114,115,873,879,883,103,101,114,59,1,8225,114,59,1,8609,104,118,59,1,10980,4,2,97,121,894,900,114,111,110,59,1,270,59,1,1044,108,4,2,59,116,910,912,1,8711,97,59,1,916,114,59,3,55349,56583,4,2,97,102,927,998,4,2,99,109,933,992,114,105,116,105,99,97,108,4,4,65,68,71,84,950,957,978,985,99,117,116,101,59,1,180,111,4,2,116,117,964,967,59,1,729,98,108,101,65,99,117,116,101,59,1,733,114,97,118,101,59,1,96,105,108,100,101,59,1,732,111,110,100,59,1,8900,102,101,114,101,110,116,105,97,108,68,59,1,8518,4,4,112,116,117,119,1021,1026,1048,1249,102,59,3,55349,56635,4,3,59,68,69,1034,1036,1041,1,168,111,116,59,1,8412,113,117,97,108,59,1,8784,98,108,101,4,6,67,68,76,82,85,86,1065,1082,1101,1189,1211,1236,111,110,116,111,117,114,73,110,116,101,103,114,97,108,59,1,8751,111,4,2,116,119,1089,1092,59,1,168,110,65,114,114,111,119,59,1,8659,4,2,101,111,1107,1141,102,116,4,3,65,82,84,1117,1124,1136,114,114,111,119,59,1,8656,105,103,104,116,65,114,114,111,119,59,1,8660,101,101,59,1,10980,110,103,4,2,76,82,1149,1177,101,102,116,4,2,65,82,1158,1165,114,114,111,119,59,1,10232,105,103,104,116,65,114,114,111,119,59,1,10234,105,103,104,116,65,114,114,111,119,59,1,10233,105,103,104,116,4,2,65,84,1199,1206,114,114,111,119,59,1,8658,101,101,59,1,8872,112,4,2,65,68,1218,1225,114,114,111,119,59,1,8657,111,119,110,65,114,114,111,119,59,1,8661,101,114,116,105,99,97,108,66,97,114,59,1,8741,110,4,6,65,66,76,82,84,97,1264,1292,1299,1352,1391,1408,114,114,111,119,4,3,59,66,85,1276,1278,1283,1,8595,97,114,59,1,10515,112,65,114,114,111,119,59,1,8693,114,101,118,101,59,1,785,101,102,116,4,3,82,84,86,1310,1323,1334,105,103,104,116,86,101,99,116,111,114,59,1,10576,101,101,86,101,99,116,111,114,59,1,10590,101,99,116,111,114,4,2,59,66,1345,1347,1,8637,97,114,59,1,10582,105,103,104,116,4,2,84,86,1362,1373,101,101,86,101,99,116,111,114,59,1,10591,101,99,116,111,114,4,2,59,66,1384,1386,1,8641,97,114,59,1,10583,101,101,4,2,59,65,1399,1401,1,8868,114,114,111,119,59,1,8615,114,114,111,119,59,1,8659,4,2,99,116,1421,1426,114,59,3,55349,56479,114,111,107,59,1,272,4,16,78,84,97,99,100,102,103,108,109,111,112,113,115,116,117,120,1466,1470,1478,1489,1515,1520,1525,1536,1544,1593,1609,1617,1650,1664,1668,1677,71,59,1,330,72,5,208,1,59,1476,1,208,99,117,116,101,5,201,1,59,1487,1,201,4,3,97,105,121,1497,1503,1512,114,111,110,59,1,282,114,99,5,202,1,59,1510,1,202,59,1,1069,111,116,59,1,278,114,59,3,55349,56584,114,97,118,101,5,200,1,59,1534,1,200,101,109,101,110,116,59,1,8712,4,2,97,112,1550,1555,99,114,59,1,274,116,121,4,2,83,86,1563,1576,109,97,108,108,83,113,117,97,114,101,59,1,9723,101,114,121,83,109,97,108,108,83,113,117,97,114,101,59,1,9643,4,2,103,112,1599,1604,111,110,59,1,280,102,59,3,55349,56636,115,105,108,111,110,59,1,917,117,4,2,97,105,1624,1640,108,4,2,59,84,1631,1633,1,10869,105,108,100,101,59,1,8770,108,105,98,114,105,117,109,59,1,8652,4,2,99,105,1656,1660,114,59,1,8496,109,59,1,10867,97,59,1,919,109,108,5,203,1,59,1675,1,203,4,2,105,112,1683,1689,115,116,115,59,1,8707,111,110,101,110,116,105,97,108,69,59,1,8519,4,5,99,102,105,111,115,1713,1717,1722,1762,1791,121,59,1,1060,114,59,3,55349,56585,108,108,101,100,4,2,83,86,1732,1745,109,97,108,108,83,113,117,97,114,101,59,1,9724,101,114,121,83,109,97,108,108,83,113,117,97,114,101,59,1,9642,4,3,112,114,117,1770,1775,1781,102,59,3,55349,56637,65,108,108,59,1,8704,114,105,101,114,116,114,102,59,1,8497,99,114,59,1,8497,4,12,74,84,97,98,99,100,102,103,111,114,115,116,1822,1827,1834,1848,1855,1877,1882,1887,1890,1896,1978,1984,99,121,59,1,1027,5,62,1,59,1832,1,62,109,109,97,4,2,59,100,1843,1845,1,915,59,1,988,114,101,118,101,59,1,286,4,3,101,105,121,1863,1869,1874,100,105,108,59,1,290,114,99,59,1,284,59,1,1043,111,116,59,1,288,114,59,3,55349,56586,59,1,8921,112,102,59,3,55349,56638,101,97,116,101,114,4,6,69,70,71,76,83,84,1915,1933,1944,1953,1959,1971,113,117,97,108,4,2,59,76,1925,1927,1,8805,101,115,115,59,1,8923,117,108,108,69,113,117,97,108,59,1,8807,114,101,97,116,101,114,59,1,10914,101,115,115,59,1,8823,108,97,110,116,69,113,117,97,108,59,1,10878,105,108,100,101,59,1,8819,99,114,59,3,55349,56482,59,1,8811,4,8,65,97,99,102,105,111,115,117,2005,2012,2026,2032,2036,2049,2073,2089,82,68,99,121,59,1,1066,4,2,99,116,2018,2023,101,107,59,1,711,59,1,94,105,114,99,59,1,292,114,59,1,8460,108,98,101,114,116,83,112,97,99,101,59,1,8459,4,2,112,114,2055,2059,102,59,1,8461,105,122,111,110,116,97,108,76,105,110,101,59,1,9472,4,2,99,116,2079,2083,114,59,1,8459,114,111,107,59,1,294,109,112,4,2,68,69,2097,2107,111,119,110,72,117,109,112,59,1,8782,113,117,97,108,59,1,8783,4,14,69,74,79,97,99,100,102,103,109,110,111,115,116,117,2144,2149,2155,2160,2171,2189,2194,2198,2209,2245,2307,2329,2334,2341,99,121,59,1,1045,108,105,103,59,1,306,99,121,59,1,1025,99,117,116,101,5,205,1,59,2169,1,205,4,2,105,121,2177,2186,114,99,5,206,1,59,2184,1,206,59,1,1048,111,116,59,1,304,114,59,1,8465,114,97,118,101,5,204,1,59,2207,1,204,4,3,59,97,112,2217,2219,2238,1,8465,4,2,99,103,2225,2229,114,59,1,298,105,110,97,114,121,73,59,1,8520,108,105,101,115,59,1,8658,4,2,116,118,2251,2281,4,2,59,101,2257,2259,1,8748,4,2,103,114,2265,2271,114,97,108,59,1,8747,115,101,99,116,105,111,110,59,1,8898,105,115,105,98,108,101,4,2,67,84,2293,2300,111,109,109,97,59,1,8291,105,109,101,115,59,1,8290,4,3,103,112,116,2315,2320,2325,111,110,59,1,302,102,59,3,55349,56640,97,59,1,921,99,114,59,1,8464,105,108,100,101,59,1,296,4,2,107,109,2347,2352,99,121,59,1,1030,108,5,207,1,59,2358,1,207,4,5,99,102,111,115,117,2372,2386,2391,2397,2414,4,2,105,121,2378,2383,114,99,59,1,308,59,1,1049,114,59,3,55349,56589,112,102,59,3,55349,56641,4,2,99,101,2403,2408,114,59,3,55349,56485,114,99,121,59,1,1032,107,99,121,59,1,1028,4,7,72,74,97,99,102,111,115,2436,2441,2446,2452,2467,2472,2478,99,121,59,1,1061,99,121,59,1,1036,112,112,97,59,1,922,4,2,101,121,2458,2464,100,105,108,59,1,310,59,1,1050,114,59,3,55349,56590,112,102,59,3,55349,56642,99,114,59,3,55349,56486,4,11,74,84,97,99,101,102,108,109,111,115,116,2508,2513,2520,2562,2585,2981,2986,3004,3011,3146,3167,99,121,59,1,1033,5,60,1,59,2518,1,60,4,5,99,109,110,112,114,2532,2538,2544,2548,2558,117,116,101,59,1,313,98,100,97,59,1,923,103,59,1,10218,108,97,99,101,116,114,102,59,1,8466,114,59,1,8606,4,3,97,101,121,2570,2576,2582,114,111,110,59,1,317,100,105,108,59,1,315,59,1,1051,4,2,102,115,2591,2907,116,4,10,65,67,68,70,82,84,85,86,97,114,2614,2663,2672,2728,2735,2760,2820,2870,2888,2895,4,2,110,114,2620,2633,103,108,101,66,114,97,99,107,101,116,59,1,10216,114,111,119,4,3,59,66,82,2644,2646,2651,1,8592,97,114,59,1,8676,105,103,104,116,65,114,114,111,119,59,1,8646,101,105,108,105,110,103,59,1,8968,111,4,2,117,119,2679,2692,98,108,101,66,114,97,99,107,101,116,59,1,10214,110,4,2,84,86,2699,2710,101,101,86,101,99,116,111,114,59,1,10593,101,99,116,111,114,4,2,59,66,2721,2723,1,8643,97,114,59,1,10585,108,111,111,114,59,1,8970,105,103,104,116,4,2,65,86,2745,2752,114,114,111,119,59,1,8596,101,99,116,111,114,59,1,10574,4,2,101,114,2766,2792,101,4,3,59,65,86,2775,2777,2784,1,8867,114,114,111,119,59,1,8612,101,99,116,111,114,59,1,10586,105,97,110,103,108,101,4,3,59,66,69,2806,2808,2813,1,8882,97,114,59,1,10703,113,117,97,108,59,1,8884,112,4,3,68,84,86,2829,2841,2852,111,119,110,86,101,99,116,111,114,59,1,10577,101,101,86,101,99,116,111,114,59,1,10592,101,99,116,111,114,4,2,59,66,2863,2865,1,8639,97,114,59,1,10584,101,99,116,111,114,4,2,59,66,2881,2883,1,8636,97,114,59,1,10578,114,114,111,119,59,1,8656,105,103,104,116,97,114,114,111,119,59,1,8660,115,4,6,69,70,71,76,83,84,2922,2936,2947,2956,2962,2974,113,117,97,108,71,114,101,97,116,101,114,59,1,8922,117,108,108,69,113,117,97,108,59,1,8806,114,101,97,116,101,114,59,1,8822,101,115,115,59,1,10913,108,97,110,116,69,113,117,97,108,59,1,10877,105,108,100,101,59,1,8818,114,59,3,55349,56591,4,2,59,101,2992,2994,1,8920,102,116,97,114,114,111,119,59,1,8666,105,100,111,116,59,1,319,4,3,110,112,119,3019,3110,3115,103,4,4,76,82,108,114,3030,3058,3070,3098,101,102,116,4,2,65,82,3039,3046,114,114,111,119,59,1,10229,105,103,104,116,65,114,114,111,119,59,1,10231,105,103,104,116,65,114,114,111,119,59,1,10230,101,102,116,4,2,97,114,3079,3086,114,114,111,119,59,1,10232,105,103,104,116,97,114,114,111,119,59,1,10234,105,103,104,116,97,114,114,111,119,59,1,10233,102,59,3,55349,56643,101,114,4,2,76,82,3123,3134,101,102,116,65,114,114,111,119,59,1,8601,105,103,104,116,65,114,114,111,119,59,1,8600,4,3,99,104,116,3154,3158,3161,114,59,1,8466,59,1,8624,114,111,107,59,1,321,59,1,8810,4,8,97,99,101,102,105,111,115,117,3188,3192,3196,3222,3227,3237,3243,3248,112,59,1,10501,121,59,1,1052,4,2,100,108,3202,3213,105,117,109,83,112,97,99,101,59,1,8287,108,105,110,116,114,102,59,1,8499,114,59,3,55349,56592,110,117,115,80,108,117,115,59,1,8723,112,102,59,3,55349,56644,99,114,59,1,8499,59,1,924,4,9,74,97,99,101,102,111,115,116,117,3271,3276,3283,3306,3422,3427,4120,4126,4137,99,121,59,1,1034,99,117,116,101,59,1,323,4,3,97,101,121,3291,3297,3303,114,111,110,59,1,327,100,105,108,59,1,325,59,1,1053,4,3,103,115,119,3314,3380,3415,97,116,105,118,101,4,3,77,84,86,3327,3340,3365,101,100,105,117,109,83,112,97,99,101,59,1,8203,104,105,4,2,99,110,3348,3357,107,83,112,97,99,101,59,1,8203,83,112,97,99,101,59,1,8203,101,114,121,84,104,105,110,83,112,97,99,101,59,1,8203,116,101,100,4,2,71,76,3389,3405,114,101,97,116,101,114,71,114,101,97,116,101,114,59,1,8811,101,115,115,76,101,115,115,59,1,8810,76,105,110,101,59,1,10,114,59,3,55349,56593,4,4,66,110,112,116,3437,3444,3460,3464,114,101,97,107,59,1,8288,66,114,101,97,107,105,110,103,83,112,97,99,101,59,1,160,102,59,1,8469,4,13,59,67,68,69,71,72,76,78,80,82,83,84,86,3492,3494,3517,3536,3578,3657,3685,3784,3823,3860,3915,4066,4107,1,10988,4,2,111,117,3500,3510,110,103,114,117,101,110,116,59,1,8802,112,67,97,112,59,1,8813,111,117,98,108,101,86,101,114,116,105,99,97,108,66,97,114,59,1,8742,4,3,108,113,120,3544,3552,3571,101,109,101,110,116,59,1,8713,117,97,108,4,2,59,84,3561,3563,1,8800,105,108,100,101,59,3,8770,824,105,115,116,115,59,1,8708,114,101,97,116,101,114,4,7,59,69,70,71,76,83,84,3600,3602,3609,3621,3631,3637,3650,1,8815,113,117,97,108,59,1,8817,117,108,108,69,113,117,97,108,59,3,8807,824,114,101,97,116,101,114,59,3,8811,824,101,115,115,59,1,8825,108,97,110,116,69,113,117,97,108,59,3,10878,824,105,108,100,101,59,1,8821,117,109,112,4,2,68,69,3666,3677,111,119,110,72,117,109,112,59,3,8782,824,113,117,97,108,59,3,8783,824,101,4,2,102,115,3692,3724,116,84,114,105,97,110,103,108,101,4,3,59,66,69,3709,3711,3717,1,8938,97,114,59,3,10703,824,113,117,97,108,59,1,8940,115,4,6,59,69,71,76,83,84,3739,3741,3748,3757,3764,3777,1,8814,113,117,97,108,59,1,8816,114,101,97,116,101,114,59,1,8824,101,115,115,59,3,8810,824,108,97,110,116,69,113,117,97,108,59,3,10877,824,105,108,100,101,59,1,8820,101,115,116,101,100,4,2,71,76,3795,3812,114,101,97,116,101,114,71,114,101,97,116,101,114,59,3,10914,824,101,115,115,76,101,115,115,59,3,10913,824,114,101,99,101,100,101,115,4,3,59,69,83,3838,3840,3848,1,8832,113,117,97,108,59,3,10927,824,108,97,110,116,69,113,117,97,108,59,1,8928,4,2,101,105,3866,3881,118,101,114,115,101,69,108,101,109,101,110,116,59,1,8716,103,104,116,84,114,105,97,110,103,108,101,4,3,59,66,69,3900,3902,3908,1,8939,97,114,59,3,10704,824,113,117,97,108,59,1,8941,4,2,113,117,3921,3973,117,97,114,101,83,117,4,2,98,112,3933,3952,115,101,116,4,2,59,69,3942,3945,3,8847,824,113,117,97,108,59,1,8930,101,114,115,101,116,4,2,59,69,3963,3966,3,8848,824,113,117,97,108,59,1,8931,4,3,98,99,112,3981,4000,4045,115,101,116,4,2,59,69,3990,3993,3,8834,8402,113,117,97,108,59,1,8840,99,101,101,100,115,4,4,59,69,83,84,4015,4017,4025,4037,1,8833,113,117,97,108,59,3,10928,824,108,97,110,116,69,113,117,97,108,59,1,8929,105,108,100,101,59,3,8831,824,101,114,115,101,116,4,2,59,69,4056,4059,3,8835,8402,113,117,97,108,59,1,8841,105,108,100,101,4,4,59,69,70,84,4080,4082,4089,4100,1,8769,113,117,97,108,59,1,8772,117,108,108,69,113,117,97,108,59,1,8775,105,108,100,101,59,1,8777,101,114,116,105,99,97,108,66,97,114,59,1,8740,99,114,59,3,55349,56489,105,108,100,101,5,209,1,59,4135,1,209,59,1,925,4,14,69,97,99,100,102,103,109,111,112,114,115,116,117,118,4170,4176,4187,4205,4212,4217,4228,4253,4259,4292,4295,4316,4337,4346,108,105,103,59,1,338,99,117,116,101,5,211,1,59,4185,1,211,4,2,105,121,4193,4202,114,99,5,212,1,59,4200,1,212,59,1,1054,98,108,97,99,59,1,336,114,59,3,55349,56594,114,97,118,101,5,210,1,59,4226,1,210,4,3,97,101,105,4236,4241,4246,99,114,59,1,332,103,97,59,1,937,99,114,111,110,59,1,927,112,102,59,3,55349,56646,101,110,67,117,114,108,121,4,2,68,81,4272,4285,111,117,98,108,101,81,117,111,116,101,59,1,8220,117,111,116,101,59,1,8216,59,1,10836,4,2,99,108,4301,4306,114,59,3,55349,56490,97,115,104,5,216,1,59,4314,1,216,105,4,2,108,109,4323,4332,100,101,5,213,1,59,4330,1,213,101,115,59,1,10807,109,108,5,214,1,59,4344,1,214,101,114,4,2,66,80,4354,4380,4,2,97,114,4360,4364,114,59,1,8254,97,99,4,2,101,107,4372,4375,59,1,9182,101,116,59,1,9140,97,114,101,110,116,104,101,115,105,115,59,1,9180,4,9,97,99,102,104,105,108,111,114,115,4413,4422,4426,4431,4435,4438,4448,4471,4561,114,116,105,97,108,68,59,1,8706,121,59,1,1055,114,59,3,55349,56595,105,59,1,934,59,1,928,117,115,77,105,110,117,115,59,1,177,4,2,105,112,4454,4467,110,99,97,114,101,112,108,97,110,101,59,1,8460,102,59,1,8473,4,4,59,101,105,111,4481,4483,4526,4531,1,10939,99,101,100,101,115,4,4,59,69,83,84,4498,4500,4507,4519,1,8826,113,117,97,108,59,1,10927,108,97,110,116,69,113,117,97,108,59,1,8828,105,108,100,101,59,1,8830,109,101,59,1,8243,4,2,100,112,4537,4543,117,99,116,59,1,8719,111,114,116,105,111,110,4,2,59,97,4555,4557,1,8759,108,59,1,8733,4,2,99,105,4567,4572,114,59,3,55349,56491,59,1,936,4,4,85,102,111,115,4585,4594,4599,4604,79,84,5,34,1,59,4592,1,34,114,59,3,55349,56596,112,102,59,1,8474,99,114,59,3,55349,56492,4,12,66,69,97,99,101,102,104,105,111,114,115,117,4636,4642,4650,4681,4704,4763,4767,4771,5047,5069,5081,5094,97,114,114,59,1,10512,71,5,174,1,59,4648,1,174,4,3,99,110,114,4658,4664,4668,117,116,101,59,1,340,103,59,1,10219,114,4,2,59,116,4675,4677,1,8608,108,59,1,10518,4,3,97,101,121,4689,4695,4701,114,111,110,59,1,344,100,105,108,59,1,342,59,1,1056,4,2,59,118,4710,4712,1,8476,101,114,115,101,4,2,69,85,4722,4748,4,2,108,113,4728,4736,101,109,101,110,116,59,1,8715,117,105,108,105,98,114,105,117,109,59,1,8651,112,69,113,117,105,108,105,98,114,105,117,109,59,1,10607,114,59,1,8476,111,59,1,929,103,104,116,4,8,65,67,68,70,84,85,86,97,4792,4840,4849,4905,4912,4972,5022,5040,4,2,110,114,4798,4811,103,108,101,66,114,97,99,107,101,116,59,1,10217,114,111,119,4,3,59,66,76,4822,4824,4829,1,8594,97,114,59,1,8677,101,102,116,65,114,114,111,119,59,1,8644,101,105,108,105,110,103,59,1,8969,111,4,2,117,119,4856,4869,98,108,101,66,114,97,99,107,101,116,59,1,10215,110,4,2,84,86,4876,4887,101,101,86,101,99,116,111,114,59,1,10589,101,99,116,111,114,4,2,59,66,4898,4900,1,8642,97,114,59,1,10581,108,111,111,114,59,1,8971,4,2,101,114,4918,4944,101,4,3,59,65,86,4927,4929,4936,1,8866,114,114,111,119,59,1,8614,101,99,116,111,114,59,1,10587,105,97,110,103,108,101,4,3,59,66,69,4958,4960,4965,1,8883,97,114,59,1,10704,113,117,97,108,59,1,8885,112,4,3,68,84,86,4981,4993,5004,111,119,110,86,101,99,116,111,114,59,1,10575,101,101,86,101,99,116,111,114,59,1,10588,101,99,116,111,114,4,2,59,66,5015,5017,1,8638,97,114,59,1,10580,101,99,116,111,114,4,2,59,66,5033,5035,1,8640,97,114,59,1,10579,114,114,111,119,59,1,8658,4,2,112,117,5053,5057,102,59,1,8477,110,100,73,109,112,108,105,101,115,59,1,10608,105,103,104,116,97,114,114,111,119,59,1,8667,4,2,99,104,5087,5091,114,59,1,8475,59,1,8625,108,101,68,101,108,97,121,101,100,59,1,10740,4,13,72,79,97,99,102,104,105,109,111,113,115,116,117,5134,5150,5157,5164,5198,5203,5259,5265,5277,5283,5374,5380,5385,4,2,67,99,5140,5146,72,99,121,59,1,1065,121,59,1,1064,70,84,99,121,59,1,1068,99,117,116,101,59,1,346,4,5,59,97,101,105,121,5176,5178,5184,5190,5195,1,10940,114,111,110,59,1,352,100,105,108,59,1,350,114,99,59,1,348,59,1,1057,114,59,3,55349,56598,111,114,116,4,4,68,76,82,85,5216,5227,5238,5250,111,119,110,65,114,114,111,119,59,1,8595,101,102,116,65,114,114,111,119,59,1,8592,105,103,104,116,65,114,114,111,119,59,1,8594,112,65,114,114,111,119,59,1,8593,103,109,97,59,1,931,97,108,108,67,105,114,99,108,101,59,1,8728,112,102,59,3,55349,56650,4,2,114,117,5289,5293,116,59,1,8730,97,114,101,4,4,59,73,83,85,5306,5308,5322,5367,1,9633,110,116,101,114,115,101,99,116,105,111,110,59,1,8851,117,4,2,98,112,5329,5347,115,101,116,4,2,59,69,5338,5340,1,8847,113,117,97,108,59,1,8849,101,114,115,101,116,4,2,59,69,5358,5360,1,8848,113,117,97,108,59,1,8850,110,105,111,110,59,1,8852,99,114,59,3,55349,56494,97,114,59,1,8902,4,4,98,99,109,112,5395,5420,5475,5478,4,2,59,115,5401,5403,1,8912,101,116,4,2,59,69,5411,5413,1,8912,113,117,97,108,59,1,8838,4,2,99,104,5426,5468,101,101,100,115,4,4,59,69,83,84,5440,5442,5449,5461,1,8827,113,117,97,108,59,1,10928,108,97,110,116,69,113,117,97,108,59,1,8829,105,108,100,101,59,1,8831,84,104,97,116,59,1,8715,59,1,8721,4,3,59,101,115,5486,5488,5507,1,8913,114,115,101,116,4,2,59,69,5498,5500,1,8835,113,117,97,108,59,1,8839,101,116,59,1,8913,4,11,72,82,83,97,99,102,104,105,111,114,115,5536,5546,5552,5567,5579,5602,5607,5655,5695,5701,5711,79,82,78,5,222,1,59,5544,1,222,65,68,69,59,1,8482,4,2,72,99,5558,5563,99,121,59,1,1035,121,59,1,1062,4,2,98,117,5573,5576,59,1,9,59,1,932,4,3,97,101,121,5587,5593,5599,114,111,110,59,1,356,100,105,108,59,1,354,59,1,1058,114,59,3,55349,56599,4,2,101,105,5613,5631,4,2,114,116,5619,5627,101,102,111,114,101,59,1,8756,97,59,1,920,4,2,99,110,5637,5647,107,83,112,97,99,101,59,3,8287,8202,83,112,97,99,101,59,1,8201,108,100,101,4,4,59,69,70,84,5668,5670,5677,5688,1,8764,113,117,97,108,59,1,8771,117,108,108,69,113,117,97,108,59,1,8773,105,108,100,101,59,1,8776,112,102,59,3,55349,56651,105,112,108,101,68,111,116,59,1,8411,4,2,99,116,5717,5722,114,59,3,55349,56495,114,111,107,59,1,358,4,14,97,98,99,100,102,103,109,110,111,112,114,115,116,117,5758,5789,5805,5823,5830,5835,5846,5852,5921,5937,6089,6095,6101,6108,4,2,99,114,5764,5774,117,116,101,5,218,1,59,5772,1,218,114,4,2,59,111,5781,5783,1,8607,99,105,114,59,1,10569,114,4,2,99,101,5796,5800,121,59,1,1038,118,101,59,1,364,4,2,105,121,5811,5820,114,99,5,219,1,59,5818,1,219,59,1,1059,98,108,97,99,59,1,368,114,59,3,55349,56600,114,97,118,101,5,217,1,59,5844,1,217,97,99,114,59,1,362,4,2,100,105,5858,5905,101,114,4,2,66,80,5866,5892,4,2,97,114,5872,5876,114,59,1,95,97,99,4,2,101,107,5884,5887,59,1,9183,101,116,59,1,9141,97,114,101,110,116,104,101,115,105,115,59,1,9181,111,110,4,2,59,80,5913,5915,1,8899,108,117,115,59,1,8846,4,2,103,112,5927,5932,111,110,59,1,370,102,59,3,55349,56652,4,8,65,68,69,84,97,100,112,115,5955,5985,5996,6009,6026,6033,6044,6075,114,114,111,119,4,3,59,66,68,5967,5969,5974,1,8593,97,114,59,1,10514,111,119,110,65,114,114,111,119,59,1,8645,111,119,110,65,114,114,111,119,59,1,8597,113,117,105,108,105,98,114,105,117,109,59,1,10606,101,101,4,2,59,65,6017,6019,1,8869,114,114,111,119,59,1,8613,114,114,111,119,59,1,8657,111,119,110,97,114,114,111,119,59,1,8661,101,114,4,2,76,82,6052,6063,101,102,116,65,114,114,111,119,59,1,8598,105,103,104,116,65,114,114,111,119,59,1,8599,105,4,2,59,108,6082,6084,1,978,111,110,59,1,933,105,110,103,59,1,366,99,114,59,3,55349,56496,105,108,100,101,59,1,360,109,108,5,220,1,59,6115,1,220,4,9,68,98,99,100,101,102,111,115,118,6137,6143,6148,6152,6166,6250,6255,6261,6267,97,115,104,59,1,8875,97,114,59,1,10987,121,59,1,1042,97,115,104,4,2,59,108,6161,6163,1,8873,59,1,10982,4,2,101,114,6172,6175,59,1,8897,4,3,98,116,121,6183,6188,6238,97,114,59,1,8214,4,2,59,105,6194,6196,1,8214,99,97,108,4,4,66,76,83,84,6209,6214,6220,6231,97,114,59,1,8739,105,110,101,59,1,124,101,112,97,114,97,116,111,114,59,1,10072,105,108,100,101,59,1,8768,84,104,105,110,83,112,97,99,101,59,1,8202,114,59,3,55349,56601,112,102,59,3,55349,56653,99,114,59,3,55349,56497,100,97,115,104,59,1,8874,4,5,99,101,102,111,115,6286,6292,6298,6303,6309,105,114,99,59,1,372,100,103,101,59,1,8896,114,59,3,55349,56602,112,102,59,3,55349,56654,99,114,59,3,55349,56498,4,4,102,105,111,115,6325,6330,6333,6339,114,59,3,55349,56603,59,1,926,112,102,59,3,55349,56655,99,114,59,3,55349,56499,4,9,65,73,85,97,99,102,111,115,117,6365,6370,6375,6380,6391,6405,6410,6416,6422,99,121,59,1,1071,99,121,59,1,1031,99,121,59,1,1070,99,117,116,101,5,221,1,59,6389,1,221,4,2,105,121,6397,6402,114,99,59,1,374,59,1,1067,114,59,3,55349,56604,112,102,59,3,55349,56656,99,114,59,3,55349,56500,109,108,59,1,376,4,8,72,97,99,100,101,102,111,115,6445,6450,6457,6472,6477,6501,6505,6510,99,121,59,1,1046,99,117,116,101,59,1,377,4,2,97,121,6463,6469,114,111,110,59,1,381,59,1,1047,111,116,59,1,379,4,2,114,116,6483,6497,111,87,105,100,116,104,83,112,97,99,101,59,1,8203,97,59,1,918,114,59,1,8488,112,102,59,1,8484,99,114,59,3,55349,56501,4,16,97,98,99,101,102,103,108,109,110,111,112,114,115,116,117,119,6550,6561,6568,6612,6622,6634,6645,6672,6699,6854,6870,6923,6933,6963,6974,6983,99,117,116,101,5,225,1,59,6559,1,225,114,101,118,101,59,1,259,4,6,59,69,100,105,117,121,6582,6584,6588,6591,6600,6609,1,8766,59,3,8766,819,59,1,8767,114,99,5,226,1,59,6598,1,226,116,101,5,180,1,59,6607,1,180,59,1,1072,108,105,103,5,230,1,59,6620,1,230,4,2,59,114,6628,6630,1,8289,59,3,55349,56606,114,97,118,101,5,224,1,59,6643,1,224,4,2,101,112,6651,6667,4,2,102,112,6657,6663,115,121,109,59,1,8501,104,59,1,8501,104,97,59,1,945,4,2,97,112,6678,6692,4,2,99,108,6684,6688,114,59,1,257,103,59,1,10815,5,38,1,59,6697,1,38,4,2,100,103,6705,6737,4,5,59,97,100,115,118,6717,6719,6724,6727,6734,1,8743,110,100,59,1,10837,59,1,10844,108,111,112,101,59,1,10840,59,1,10842,4,7,59,101,108,109,114,115,122,6753,6755,6758,6762,6814,6835,6848,1,8736,59,1,10660,101,59,1,8736,115,100,4,2,59,97,6770,6772,1,8737,4,8,97,98,99,100,101,102,103,104,6790,6793,6796,6799,6802,6805,6808,6811,59,1,10664,59,1,10665,59,1,10666,59,1,10667,59,1,10668,59,1,10669,59,1,10670,59,1,10671,116,4,2,59,118,6821,6823,1,8735,98,4,2,59,100,6830,6832,1,8894,59,1,10653,4,2,112,116,6841,6845,104,59,1,8738,59,1,197,97,114,114,59,1,9084,4,2,103,112,6860,6865,111,110,59,1,261,102,59,3,55349,56658,4,7,59,69,97,101,105,111,112,6886,6888,6891,6897,6900,6904,6908,1,8776,59,1,10864,99,105,114,59,1,10863,59,1,8778,100,59,1,8779,115,59,1,39,114,111,120,4,2,59,101,6917,6919,1,8776,113,59,1,8778,105,110,103,5,229,1,59,6931,1,229,4,3,99,116,121,6941,6946,6949,114,59,3,55349,56502,59,1,42,109,112,4,2,59,101,6957,6959,1,8776,113,59,1,8781,105,108,100,101,5,227,1,59,6972,1,227,109,108,5,228,1,59,6981,1,228,4,2,99,105,6989,6997,111,110,105,110,116,59,1,8755,110,116,59,1,10769,4,16,78,97,98,99,100,101,102,105,107,108,110,111,112,114,115,117,7036,7041,7119,7135,7149,7155,7219,7224,7347,7354,7463,7489,7786,7793,7814,7866,111,116,59,1,10989,4,2,99,114,7047,7094,107,4,4,99,101,112,115,7058,7064,7073,7080,111,110,103,59,1,8780,112,115,105,108,111,110,59,1,1014,114,105,109,101,59,1,8245,105,109,4,2,59,101,7088,7090,1,8765,113,59,1,8909,4,2,118,119,7100,7105,101,101,59,1,8893,101,100,4,2,59,103,7113,7115,1,8965,101,59,1,8965,114,107,4,2,59,116,7127,7129,1,9141,98,114,107,59,1,9142,4,2,111,121,7141,7146,110,103,59,1,8780,59,1,1073,113,117,111,59,1,8222,4,5,99,109,112,114,116,7167,7181,7188,7193,7199,97,117,115,4,2,59,101,7176,7178,1,8757,59,1,8757,112,116,121,118,59,1,10672,115,105,59,1,1014,110,111,117,59,1,8492,4,3,97,104,119,7207,7210,7213,59,1,946,59,1,8502,101,101,110,59,1,8812,114,59,3,55349,56607,103,4,7,99,111,115,116,117,118,119,7241,7262,7288,7305,7328,7335,7340,4,3,97,105,117,7249,7253,7258,112,59,1,8898,114,99,59,1,9711,112,59,1,8899,4,3,100,112,116,7270,7275,7281,111,116,59,1,10752,108,117,115,59,1,10753,105,109,101,115,59,1,10754,4,2,113,116,7294,7300,99,117,112,59,1,10758,97,114,59,1,9733,114,105,97,110,103,108,101,4,2,100,117,7318,7324,111,119,110,59,1,9661,112,59,1,9651,112,108,117,115,59,1,10756,101,101,59,1,8897,101,100,103,101,59,1,8896,97,114,111,119,59,1,10509,4,3,97,107,111,7362,7436,7458,4,2,99,110,7368,7432,107,4,3,108,115,116,7377,7386,7394,111,122,101,110,103,101,59,1,10731,113,117,97,114,101,59,1,9642,114,105,97,110,103,108,101,4,4,59,100,108,114,7411,7413,7419,7425,1,9652,111,119,110,59,1,9662,101,102,116,59,1,9666,105,103,104,116,59,1,9656,107,59,1,9251,4,2,49,51,7442,7454,4,2,50,52,7448,7451,59,1,9618,59,1,9617,52,59,1,9619,99,107,59,1,9608,4,2,101,111,7469,7485,4,2,59,113,7475,7478,3,61,8421,117,105,118,59,3,8801,8421,116,59,1,8976,4,4,112,116,119,120,7499,7504,7517,7523,102,59,3,55349,56659,4,2,59,116,7510,7512,1,8869,111,109,59,1,8869,116,105,101,59,1,8904,4,12,68,72,85,86,98,100,104,109,112,116,117,118,7549,7571,7597,7619,7655,7660,7682,7708,7715,7721,7728,7750,4,4,76,82,108,114,7559,7562,7565,7568,59,1,9559,59,1,9556,59,1,9558,59,1,9555,4,5,59,68,85,100,117,7583,7585,7588,7591,7594,1,9552,59,1,9574,59,1,9577,59,1,9572,59,1,9575,4,4,76,82,108,114,7607,7610,7613,7616,59,1,9565,59,1,9562,59,1,9564,59,1,9561,4,7,59,72,76,82,104,108,114,7635,7637,7640,7643,7646,7649,7652,1,9553,59,1,9580,59,1,9571,59,1,9568,59,1,9579,59,1,9570,59,1,9567,111,120,59,1,10697,4,4,76,82,108,114,7670,7673,7676,7679,59,1,9557,59,1,9554,59,1,9488,59,1,9484,4,5,59,68,85,100,117,7694,7696,7699,7702,7705,1,9472,59,1,9573,59,1,9576,59,1,9516,59,1,9524,105,110,117,115,59,1,8863,108,117,115,59,1,8862,105,109,101,115,59,1,8864,4,4,76,82,108,114,7738,7741,7744,7747,59,1,9563,59,1,9560,59,1,9496,59,1,9492,4,7,59,72,76,82,104,108,114,7766,7768,7771,7774,7777,7780,7783,1,9474,59,1,9578,59,1,9569,59,1,9566,59,1,9532,59,1,9508,59,1,9500,114,105,109,101,59,1,8245,4,2,101,118,7799,7804,118,101,59,1,728,98,97,114,5,166,1,59,7812,1,166,4,4,99,101,105,111,7824,7829,7834,7846,114,59,3,55349,56503,109,105,59,1,8271,109,4,2,59,101,7841,7843,1,8765,59,1,8909,108,4,3,59,98,104,7855,7857,7860,1,92,59,1,10693,115,117,98,59,1,10184,4,2,108,109,7872,7885,108,4,2,59,101,7879,7881,1,8226,116,59,1,8226,112,4,3,59,69,101,7894,7896,7899,1,8782,59,1,10926,4,2,59,113,7905,7907,1,8783,59,1,8783,4,15,97,99,100,101,102,104,105,108,111,114,115,116,117,119,121,7942,8021,8075,8080,8121,8126,8157,8279,8295,8430,8446,8485,8491,8707,8726,4,3,99,112,114,7950,7956,8007,117,116,101,59,1,263,4,6,59,97,98,99,100,115,7970,7972,7977,7984,7998,8003,1,8745,110,100,59,1,10820,114,99,117,112,59,1,10825,4,2,97,117,7990,7994,112,59,1,10827,112,59,1,10823,111,116,59,1,10816,59,3,8745,65024,4,2,101,111,8013,8017,116,59,1,8257,110,59,1,711,4,4,97,101,105,117,8031,8046,8056,8061,4,2,112,114,8037,8041,115,59,1,10829,111,110,59,1,269,100,105,108,5,231,1,59,8054,1,231,114,99,59,1,265,112,115,4,2,59,115,8069,8071,1,10828,109,59,1,10832,111,116,59,1,267,4,3,100,109,110,8088,8097,8104,105,108,5,184,1,59,8095,1,184,112,116,121,118,59,1,10674,116,5,162,2,59,101,8112,8114,1,162,114,100,111,116,59,1,183,114,59,3,55349,56608,4,3,99,101,105,8134,8138,8154,121,59,1,1095,99,107,4,2,59,109,8146,8148,1,10003,97,114,107,59,1,10003,59,1,967,114,4,7,59,69,99,101,102,109,115,8174,8176,8179,8258,8261,8268,8273,1,9675,59,1,10691,4,3,59,101,108,8187,8189,8193,1,710,113,59,1,8791,101,4,2,97,100,8200,8223,114,114,111,119,4,2,108,114,8210,8216,101,102,116,59,1,8634,105,103,104,116,59,1,8635,4,5,82,83,97,99,100,8235,8238,8241,8246,8252,59,1,174,59,1,9416,115,116,59,1,8859,105,114,99,59,1,8858,97,115,104,59,1,8861,59,1,8791,110,105,110,116,59,1,10768,105,100,59,1,10991,99,105,114,59,1,10690,117,98,115,4,2,59,117,8288,8290,1,9827,105,116,59,1,9827,4,4,108,109,110,112,8305,8326,8376,8400,111,110,4,2,59,101,8313,8315,1,58,4,2,59,113,8321,8323,1,8788,59,1,8788,4,2,109,112,8332,8344,97,4,2,59,116,8339,8341,1,44,59,1,64,4,3,59,102,108,8352,8354,8358,1,8705,110,59,1,8728,101,4,2,109,120,8365,8371,101,110,116,59,1,8705,101,115,59,1,8450,4,2,103,105,8382,8395,4,2,59,100,8388,8390,1,8773,111,116,59,1,10861,110,116,59,1,8750,4,3,102,114,121,8408,8412,8417,59,3,55349,56660,111,100,59,1,8720,5,169,2,59,115,8424,8426,1,169,114,59,1,8471,4,2,97,111,8436,8441,114,114,59,1,8629,115,115,59,1,10007,4,2,99,117,8452,8457,114,59,3,55349,56504,4,2,98,112,8463,8474,4,2,59,101,8469,8471,1,10959,59,1,10961,4,2,59,101,8480,8482,1,10960,59,1,10962,100,111,116,59,1,8943,4,7,100,101,108,112,114,118,119,8507,8522,8536,8550,8600,8697,8702,97,114,114,4,2,108,114,8516,8519,59,1,10552,59,1,10549,4,2,112,115,8528,8532,114,59,1,8926,99,59,1,8927,97,114,114,4,2,59,112,8545,8547,1,8630,59,1,10557,4,6,59,98,99,100,111,115,8564,8566,8573,8587,8592,8596,1,8746,114,99,97,112,59,1,10824,4,2,97,117,8579,8583,112,59,1,10822,112,59,1,10826,111,116,59,1,8845,114,59,1,10821,59,3,8746,65024,4,4,97,108,114,118,8610,8623,8663,8672,114,114,4,2,59,109,8618,8620,1,8631,59,1,10556,121,4,3,101,118,119,8632,8651,8656,113,4,2,112,115,8639,8645,114,101,99,59,1,8926,117,99,99,59,1,8927,101,101,59,1,8910,101,100,103,101,59,1,8911,101,110,5,164,1,59,8670,1,164,101,97,114,114,111,119,4,2,108,114,8684,8690,101,102,116,59,1,8630,105,103,104,116,59,1,8631,101,101,59,1,8910,101,100,59,1,8911,4,2,99,105,8713,8721,111,110,105,110,116,59,1,8754,110,116,59,1,8753,108,99,116,121,59,1,9005,4,19,65,72,97,98,99,100,101,102,104,105,106,108,111,114,115,116,117,119,122,8773,8778,8783,8821,8839,8854,8887,8914,8930,8944,9036,9041,9058,9197,9227,9258,9281,9297,9305,114,114,59,1,8659,97,114,59,1,10597,4,4,103,108,114,115,8793,8799,8805,8809,103,101,114,59,1,8224,101,116,104,59,1,8504,114,59,1,8595,104,4,2,59,118,8816,8818,1,8208,59,1,8867,4,2,107,108,8827,8834,97,114,111,119,59,1,10511,97,99,59,1,733,4,2,97,121,8845,8851,114,111,110,59,1,271,59,1,1076,4,3,59,97,111,8862,8864,8880,1,8518,4,2,103,114,8870,8876,103,101,114,59,1,8225,114,59,1,8650,116,115,101,113,59,1,10871,4,3,103,108,109,8895,8902,8907,5,176,1,59,8900,1,176,116,97,59,1,948,112,116,121,118,59,1,10673,4,2,105,114,8920,8926,115,104,116,59,1,10623,59,3,55349,56609,97,114,4,2,108,114,8938,8941,59,1,8643,59,1,8642,4,5,97,101,103,115,118,8956,8986,8989,8996,9001,109,4,3,59,111,115,8965,8967,8983,1,8900,110,100,4,2,59,115,8975,8977,1,8900,117,105,116,59,1,9830,59,1,9830,59,1,168,97,109,109,97,59,1,989,105,110,59,1,8946,4,3,59,105,111,9009,9011,9031,1,247,100,101,5,247,2,59,111,9020,9022,1,247,110,116,105,109,101,115,59,1,8903,110,120,59,1,8903,99,121,59,1,1106,99,4,2,111,114,9048,9053,114,110,59,1,8990,111,112,59,1,8973,4,5,108,112,116,117,119,9070,9076,9081,9130,9144,108,97,114,59,1,36,102,59,3,55349,56661,4,5,59,101,109,112,115,9093,9095,9109,9116,9122,1,729,113,4,2,59,100,9102,9104,1,8784,111,116,59,1,8785,105,110,117,115,59,1,8760,108,117,115,59,1,8724,113,117,97,114,101,59,1,8865,98,108,101,98,97,114,119,101,100,103,101,59,1,8966,110,4,3,97,100,104,9153,9160,9172,114,114,111,119,59,1,8595,111,119,110,97,114,114,111,119,115,59,1,8650,97,114,112,111,111,110,4,2,108,114,9184,9190,101,102,116,59,1,8643,105,103,104,116,59,1,8642,4,2,98,99,9203,9211,107,97,114,111,119,59,1,10512,4,2,111,114,9217,9222,114,110,59,1,8991,111,112,59,1,8972,4,3,99,111,116,9235,9248,9252,4,2,114,121,9241,9245,59,3,55349,56505,59,1,1109,108,59,1,10742,114,111,107,59,1,273,4,2,100,114,9264,9269,111,116,59,1,8945,105,4,2,59,102,9276,9278,1,9663,59,1,9662,4,2,97,104,9287,9292,114,114,59,1,8693,97,114,59,1,10607,97,110,103,108,101,59,1,10662,4,2,99,105,9311,9315,121,59,1,1119,103,114,97,114,114,59,1,10239,4,18,68,97,99,100,101,102,103,108,109,110,111,112,113,114,115,116,117,120,9361,9376,9398,9439,9444,9447,9462,9495,9531,9585,9598,9614,9659,9755,9771,9792,9808,9826,4,2,68,111,9367,9372,111,116,59,1,10871,116,59,1,8785,4,2,99,115,9382,9392,117,116,101,5,233,1,59,9390,1,233,116,101,114,59,1,10862,4,4,97,105,111,121,9408,9414,9430,9436,114,111,110,59,1,283,114,4,2,59,99,9421,9423,1,8790,5,234,1,59,9428,1,234,108,111,110,59,1,8789,59,1,1101,111,116,59,1,279,59,1,8519,4,2,68,114,9453,9458,111,116,59,1,8786,59,3,55349,56610,4,3,59,114,115,9470,9472,9482,1,10906,97,118,101,5,232,1,59,9480,1,232,4,2,59,100,9488,9490,1,10902,111,116,59,1,10904,4,4,59,105,108,115,9505,9507,9515,9518,1,10905,110,116,101,114,115,59,1,9191,59,1,8467,4,2,59,100,9524,9526,1,10901,111,116,59,1,10903,4,3,97,112,115,9539,9544,9564,99,114,59,1,275,116,121,4,3,59,115,118,9554,9556,9561,1,8709,101,116,59,1,8709,59,1,8709,112,4,2,49,59,9571,9583,4,2,51,52,9577,9580,59,1,8196,59,1,8197,1,8195,4,2,103,115,9591,9594,59,1,331,112,59,1,8194,4,2,103,112,9604,9609,111,110,59,1,281,102,59,3,55349,56662,4,3,97,108,115,9622,9635,9640,114,4,2,59,115,9629,9631,1,8917,108,59,1,10723,117,115,59,1,10865,105,4,3,59,108,118,9649,9651,9656,1,949,111,110,59,1,949,59,1,1013,4,4,99,115,117,118,9669,9686,9716,9747,4,2,105,111,9675,9680,114,99,59,1,8790,108,111,110,59,1,8789,4,2,105,108,9692,9696,109,59,1,8770,97,110,116,4,2,103,108,9705,9710,116,114,59,1,10902,101,115,115,59,1,10901,4,3,97,101,105,9724,9729,9734,108,115,59,1,61,115,116,59,1,8799,118,4,2,59,68,9741,9743,1,8801,68,59,1,10872,112,97,114,115,108,59,1,10725,4,2,68,97,9761,9766,111,116,59,1,8787,114,114,59,1,10609,4,3,99,100,105,9779,9783,9788,114,59,1,8495,111,116,59,1,8784,109,59,1,8770,4,2,97,104,9798,9801,59,1,951,5,240,1,59,9806,1,240,4,2,109,114,9814,9822,108,5,235,1,59,9820,1,235,111,59,1,8364,4,3,99,105,112,9834,9838,9843,108,59,1,33,115,116,59,1,8707,4,2,101,111,9849,9859,99,116,97,116,105,111,110,59,1,8496,110,101,110,116,105,97,108,101,59,1,8519,4,12,97,99,101,102,105,106,108,110,111,112,114,115,9896,9910,9914,9921,9954,9960,9967,9989,9994,10027,10036,10164,108,108,105,110,103,100,111,116,115,101,113,59,1,8786,121,59,1,1092,109,97,108,101,59,1,9792,4,3,105,108,114,9929,9935,9950,108,105,103,59,1,64259,4,2,105,108,9941,9945,103,59,1,64256,105,103,59,1,64260,59,3,55349,56611,108,105,103,59,1,64257,108,105,103,59,3,102,106,4,3,97,108,116,9975,9979,9984,116,59,1,9837,105,103,59,1,64258,110,115,59,1,9649,111,102,59,1,402,4,2,112,114,10000,10005,102,59,3,55349,56663,4,2,97,107,10011,10016,108,108,59,1,8704,4,2,59,118,10022,10024,1,8916,59,1,10969,97,114,116,105,110,116,59,1,10765,4,2,97,111,10042,10159,4,2,99,115,10048,10155,4,6,49,50,51,52,53,55,10062,10102,10114,10135,10139,10151,4,6,50,51,52,53,54,56,10076,10083,10086,10093,10096,10099,5,189,1,59,10081,1,189,59,1,8531,5,188,1,59,10091,1,188,59,1,8533,59,1,8537,59,1,8539,4,2,51,53,10108,10111,59,1,8532,59,1,8534,4,3,52,53,56,10122,10129,10132,5,190,1,59,10127,1,190,59,1,8535,59,1,8540,53,59,1,8536,4,2,54,56,10145,10148,59,1,8538,59,1,8541,56,59,1,8542,108,59,1,8260,119,110,59,1,8994,99,114,59,3,55349,56507,4,17,69,97,98,99,100,101,102,103,105,106,108,110,111,114,115,116,118,10206,10217,10247,10254,10268,10273,10358,10363,10374,10380,10385,10406,10458,10464,10470,10497,10610,4,2,59,108,10212,10214,1,8807,59,1,10892,4,3,99,109,112,10225,10231,10244,117,116,101,59,1,501,109,97,4,2,59,100,10239,10241,1,947,59,1,989,59,1,10886,114,101,118,101,59,1,287,4,2,105,121,10260,10265,114,99,59,1,285,59,1,1075,111,116,59,1,289,4,4,59,108,113,115,10283,10285,10288,10308,1,8805,59,1,8923,4,3,59,113,115,10296,10298,10301,1,8805,59,1,8807,108,97,110,116,59,1,10878,4,4,59,99,100,108,10318,10320,10324,10345,1,10878,99,59,1,10921,111,116,4,2,59,111,10332,10334,1,10880,4,2,59,108,10340,10342,1,10882,59,1,10884,4,2,59,101,10351,10354,3,8923,65024,115,59,1,10900,114,59,3,55349,56612,4,2,59,103,10369,10371,1,8811,59,1,8921,109,101,108,59,1,8503,99,121,59,1,1107,4,4,59,69,97,106,10395,10397,10400,10403,1,8823,59,1,10898,59,1,10917,59,1,10916,4,4,69,97,101,115,10416,10419,10434,10453,59,1,8809,112,4,2,59,112,10426,10428,1,10890,114,111,120,59,1,10890,4,2,59,113,10440,10442,1,10888,4,2,59,113,10448,10450,1,10888,59,1,8809,105,109,59,1,8935,112,102,59,3,55349,56664,97,118,101,59,1,96,4,2,99,105,10476,10480,114,59,1,8458,109,4,3,59,101,108,10489,10491,10494,1,8819,59,1,10894,59,1,10896,5,62,6,59,99,100,108,113,114,10512,10514,10527,10532,10538,10545,1,62,4,2,99,105,10520,10523,59,1,10919,114,59,1,10874,111,116,59,1,8919,80,97,114,59,1,10645,117,101,115,116,59,1,10876,4,5,97,100,101,108,115,10557,10574,10579,10599,10605,4,2,112,114,10563,10570,112,114,111,120,59,1,10886,114,59,1,10616,111,116,59,1,8919,113,4,2,108,113,10586,10592,101,115,115,59,1,8923,108,101,115,115,59,1,10892,101,115,115,59,1,8823,105,109,59,1,8819,4,2,101,110,10616,10626,114,116,110,101,113,113,59,3,8809,65024,69,59,3,8809,65024,4,10,65,97,98,99,101,102,107,111,115,121,10653,10658,10713,10718,10724,10760,10765,10786,10850,10875,114,114,59,1,8660,4,4,105,108,109,114,10668,10674,10678,10684,114,115,112,59,1,8202,102,59,1,189,105,108,116,59,1,8459,4,2,100,114,10690,10695,99,121,59,1,1098,4,3,59,99,119,10703,10705,10710,1,8596,105,114,59,1,10568,59,1,8621,97,114,59,1,8463,105,114,99,59,1,293,4,3,97,108,114,10732,10748,10754,114,116,115,4,2,59,117,10741,10743,1,9829,105,116,59,1,9829,108,105,112,59,1,8230,99,111,110,59,1,8889,114,59,3,55349,56613,115,4,2,101,119,10772,10779,97,114,111,119,59,1,10533,97,114,111,119,59,1,10534,4,5,97,109,111,112,114,10798,10803,10809,10839,10844,114,114,59,1,8703,116,104,116,59,1,8763,107,4,2,108,114,10816,10827,101,102,116,97,114,114,111,119,59,1,8617,105,103,104,116,97,114,114,111,119,59,1,8618,102,59,3,55349,56665,98,97,114,59,1,8213,4,3,99,108,116,10858,10863,10869,114,59,3,55349,56509,97,115,104,59,1,8463,114,111,107,59,1,295,4,2,98,112,10881,10887,117,108,108,59,1,8259,104,101,110,59,1,8208,4,15,97,99,101,102,103,105,106,109,110,111,112,113,115,116,117,10925,10936,10958,10977,10990,11001,11039,11045,11101,11192,11220,11226,11237,11285,11299,99,117,116,101,5,237,1,59,10934,1,237,4,3,59,105,121,10944,10946,10955,1,8291,114,99,5,238,1,59,10953,1,238,59,1,1080,4,2,99,120,10964,10968,121,59,1,1077,99,108,5,161,1,59,10975,1,161,4,2,102,114,10983,10986,59,1,8660,59,3,55349,56614,114,97,118,101,5,236,1,59,10999,1,236,4,4,59,105,110,111,11011,11013,11028,11034,1,8520,4,2,105,110,11019,11024,110,116,59,1,10764,116,59,1,8749,102,105,110,59,1,10716,116,97,59,1,8489,108,105,103,59,1,307,4,3,97,111,112,11053,11092,11096,4,3,99,103,116,11061,11065,11088,114,59,1,299,4,3,101,108,112,11073,11076,11082,59,1,8465,105,110,101,59,1,8464,97,114,116,59,1,8465,104,59,1,305,102,59,1,8887,101,100,59,1,437,4,5,59,99,102,111,116,11113,11115,11121,11136,11142,1,8712,97,114,101,59,1,8453,105,110,4,2,59,116,11129,11131,1,8734,105,101,59,1,10717,100,111,116,59,1,305,4,5,59,99,101,108,112,11154,11156,11161,11179,11186,1,8747,97,108,59,1,8890,4,2,103,114,11167,11173,101,114,115,59,1,8484,99,97,108,59,1,8890,97,114,104,107,59,1,10775,114,111,100,59,1,10812,4,4,99,103,112,116,11202,11206,11211,11216,121,59,1,1105,111,110,59,1,303,102,59,3,55349,56666,97,59,1,953,114,111,100,59,1,10812,117,101,115,116,5,191,1,59,11235,1,191,4,2,99,105,11243,11248,114,59,3,55349,56510,110,4,5,59,69,100,115,118,11261,11263,11266,11271,11282,1,8712,59,1,8953,111,116,59,1,8949,4,2,59,118,11277,11279,1,8948,59,1,8947,59,1,8712,4,2,59,105,11291,11293,1,8290,108,100,101,59,1,297,4,2,107,109,11305,11310,99,121,59,1,1110,108,5,239,1,59,11316,1,239,4,6,99,102,109,111,115,117,11332,11346,11351,11357,11363,11380,4,2,105,121,11338,11343,114,99,59,1,309,59,1,1081,114,59,3,55349,56615,97,116,104,59,1,567,112,102,59,3,55349,56667,4,2,99,101,11369,11374,114,59,3,55349,56511,114,99,121,59,1,1112,107,99,121,59,1,1108,4,8,97,99,102,103,104,106,111,115,11404,11418,11433,11438,11445,11450,11455,11461,112,112,97,4,2,59,118,11413,11415,1,954,59,1,1008,4,2,101,121,11424,11430,100,105,108,59,1,311,59,1,1082,114,59,3,55349,56616,114,101,101,110,59,1,312,99,121,59,1,1093,99,121,59,1,1116,112,102,59,3,55349,56668,99,114,59,3,55349,56512,4,23,65,66,69,72,97,98,99,100,101,102,103,104,106,108,109,110,111,112,114,115,116,117,118,11515,11538,11544,11555,11560,11721,11780,11818,11868,12136,12160,12171,12203,12208,12246,12275,12327,12509,12523,12569,12641,12732,12752,4,3,97,114,116,11523,11528,11532,114,114,59,1,8666,114,59,1,8656,97,105,108,59,1,10523,97,114,114,59,1,10510,4,2,59,103,11550,11552,1,8806,59,1,10891,97,114,59,1,10594,4,9,99,101,103,109,110,112,113,114,116,11580,11586,11594,11600,11606,11624,11627,11636,11694,117,116,101,59,1,314,109,112,116,121,118,59,1,10676,114,97,110,59,1,8466,98,100,97,59,1,955,103,4,3,59,100,108,11615,11617,11620,1,10216,59,1,10641,101,59,1,10216,59,1,10885,117,111,5,171,1,59,11634,1,171,114,4,8,59,98,102,104,108,112,115,116,11655,11657,11669,11673,11677,11681,11685,11690,1,8592,4,2,59,102,11663,11665,1,8676,115,59,1,10527,115,59,1,10525,107,59,1,8617,112,59,1,8619,108,59,1,10553,105,109,59,1,10611,108,59,1,8610,4,3,59,97,101,11702,11704,11709,1,10923,105,108,59,1,10521,4,2,59,115,11715,11717,1,10925,59,3,10925,65024,4,3,97,98,114,11729,11734,11739,114,114,59,1,10508,114,107,59,1,10098,4,2,97,107,11745,11758,99,4,2,101,107,11752,11755,59,1,123,59,1,91,4,2,101,115,11764,11767,59,1,10635,108,4,2,100,117,11774,11777,59,1,10639,59,1,10637,4,4,97,101,117,121,11790,11796,11811,11815,114,111,110,59,1,318,4,2,100,105,11802,11807,105,108,59,1,316,108,59,1,8968,98,59,1,123,59,1,1083,4,4,99,113,114,115,11828,11832,11845,11864,97,59,1,10550,117,111,4,2,59,114,11840,11842,1,8220,59,1,8222,4,2,100,117,11851,11857,104,97,114,59,1,10599,115,104,97,114,59,1,10571,104,59,1,8626,4,5,59,102,103,113,115,11880,11882,12008,12011,12031,1,8804,116,4,5,97,104,108,114,116,11895,11913,11935,11947,11996,114,114,111,119,4,2,59,116,11905,11907,1,8592,97,105,108,59,1,8610,97,114,112,111,111,110,4,2,100,117,11925,11931,111,119,110,59,1,8637,112,59,1,8636,101,102,116,97,114,114,111,119,115,59,1,8647,105,103,104,116,4,3,97,104,115,11959,11974,11984,114,114,111,119,4,2,59,115,11969,11971,1,8596,59,1,8646,97,114,112,111,111,110,115,59,1,8651,113,117,105,103,97,114,114,111,119,59,1,8621,104,114,101,101,116,105,109,101,115,59,1,8907,59,1,8922,4,3,59,113,115,12019,12021,12024,1,8804,59,1,8806,108,97,110,116,59,1,10877,4,5,59,99,100,103,115,12043,12045,12049,12070,12083,1,10877,99,59,1,10920,111,116,4,2,59,111,12057,12059,1,10879,4,2,59,114,12065,12067,1,10881,59,1,10883,4,2,59,101,12076,12079,3,8922,65024,115,59,1,10899,4,5,97,100,101,103,115,12095,12103,12108,12126,12131,112,112,114,111,120,59,1,10885,111,116,59,1,8918,113,4,2,103,113,12115,12120,116,114,59,1,8922,103,116,114,59,1,10891,116,114,59,1,8822,105,109,59,1,8818,4,3,105,108,114,12144,12150,12156,115,104,116,59,1,10620,111,111,114,59,1,8970,59,3,55349,56617,4,2,59,69,12166,12168,1,8822,59,1,10897,4,2,97,98,12177,12198,114,4,2,100,117,12184,12187,59,1,8637,4,2,59,108,12193,12195,1,8636,59,1,10602,108,107,59,1,9604,99,121,59,1,1113,4,5,59,97,99,104,116,12220,12222,12227,12235,12241,1,8810,114,114,59,1,8647,111,114,110,101,114,59,1,8990,97,114,100,59,1,10603,114,105,59,1,9722,4,2,105,111,12252,12258,100,111,116,59,1,320,117,115,116,4,2,59,97,12267,12269,1,9136,99,104,101,59,1,9136,4,4,69,97,101,115,12285,12288,12303,12322,59,1,8808,112,4,2,59,112,12295,12297,1,10889,114,111,120,59,1,10889,4,2,59,113,12309,12311,1,10887,4,2,59,113,12317,12319,1,10887,59,1,8808,105,109,59,1,8934,4,8,97,98,110,111,112,116,119,122,12345,12359,12364,12421,12446,12467,12474,12490,4,2,110,114,12351,12355,103,59,1,10220,114,59,1,8701,114,107,59,1,10214,103,4,3,108,109,114,12373,12401,12409,101,102,116,4,2,97,114,12382,12389,114,114,111,119,59,1,10229,105,103,104,116,97,114,114,111,119,59,1,10231,97,112,115,116,111,59,1,10236,105,103,104,116,97,114,114,111,119,59,1,10230,112,97,114,114,111,119,4,2,108,114,12433,12439,101,102,116,59,1,8619,105,103,104,116,59,1,8620,4,3,97,102,108,12454,12458,12462,114,59,1,10629,59,3,55349,56669,117,115,59,1,10797,105,109,101,115,59,1,10804,4,2,97,98,12480,12485,115,116,59,1,8727,97,114,59,1,95,4,3,59,101,102,12498,12500,12506,1,9674,110,103,101,59,1,9674,59,1,10731,97,114,4,2,59,108,12517,12519,1,40,116,59,1,10643,4,5,97,99,104,109,116,12535,12540,12548,12561,12564,114,114,59,1,8646,111,114,110,101,114,59,1,8991,97,114,4,2,59,100,12556,12558,1,8651,59,1,10605,59,1,8206,114,105,59,1,8895,4,6,97,99,104,105,113,116,12583,12589,12594,12597,12614,12635,113,117,111,59,1,8249,114,59,3,55349,56513,59,1,8624,109,4,3,59,101,103,12606,12608,12611,1,8818,59,1,10893,59,1,10895,4,2,98,117,12620,12623,59,1,91,111,4,2,59,114,12630,12632,1,8216,59,1,8218,114,111,107,59,1,322,5,60,8,59,99,100,104,105,108,113,114,12660,12662,12675,12680,12686,12692,12698,12705,1,60,4,2,99,105,12668,12671,59,1,10918,114,59,1,10873,111,116,59,1,8918,114,101,101,59,1,8907,109,101,115,59,1,8905,97,114,114,59,1,10614,117,101,115,116,59,1,10875,4,2,80,105,12711,12716,97,114,59,1,10646,4,3,59,101,102,12724,12726,12729,1,9667,59,1,8884,59,1,9666,114,4,2,100,117,12739,12746,115,104,97,114,59,1,10570,104,97,114,59,1,10598,4,2,101,110,12758,12768,114,116,110,101,113,113,59,3,8808,65024,69,59,3,8808,65024,4,14,68,97,99,100,101,102,104,105,108,110,111,112,115,117,12803,12809,12893,12908,12914,12928,12933,12937,13011,13025,13032,13049,13052,13069,68,111,116,59,1,8762,4,4,99,108,112,114,12819,12827,12849,12887,114,5,175,1,59,12825,1,175,4,2,101,116,12833,12836,59,1,9794,4,2,59,101,12842,12844,1,10016,115,101,59,1,10016,4,2,59,115,12855,12857,1,8614,116,111,4,4,59,100,108,117,12869,12871,12877,12883,1,8614,111,119,110,59,1,8615,101,102,116,59,1,8612,112,59,1,8613,107,101,114,59,1,9646,4,2,111,121,12899,12905,109,109,97,59,1,10793,59,1,1084,97,115,104,59,1,8212,97,115,117,114,101,100,97,110,103,108,101,59,1,8737,114,59,3,55349,56618,111,59,1,8487,4,3,99,100,110,12945,12954,12985,114,111,5,181,1,59,12952,1,181,4,4,59,97,99,100,12964,12966,12971,12976,1,8739,115,116,59,1,42,105,114,59,1,10992,111,116,5,183,1,59,12983,1,183,117,115,4,3,59,98,100,12995,12997,13000,1,8722,59,1,8863,4,2,59,117,13006,13008,1,8760,59,1,10794,4,2,99,100,13017,13021,112,59,1,10971,114,59,1,8230,112,108,117,115,59,1,8723,4,2,100,112,13038,13044,101,108,115,59,1,8871,102,59,3,55349,56670,59,1,8723,4,2,99,116,13058,13063,114,59,3,55349,56514,112,111,115,59,1,8766,4,3,59,108,109,13077,13079,13087,1,956,116,105,109,97,112,59,1,8888,97,112,59,1,8888,4,24,71,76,82,86,97,98,99,100,101,102,103,104,105,106,108,109,111,112,114,115,116,117,118,119,13142,13165,13217,13229,13247,13330,13359,13414,13420,13508,13513,13579,13602,13626,13631,13762,13767,13855,13936,13995,14214,14285,14312,14432,4,2,103,116,13148,13152,59,3,8921,824,4,2,59,118,13158,13161,3,8811,8402,59,3,8811,824,4,3,101,108,116,13173,13200,13204,102,116,4,2,97,114,13181,13188,114,114,111,119,59,1,8653,105,103,104,116,97,114,114,111,119,59,1,8654,59,3,8920,824,4,2,59,118,13210,13213,3,8810,8402,59,3,8810,824,105,103,104,116,97,114,114,111,119,59,1,8655,4,2,68,100,13235,13241,97,115,104,59,1,8879,97,115,104,59,1,8878,4,5,98,99,110,112,116,13259,13264,13270,13275,13308,108,97,59,1,8711,117,116,101,59,1,324,103,59,3,8736,8402,4,5,59,69,105,111,112,13287,13289,13293,13298,13302,1,8777,59,3,10864,824,100,59,3,8779,824,115,59,1,329,114,111,120,59,1,8777,117,114,4,2,59,97,13316,13318,1,9838,108,4,2,59,115,13325,13327,1,9838,59,1,8469,4,2,115,117,13336,13344,112,5,160,1,59,13342,1,160,109,112,4,2,59,101,13352,13355,3,8782,824,59,3,8783,824,4,5,97,101,111,117,121,13371,13385,13391,13407,13411,4,2,112,114,13377,13380,59,1,10819,111,110,59,1,328,100,105,108,59,1,326,110,103,4,2,59,100,13399,13401,1,8775,111,116,59,3,10861,824,112,59,1,10818,59,1,1085,97,115,104,59,1,8211,4,7,59,65,97,100,113,115,120,13436,13438,13443,13466,13472,13478,13494,1,8800,114,114,59,1,8663,114,4,2,104,114,13450,13454,107,59,1,10532,4,2,59,111,13460,13462,1,8599,119,59,1,8599,111,116,59,3,8784,824,117,105,118,59,1,8802,4,2,101,105,13484,13489,97,114,59,1,10536,109,59,3,8770,824,105,115,116,4,2,59,115,13503,13505,1,8708,59,1,8708,114,59,3,55349,56619,4,4,69,101,115,116,13523,13527,13563,13568,59,3,8807,824,4,3,59,113,115,13535,13537,13559,1,8817,4,3,59,113,115,13545,13547,13551,1,8817,59,3,8807,824,108,97,110,116,59,3,10878,824,59,3,10878,824,105,109,59,1,8821,4,2,59,114,13574,13576,1,8815,59,1,8815,4,3,65,97,112,13587,13592,13597,114,114,59,1,8654,114,114,59,1,8622,97,114,59,1,10994,4,3,59,115,118,13610,13612,13623,1,8715,4,2,59,100,13618,13620,1,8956,59,1,8954,59,1,8715,99,121,59,1,1114,4,7,65,69,97,100,101,115,116,13647,13652,13656,13661,13665,13737,13742,114,114,59,1,8653,59,3,8806,824,114,114,59,1,8602,114,59,1,8229,4,4,59,102,113,115,13675,13677,13703,13725,1,8816,116,4,2,97,114,13684,13691,114,114,111,119,59,1,8602,105,103,104,116,97,114,114,111,119,59,1,8622,4,3,59,113,115,13711,13713,13717,1,8816,59,3,8806,824,108,97,110,116,59,3,10877,824,4,2,59,115,13731,13734,3,10877,824,59,1,8814,105,109,59,1,8820,4,2,59,114,13748,13750,1,8814,105,4,2,59,101,13757,13759,1,8938,59,1,8940,105,100,59,1,8740,4,2,112,116,13773,13778,102,59,3,55349,56671,5,172,3,59,105,110,13787,13789,13829,1,172,110,4,4,59,69,100,118,13800,13802,13806,13812,1,8713,59,3,8953,824,111,116,59,3,8949,824,4,3,97,98,99,13820,13823,13826,59,1,8713,59,1,8951,59,1,8950,105,4,2,59,118,13836,13838,1,8716,4,3,97,98,99,13846,13849,13852,59,1,8716,59,1,8958,59,1,8957,4,3,97,111,114,13863,13892,13899,114,4,4,59,97,115,116,13874,13876,13883,13888,1,8742,108,108,101,108,59,1,8742,108,59,3,11005,8421,59,3,8706,824,108,105,110,116,59,1,10772,4,3,59,99,101,13907,13909,13914,1,8832,117,101,59,1,8928,4,2,59,99,13920,13923,3,10927,824,4,2,59,101,13929,13931,1,8832,113,59,3,10927,824,4,4,65,97,105,116,13946,13951,13971,13982,114,114,59,1,8655,114,114,4,3,59,99,119,13961,13963,13967,1,8603,59,3,10547,824,59,3,8605,824,103,104,116,97,114,114,111,119,59,1,8603,114,105,4,2,59,101,13990,13992,1,8939,59,1,8941,4,7,99,104,105,109,112,113,117,14011,14036,14060,14080,14085,14090,14106,4,4,59,99,101,114,14021,14023,14028,14032,1,8833,117,101,59,1,8929,59,3,10928,824,59,3,55349,56515,111,114,116,4,2,109,112,14045,14050,105,100,59,1,8740,97,114,97,108,108,101,108,59,1,8742,109,4,2,59,101,14067,14069,1,8769,4,2,59,113,14075,14077,1,8772,59,1,8772,105,100,59,1,8740,97,114,59,1,8742,115,117,4,2,98,112,14098,14102,101,59,1,8930,101,59,1,8931,4,3,98,99,112,14114,14157,14171,4,4,59,69,101,115,14124,14126,14130,14133,1,8836,59,3,10949,824,59,1,8840,101,116,4,2,59,101,14141,14144,3,8834,8402,113,4,2,59,113,14151,14153,1,8840,59,3,10949,824,99,4,2,59,101,14164,14166,1,8833,113,59,3,10928,824,4,4,59,69,101,115,14181,14183,14187,14190,1,8837,59,3,10950,824,59,1,8841,101,116,4,2,59,101,14198,14201,3,8835,8402,113,4,2,59,113,14208,14210,1,8841,59,3,10950,824,4,4,103,105,108,114,14224,14228,14238,14242,108,59,1,8825,108,100,101,5,241,1,59,14236,1,241,103,59,1,8824,105,97,110,103,108,101,4,2,108,114,14254,14269,101,102,116,4,2,59,101,14263,14265,1,8938,113,59,1,8940,105,103,104,116,4,2,59,101,14279,14281,1,8939,113,59,1,8941,4,2,59,109,14291,14293,1,957,4,3,59,101,115,14301,14303,14308,1,35,114,111,59,1,8470,112,59,1,8199,4,9,68,72,97,100,103,105,108,114,115,14332,14338,14344,14349,14355,14369,14376,14408,14426,97,115,104,59,1,8877,97,114,114,59,1,10500,112,59,3,8781,8402,97,115,104,59,1,8876,4,2,101,116,14361,14365,59,3,8805,8402,59,3,62,8402,110,102,105,110,59,1,10718,4,3,65,101,116,14384,14389,14393,114,114,59,1,10498,59,3,8804,8402,4,2,59,114,14399,14402,3,60,8402,105,101,59,3,8884,8402,4,2,65,116,14414,14419,114,114,59,1,10499,114,105,101,59,3,8885,8402,105,109,59,3,8764,8402,4,3,65,97,110,14440,14445,14468,114,114,59,1,8662,114,4,2,104,114,14452,14456,107,59,1,10531,4,2,59,111,14462,14464,1,8598,119,59,1,8598,101,97,114,59,1,10535,4,18,83,97,99,100,101,102,103,104,105,108,109,111,112,114,115,116,117,118,14512,14515,14535,14560,14597,14603,14618,14643,14657,14662,14701,14741,14747,14769,14851,14877,14907,14916,59,1,9416,4,2,99,115,14521,14531,117,116,101,5,243,1,59,14529,1,243,116,59,1,8859,4,2,105,121,14541,14557,114,4,2,59,99,14548,14550,1,8858,5,244,1,59,14555,1,244,59,1,1086,4,5,97,98,105,111,115,14572,14577,14583,14587,14591,115,104,59,1,8861,108,97,99,59,1,337,118,59,1,10808,116,59,1,8857,111,108,100,59,1,10684,108,105,103,59,1,339,4,2,99,114,14609,14614,105,114,59,1,10687,59,3,55349,56620,4,3,111,114,116,14626,14630,14640,110,59,1,731,97,118,101,5,242,1,59,14638,1,242,59,1,10689,4,2,98,109,14649,14654,97,114,59,1,10677,59,1,937,110,116,59,1,8750,4,4,97,99,105,116,14672,14677,14693,14698,114,114,59,1,8634,4,2,105,114,14683,14687,114,59,1,10686,111,115,115,59,1,10683,110,101,59,1,8254,59,1,10688,4,3,97,101,105,14709,14714,14719,99,114,59,1,333,103,97,59,1,969,4,3,99,100,110,14727,14733,14736,114,111,110,59,1,959,59,1,10678,117,115,59,1,8854,112,102,59,3,55349,56672,4,3,97,101,108,14755,14759,14764,114,59,1,10679,114,112,59,1,10681,117,115,59,1,8853,4,7,59,97,100,105,111,115,118,14785,14787,14792,14831,14837,14841,14848,1,8744,114,114,59,1,8635,4,4,59,101,102,109,14802,14804,14817,14824,1,10845,114,4,2,59,111,14811,14813,1,8500,102,59,1,8500,5,170,1,59,14822,1,170,5,186,1,59,14829,1,186,103,111,102,59,1,8886,114,59,1,10838,108,111,112,101,59,1,10839,59,1,10843,4,3,99,108,111,14859,14863,14873,114,59,1,8500,97,115,104,5,248,1,59,14871,1,248,108,59,1,8856,105,4,2,108,109,14884,14893,100,101,5,245,1,59,14891,1,245,101,115,4,2,59,97,14901,14903,1,8855,115,59,1,10806,109,108,5,246,1,59,14914,1,246,98,97,114,59,1,9021,4,12,97,99,101,102,104,105,108,109,111,114,115,117,14948,14992,14996,15033,15038,15068,15090,15189,15192,15222,15427,15441,114,4,4,59,97,115,116,14959,14961,14976,14989,1,8741,5,182,2,59,108,14968,14970,1,182,108,101,108,59,1,8741,4,2,105,108,14982,14986,109,59,1,10995,59,1,11005,59,1,8706,121,59,1,1087,114,4,5,99,105,109,112,116,15009,15014,15019,15024,15027,110,116,59,1,37,111,100,59,1,46,105,108,59,1,8240,59,1,8869,101,110,107,59,1,8241,114,59,3,55349,56621,4,3,105,109,111,15046,15057,15063,4,2,59,118,15052,15054,1,966,59,1,981,109,97,116,59,1,8499,110,101,59,1,9742,4,3,59,116,118,15076,15078,15087,1,960,99,104,102,111,114,107,59,1,8916,59,1,982,4,2,97,117,15096,15119,110,4,2,99,107,15103,15115,107,4,2,59,104,15110,15112,1,8463,59,1,8462,118,59,1,8463,115,4,9,59,97,98,99,100,101,109,115,116,15140,15142,15148,15151,15156,15168,15171,15179,15184,1,43,99,105,114,59,1,10787,59,1,8862,105,114,59,1,10786,4,2,111,117,15162,15165,59,1,8724,59,1,10789,59,1,10866,110,5,177,1,59,15177,1,177,105,109,59,1,10790,119,111,59,1,10791,59,1,177,4,3,105,112,117,15200,15208,15213,110,116,105,110,116,59,1,10773,102,59,3,55349,56673,110,100,5,163,1,59,15220,1,163,4,10,59,69,97,99,101,105,110,111,115,117,15244,15246,15249,15253,15258,15334,15347,15367,15416,15421,1,8826,59,1,10931,112,59,1,10935,117,101,59,1,8828,4,2,59,99,15264,15266,1,10927,4,6,59,97,99,101,110,115,15280,15282,15290,15299,15303,15329,1,8826,112,112,114,111,120,59,1,10935,117,114,108,121,101,113,59,1,8828,113,59,1,10927,4,3,97,101,115,15311,15319,15324,112,112,114,111,120,59,1,10937,113,113,59,1,10933,105,109,59,1,8936,105,109,59,1,8830,109,101,4,2,59,115,15342,15344,1,8242,59,1,8473,4,3,69,97,115,15355,15358,15362,59,1,10933,112,59,1,10937,105,109,59,1,8936,4,3,100,102,112,15375,15378,15404,59,1,8719,4,3,97,108,115,15386,15392,15398,108,97,114,59,1,9006,105,110,101,59,1,8978,117,114,102,59,1,8979,4,2,59,116,15410,15412,1,8733,111,59,1,8733,105,109,59,1,8830,114,101,108,59,1,8880,4,2,99,105,15433,15438,114,59,3,55349,56517,59,1,968,110,99,115,112,59,1,8200,4,6,102,105,111,112,115,117,15462,15467,15472,15478,15485,15491,114,59,3,55349,56622,110,116,59,1,10764,112,102,59,3,55349,56674,114,105,109,101,59,1,8279,99,114,59,3,55349,56518,4,3,97,101,111,15499,15520,15534,116,4,2,101,105,15506,15515,114,110,105,111,110,115,59,1,8461,110,116,59,1,10774,115,116,4,2,59,101,15528,15530,1,63,113,59,1,8799,116,5,34,1,59,15540,1,34,4,21,65,66,72,97,98,99,100,101,102,104,105,108,109,110,111,112,114,115,116,117,120,15586,15609,15615,15620,15796,15855,15893,15931,15977,16001,16039,16183,16204,16222,16228,16285,16312,16318,16363,16408,16416,4,3,97,114,116,15594,15599,15603,114,114,59,1,8667,114,59,1,8658,97,105,108,59,1,10524,97,114,114,59,1,10511,97,114,59,1,10596,4,7,99,100,101,110,113,114,116,15636,15651,15656,15664,15687,15696,15770,4,2,101,117,15642,15646,59,3,8765,817,116,101,59,1,341,105,99,59,1,8730,109,112,116,121,118,59,1,10675,103,4,4,59,100,101,108,15675,15677,15680,15683,1,10217,59,1,10642,59,1,10661,101,59,1,10217,117,111,5,187,1,59,15694,1,187,114,4,11,59,97,98,99,102,104,108,112,115,116,119,15721,15723,15727,15739,15742,15746,15750,15754,15758,15763,15767,1,8594,112,59,1,10613,4,2,59,102,15733,15735,1,8677,115,59,1,10528,59,1,10547,115,59,1,10526,107,59,1,8618,112,59,1,8620,108,59,1,10565,105,109,59,1,10612,108,59,1,8611,59,1,8605,4,2,97,105,15776,15781,105,108,59,1,10522,111,4,2,59,110,15788,15790,1,8758,97,108,115,59,1,8474,4,3,97,98,114,15804,15809,15814,114,114,59,1,10509,114,107,59,1,10099,4,2,97,107,15820,15833,99,4,2,101,107,15827,15830,59,1,125,59,1,93,4,2,101,115,15839,15842,59,1,10636,108,4,2,100,117,15849,15852,59,1,10638,59,1,10640,4,4,97,101,117,121,15865,15871,15886,15890,114,111,110,59,1,345,4,2,100,105,15877,15882,105,108,59,1,343,108,59,1,8969,98,59,1,125,59,1,1088,4,4,99,108,113,115,15903,15907,15914,15927,97,59,1,10551,100,104,97,114,59,1,10601,117,111,4,2,59,114,15922,15924,1,8221,59,1,8221,104,59,1,8627,4,3,97,99,103,15939,15966,15970,108,4,4,59,105,112,115,15950,15952,15957,15963,1,8476,110,101,59,1,8475,97,114,116,59,1,8476,59,1,8477,116,59,1,9645,5,174,1,59,15975,1,174,4,3,105,108,114,15985,15991,15997,115,104,116,59,1,10621,111,111,114,59,1,8971,59,3,55349,56623,4,2,97,111,16007,16028,114,4,2,100,117,16014,16017,59,1,8641,4,2,59,108,16023,16025,1,8640,59,1,10604,4,2,59,118,16034,16036,1,961,59,1,1009,4,3,103,110,115,16047,16167,16171,104,116,4,6,97,104,108,114,115,116,16063,16081,16103,16130,16143,16155,114,114,111,119,4,2,59,116,16073,16075,1,8594,97,105,108,59,1,8611,97,114,112,111,111,110,4,2,100,117,16093,16099,111,119,110,59,1,8641,112,59,1,8640,101,102,116,4,2,97,104,16112,16120,114,114,111,119,115,59,1,8644,97,114,112,111,111,110,115,59,1,8652,105,103,104,116,97,114,114,111,119,115,59,1,8649,113,117,105,103,97,114,114,111,119,59,1,8605,104,114,101,101,116,105,109,101,115,59,1,8908,103,59,1,730,105,110,103,100,111,116,115,101,113,59,1,8787,4,3,97,104,109,16191,16196,16201,114,114,59,1,8644,97,114,59,1,8652,59,1,8207,111,117,115,116,4,2,59,97,16214,16216,1,9137,99,104,101,59,1,9137,109,105,100,59,1,10990,4,4,97,98,112,116,16238,16252,16257,16278,4,2,110,114,16244,16248,103,59,1,10221,114,59,1,8702,114,107,59,1,10215,4,3,97,102,108,16265,16269,16273,114,59,1,10630,59,3,55349,56675,117,115,59,1,10798,105,109,101,115,59,1,10805,4,2,97,112,16291,16304,114,4,2,59,103,16298,16300,1,41,116,59,1,10644,111,108,105,110,116,59,1,10770,97,114,114,59,1,8649,4,4,97,99,104,113,16328,16334,16339,16342,113,117,111,59,1,8250,114,59,3,55349,56519,59,1,8625,4,2,98,117,16348,16351,59,1,93,111,4,2,59,114,16358,16360,1,8217,59,1,8217,4,3,104,105,114,16371,16377,16383,114,101,101,59,1,8908,109,101,115,59,1,8906,105,4,4,59,101,102,108,16394,16396,16399,16402,1,9657,59,1,8885,59,1,9656,116,114,105,59,1,10702,108,117,104,97,114,59,1,10600,59,1,8478,4,19,97,98,99,100,101,102,104,105,108,109,111,112,113,114,115,116,117,119,122,16459,16466,16472,16572,16590,16672,16687,16746,16844,16850,16924,16963,16988,17115,17121,17154,17206,17614,17656,99,117,116,101,59,1,347,113,117,111,59,1,8218,4,10,59,69,97,99,101,105,110,112,115,121,16494,16496,16499,16513,16518,16531,16536,16556,16564,16569,1,8827,59,1,10932,4,2,112,114,16505,16508,59,1,10936,111,110,59,1,353,117,101,59,1,8829,4,2,59,100,16524,16526,1,10928,105,108,59,1,351,114,99,59,1,349,4,3,69,97,115,16544,16547,16551,59,1,10934,112,59,1,10938,105,109,59,1,8937,111,108,105,110,116,59,1,10771,105,109,59,1,8831,59,1,1089,111,116,4,3,59,98,101,16582,16584,16587,1,8901,59,1,8865,59,1,10854,4,7,65,97,99,109,115,116,120,16606,16611,16634,16642,16646,16652,16668,114,114,59,1,8664,114,4,2,104,114,16618,16622,107,59,1,10533,4,2,59,111,16628,16630,1,8600,119,59,1,8600,116,5,167,1,59,16640,1,167,105,59,1,59,119,97,114,59,1,10537,109,4,2,105,110,16659,16665,110,117,115,59,1,8726,59,1,8726,116,59,1,10038,114,4,2,59,111,16679,16682,3,55349,56624,119,110,59,1,8994,4,4,97,99,111,121,16697,16702,16716,16739,114,112,59,1,9839,4,2,104,121,16708,16713,99,121,59,1,1097,59,1,1096,114,116,4,2,109,112,16724,16729,105,100,59,1,8739,97,114,97,108,108,101,108,59,1,8741,5,173,1,59,16744,1,173,4,2,103,109,16752,16770,109,97,4,3,59,102,118,16762,16764,16767,1,963,59,1,962,59,1,962,4,8,59,100,101,103,108,110,112,114,16788,16790,16795,16806,16817,16828,16832,16838,1,8764,111,116,59,1,10858,4,2,59,113,16801,16803,1,8771,59,1,8771,4,2,59,69,16812,16814,1,10910,59,1,10912,4,2,59,69,16823,16825,1,10909,59,1,10911,101,59,1,8774,108,117,115,59,1,10788,97,114,114,59,1,10610,97,114,114,59,1,8592,4,4,97,101,105,116,16860,16883,16891,16904,4,2,108,115,16866,16878,108,115,101,116,109,105,110,117,115,59,1,8726,104,112,59,1,10803,112,97,114,115,108,59,1,10724,4,2,100,108,16897,16900,59,1,8739,101,59,1,8995,4,2,59,101,16910,16912,1,10922,4,2,59,115,16918,16920,1,10924,59,3,10924,65024,4,3,102,108,112,16932,16938,16958,116,99,121,59,1,1100,4,2,59,98,16944,16946,1,47,4,2,59,97,16952,16954,1,10692,114,59,1,9023,102,59,3,55349,56676,97,4,2,100,114,16970,16985,101,115,4,2,59,117,16978,16980,1,9824,105,116,59,1,9824,59,1,8741,4,3,99,115,117,16996,17028,17089,4,2,97,117,17002,17015,112,4,2,59,115,17009,17011,1,8851,59,3,8851,65024,112,4,2,59,115,17022,17024,1,8852,59,3,8852,65024,117,4,2,98,112,17035,17062,4,3,59,101,115,17043,17045,17048,1,8847,59,1,8849,101,116,4,2,59,101,17056,17058,1,8847,113,59,1,8849,4,3,59,101,115,17070,17072,17075,1,8848,59,1,8850,101,116,4,2,59,101,17083,17085,1,8848,113,59,1,8850,4,3,59,97,102,17097,17099,17112,1,9633,114,4,2,101,102,17106,17109,59,1,9633,59,1,9642,59,1,9642,97,114,114,59,1,8594,4,4,99,101,109,116,17131,17136,17142,17148,114,59,3,55349,56520,116,109,110,59,1,8726,105,108,101,59,1,8995,97,114,102,59,1,8902,4,2,97,114,17160,17172,114,4,2,59,102,17167,17169,1,9734,59,1,9733,4,2,97,110,17178,17202,105,103,104,116,4,2,101,112,17188,17197,112,115,105,108,111,110,59,1,1013,104,105,59,1,981,115,59,1,175,4,5,98,99,109,110,112,17218,17351,17420,17423,17427,4,9,59,69,100,101,109,110,112,114,115,17238,17240,17243,17248,17261,17267,17279,17285,17291,1,8834,59,1,10949,111,116,59,1,10941,4,2,59,100,17254,17256,1,8838,111,116,59,1,10947,117,108,116,59,1,10945,4,2,69,101,17273,17276,59,1,10955,59,1,8842,108,117,115,59,1,10943,97,114,114,59,1,10617,4,3,101,105,117,17299,17335,17339,116,4,3,59,101,110,17308,17310,17322,1,8834,113,4,2,59,113,17317,17319,1,8838,59,1,10949,101,113,4,2,59,113,17330,17332,1,8842,59,1,10955,109,59,1,10951,4,2,98,112,17345,17348,59,1,10965,59,1,10963,99,4,6,59,97,99,101,110,115,17366,17368,17376,17385,17389,17415,1,8827,112,112,114,111,120,59,1,10936,117,114,108,121,101,113,59,1,8829,113,59,1,10928,4,3,97,101,115,17397,17405,17410,112,112,114,111,120,59,1,10938,113,113,59,1,10934,105,109,59,1,8937,105,109,59,1,8831,59,1,8721,103,59,1,9834,4,13,49,50,51,59,69,100,101,104,108,109,110,112,115,17455,17462,17469,17476,17478,17481,17496,17509,17524,17530,17536,17548,17554,5,185,1,59,17460,1,185,5,178,1,59,17467,1,178,5,179,1,59,17474,1,179,1,8835,59,1,10950,4,2,111,115,17487,17491,116,59,1,10942,117,98,59,1,10968,4,2,59,100,17502,17504,1,8839,111,116,59,1,10948,115,4,2,111,117,17516,17520,108,59,1,10185,98,59,1,10967,97,114,114,59,1,10619,117,108,116,59,1,10946,4,2,69,101,17542,17545,59,1,10956,59,1,8843,108,117,115,59,1,10944,4,3,101,105,117,17562,17598,17602,116,4,3,59,101,110,17571,17573,17585,1,8835,113,4,2,59,113,17580,17582,1,8839,59,1,10950,101,113,4,2,59,113,17593,17595,1,8843,59,1,10956,109,59,1,10952,4,2,98,112,17608,17611,59,1,10964,59,1,10966,4,3,65,97,110,17622,17627,17650,114,114,59,1,8665,114,4,2,104,114,17634,17638,107,59,1,10534,4,2,59,111,17644,17646,1,8601,119,59,1,8601,119,97,114,59,1,10538,108,105,103,5,223,1,59,17664,1,223,4,13,97,98,99,100,101,102,104,105,111,112,114,115,119,17694,17709,17714,17737,17742,17749,17754,17860,17905,17957,17964,18090,18122,4,2,114,117,17700,17706,103,101,116,59,1,8982,59,1,964,114,107,59,1,9140,4,3,97,101,121,17722,17728,17734,114,111,110,59,1,357,100,105,108,59,1,355,59,1,1090,111,116,59,1,8411,108,114,101,99,59,1,8981,114,59,3,55349,56625,4,4,101,105,107,111,17764,17805,17836,17851,4,2,114,116,17770,17786,101,4,2,52,102,17777,17780,59,1,8756,111,114,101,59,1,8756,97,4,3,59,115,118,17795,17797,17802,1,952,121,109,59,1,977,59,1,977,4,2,99,110,17811,17831,107,4,2,97,115,17818,17826,112,112,114,111,120,59,1,8776,105,109,59,1,8764,115,112,59,1,8201,4,2,97,115,17842,17846,112,59,1,8776,105,109,59,1,8764,114,110,5,254,1,59,17858,1,254,4,3,108,109,110,17868,17873,17901,100,101,59,1,732,101,115,5,215,3,59,98,100,17884,17886,17898,1,215,4,2,59,97,17892,17894,1,8864,114,59,1,10801,59,1,10800,116,59,1,8749,4,3,101,112,115,17913,17917,17953,97,59,1,10536,4,4,59,98,99,102,17927,17929,17934,17939,1,8868,111,116,59,1,9014,105,114,59,1,10993,4,2,59,111,17945,17948,3,55349,56677,114,107,59,1,10970,97,59,1,10537,114,105,109,101,59,1,8244,4,3,97,105,112,17972,17977,18082,100,101,59,1,8482,4,7,97,100,101,109,112,115,116,17993,18051,18056,18059,18066,18072,18076,110,103,108,101,4,5,59,100,108,113,114,18009,18011,18017,18032,18035,1,9653,111,119,110,59,1,9663,101,102,116,4,2,59,101,18026,18028,1,9667,113,59,1,8884,59,1,8796,105,103,104,116,4,2,59,101,18045,18047,1,9657,113,59,1,8885,111,116,59,1,9708,59,1,8796,105,110,117,115,59,1,10810,108,117,115,59,1,10809,98,59,1,10701,105,109,101,59,1,10811,101,122,105,117,109,59,1,9186,4,3,99,104,116,18098,18111,18116,4,2,114,121,18104,18108,59,3,55349,56521,59,1,1094,99,121,59,1,1115,114,111,107,59,1,359,4,2,105,111,18128,18133,120,116,59,1,8812,104,101,97,100,4,2,108,114,18143,18154,101,102,116,97,114,114,111,119,59,1,8606,105,103,104,116,97,114,114,111,119,59,1,8608,4,18,65,72,97,98,99,100,102,103,104,108,109,111,112,114,115,116,117,119,18204,18209,18214,18234,18250,18268,18292,18308,18319,18343,18379,18397,18413,18504,18547,18553,18584,18603,114,114,59,1,8657,97,114,59,1,10595,4,2,99,114,18220,18230,117,116,101,5,250,1,59,18228,1,250,114,59,1,8593,114,4,2,99,101,18241,18245,121,59,1,1118,118,101,59,1,365,4,2,105,121,18256,18265,114,99,5,251,1,59,18263,1,251,59,1,1091,4,3,97,98,104,18276,18281,18287,114,114,59,1,8645,108,97,99,59,1,369,97,114,59,1,10606,4,2,105,114,18298,18304,115,104,116,59,1,10622,59,3,55349,56626,114,97,118,101,5,249,1,59,18317,1,249,4,2,97,98,18325,18338,114,4,2,108,114,18332,18335,59,1,8639,59,1,8638,108,107,59,1,9600,4,2,99,116,18349,18374,4,2,111,114,18355,18369,114,110,4,2,59,101,18363,18365,1,8988,114,59,1,8988,111,112,59,1,8975,114,105,59,1,9720,4,2,97,108,18385,18390,99,114,59,1,363,5,168,1,59,18395,1,168,4,2,103,112,18403,18408,111,110,59,1,371,102,59,3,55349,56678,4,6,97,100,104,108,115,117,18427,18434,18445,18470,18475,18494,114,114,111,119,59,1,8593,111,119,110,97,114,114,111,119,59,1,8597,97,114,112,111,111,110,4,2,108,114,18457,18463,101,102,116,59,1,8639,105,103,104,116,59,1,8638,117,115,59,1,8846,105,4,3,59,104,108,18484,18486,18489,1,965,59,1,978,111,110,59,1,965,112,97,114,114,111,119,115,59,1,8648,4,3,99,105,116,18512,18537,18542,4,2,111,114,18518,18532,114,110,4,2,59,101,18526,18528,1,8989,114,59,1,8989,111,112,59,1,8974,110,103,59,1,367,114,105,59,1,9721,99,114,59,3,55349,56522,4,3,100,105,114,18561,18566,18572,111,116,59,1,8944,108,100,101,59,1,361,105,4,2,59,102,18579,18581,1,9653,59,1,9652,4,2,97,109,18590,18595,114,114,59,1,8648,108,5,252,1,59,18601,1,252,97,110,103,108,101,59,1,10663,4,15,65,66,68,97,99,100,101,102,108,110,111,112,114,115,122,18643,18648,18661,18667,18847,18851,18857,18904,18909,18915,18931,18937,18943,18949,18996,114,114,59,1,8661,97,114,4,2,59,118,18656,18658,1,10984,59,1,10985,97,115,104,59,1,8872,4,2,110,114,18673,18679,103,114,116,59,1,10652,4,7,101,107,110,112,114,115,116,18695,18704,18711,18720,18742,18754,18810,112,115,105,108,111,110,59,1,1013,97,112,112,97,59,1,1008,111,116,104,105,110,103,59,1,8709,4,3,104,105,114,18728,18732,18735,105,59,1,981,59,1,982,111,112,116,111,59,1,8733,4,2,59,104,18748,18750,1,8597,111,59,1,1009,4,2,105,117,18760,18766,103,109,97,59,1,962,4,2,98,112,18772,18791,115,101,116,110,101,113,4,2,59,113,18784,18787,3,8842,65024,59,3,10955,65024,115,101,116,110,101,113,4,2,59,113,18803,18806,3,8843,65024,59,3,10956,65024,4,2,104,114,18816,18822,101,116,97,59,1,977,105,97,110,103,108,101,4,2,108,114,18834,18840,101,102,116,59,1,8882,105,103,104,116,59,1,8883,121,59,1,1074,97,115,104,59,1,8866,4,3,101,108,114,18865,18884,18890,4,3,59,98,101,18873,18875,18880,1,8744,97,114,59,1,8891,113,59,1,8794,108,105,112,59,1,8942,4,2,98,116,18896,18901,97,114,59,1,124,59,1,124,114,59,3,55349,56627,116,114,105,59,1,8882,115,117,4,2,98,112,18923,18927,59,3,8834,8402,59,3,8835,8402,112,102,59,3,55349,56679,114,111,112,59,1,8733,116,114,105,59,1,8883,4,2,99,117,18955,18960,114,59,3,55349,56523,4,2,98,112,18966,18981,110,4,2,69,101,18973,18977,59,3,10955,65024,59,3,8842,65024,110,4,2,69,101,18988,18992,59,3,10956,65024,59,3,8843,65024,105,103,122,97,103,59,1,10650,4,7,99,101,102,111,112,114,115,19020,19026,19061,19066,19072,19075,19089,105,114,99,59,1,373,4,2,100,105,19032,19055,4,2,98,103,19038,19043,97,114,59,1,10847,101,4,2,59,113,19050,19052,1,8743,59,1,8793,101,114,112,59,1,8472,114,59,3,55349,56628,112,102,59,3,55349,56680,59,1,8472,4,2,59,101,19081,19083,1,8768,97,116,104,59,1,8768,99,114,59,3,55349,56524,4,14,99,100,102,104,105,108,109,110,111,114,115,117,118,119,19125,19146,19152,19157,19173,19176,19192,19197,19202,19236,19252,19269,19286,19291,4,3,97,105,117,19133,19137,19142,112,59,1,8898,114,99,59,1,9711,112,59,1,8899,116,114,105,59,1,9661,114,59,3,55349,56629,4,2,65,97,19163,19168,114,114,59,1,10234,114,114,59,1,10231,59,1,958,4,2,65,97,19182,19187,114,114,59,1,10232,114,114,59,1,10229,97,112,59,1,10236,105,115,59,1,8955,4,3,100,112,116,19210,19215,19230,111,116,59,1,10752,4,2,102,108,19221,19225,59,3,55349,56681,117,115,59,1,10753,105,109,101,59,1,10754,4,2,65,97,19242,19247,114,114,59,1,10233,114,114,59,1,10230,4,2,99,113,19258,19263,114,59,3,55349,56525,99,117,112,59,1,10758,4,2,112,116,19275,19281,108,117,115,59,1,10756,114,105,59,1,9651,101,101,59,1,8897,101,100,103,101,59,1,8896,4,8,97,99,101,102,105,111,115,117,19316,19335,19349,19357,19362,19367,19373,19379,99,4,2,117,121,19323,19332,116,101,5,253,1,59,19330,1,253,59,1,1103,4,2,105,121,19341,19346,114,99,59,1,375,59,1,1099,110,5,165,1,59,19355,1,165,114,59,3,55349,56630,99,121,59,1,1111,112,102,59,3,55349,56682,99,114,59,3,55349,56526,4,2,99,109,19385,19389,121,59,1,1102,108,5,255,1,59,19395,1,255,4,10,97,99,100,101,102,104,105,111,115,119,19419,19426,19441,19446,19462,19467,19472,19480,19486,19492,99,117,116,101,59,1,378,4,2,97,121,19432,19438,114,111,110,59,1,382,59,1,1079,111,116,59,1,380,4,2,101,116,19452,19458,116,114,102,59,1,8488,97,59,1,950,114,59,3,55349,56631,99,121,59,1,1078,103,114,97,114,114,59,1,8669,112,102,59,3,55349,56683,99,114,59,3,55349,56527,4,2,106,110,19498,19501,59,1,8205,106,59,1,8204]);
	return namedEntityData;
}

var tokenizer;
var hasRequiredTokenizer;

function requireTokenizer () {
	if (hasRequiredTokenizer) return tokenizer;
	hasRequiredTokenizer = 1;

	const Preprocessor = requirePreprocessor();
	const unicode = requireUnicode();
	const neTree = requireNamedEntityData();
	const ERR = requireErrorCodes();

	//Aliases
	const $ = unicode.CODE_POINTS;
	const $$ = unicode.CODE_POINT_SEQUENCES;

	//C1 Unicode control character reference replacements
	const C1_CONTROLS_REFERENCE_REPLACEMENTS = {
	    0x80: 0x20ac,
	    0x82: 0x201a,
	    0x83: 0x0192,
	    0x84: 0x201e,
	    0x85: 0x2026,
	    0x86: 0x2020,
	    0x87: 0x2021,
	    0x88: 0x02c6,
	    0x89: 0x2030,
	    0x8a: 0x0160,
	    0x8b: 0x2039,
	    0x8c: 0x0152,
	    0x8e: 0x017d,
	    0x91: 0x2018,
	    0x92: 0x2019,
	    0x93: 0x201c,
	    0x94: 0x201d,
	    0x95: 0x2022,
	    0x96: 0x2013,
	    0x97: 0x2014,
	    0x98: 0x02dc,
	    0x99: 0x2122,
	    0x9a: 0x0161,
	    0x9b: 0x203a,
	    0x9c: 0x0153,
	    0x9e: 0x017e,
	    0x9f: 0x0178
	};

	// Named entity tree flags
	const HAS_DATA_FLAG = 1 << 0;
	const DATA_DUPLET_FLAG = 1 << 1;
	const HAS_BRANCHES_FLAG = 1 << 2;
	const MAX_BRANCH_MARKER_VALUE = HAS_DATA_FLAG | DATA_DUPLET_FLAG | HAS_BRANCHES_FLAG;

	//States
	const DATA_STATE = 'DATA_STATE';
	const RCDATA_STATE = 'RCDATA_STATE';
	const RAWTEXT_STATE = 'RAWTEXT_STATE';
	const SCRIPT_DATA_STATE = 'SCRIPT_DATA_STATE';
	const PLAINTEXT_STATE = 'PLAINTEXT_STATE';
	const TAG_OPEN_STATE = 'TAG_OPEN_STATE';
	const END_TAG_OPEN_STATE = 'END_TAG_OPEN_STATE';
	const TAG_NAME_STATE = 'TAG_NAME_STATE';
	const RCDATA_LESS_THAN_SIGN_STATE = 'RCDATA_LESS_THAN_SIGN_STATE';
	const RCDATA_END_TAG_OPEN_STATE = 'RCDATA_END_TAG_OPEN_STATE';
	const RCDATA_END_TAG_NAME_STATE = 'RCDATA_END_TAG_NAME_STATE';
	const RAWTEXT_LESS_THAN_SIGN_STATE = 'RAWTEXT_LESS_THAN_SIGN_STATE';
	const RAWTEXT_END_TAG_OPEN_STATE = 'RAWTEXT_END_TAG_OPEN_STATE';
	const RAWTEXT_END_TAG_NAME_STATE = 'RAWTEXT_END_TAG_NAME_STATE';
	const SCRIPT_DATA_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_LESS_THAN_SIGN_STATE';
	const SCRIPT_DATA_END_TAG_OPEN_STATE = 'SCRIPT_DATA_END_TAG_OPEN_STATE';
	const SCRIPT_DATA_END_TAG_NAME_STATE = 'SCRIPT_DATA_END_TAG_NAME_STATE';
	const SCRIPT_DATA_ESCAPE_START_STATE = 'SCRIPT_DATA_ESCAPE_START_STATE';
	const SCRIPT_DATA_ESCAPE_START_DASH_STATE = 'SCRIPT_DATA_ESCAPE_START_DASH_STATE';
	const SCRIPT_DATA_ESCAPED_STATE = 'SCRIPT_DATA_ESCAPED_STATE';
	const SCRIPT_DATA_ESCAPED_DASH_STATE = 'SCRIPT_DATA_ESCAPED_DASH_STATE';
	const SCRIPT_DATA_ESCAPED_DASH_DASH_STATE = 'SCRIPT_DATA_ESCAPED_DASH_DASH_STATE';
	const SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE';
	const SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE = 'SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE';
	const SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE = 'SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE';
	const SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE';
	const SCRIPT_DATA_DOUBLE_ESCAPED_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_STATE';
	const SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE';
	const SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE';
	const SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE';
	const SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE';
	const BEFORE_ATTRIBUTE_NAME_STATE = 'BEFORE_ATTRIBUTE_NAME_STATE';
	const ATTRIBUTE_NAME_STATE = 'ATTRIBUTE_NAME_STATE';
	const AFTER_ATTRIBUTE_NAME_STATE = 'AFTER_ATTRIBUTE_NAME_STATE';
	const BEFORE_ATTRIBUTE_VALUE_STATE = 'BEFORE_ATTRIBUTE_VALUE_STATE';
	const ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE = 'ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE';
	const ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE = 'ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE';
	const ATTRIBUTE_VALUE_UNQUOTED_STATE = 'ATTRIBUTE_VALUE_UNQUOTED_STATE';
	const AFTER_ATTRIBUTE_VALUE_QUOTED_STATE = 'AFTER_ATTRIBUTE_VALUE_QUOTED_STATE';
	const SELF_CLOSING_START_TAG_STATE = 'SELF_CLOSING_START_TAG_STATE';
	const BOGUS_COMMENT_STATE = 'BOGUS_COMMENT_STATE';
	const MARKUP_DECLARATION_OPEN_STATE = 'MARKUP_DECLARATION_OPEN_STATE';
	const COMMENT_START_STATE = 'COMMENT_START_STATE';
	const COMMENT_START_DASH_STATE = 'COMMENT_START_DASH_STATE';
	const COMMENT_STATE = 'COMMENT_STATE';
	const COMMENT_LESS_THAN_SIGN_STATE = 'COMMENT_LESS_THAN_SIGN_STATE';
	const COMMENT_LESS_THAN_SIGN_BANG_STATE = 'COMMENT_LESS_THAN_SIGN_BANG_STATE';
	const COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE = 'COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE';
	const COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE = 'COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE';
	const COMMENT_END_DASH_STATE = 'COMMENT_END_DASH_STATE';
	const COMMENT_END_STATE = 'COMMENT_END_STATE';
	const COMMENT_END_BANG_STATE = 'COMMENT_END_BANG_STATE';
	const DOCTYPE_STATE = 'DOCTYPE_STATE';
	const BEFORE_DOCTYPE_NAME_STATE = 'BEFORE_DOCTYPE_NAME_STATE';
	const DOCTYPE_NAME_STATE = 'DOCTYPE_NAME_STATE';
	const AFTER_DOCTYPE_NAME_STATE = 'AFTER_DOCTYPE_NAME_STATE';
	const AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE = 'AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE';
	const BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE = 'BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE';
	const DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE = 'DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE';
	const DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE = 'DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE';
	const AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE = 'AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE';
	const BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE = 'BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE';
	const AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE = 'AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE';
	const BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE = 'BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE';
	const DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE = 'DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE';
	const DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE = 'DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE';
	const AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE = 'AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE';
	const BOGUS_DOCTYPE_STATE = 'BOGUS_DOCTYPE_STATE';
	const CDATA_SECTION_STATE = 'CDATA_SECTION_STATE';
	const CDATA_SECTION_BRACKET_STATE = 'CDATA_SECTION_BRACKET_STATE';
	const CDATA_SECTION_END_STATE = 'CDATA_SECTION_END_STATE';
	const CHARACTER_REFERENCE_STATE = 'CHARACTER_REFERENCE_STATE';
	const NAMED_CHARACTER_REFERENCE_STATE = 'NAMED_CHARACTER_REFERENCE_STATE';
	const AMBIGUOUS_AMPERSAND_STATE = 'AMBIGUOS_AMPERSAND_STATE';
	const NUMERIC_CHARACTER_REFERENCE_STATE = 'NUMERIC_CHARACTER_REFERENCE_STATE';
	const HEXADEMICAL_CHARACTER_REFERENCE_START_STATE = 'HEXADEMICAL_CHARACTER_REFERENCE_START_STATE';
	const DECIMAL_CHARACTER_REFERENCE_START_STATE = 'DECIMAL_CHARACTER_REFERENCE_START_STATE';
	const HEXADEMICAL_CHARACTER_REFERENCE_STATE = 'HEXADEMICAL_CHARACTER_REFERENCE_STATE';
	const DECIMAL_CHARACTER_REFERENCE_STATE = 'DECIMAL_CHARACTER_REFERENCE_STATE';
	const NUMERIC_CHARACTER_REFERENCE_END_STATE = 'NUMERIC_CHARACTER_REFERENCE_END_STATE';

	//Utils

	//OPTIMIZATION: these utility functions should not be moved out of this module. V8 Crankshaft will not inline
	//this functions if they will be situated in another module due to context switch.
	//Always perform inlining check before modifying this functions ('node --trace-inlining').
	function isWhitespace(cp) {
	    return cp === $.SPACE || cp === $.LINE_FEED || cp === $.TABULATION || cp === $.FORM_FEED;
	}

	function isAsciiDigit(cp) {
	    return cp >= $.DIGIT_0 && cp <= $.DIGIT_9;
	}

	function isAsciiUpper(cp) {
	    return cp >= $.LATIN_CAPITAL_A && cp <= $.LATIN_CAPITAL_Z;
	}

	function isAsciiLower(cp) {
	    return cp >= $.LATIN_SMALL_A && cp <= $.LATIN_SMALL_Z;
	}

	function isAsciiLetter(cp) {
	    return isAsciiLower(cp) || isAsciiUpper(cp);
	}

	function isAsciiAlphaNumeric(cp) {
	    return isAsciiLetter(cp) || isAsciiDigit(cp);
	}

	function isAsciiUpperHexDigit(cp) {
	    return cp >= $.LATIN_CAPITAL_A && cp <= $.LATIN_CAPITAL_F;
	}

	function isAsciiLowerHexDigit(cp) {
	    return cp >= $.LATIN_SMALL_A && cp <= $.LATIN_SMALL_F;
	}

	function isAsciiHexDigit(cp) {
	    return isAsciiDigit(cp) || isAsciiUpperHexDigit(cp) || isAsciiLowerHexDigit(cp);
	}

	function toAsciiLowerCodePoint(cp) {
	    return cp + 0x0020;
	}

	//NOTE: String.fromCharCode() function can handle only characters from BMP subset.
	//So, we need to workaround this manually.
	//(see: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/fromCharCode#Getting_it_to_work_with_higher_values)
	function toChar(cp) {
	    if (cp <= 0xffff) {
	        return String.fromCharCode(cp);
	    }

	    cp -= 0x10000;
	    return String.fromCharCode(((cp >>> 10) & 0x3ff) | 0xd800) + String.fromCharCode(0xdc00 | (cp & 0x3ff));
	}

	function toAsciiLowerChar(cp) {
	    return String.fromCharCode(toAsciiLowerCodePoint(cp));
	}

	function findNamedEntityTreeBranch(nodeIx, cp) {
	    const branchCount = neTree[++nodeIx];
	    let lo = ++nodeIx;
	    let hi = lo + branchCount - 1;

	    while (lo <= hi) {
	        const mid = (lo + hi) >>> 1;
	        const midCp = neTree[mid];

	        if (midCp < cp) {
	            lo = mid + 1;
	        } else if (midCp > cp) {
	            hi = mid - 1;
	        } else {
	            return neTree[mid + branchCount];
	        }
	    }

	    return -1;
	}

	//Tokenizer
	class Tokenizer {
	    constructor() {
	        this.preprocessor = new Preprocessor();

	        this.tokenQueue = [];

	        this.allowCDATA = false;

	        this.state = DATA_STATE;
	        this.returnState = '';

	        this.charRefCode = -1;
	        this.tempBuff = [];
	        this.lastStartTagName = '';

	        this.consumedAfterSnapshot = -1;
	        this.active = false;

	        this.currentCharacterToken = null;
	        this.currentToken = null;
	        this.currentAttr = null;
	    }

	    //Errors
	    _err() {
	        // NOTE: err reporting is noop by default. Enabled by mixin.
	    }

	    _errOnNextCodePoint(err) {
	        this._consume();
	        this._err(err);
	        this._unconsume();
	    }

	    //API
	    getNextToken() {
	        while (!this.tokenQueue.length && this.active) {
	            this.consumedAfterSnapshot = 0;

	            const cp = this._consume();

	            if (!this._ensureHibernation()) {
	                this[this.state](cp);
	            }
	        }

	        return this.tokenQueue.shift();
	    }

	    write(chunk, isLastChunk) {
	        this.active = true;
	        this.preprocessor.write(chunk, isLastChunk);
	    }

	    insertHtmlAtCurrentPos(chunk) {
	        this.active = true;
	        this.preprocessor.insertHtmlAtCurrentPos(chunk);
	    }

	    //Hibernation
	    _ensureHibernation() {
	        if (this.preprocessor.endOfChunkHit) {
	            for (; this.consumedAfterSnapshot > 0; this.consumedAfterSnapshot--) {
	                this.preprocessor.retreat();
	            }

	            this.active = false;
	            this.tokenQueue.push({ type: Tokenizer.HIBERNATION_TOKEN });

	            return true;
	        }

	        return false;
	    }

	    //Consumption
	    _consume() {
	        this.consumedAfterSnapshot++;
	        return this.preprocessor.advance();
	    }

	    _unconsume() {
	        this.consumedAfterSnapshot--;
	        this.preprocessor.retreat();
	    }

	    _reconsumeInState(state) {
	        this.state = state;
	        this._unconsume();
	    }

	    _consumeSequenceIfMatch(pattern, startCp, caseSensitive) {
	        let consumedCount = 0;
	        let isMatch = true;
	        const patternLength = pattern.length;
	        let patternPos = 0;
	        let cp = startCp;
	        let patternCp = void 0;

	        for (; patternPos < patternLength; patternPos++) {
	            if (patternPos > 0) {
	                cp = this._consume();
	                consumedCount++;
	            }

	            if (cp === $.EOF) {
	                isMatch = false;
	                break;
	            }

	            patternCp = pattern[patternPos];

	            if (cp !== patternCp && (caseSensitive || cp !== toAsciiLowerCodePoint(patternCp))) {
	                isMatch = false;
	                break;
	            }
	        }

	        if (!isMatch) {
	            while (consumedCount--) {
	                this._unconsume();
	            }
	        }

	        return isMatch;
	    }

	    //Temp buffer
	    _isTempBufferEqualToScriptString() {
	        if (this.tempBuff.length !== $$.SCRIPT_STRING.length) {
	            return false;
	        }

	        for (let i = 0; i < this.tempBuff.length; i++) {
	            if (this.tempBuff[i] !== $$.SCRIPT_STRING[i]) {
	                return false;
	            }
	        }

	        return true;
	    }

	    //Token creation
	    _createStartTagToken() {
	        this.currentToken = {
	            type: Tokenizer.START_TAG_TOKEN,
	            tagName: '',
	            selfClosing: false,
	            ackSelfClosing: false,
	            attrs: []
	        };
	    }

	    _createEndTagToken() {
	        this.currentToken = {
	            type: Tokenizer.END_TAG_TOKEN,
	            tagName: '',
	            selfClosing: false,
	            attrs: []
	        };
	    }

	    _createCommentToken() {
	        this.currentToken = {
	            type: Tokenizer.COMMENT_TOKEN,
	            data: ''
	        };
	    }

	    _createDoctypeToken(initialName) {
	        this.currentToken = {
	            type: Tokenizer.DOCTYPE_TOKEN,
	            name: initialName,
	            forceQuirks: false,
	            publicId: null,
	            systemId: null
	        };
	    }

	    _createCharacterToken(type, ch) {
	        this.currentCharacterToken = {
	            type: type,
	            chars: ch
	        };
	    }

	    _createEOFToken() {
	        this.currentToken = { type: Tokenizer.EOF_TOKEN };
	    }

	    //Tag attributes
	    _createAttr(attrNameFirstCh) {
	        this.currentAttr = {
	            name: attrNameFirstCh,
	            value: ''
	        };
	    }

	    _leaveAttrName(toState) {
	        if (Tokenizer.getTokenAttr(this.currentToken, this.currentAttr.name) === null) {
	            this.currentToken.attrs.push(this.currentAttr);
	        } else {
	            this._err(ERR.duplicateAttribute);
	        }

	        this.state = toState;
	    }

	    _leaveAttrValue(toState) {
	        this.state = toState;
	    }

	    //Token emission
	    _emitCurrentToken() {
	        this._emitCurrentCharacterToken();

	        const ct = this.currentToken;

	        this.currentToken = null;

	        //NOTE: store emited start tag's tagName to determine is the following end tag token is appropriate.
	        if (ct.type === Tokenizer.START_TAG_TOKEN) {
	            this.lastStartTagName = ct.tagName;
	        } else if (ct.type === Tokenizer.END_TAG_TOKEN) {
	            if (ct.attrs.length > 0) {
	                this._err(ERR.endTagWithAttributes);
	            }

	            if (ct.selfClosing) {
	                this._err(ERR.endTagWithTrailingSolidus);
	            }
	        }

	        this.tokenQueue.push(ct);
	    }

	    _emitCurrentCharacterToken() {
	        if (this.currentCharacterToken) {
	            this.tokenQueue.push(this.currentCharacterToken);
	            this.currentCharacterToken = null;
	        }
	    }

	    _emitEOFToken() {
	        this._createEOFToken();
	        this._emitCurrentToken();
	    }

	    //Characters emission

	    //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
	    //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
	    //If we have a sequence of characters that belong to the same group, parser can process it
	    //as a single solid character token.
	    //So, there are 3 types of character tokens in parse5:
	    //1)NULL_CHARACTER_TOKEN - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
	    //2)WHITESPACE_CHARACTER_TOKEN - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
	    //3)CHARACTER_TOKEN - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
	    _appendCharToCurrentCharacterToken(type, ch) {
	        if (this.currentCharacterToken && this.currentCharacterToken.type !== type) {
	            this._emitCurrentCharacterToken();
	        }

	        if (this.currentCharacterToken) {
	            this.currentCharacterToken.chars += ch;
	        } else {
	            this._createCharacterToken(type, ch);
	        }
	    }

	    _emitCodePoint(cp) {
	        let type = Tokenizer.CHARACTER_TOKEN;

	        if (isWhitespace(cp)) {
	            type = Tokenizer.WHITESPACE_CHARACTER_TOKEN;
	        } else if (cp === $.NULL) {
	            type = Tokenizer.NULL_CHARACTER_TOKEN;
	        }

	        this._appendCharToCurrentCharacterToken(type, toChar(cp));
	    }

	    _emitSeveralCodePoints(codePoints) {
	        for (let i = 0; i < codePoints.length; i++) {
	            this._emitCodePoint(codePoints[i]);
	        }
	    }

	    //NOTE: used then we emit character explicitly. This is always a non-whitespace and a non-null character.
	    //So we can avoid additional checks here.
	    _emitChars(ch) {
	        this._appendCharToCurrentCharacterToken(Tokenizer.CHARACTER_TOKEN, ch);
	    }

	    // Character reference helpers
	    _matchNamedCharacterReference(startCp) {
	        let result = null;
	        let excess = 1;
	        let i = findNamedEntityTreeBranch(0, startCp);

	        this.tempBuff.push(startCp);

	        while (i > -1) {
	            const current = neTree[i];
	            const inNode = current < MAX_BRANCH_MARKER_VALUE;
	            const nodeWithData = inNode && current & HAS_DATA_FLAG;

	            if (nodeWithData) {
	                //NOTE: we use greedy search, so we continue lookup at this point
	                result = current & DATA_DUPLET_FLAG ? [neTree[++i], neTree[++i]] : [neTree[++i]];
	                excess = 0;
	            }

	            const cp = this._consume();

	            this.tempBuff.push(cp);
	            excess++;

	            if (cp === $.EOF) {
	                break;
	            }

	            if (inNode) {
	                i = current & HAS_BRANCHES_FLAG ? findNamedEntityTreeBranch(i, cp) : -1;
	            } else {
	                i = cp === current ? ++i : -1;
	            }
	        }

	        while (excess--) {
	            this.tempBuff.pop();
	            this._unconsume();
	        }

	        return result;
	    }

	    _isCharacterReferenceInAttribute() {
	        return (
	            this.returnState === ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE ||
	            this.returnState === ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE ||
	            this.returnState === ATTRIBUTE_VALUE_UNQUOTED_STATE
	        );
	    }

	    _isCharacterReferenceAttributeQuirk(withSemicolon) {
	        if (!withSemicolon && this._isCharacterReferenceInAttribute()) {
	            const nextCp = this._consume();

	            this._unconsume();

	            return nextCp === $.EQUALS_SIGN || isAsciiAlphaNumeric(nextCp);
	        }

	        return false;
	    }

	    _flushCodePointsConsumedAsCharacterReference() {
	        if (this._isCharacterReferenceInAttribute()) {
	            for (let i = 0; i < this.tempBuff.length; i++) {
	                this.currentAttr.value += toChar(this.tempBuff[i]);
	            }
	        } else {
	            this._emitSeveralCodePoints(this.tempBuff);
	        }

	        this.tempBuff = [];
	    }

	    // State machine

	    // Data state
	    //------------------------------------------------------------------
	    [DATA_STATE](cp) {
	        this.preprocessor.dropParsedChunk();

	        if (cp === $.LESS_THAN_SIGN) {
	            this.state = TAG_OPEN_STATE;
	        } else if (cp === $.AMPERSAND) {
	            this.returnState = DATA_STATE;
	            this.state = CHARACTER_REFERENCE_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this._emitCodePoint(cp);
	        } else if (cp === $.EOF) {
	            this._emitEOFToken();
	        } else {
	            this._emitCodePoint(cp);
	        }
	    }

	    //  RCDATA state
	    //------------------------------------------------------------------
	    [RCDATA_STATE](cp) {
	        this.preprocessor.dropParsedChunk();

	        if (cp === $.AMPERSAND) {
	            this.returnState = RCDATA_STATE;
	            this.state = CHARACTER_REFERENCE_STATE;
	        } else if (cp === $.LESS_THAN_SIGN) {
	            this.state = RCDATA_LESS_THAN_SIGN_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this._emitChars(unicode.REPLACEMENT_CHARACTER);
	        } else if (cp === $.EOF) {
	            this._emitEOFToken();
	        } else {
	            this._emitCodePoint(cp);
	        }
	    }

	    // RAWTEXT state
	    //------------------------------------------------------------------
	    [RAWTEXT_STATE](cp) {
	        this.preprocessor.dropParsedChunk();

	        if (cp === $.LESS_THAN_SIGN) {
	            this.state = RAWTEXT_LESS_THAN_SIGN_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this._emitChars(unicode.REPLACEMENT_CHARACTER);
	        } else if (cp === $.EOF) {
	            this._emitEOFToken();
	        } else {
	            this._emitCodePoint(cp);
	        }
	    }

	    // Script data state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_STATE](cp) {
	        this.preprocessor.dropParsedChunk();

	        if (cp === $.LESS_THAN_SIGN) {
	            this.state = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this._emitChars(unicode.REPLACEMENT_CHARACTER);
	        } else if (cp === $.EOF) {
	            this._emitEOFToken();
	        } else {
	            this._emitCodePoint(cp);
	        }
	    }

	    // PLAINTEXT state
	    //------------------------------------------------------------------
	    [PLAINTEXT_STATE](cp) {
	        this.preprocessor.dropParsedChunk();

	        if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this._emitChars(unicode.REPLACEMENT_CHARACTER);
	        } else if (cp === $.EOF) {
	            this._emitEOFToken();
	        } else {
	            this._emitCodePoint(cp);
	        }
	    }

	    // Tag open state
	    //------------------------------------------------------------------
	    [TAG_OPEN_STATE](cp) {
	        if (cp === $.EXCLAMATION_MARK) {
	            this.state = MARKUP_DECLARATION_OPEN_STATE;
	        } else if (cp === $.SOLIDUS) {
	            this.state = END_TAG_OPEN_STATE;
	        } else if (isAsciiLetter(cp)) {
	            this._createStartTagToken();
	            this._reconsumeInState(TAG_NAME_STATE);
	        } else if (cp === $.QUESTION_MARK) {
	            this._err(ERR.unexpectedQuestionMarkInsteadOfTagName);
	            this._createCommentToken();
	            this._reconsumeInState(BOGUS_COMMENT_STATE);
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofBeforeTagName);
	            this._emitChars('<');
	            this._emitEOFToken();
	        } else {
	            this._err(ERR.invalidFirstCharacterOfTagName);
	            this._emitChars('<');
	            this._reconsumeInState(DATA_STATE);
	        }
	    }

	    // End tag open state
	    //------------------------------------------------------------------
	    [END_TAG_OPEN_STATE](cp) {
	        if (isAsciiLetter(cp)) {
	            this._createEndTagToken();
	            this._reconsumeInState(TAG_NAME_STATE);
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.missingEndTagName);
	            this.state = DATA_STATE;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofBeforeTagName);
	            this._emitChars('</');
	            this._emitEOFToken();
	        } else {
	            this._err(ERR.invalidFirstCharacterOfTagName);
	            this._createCommentToken();
	            this._reconsumeInState(BOGUS_COMMENT_STATE);
	        }
	    }

	    // Tag name state
	    //------------------------------------------------------------------
	    [TAG_NAME_STATE](cp) {
	        if (isWhitespace(cp)) {
	            this.state = BEFORE_ATTRIBUTE_NAME_STATE;
	        } else if (cp === $.SOLIDUS) {
	            this.state = SELF_CLOSING_START_TAG_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (isAsciiUpper(cp)) {
	            this.currentToken.tagName += toAsciiLowerChar(cp);
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.currentToken.tagName += unicode.REPLACEMENT_CHARACTER;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInTag);
	            this._emitEOFToken();
	        } else {
	            this.currentToken.tagName += toChar(cp);
	        }
	    }

	    // RCDATA less-than sign state
	    //------------------------------------------------------------------
	    [RCDATA_LESS_THAN_SIGN_STATE](cp) {
	        if (cp === $.SOLIDUS) {
	            this.tempBuff = [];
	            this.state = RCDATA_END_TAG_OPEN_STATE;
	        } else {
	            this._emitChars('<');
	            this._reconsumeInState(RCDATA_STATE);
	        }
	    }

	    // RCDATA end tag open state
	    //------------------------------------------------------------------
	    [RCDATA_END_TAG_OPEN_STATE](cp) {
	        if (isAsciiLetter(cp)) {
	            this._createEndTagToken();
	            this._reconsumeInState(RCDATA_END_TAG_NAME_STATE);
	        } else {
	            this._emitChars('</');
	            this._reconsumeInState(RCDATA_STATE);
	        }
	    }

	    // RCDATA end tag name state
	    //------------------------------------------------------------------
	    [RCDATA_END_TAG_NAME_STATE](cp) {
	        if (isAsciiUpper(cp)) {
	            this.currentToken.tagName += toAsciiLowerChar(cp);
	            this.tempBuff.push(cp);
	        } else if (isAsciiLower(cp)) {
	            this.currentToken.tagName += toChar(cp);
	            this.tempBuff.push(cp);
	        } else {
	            if (this.lastStartTagName === this.currentToken.tagName) {
	                if (isWhitespace(cp)) {
	                    this.state = BEFORE_ATTRIBUTE_NAME_STATE;
	                    return;
	                }

	                if (cp === $.SOLIDUS) {
	                    this.state = SELF_CLOSING_START_TAG_STATE;
	                    return;
	                }

	                if (cp === $.GREATER_THAN_SIGN) {
	                    this.state = DATA_STATE;
	                    this._emitCurrentToken();
	                    return;
	                }
	            }

	            this._emitChars('</');
	            this._emitSeveralCodePoints(this.tempBuff);
	            this._reconsumeInState(RCDATA_STATE);
	        }
	    }

	    // RAWTEXT less-than sign state
	    //------------------------------------------------------------------
	    [RAWTEXT_LESS_THAN_SIGN_STATE](cp) {
	        if (cp === $.SOLIDUS) {
	            this.tempBuff = [];
	            this.state = RAWTEXT_END_TAG_OPEN_STATE;
	        } else {
	            this._emitChars('<');
	            this._reconsumeInState(RAWTEXT_STATE);
	        }
	    }

	    // RAWTEXT end tag open state
	    //------------------------------------------------------------------
	    [RAWTEXT_END_TAG_OPEN_STATE](cp) {
	        if (isAsciiLetter(cp)) {
	            this._createEndTagToken();
	            this._reconsumeInState(RAWTEXT_END_TAG_NAME_STATE);
	        } else {
	            this._emitChars('</');
	            this._reconsumeInState(RAWTEXT_STATE);
	        }
	    }

	    // RAWTEXT end tag name state
	    //------------------------------------------------------------------
	    [RAWTEXT_END_TAG_NAME_STATE](cp) {
	        if (isAsciiUpper(cp)) {
	            this.currentToken.tagName += toAsciiLowerChar(cp);
	            this.tempBuff.push(cp);
	        } else if (isAsciiLower(cp)) {
	            this.currentToken.tagName += toChar(cp);
	            this.tempBuff.push(cp);
	        } else {
	            if (this.lastStartTagName === this.currentToken.tagName) {
	                if (isWhitespace(cp)) {
	                    this.state = BEFORE_ATTRIBUTE_NAME_STATE;
	                    return;
	                }

	                if (cp === $.SOLIDUS) {
	                    this.state = SELF_CLOSING_START_TAG_STATE;
	                    return;
	                }

	                if (cp === $.GREATER_THAN_SIGN) {
	                    this._emitCurrentToken();
	                    this.state = DATA_STATE;
	                    return;
	                }
	            }

	            this._emitChars('</');
	            this._emitSeveralCodePoints(this.tempBuff);
	            this._reconsumeInState(RAWTEXT_STATE);
	        }
	    }

	    // Script data less-than sign state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_LESS_THAN_SIGN_STATE](cp) {
	        if (cp === $.SOLIDUS) {
	            this.tempBuff = [];
	            this.state = SCRIPT_DATA_END_TAG_OPEN_STATE;
	        } else if (cp === $.EXCLAMATION_MARK) {
	            this.state = SCRIPT_DATA_ESCAPE_START_STATE;
	            this._emitChars('<!');
	        } else {
	            this._emitChars('<');
	            this._reconsumeInState(SCRIPT_DATA_STATE);
	        }
	    }

	    // Script data end tag open state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_END_TAG_OPEN_STATE](cp) {
	        if (isAsciiLetter(cp)) {
	            this._createEndTagToken();
	            this._reconsumeInState(SCRIPT_DATA_END_TAG_NAME_STATE);
	        } else {
	            this._emitChars('</');
	            this._reconsumeInState(SCRIPT_DATA_STATE);
	        }
	    }

	    // Script data end tag name state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_END_TAG_NAME_STATE](cp) {
	        if (isAsciiUpper(cp)) {
	            this.currentToken.tagName += toAsciiLowerChar(cp);
	            this.tempBuff.push(cp);
	        } else if (isAsciiLower(cp)) {
	            this.currentToken.tagName += toChar(cp);
	            this.tempBuff.push(cp);
	        } else {
	            if (this.lastStartTagName === this.currentToken.tagName) {
	                if (isWhitespace(cp)) {
	                    this.state = BEFORE_ATTRIBUTE_NAME_STATE;
	                    return;
	                } else if (cp === $.SOLIDUS) {
	                    this.state = SELF_CLOSING_START_TAG_STATE;
	                    return;
	                } else if (cp === $.GREATER_THAN_SIGN) {
	                    this._emitCurrentToken();
	                    this.state = DATA_STATE;
	                    return;
	                }
	            }

	            this._emitChars('</');
	            this._emitSeveralCodePoints(this.tempBuff);
	            this._reconsumeInState(SCRIPT_DATA_STATE);
	        }
	    }

	    // Script data escape start state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_ESCAPE_START_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.state = SCRIPT_DATA_ESCAPE_START_DASH_STATE;
	            this._emitChars('-');
	        } else {
	            this._reconsumeInState(SCRIPT_DATA_STATE);
	        }
	    }

	    // Script data escape start dash state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_ESCAPE_START_DASH_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
	            this._emitChars('-');
	        } else {
	            this._reconsumeInState(SCRIPT_DATA_STATE);
	        }
	    }

	    // Script data escaped state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_ESCAPED_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.state = SCRIPT_DATA_ESCAPED_DASH_STATE;
	            this._emitChars('-');
	        } else if (cp === $.LESS_THAN_SIGN) {
	            this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this._emitChars(unicode.REPLACEMENT_CHARACTER);
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInScriptHtmlCommentLikeText);
	            this._emitEOFToken();
	        } else {
	            this._emitCodePoint(cp);
	        }
	    }

	    // Script data escaped dash state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_ESCAPED_DASH_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
	            this._emitChars('-');
	        } else if (cp === $.LESS_THAN_SIGN) {
	            this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.state = SCRIPT_DATA_ESCAPED_STATE;
	            this._emitChars(unicode.REPLACEMENT_CHARACTER);
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInScriptHtmlCommentLikeText);
	            this._emitEOFToken();
	        } else {
	            this.state = SCRIPT_DATA_ESCAPED_STATE;
	            this._emitCodePoint(cp);
	        }
	    }

	    // Script data escaped dash dash state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_ESCAPED_DASH_DASH_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this._emitChars('-');
	        } else if (cp === $.LESS_THAN_SIGN) {
	            this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this.state = SCRIPT_DATA_STATE;
	            this._emitChars('>');
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.state = SCRIPT_DATA_ESCAPED_STATE;
	            this._emitChars(unicode.REPLACEMENT_CHARACTER);
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInScriptHtmlCommentLikeText);
	            this._emitEOFToken();
	        } else {
	            this.state = SCRIPT_DATA_ESCAPED_STATE;
	            this._emitCodePoint(cp);
	        }
	    }

	    // Script data escaped less-than sign state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE](cp) {
	        if (cp === $.SOLIDUS) {
	            this.tempBuff = [];
	            this.state = SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE;
	        } else if (isAsciiLetter(cp)) {
	            this.tempBuff = [];
	            this._emitChars('<');
	            this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE);
	        } else {
	            this._emitChars('<');
	            this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
	        }
	    }

	    // Script data escaped end tag open state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE](cp) {
	        if (isAsciiLetter(cp)) {
	            this._createEndTagToken();
	            this._reconsumeInState(SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE);
	        } else {
	            this._emitChars('</');
	            this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
	        }
	    }

	    // Script data escaped end tag name state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE](cp) {
	        if (isAsciiUpper(cp)) {
	            this.currentToken.tagName += toAsciiLowerChar(cp);
	            this.tempBuff.push(cp);
	        } else if (isAsciiLower(cp)) {
	            this.currentToken.tagName += toChar(cp);
	            this.tempBuff.push(cp);
	        } else {
	            if (this.lastStartTagName === this.currentToken.tagName) {
	                if (isWhitespace(cp)) {
	                    this.state = BEFORE_ATTRIBUTE_NAME_STATE;
	                    return;
	                }

	                if (cp === $.SOLIDUS) {
	                    this.state = SELF_CLOSING_START_TAG_STATE;
	                    return;
	                }

	                if (cp === $.GREATER_THAN_SIGN) {
	                    this._emitCurrentToken();
	                    this.state = DATA_STATE;
	                    return;
	                }
	            }

	            this._emitChars('</');
	            this._emitSeveralCodePoints(this.tempBuff);
	            this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
	        }
	    }

	    // Script data double escape start state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE](cp) {
	        if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN) {
	            this.state = this._isTempBufferEqualToScriptString()
	                ? SCRIPT_DATA_DOUBLE_ESCAPED_STATE
	                : SCRIPT_DATA_ESCAPED_STATE;
	            this._emitCodePoint(cp);
	        } else if (isAsciiUpper(cp)) {
	            this.tempBuff.push(toAsciiLowerCodePoint(cp));
	            this._emitCodePoint(cp);
	        } else if (isAsciiLower(cp)) {
	            this.tempBuff.push(cp);
	            this._emitCodePoint(cp);
	        } else {
	            this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
	        }
	    }

	    // Script data double escaped state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_DOUBLE_ESCAPED_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;
	            this._emitChars('-');
	        } else if (cp === $.LESS_THAN_SIGN) {
	            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
	            this._emitChars('<');
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this._emitChars(unicode.REPLACEMENT_CHARACTER);
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInScriptHtmlCommentLikeText);
	            this._emitEOFToken();
	        } else {
	            this._emitCodePoint(cp);
	        }
	    }

	    // Script data double escaped dash state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE;
	            this._emitChars('-');
	        } else if (cp === $.LESS_THAN_SIGN) {
	            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
	            this._emitChars('<');
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
	            this._emitChars(unicode.REPLACEMENT_CHARACTER);
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInScriptHtmlCommentLikeText);
	            this._emitEOFToken();
	        } else {
	            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
	            this._emitCodePoint(cp);
	        }
	    }

	    // Script data double escaped dash dash state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this._emitChars('-');
	        } else if (cp === $.LESS_THAN_SIGN) {
	            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
	            this._emitChars('<');
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this.state = SCRIPT_DATA_STATE;
	            this._emitChars('>');
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
	            this._emitChars(unicode.REPLACEMENT_CHARACTER);
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInScriptHtmlCommentLikeText);
	            this._emitEOFToken();
	        } else {
	            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
	            this._emitCodePoint(cp);
	        }
	    }

	    // Script data double escaped less-than sign state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE](cp) {
	        if (cp === $.SOLIDUS) {
	            this.tempBuff = [];
	            this.state = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;
	            this._emitChars('/');
	        } else {
	            this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
	        }
	    }

	    // Script data double escape end state
	    //------------------------------------------------------------------
	    [SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE](cp) {
	        if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN) {
	            this.state = this._isTempBufferEqualToScriptString()
	                ? SCRIPT_DATA_ESCAPED_STATE
	                : SCRIPT_DATA_DOUBLE_ESCAPED_STATE;

	            this._emitCodePoint(cp);
	        } else if (isAsciiUpper(cp)) {
	            this.tempBuff.push(toAsciiLowerCodePoint(cp));
	            this._emitCodePoint(cp);
	        } else if (isAsciiLower(cp)) {
	            this.tempBuff.push(cp);
	            this._emitCodePoint(cp);
	        } else {
	            this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
	        }
	    }

	    // Before attribute name state
	    //------------------------------------------------------------------
	    [BEFORE_ATTRIBUTE_NAME_STATE](cp) {
	        if (isWhitespace(cp)) {
	            return;
	        }

	        if (cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN || cp === $.EOF) {
	            this._reconsumeInState(AFTER_ATTRIBUTE_NAME_STATE);
	        } else if (cp === $.EQUALS_SIGN) {
	            this._err(ERR.unexpectedEqualsSignBeforeAttributeName);
	            this._createAttr('=');
	            this.state = ATTRIBUTE_NAME_STATE;
	        } else {
	            this._createAttr('');
	            this._reconsumeInState(ATTRIBUTE_NAME_STATE);
	        }
	    }

	    // Attribute name state
	    //------------------------------------------------------------------
	    [ATTRIBUTE_NAME_STATE](cp) {
	        if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN || cp === $.EOF) {
	            this._leaveAttrName(AFTER_ATTRIBUTE_NAME_STATE);
	            this._unconsume();
	        } else if (cp === $.EQUALS_SIGN) {
	            this._leaveAttrName(BEFORE_ATTRIBUTE_VALUE_STATE);
	        } else if (isAsciiUpper(cp)) {
	            this.currentAttr.name += toAsciiLowerChar(cp);
	        } else if (cp === $.QUOTATION_MARK || cp === $.APOSTROPHE || cp === $.LESS_THAN_SIGN) {
	            this._err(ERR.unexpectedCharacterInAttributeName);
	            this.currentAttr.name += toChar(cp);
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.currentAttr.name += unicode.REPLACEMENT_CHARACTER;
	        } else {
	            this.currentAttr.name += toChar(cp);
	        }
	    }

	    // After attribute name state
	    //------------------------------------------------------------------
	    [AFTER_ATTRIBUTE_NAME_STATE](cp) {
	        if (isWhitespace(cp)) {
	            return;
	        }

	        if (cp === $.SOLIDUS) {
	            this.state = SELF_CLOSING_START_TAG_STATE;
	        } else if (cp === $.EQUALS_SIGN) {
	            this.state = BEFORE_ATTRIBUTE_VALUE_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInTag);
	            this._emitEOFToken();
	        } else {
	            this._createAttr('');
	            this._reconsumeInState(ATTRIBUTE_NAME_STATE);
	        }
	    }

	    // Before attribute value state
	    //------------------------------------------------------------------
	    [BEFORE_ATTRIBUTE_VALUE_STATE](cp) {
	        if (isWhitespace(cp)) {
	            return;
	        }

	        if (cp === $.QUOTATION_MARK) {
	            this.state = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
	        } else if (cp === $.APOSTROPHE) {
	            this.state = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.missingAttributeValue);
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else {
	            this._reconsumeInState(ATTRIBUTE_VALUE_UNQUOTED_STATE);
	        }
	    }

	    // Attribute value (double-quoted) state
	    //------------------------------------------------------------------
	    [ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE](cp) {
	        if (cp === $.QUOTATION_MARK) {
	            this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
	        } else if (cp === $.AMPERSAND) {
	            this.returnState = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
	            this.state = CHARACTER_REFERENCE_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.currentAttr.value += unicode.REPLACEMENT_CHARACTER;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInTag);
	            this._emitEOFToken();
	        } else {
	            this.currentAttr.value += toChar(cp);
	        }
	    }

	    // Attribute value (single-quoted) state
	    //------------------------------------------------------------------
	    [ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE](cp) {
	        if (cp === $.APOSTROPHE) {
	            this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
	        } else if (cp === $.AMPERSAND) {
	            this.returnState = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
	            this.state = CHARACTER_REFERENCE_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.currentAttr.value += unicode.REPLACEMENT_CHARACTER;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInTag);
	            this._emitEOFToken();
	        } else {
	            this.currentAttr.value += toChar(cp);
	        }
	    }

	    // Attribute value (unquoted) state
	    //------------------------------------------------------------------
	    [ATTRIBUTE_VALUE_UNQUOTED_STATE](cp) {
	        if (isWhitespace(cp)) {
	            this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);
	        } else if (cp === $.AMPERSAND) {
	            this.returnState = ATTRIBUTE_VALUE_UNQUOTED_STATE;
	            this.state = CHARACTER_REFERENCE_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._leaveAttrValue(DATA_STATE);
	            this._emitCurrentToken();
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.currentAttr.value += unicode.REPLACEMENT_CHARACTER;
	        } else if (
	            cp === $.QUOTATION_MARK ||
	            cp === $.APOSTROPHE ||
	            cp === $.LESS_THAN_SIGN ||
	            cp === $.EQUALS_SIGN ||
	            cp === $.GRAVE_ACCENT
	        ) {
	            this._err(ERR.unexpectedCharacterInUnquotedAttributeValue);
	            this.currentAttr.value += toChar(cp);
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInTag);
	            this._emitEOFToken();
	        } else {
	            this.currentAttr.value += toChar(cp);
	        }
	    }

	    // After attribute value (quoted) state
	    //------------------------------------------------------------------
	    [AFTER_ATTRIBUTE_VALUE_QUOTED_STATE](cp) {
	        if (isWhitespace(cp)) {
	            this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);
	        } else if (cp === $.SOLIDUS) {
	            this._leaveAttrValue(SELF_CLOSING_START_TAG_STATE);
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._leaveAttrValue(DATA_STATE);
	            this._emitCurrentToken();
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInTag);
	            this._emitEOFToken();
	        } else {
	            this._err(ERR.missingWhitespaceBetweenAttributes);
	            this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
	        }
	    }

	    // Self-closing start tag state
	    //------------------------------------------------------------------
	    [SELF_CLOSING_START_TAG_STATE](cp) {
	        if (cp === $.GREATER_THAN_SIGN) {
	            this.currentToken.selfClosing = true;
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInTag);
	            this._emitEOFToken();
	        } else {
	            this._err(ERR.unexpectedSolidusInTag);
	            this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
	        }
	    }

	    // Bogus comment state
	    //------------------------------------------------------------------
	    [BOGUS_COMMENT_STATE](cp) {
	        if (cp === $.GREATER_THAN_SIGN) {
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (cp === $.EOF) {
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.currentToken.data += unicode.REPLACEMENT_CHARACTER;
	        } else {
	            this.currentToken.data += toChar(cp);
	        }
	    }

	    // Markup declaration open state
	    //------------------------------------------------------------------
	    [MARKUP_DECLARATION_OPEN_STATE](cp) {
	        if (this._consumeSequenceIfMatch($$.DASH_DASH_STRING, cp, true)) {
	            this._createCommentToken();
	            this.state = COMMENT_START_STATE;
	        } else if (this._consumeSequenceIfMatch($$.DOCTYPE_STRING, cp, false)) {
	            this.state = DOCTYPE_STATE;
	        } else if (this._consumeSequenceIfMatch($$.CDATA_START_STRING, cp, true)) {
	            if (this.allowCDATA) {
	                this.state = CDATA_SECTION_STATE;
	            } else {
	                this._err(ERR.cdataInHtmlContent);
	                this._createCommentToken();
	                this.currentToken.data = '[CDATA[';
	                this.state = BOGUS_COMMENT_STATE;
	            }
	        }

	        //NOTE: sequence lookup can be abrupted by hibernation. In that case lookup
	        //results are no longer valid and we will need to start over.
	        else if (!this._ensureHibernation()) {
	            this._err(ERR.incorrectlyOpenedComment);
	            this._createCommentToken();
	            this._reconsumeInState(BOGUS_COMMENT_STATE);
	        }
	    }

	    // Comment start state
	    //------------------------------------------------------------------
	    [COMMENT_START_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.state = COMMENT_START_DASH_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.abruptClosingOfEmptyComment);
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else {
	            this._reconsumeInState(COMMENT_STATE);
	        }
	    }

	    // Comment start dash state
	    //------------------------------------------------------------------
	    [COMMENT_START_DASH_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.state = COMMENT_END_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.abruptClosingOfEmptyComment);
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInComment);
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this.currentToken.data += '-';
	            this._reconsumeInState(COMMENT_STATE);
	        }
	    }

	    // Comment state
	    //------------------------------------------------------------------
	    [COMMENT_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.state = COMMENT_END_DASH_STATE;
	        } else if (cp === $.LESS_THAN_SIGN) {
	            this.currentToken.data += '<';
	            this.state = COMMENT_LESS_THAN_SIGN_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.currentToken.data += unicode.REPLACEMENT_CHARACTER;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInComment);
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this.currentToken.data += toChar(cp);
	        }
	    }

	    // Comment less-than sign state
	    //------------------------------------------------------------------
	    [COMMENT_LESS_THAN_SIGN_STATE](cp) {
	        if (cp === $.EXCLAMATION_MARK) {
	            this.currentToken.data += '!';
	            this.state = COMMENT_LESS_THAN_SIGN_BANG_STATE;
	        } else if (cp === $.LESS_THAN_SIGN) {
	            this.currentToken.data += '!';
	        } else {
	            this._reconsumeInState(COMMENT_STATE);
	        }
	    }

	    // Comment less-than sign bang state
	    //------------------------------------------------------------------
	    [COMMENT_LESS_THAN_SIGN_BANG_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE;
	        } else {
	            this._reconsumeInState(COMMENT_STATE);
	        }
	    }

	    // Comment less-than sign bang dash state
	    //------------------------------------------------------------------
	    [COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE;
	        } else {
	            this._reconsumeInState(COMMENT_END_DASH_STATE);
	        }
	    }

	    // Comment less-than sign bang dash dash state
	    //------------------------------------------------------------------
	    [COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE](cp) {
	        if (cp !== $.GREATER_THAN_SIGN && cp !== $.EOF) {
	            this._err(ERR.nestedComment);
	        }

	        this._reconsumeInState(COMMENT_END_STATE);
	    }

	    // Comment end dash state
	    //------------------------------------------------------------------
	    [COMMENT_END_DASH_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.state = COMMENT_END_STATE;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInComment);
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this.currentToken.data += '-';
	            this._reconsumeInState(COMMENT_STATE);
	        }
	    }

	    // Comment end state
	    //------------------------------------------------------------------
	    [COMMENT_END_STATE](cp) {
	        if (cp === $.GREATER_THAN_SIGN) {
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (cp === $.EXCLAMATION_MARK) {
	            this.state = COMMENT_END_BANG_STATE;
	        } else if (cp === $.HYPHEN_MINUS) {
	            this.currentToken.data += '-';
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInComment);
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this.currentToken.data += '--';
	            this._reconsumeInState(COMMENT_STATE);
	        }
	    }

	    // Comment end bang state
	    //------------------------------------------------------------------
	    [COMMENT_END_BANG_STATE](cp) {
	        if (cp === $.HYPHEN_MINUS) {
	            this.currentToken.data += '--!';
	            this.state = COMMENT_END_DASH_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.incorrectlyClosedComment);
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInComment);
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this.currentToken.data += '--!';
	            this._reconsumeInState(COMMENT_STATE);
	        }
	    }

	    // DOCTYPE state
	    //------------------------------------------------------------------
	    [DOCTYPE_STATE](cp) {
	        if (isWhitespace(cp)) {
	            this.state = BEFORE_DOCTYPE_NAME_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this._createDoctypeToken(null);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this._err(ERR.missingWhitespaceBeforeDoctypeName);
	            this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);
	        }
	    }

	    // Before DOCTYPE name state
	    //------------------------------------------------------------------
	    [BEFORE_DOCTYPE_NAME_STATE](cp) {
	        if (isWhitespace(cp)) {
	            return;
	        }

	        if (isAsciiUpper(cp)) {
	            this._createDoctypeToken(toAsciiLowerChar(cp));
	            this.state = DOCTYPE_NAME_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this._createDoctypeToken(unicode.REPLACEMENT_CHARACTER);
	            this.state = DOCTYPE_NAME_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.missingDoctypeName);
	            this._createDoctypeToken(null);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this.state = DATA_STATE;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this._createDoctypeToken(null);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this._createDoctypeToken(toChar(cp));
	            this.state = DOCTYPE_NAME_STATE;
	        }
	    }

	    // DOCTYPE name state
	    //------------------------------------------------------------------
	    [DOCTYPE_NAME_STATE](cp) {
	        if (isWhitespace(cp)) {
	            this.state = AFTER_DOCTYPE_NAME_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (isAsciiUpper(cp)) {
	            this.currentToken.name += toAsciiLowerChar(cp);
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.currentToken.name += unicode.REPLACEMENT_CHARACTER;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this.currentToken.name += toChar(cp);
	        }
	    }

	    // After DOCTYPE name state
	    //------------------------------------------------------------------
	    [AFTER_DOCTYPE_NAME_STATE](cp) {
	        if (isWhitespace(cp)) {
	            return;
	        }

	        if (cp === $.GREATER_THAN_SIGN) {
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else if (this._consumeSequenceIfMatch($$.PUBLIC_STRING, cp, false)) {
	            this.state = AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE;
	        } else if (this._consumeSequenceIfMatch($$.SYSTEM_STRING, cp, false)) {
	            this.state = AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE;
	        }
	        //NOTE: sequence lookup can be abrupted by hibernation. In that case lookup
	        //results are no longer valid and we will need to start over.
	        else if (!this._ensureHibernation()) {
	            this._err(ERR.invalidCharacterSequenceAfterDoctypeName);
	            this.currentToken.forceQuirks = true;
	            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
	        }
	    }

	    // After DOCTYPE public keyword state
	    //------------------------------------------------------------------
	    [AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE](cp) {
	        if (isWhitespace(cp)) {
	            this.state = BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
	        } else if (cp === $.QUOTATION_MARK) {
	            this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
	            this.currentToken.publicId = '';
	            this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
	        } else if (cp === $.APOSTROPHE) {
	            this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
	            this.currentToken.publicId = '';
	            this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.missingDoctypePublicIdentifier);
	            this.currentToken.forceQuirks = true;
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
	            this.currentToken.forceQuirks = true;
	            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
	        }
	    }

	    // Before DOCTYPE public identifier state
	    //------------------------------------------------------------------
	    [BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE](cp) {
	        if (isWhitespace(cp)) {
	            return;
	        }

	        if (cp === $.QUOTATION_MARK) {
	            this.currentToken.publicId = '';
	            this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
	        } else if (cp === $.APOSTROPHE) {
	            this.currentToken.publicId = '';
	            this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.missingDoctypePublicIdentifier);
	            this.currentToken.forceQuirks = true;
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
	            this.currentToken.forceQuirks = true;
	            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
	        }
	    }

	    // DOCTYPE public identifier (double-quoted) state
	    //------------------------------------------------------------------
	    [DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE](cp) {
	        if (cp === $.QUOTATION_MARK) {
	            this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.currentToken.publicId += unicode.REPLACEMENT_CHARACTER;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.abruptDoctypePublicIdentifier);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this.state = DATA_STATE;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this.currentToken.publicId += toChar(cp);
	        }
	    }

	    // DOCTYPE public identifier (single-quoted) state
	    //------------------------------------------------------------------
	    [DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE](cp) {
	        if (cp === $.APOSTROPHE) {
	            this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.currentToken.publicId += unicode.REPLACEMENT_CHARACTER;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.abruptDoctypePublicIdentifier);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this.state = DATA_STATE;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this.currentToken.publicId += toChar(cp);
	        }
	    }

	    // After DOCTYPE public identifier state
	    //------------------------------------------------------------------
	    [AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE](cp) {
	        if (isWhitespace(cp)) {
	            this.state = BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (cp === $.QUOTATION_MARK) {
	            this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
	            this.currentToken.systemId = '';
	            this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
	        } else if (cp === $.APOSTROPHE) {
	            this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
	            this.currentToken.systemId = '';
	            this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
	            this.currentToken.forceQuirks = true;
	            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
	        }
	    }

	    // Between DOCTYPE public and system identifiers state
	    //------------------------------------------------------------------
	    [BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE](cp) {
	        if (isWhitespace(cp)) {
	            return;
	        }

	        if (cp === $.GREATER_THAN_SIGN) {
	            this._emitCurrentToken();
	            this.state = DATA_STATE;
	        } else if (cp === $.QUOTATION_MARK) {
	            this.currentToken.systemId = '';
	            this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
	        } else if (cp === $.APOSTROPHE) {
	            this.currentToken.systemId = '';
	            this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
	            this.currentToken.forceQuirks = true;
	            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
	        }
	    }

	    // After DOCTYPE system keyword state
	    //------------------------------------------------------------------
	    [AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE](cp) {
	        if (isWhitespace(cp)) {
	            this.state = BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
	        } else if (cp === $.QUOTATION_MARK) {
	            this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
	            this.currentToken.systemId = '';
	            this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
	        } else if (cp === $.APOSTROPHE) {
	            this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
	            this.currentToken.systemId = '';
	            this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.missingDoctypeSystemIdentifier);
	            this.currentToken.forceQuirks = true;
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
	            this.currentToken.forceQuirks = true;
	            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
	        }
	    }

	    // Before DOCTYPE system identifier state
	    //------------------------------------------------------------------
	    [BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE](cp) {
	        if (isWhitespace(cp)) {
	            return;
	        }

	        if (cp === $.QUOTATION_MARK) {
	            this.currentToken.systemId = '';
	            this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
	        } else if (cp === $.APOSTROPHE) {
	            this.currentToken.systemId = '';
	            this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.missingDoctypeSystemIdentifier);
	            this.currentToken.forceQuirks = true;
	            this.state = DATA_STATE;
	            this._emitCurrentToken();
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
	            this.currentToken.forceQuirks = true;
	            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
	        }
	    }

	    // DOCTYPE system identifier (double-quoted) state
	    //------------------------------------------------------------------
	    [DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE](cp) {
	        if (cp === $.QUOTATION_MARK) {
	            this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.currentToken.systemId += unicode.REPLACEMENT_CHARACTER;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.abruptDoctypeSystemIdentifier);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this.state = DATA_STATE;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this.currentToken.systemId += toChar(cp);
	        }
	    }

	    // DOCTYPE system identifier (single-quoted) state
	    //------------------------------------------------------------------
	    [DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE](cp) {
	        if (cp === $.APOSTROPHE) {
	            this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	            this.currentToken.systemId += unicode.REPLACEMENT_CHARACTER;
	        } else if (cp === $.GREATER_THAN_SIGN) {
	            this._err(ERR.abruptDoctypeSystemIdentifier);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this.state = DATA_STATE;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this.currentToken.systemId += toChar(cp);
	        }
	    }

	    // After DOCTYPE system identifier state
	    //------------------------------------------------------------------
	    [AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE](cp) {
	        if (isWhitespace(cp)) {
	            return;
	        }

	        if (cp === $.GREATER_THAN_SIGN) {
	            this._emitCurrentToken();
	            this.state = DATA_STATE;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInDoctype);
	            this.currentToken.forceQuirks = true;
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        } else {
	            this._err(ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);
	            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
	        }
	    }

	    // Bogus DOCTYPE state
	    //------------------------------------------------------------------
	    [BOGUS_DOCTYPE_STATE](cp) {
	        if (cp === $.GREATER_THAN_SIGN) {
	            this._emitCurrentToken();
	            this.state = DATA_STATE;
	        } else if (cp === $.NULL) {
	            this._err(ERR.unexpectedNullCharacter);
	        } else if (cp === $.EOF) {
	            this._emitCurrentToken();
	            this._emitEOFToken();
	        }
	    }

	    // CDATA section state
	    //------------------------------------------------------------------
	    [CDATA_SECTION_STATE](cp) {
	        if (cp === $.RIGHT_SQUARE_BRACKET) {
	            this.state = CDATA_SECTION_BRACKET_STATE;
	        } else if (cp === $.EOF) {
	            this._err(ERR.eofInCdata);
	            this._emitEOFToken();
	        } else {
	            this._emitCodePoint(cp);
	        }
	    }

	    // CDATA section bracket state
	    //------------------------------------------------------------------
	    [CDATA_SECTION_BRACKET_STATE](cp) {
	        if (cp === $.RIGHT_SQUARE_BRACKET) {
	            this.state = CDATA_SECTION_END_STATE;
	        } else {
	            this._emitChars(']');
	            this._reconsumeInState(CDATA_SECTION_STATE);
	        }
	    }

	    // CDATA section end state
	    //------------------------------------------------------------------
	    [CDATA_SECTION_END_STATE](cp) {
	        if (cp === $.GREATER_THAN_SIGN) {
	            this.state = DATA_STATE;
	        } else if (cp === $.RIGHT_SQUARE_BRACKET) {
	            this._emitChars(']');
	        } else {
	            this._emitChars(']]');
	            this._reconsumeInState(CDATA_SECTION_STATE);
	        }
	    }

	    // Character reference state
	    //------------------------------------------------------------------
	    [CHARACTER_REFERENCE_STATE](cp) {
	        this.tempBuff = [$.AMPERSAND];

	        if (cp === $.NUMBER_SIGN) {
	            this.tempBuff.push(cp);
	            this.state = NUMERIC_CHARACTER_REFERENCE_STATE;
	        } else if (isAsciiAlphaNumeric(cp)) {
	            this._reconsumeInState(NAMED_CHARACTER_REFERENCE_STATE);
	        } else {
	            this._flushCodePointsConsumedAsCharacterReference();
	            this._reconsumeInState(this.returnState);
	        }
	    }

	    // Named character reference state
	    //------------------------------------------------------------------
	    [NAMED_CHARACTER_REFERENCE_STATE](cp) {
	        const matchResult = this._matchNamedCharacterReference(cp);

	        //NOTE: matching can be abrupted by hibernation. In that case match
	        //results are no longer valid and we will need to start over.
	        if (this._ensureHibernation()) {
	            this.tempBuff = [$.AMPERSAND];
	        } else if (matchResult) {
	            const withSemicolon = this.tempBuff[this.tempBuff.length - 1] === $.SEMICOLON;

	            if (!this._isCharacterReferenceAttributeQuirk(withSemicolon)) {
	                if (!withSemicolon) {
	                    this._errOnNextCodePoint(ERR.missingSemicolonAfterCharacterReference);
	                }

	                this.tempBuff = matchResult;
	            }

	            this._flushCodePointsConsumedAsCharacterReference();
	            this.state = this.returnState;
	        } else {
	            this._flushCodePointsConsumedAsCharacterReference();
	            this.state = AMBIGUOUS_AMPERSAND_STATE;
	        }
	    }

	    // Ambiguos ampersand state
	    //------------------------------------------------------------------
	    [AMBIGUOUS_AMPERSAND_STATE](cp) {
	        if (isAsciiAlphaNumeric(cp)) {
	            if (this._isCharacterReferenceInAttribute()) {
	                this.currentAttr.value += toChar(cp);
	            } else {
	                this._emitCodePoint(cp);
	            }
	        } else {
	            if (cp === $.SEMICOLON) {
	                this._err(ERR.unknownNamedCharacterReference);
	            }

	            this._reconsumeInState(this.returnState);
	        }
	    }

	    // Numeric character reference state
	    //------------------------------------------------------------------
	    [NUMERIC_CHARACTER_REFERENCE_STATE](cp) {
	        this.charRefCode = 0;

	        if (cp === $.LATIN_SMALL_X || cp === $.LATIN_CAPITAL_X) {
	            this.tempBuff.push(cp);
	            this.state = HEXADEMICAL_CHARACTER_REFERENCE_START_STATE;
	        } else {
	            this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_START_STATE);
	        }
	    }

	    // Hexademical character reference start state
	    //------------------------------------------------------------------
	    [HEXADEMICAL_CHARACTER_REFERENCE_START_STATE](cp) {
	        if (isAsciiHexDigit(cp)) {
	            this._reconsumeInState(HEXADEMICAL_CHARACTER_REFERENCE_STATE);
	        } else {
	            this._err(ERR.absenceOfDigitsInNumericCharacterReference);
	            this._flushCodePointsConsumedAsCharacterReference();
	            this._reconsumeInState(this.returnState);
	        }
	    }

	    // Decimal character reference start state
	    //------------------------------------------------------------------
	    [DECIMAL_CHARACTER_REFERENCE_START_STATE](cp) {
	        if (isAsciiDigit(cp)) {
	            this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_STATE);
	        } else {
	            this._err(ERR.absenceOfDigitsInNumericCharacterReference);
	            this._flushCodePointsConsumedAsCharacterReference();
	            this._reconsumeInState(this.returnState);
	        }
	    }

	    // Hexademical character reference state
	    //------------------------------------------------------------------
	    [HEXADEMICAL_CHARACTER_REFERENCE_STATE](cp) {
	        if (isAsciiUpperHexDigit(cp)) {
	            this.charRefCode = this.charRefCode * 16 + cp - 0x37;
	        } else if (isAsciiLowerHexDigit(cp)) {
	            this.charRefCode = this.charRefCode * 16 + cp - 0x57;
	        } else if (isAsciiDigit(cp)) {
	            this.charRefCode = this.charRefCode * 16 + cp - 0x30;
	        } else if (cp === $.SEMICOLON) {
	            this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;
	        } else {
	            this._err(ERR.missingSemicolonAfterCharacterReference);
	            this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);
	        }
	    }

	    // Decimal character reference state
	    //------------------------------------------------------------------
	    [DECIMAL_CHARACTER_REFERENCE_STATE](cp) {
	        if (isAsciiDigit(cp)) {
	            this.charRefCode = this.charRefCode * 10 + cp - 0x30;
	        } else if (cp === $.SEMICOLON) {
	            this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;
	        } else {
	            this._err(ERR.missingSemicolonAfterCharacterReference);
	            this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);
	        }
	    }

	    // Numeric character reference end state
	    //------------------------------------------------------------------
	    [NUMERIC_CHARACTER_REFERENCE_END_STATE]() {
	        if (this.charRefCode === $.NULL) {
	            this._err(ERR.nullCharacterReference);
	            this.charRefCode = $.REPLACEMENT_CHARACTER;
	        } else if (this.charRefCode > 0x10ffff) {
	            this._err(ERR.characterReferenceOutsideUnicodeRange);
	            this.charRefCode = $.REPLACEMENT_CHARACTER;
	        } else if (unicode.isSurrogate(this.charRefCode)) {
	            this._err(ERR.surrogateCharacterReference);
	            this.charRefCode = $.REPLACEMENT_CHARACTER;
	        } else if (unicode.isUndefinedCodePoint(this.charRefCode)) {
	            this._err(ERR.noncharacterCharacterReference);
	        } else if (unicode.isControlCodePoint(this.charRefCode) || this.charRefCode === $.CARRIAGE_RETURN) {
	            this._err(ERR.controlCharacterReference);

	            const replacement = C1_CONTROLS_REFERENCE_REPLACEMENTS[this.charRefCode];

	            if (replacement) {
	                this.charRefCode = replacement;
	            }
	        }

	        this.tempBuff = [this.charRefCode];

	        this._flushCodePointsConsumedAsCharacterReference();
	        this._reconsumeInState(this.returnState);
	    }
	}

	//Token types
	Tokenizer.CHARACTER_TOKEN = 'CHARACTER_TOKEN';
	Tokenizer.NULL_CHARACTER_TOKEN = 'NULL_CHARACTER_TOKEN';
	Tokenizer.WHITESPACE_CHARACTER_TOKEN = 'WHITESPACE_CHARACTER_TOKEN';
	Tokenizer.START_TAG_TOKEN = 'START_TAG_TOKEN';
	Tokenizer.END_TAG_TOKEN = 'END_TAG_TOKEN';
	Tokenizer.COMMENT_TOKEN = 'COMMENT_TOKEN';
	Tokenizer.DOCTYPE_TOKEN = 'DOCTYPE_TOKEN';
	Tokenizer.EOF_TOKEN = 'EOF_TOKEN';
	Tokenizer.HIBERNATION_TOKEN = 'HIBERNATION_TOKEN';

	//Tokenizer initial states for different modes
	Tokenizer.MODE = {
	    DATA: DATA_STATE,
	    RCDATA: RCDATA_STATE,
	    RAWTEXT: RAWTEXT_STATE,
	    SCRIPT_DATA: SCRIPT_DATA_STATE,
	    PLAINTEXT: PLAINTEXT_STATE
	};

	//Static
	Tokenizer.getTokenAttr = function(token, attrName) {
	    for (let i = token.attrs.length - 1; i >= 0; i--) {
	        if (token.attrs[i].name === attrName) {
	            return token.attrs[i].value;
	        }
	    }

	    return null;
	};

	tokenizer = Tokenizer;
	return tokenizer;
}

var html$1 = {};

var hasRequiredHtml;

function requireHtml () {
	if (hasRequiredHtml) return html$1;
	hasRequiredHtml = 1;

	const NS = (html$1.NAMESPACES = {
	    HTML: 'http://www.w3.org/1999/xhtml',
	    MATHML: 'http://www.w3.org/1998/Math/MathML',
	    SVG: 'http://www.w3.org/2000/svg',
	    XLINK: 'http://www.w3.org/1999/xlink',
	    XML: 'http://www.w3.org/XML/1998/namespace',
	    XMLNS: 'http://www.w3.org/2000/xmlns/'
	});

	html$1.ATTRS = {
	    TYPE: 'type',
	    ACTION: 'action',
	    ENCODING: 'encoding',
	    PROMPT: 'prompt',
	    NAME: 'name',
	    COLOR: 'color',
	    FACE: 'face',
	    SIZE: 'size'
	};

	html$1.DOCUMENT_MODE = {
	    NO_QUIRKS: 'no-quirks',
	    QUIRKS: 'quirks',
	    LIMITED_QUIRKS: 'limited-quirks'
	};

	const $ = (html$1.TAG_NAMES = {
	    A: 'a',
	    ADDRESS: 'address',
	    ANNOTATION_XML: 'annotation-xml',
	    APPLET: 'applet',
	    AREA: 'area',
	    ARTICLE: 'article',
	    ASIDE: 'aside',

	    B: 'b',
	    BASE: 'base',
	    BASEFONT: 'basefont',
	    BGSOUND: 'bgsound',
	    BIG: 'big',
	    BLOCKQUOTE: 'blockquote',
	    BODY: 'body',
	    BR: 'br',
	    BUTTON: 'button',

	    CAPTION: 'caption',
	    CENTER: 'center',
	    CODE: 'code',
	    COL: 'col',
	    COLGROUP: 'colgroup',

	    DD: 'dd',
	    DESC: 'desc',
	    DETAILS: 'details',
	    DIALOG: 'dialog',
	    DIR: 'dir',
	    DIV: 'div',
	    DL: 'dl',
	    DT: 'dt',

	    EM: 'em',
	    EMBED: 'embed',

	    FIELDSET: 'fieldset',
	    FIGCAPTION: 'figcaption',
	    FIGURE: 'figure',
	    FONT: 'font',
	    FOOTER: 'footer',
	    FOREIGN_OBJECT: 'foreignObject',
	    FORM: 'form',
	    FRAME: 'frame',
	    FRAMESET: 'frameset',

	    H1: 'h1',
	    H2: 'h2',
	    H3: 'h3',
	    H4: 'h4',
	    H5: 'h5',
	    H6: 'h6',
	    HEAD: 'head',
	    HEADER: 'header',
	    HGROUP: 'hgroup',
	    HR: 'hr',
	    HTML: 'html',

	    I: 'i',
	    IMG: 'img',
	    IMAGE: 'image',
	    INPUT: 'input',
	    IFRAME: 'iframe',

	    KEYGEN: 'keygen',

	    LABEL: 'label',
	    LI: 'li',
	    LINK: 'link',
	    LISTING: 'listing',

	    MAIN: 'main',
	    MALIGNMARK: 'malignmark',
	    MARQUEE: 'marquee',
	    MATH: 'math',
	    MENU: 'menu',
	    META: 'meta',
	    MGLYPH: 'mglyph',
	    MI: 'mi',
	    MO: 'mo',
	    MN: 'mn',
	    MS: 'ms',
	    MTEXT: 'mtext',

	    NAV: 'nav',
	    NOBR: 'nobr',
	    NOFRAMES: 'noframes',
	    NOEMBED: 'noembed',
	    NOSCRIPT: 'noscript',

	    OBJECT: 'object',
	    OL: 'ol',
	    OPTGROUP: 'optgroup',
	    OPTION: 'option',

	    P: 'p',
	    PARAM: 'param',
	    PLAINTEXT: 'plaintext',
	    PRE: 'pre',

	    RB: 'rb',
	    RP: 'rp',
	    RT: 'rt',
	    RTC: 'rtc',
	    RUBY: 'ruby',

	    S: 's',
	    SCRIPT: 'script',
	    SECTION: 'section',
	    SELECT: 'select',
	    SOURCE: 'source',
	    SMALL: 'small',
	    SPAN: 'span',
	    STRIKE: 'strike',
	    STRONG: 'strong',
	    STYLE: 'style',
	    SUB: 'sub',
	    SUMMARY: 'summary',
	    SUP: 'sup',

	    TABLE: 'table',
	    TBODY: 'tbody',
	    TEMPLATE: 'template',
	    TEXTAREA: 'textarea',
	    TFOOT: 'tfoot',
	    TD: 'td',
	    TH: 'th',
	    THEAD: 'thead',
	    TITLE: 'title',
	    TR: 'tr',
	    TRACK: 'track',
	    TT: 'tt',

	    U: 'u',
	    UL: 'ul',

	    SVG: 'svg',

	    VAR: 'var',

	    WBR: 'wbr',

	    XMP: 'xmp'
	});

	html$1.SPECIAL_ELEMENTS = {
	    [NS.HTML]: {
	        [$.ADDRESS]: true,
	        [$.APPLET]: true,
	        [$.AREA]: true,
	        [$.ARTICLE]: true,
	        [$.ASIDE]: true,
	        [$.BASE]: true,
	        [$.BASEFONT]: true,
	        [$.BGSOUND]: true,
	        [$.BLOCKQUOTE]: true,
	        [$.BODY]: true,
	        [$.BR]: true,
	        [$.BUTTON]: true,
	        [$.CAPTION]: true,
	        [$.CENTER]: true,
	        [$.COL]: true,
	        [$.COLGROUP]: true,
	        [$.DD]: true,
	        [$.DETAILS]: true,
	        [$.DIR]: true,
	        [$.DIV]: true,
	        [$.DL]: true,
	        [$.DT]: true,
	        [$.EMBED]: true,
	        [$.FIELDSET]: true,
	        [$.FIGCAPTION]: true,
	        [$.FIGURE]: true,
	        [$.FOOTER]: true,
	        [$.FORM]: true,
	        [$.FRAME]: true,
	        [$.FRAMESET]: true,
	        [$.H1]: true,
	        [$.H2]: true,
	        [$.H3]: true,
	        [$.H4]: true,
	        [$.H5]: true,
	        [$.H6]: true,
	        [$.HEAD]: true,
	        [$.HEADER]: true,
	        [$.HGROUP]: true,
	        [$.HR]: true,
	        [$.HTML]: true,
	        [$.IFRAME]: true,
	        [$.IMG]: true,
	        [$.INPUT]: true,
	        [$.LI]: true,
	        [$.LINK]: true,
	        [$.LISTING]: true,
	        [$.MAIN]: true,
	        [$.MARQUEE]: true,
	        [$.MENU]: true,
	        [$.META]: true,
	        [$.NAV]: true,
	        [$.NOEMBED]: true,
	        [$.NOFRAMES]: true,
	        [$.NOSCRIPT]: true,
	        [$.OBJECT]: true,
	        [$.OL]: true,
	        [$.P]: true,
	        [$.PARAM]: true,
	        [$.PLAINTEXT]: true,
	        [$.PRE]: true,
	        [$.SCRIPT]: true,
	        [$.SECTION]: true,
	        [$.SELECT]: true,
	        [$.SOURCE]: true,
	        [$.STYLE]: true,
	        [$.SUMMARY]: true,
	        [$.TABLE]: true,
	        [$.TBODY]: true,
	        [$.TD]: true,
	        [$.TEMPLATE]: true,
	        [$.TEXTAREA]: true,
	        [$.TFOOT]: true,
	        [$.TH]: true,
	        [$.THEAD]: true,
	        [$.TITLE]: true,
	        [$.TR]: true,
	        [$.TRACK]: true,
	        [$.UL]: true,
	        [$.WBR]: true,
	        [$.XMP]: true
	    },
	    [NS.MATHML]: {
	        [$.MI]: true,
	        [$.MO]: true,
	        [$.MN]: true,
	        [$.MS]: true,
	        [$.MTEXT]: true,
	        [$.ANNOTATION_XML]: true
	    },
	    [NS.SVG]: {
	        [$.TITLE]: true,
	        [$.FOREIGN_OBJECT]: true,
	        [$.DESC]: true
	    }
	};
	return html$1;
}

var openElementStack;
var hasRequiredOpenElementStack;

function requireOpenElementStack () {
	if (hasRequiredOpenElementStack) return openElementStack;
	hasRequiredOpenElementStack = 1;

	const HTML = requireHtml();

	//Aliases
	const $ = HTML.TAG_NAMES;
	const NS = HTML.NAMESPACES;

	//Element utils

	//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.
	//It's faster than using dictionary.
	function isImpliedEndTagRequired(tn) {
	    switch (tn.length) {
	        case 1:
	            return tn === $.P;

	        case 2:
	            return tn === $.RB || tn === $.RP || tn === $.RT || tn === $.DD || tn === $.DT || tn === $.LI;

	        case 3:
	            return tn === $.RTC;

	        case 6:
	            return tn === $.OPTION;

	        case 8:
	            return tn === $.OPTGROUP;
	    }

	    return false;
	}

	function isImpliedEndTagRequiredThoroughly(tn) {
	    switch (tn.length) {
	        case 1:
	            return tn === $.P;

	        case 2:
	            return (
	                tn === $.RB ||
	                tn === $.RP ||
	                tn === $.RT ||
	                tn === $.DD ||
	                tn === $.DT ||
	                tn === $.LI ||
	                tn === $.TD ||
	                tn === $.TH ||
	                tn === $.TR
	            );

	        case 3:
	            return tn === $.RTC;

	        case 5:
	            return tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD;

	        case 6:
	            return tn === $.OPTION;

	        case 7:
	            return tn === $.CAPTION;

	        case 8:
	            return tn === $.OPTGROUP || tn === $.COLGROUP;
	    }

	    return false;
	}

	function isScopingElement(tn, ns) {
	    switch (tn.length) {
	        case 2:
	            if (tn === $.TD || tn === $.TH) {
	                return ns === NS.HTML;
	            } else if (tn === $.MI || tn === $.MO || tn === $.MN || tn === $.MS) {
	                return ns === NS.MATHML;
	            }

	            break;

	        case 4:
	            if (tn === $.HTML) {
	                return ns === NS.HTML;
	            } else if (tn === $.DESC) {
	                return ns === NS.SVG;
	            }

	            break;

	        case 5:
	            if (tn === $.TABLE) {
	                return ns === NS.HTML;
	            } else if (tn === $.MTEXT) {
	                return ns === NS.MATHML;
	            } else if (tn === $.TITLE) {
	                return ns === NS.SVG;
	            }

	            break;

	        case 6:
	            return (tn === $.APPLET || tn === $.OBJECT) && ns === NS.HTML;

	        case 7:
	            return (tn === $.CAPTION || tn === $.MARQUEE) && ns === NS.HTML;

	        case 8:
	            return tn === $.TEMPLATE && ns === NS.HTML;

	        case 13:
	            return tn === $.FOREIGN_OBJECT && ns === NS.SVG;

	        case 14:
	            return tn === $.ANNOTATION_XML && ns === NS.MATHML;
	    }

	    return false;
	}

	//Stack of open elements
	class OpenElementStack {
	    constructor(document, treeAdapter) {
	        this.stackTop = -1;
	        this.items = [];
	        this.current = document;
	        this.currentTagName = null;
	        this.currentTmplContent = null;
	        this.tmplCount = 0;
	        this.treeAdapter = treeAdapter;
	    }

	    //Index of element
	    _indexOf(element) {
	        let idx = -1;

	        for (let i = this.stackTop; i >= 0; i--) {
	            if (this.items[i] === element) {
	                idx = i;
	                break;
	            }
	        }
	        return idx;
	    }

	    //Update current element
	    _isInTemplate() {
	        return this.currentTagName === $.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS.HTML;
	    }

	    _updateCurrentElement() {
	        this.current = this.items[this.stackTop];
	        this.currentTagName = this.current && this.treeAdapter.getTagName(this.current);

	        this.currentTmplContent = this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : null;
	    }

	    //Mutations
	    push(element) {
	        this.items[++this.stackTop] = element;
	        this._updateCurrentElement();

	        if (this._isInTemplate()) {
	            this.tmplCount++;
	        }
	    }

	    pop() {
	        this.stackTop--;

	        if (this.tmplCount > 0 && this._isInTemplate()) {
	            this.tmplCount--;
	        }

	        this._updateCurrentElement();
	    }

	    replace(oldElement, newElement) {
	        const idx = this._indexOf(oldElement);

	        this.items[idx] = newElement;

	        if (idx === this.stackTop) {
	            this._updateCurrentElement();
	        }
	    }

	    insertAfter(referenceElement, newElement) {
	        const insertionIdx = this._indexOf(referenceElement) + 1;

	        this.items.splice(insertionIdx, 0, newElement);

	        if (insertionIdx === ++this.stackTop) {
	            this._updateCurrentElement();
	        }
	    }

	    popUntilTagNamePopped(tagName) {
	        while (this.stackTop > -1) {
	            const tn = this.currentTagName;
	            const ns = this.treeAdapter.getNamespaceURI(this.current);

	            this.pop();

	            if (tn === tagName && ns === NS.HTML) {
	                break;
	            }
	        }
	    }

	    popUntilElementPopped(element) {
	        while (this.stackTop > -1) {
	            const poppedElement = this.current;

	            this.pop();

	            if (poppedElement === element) {
	                break;
	            }
	        }
	    }

	    popUntilNumberedHeaderPopped() {
	        while (this.stackTop > -1) {
	            const tn = this.currentTagName;
	            const ns = this.treeAdapter.getNamespaceURI(this.current);

	            this.pop();

	            if (
	                tn === $.H1 ||
	                tn === $.H2 ||
	                tn === $.H3 ||
	                tn === $.H4 ||
	                tn === $.H5 ||
	                (tn === $.H6 && ns === NS.HTML)
	            ) {
	                break;
	            }
	        }
	    }

	    popUntilTableCellPopped() {
	        while (this.stackTop > -1) {
	            const tn = this.currentTagName;
	            const ns = this.treeAdapter.getNamespaceURI(this.current);

	            this.pop();

	            if (tn === $.TD || (tn === $.TH && ns === NS.HTML)) {
	                break;
	            }
	        }
	    }

	    popAllUpToHtmlElement() {
	        //NOTE: here we assume that root <html> element is always first in the open element stack, so
	        //we perform this fast stack clean up.
	        this.stackTop = 0;
	        this._updateCurrentElement();
	    }

	    clearBackToTableContext() {
	        while (
	            (this.currentTagName !== $.TABLE && this.currentTagName !== $.TEMPLATE && this.currentTagName !== $.HTML) ||
	            this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML
	        ) {
	            this.pop();
	        }
	    }

	    clearBackToTableBodyContext() {
	        while (
	            (this.currentTagName !== $.TBODY &&
	                this.currentTagName !== $.TFOOT &&
	                this.currentTagName !== $.THEAD &&
	                this.currentTagName !== $.TEMPLATE &&
	                this.currentTagName !== $.HTML) ||
	            this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML
	        ) {
	            this.pop();
	        }
	    }

	    clearBackToTableRowContext() {
	        while (
	            (this.currentTagName !== $.TR && this.currentTagName !== $.TEMPLATE && this.currentTagName !== $.HTML) ||
	            this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML
	        ) {
	            this.pop();
	        }
	    }

	    remove(element) {
	        for (let i = this.stackTop; i >= 0; i--) {
	            if (this.items[i] === element) {
	                this.items.splice(i, 1);
	                this.stackTop--;
	                this._updateCurrentElement();
	                break;
	            }
	        }
	    }

	    //Search
	    tryPeekProperlyNestedBodyElement() {
	        //Properly nested <body> element (should be second element in stack).
	        const element = this.items[1];

	        return element && this.treeAdapter.getTagName(element) === $.BODY ? element : null;
	    }

	    contains(element) {
	        return this._indexOf(element) > -1;
	    }

	    getCommonAncestor(element) {
	        let elementIdx = this._indexOf(element);

	        return --elementIdx >= 0 ? this.items[elementIdx] : null;
	    }

	    isRootHtmlElementCurrent() {
	        return this.stackTop === 0 && this.currentTagName === $.HTML;
	    }

	    //Element in scope
	    hasInScope(tagName) {
	        for (let i = this.stackTop; i >= 0; i--) {
	            const tn = this.treeAdapter.getTagName(this.items[i]);
	            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

	            if (tn === tagName && ns === NS.HTML) {
	                return true;
	            }

	            if (isScopingElement(tn, ns)) {
	                return false;
	            }
	        }

	        return true;
	    }

	    hasNumberedHeaderInScope() {
	        for (let i = this.stackTop; i >= 0; i--) {
	            const tn = this.treeAdapter.getTagName(this.items[i]);
	            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

	            if (
	                (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) &&
	                ns === NS.HTML
	            ) {
	                return true;
	            }

	            if (isScopingElement(tn, ns)) {
	                return false;
	            }
	        }

	        return true;
	    }

	    hasInListItemScope(tagName) {
	        for (let i = this.stackTop; i >= 0; i--) {
	            const tn = this.treeAdapter.getTagName(this.items[i]);
	            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

	            if (tn === tagName && ns === NS.HTML) {
	                return true;
	            }

	            if (((tn === $.UL || tn === $.OL) && ns === NS.HTML) || isScopingElement(tn, ns)) {
	                return false;
	            }
	        }

	        return true;
	    }

	    hasInButtonScope(tagName) {
	        for (let i = this.stackTop; i >= 0; i--) {
	            const tn = this.treeAdapter.getTagName(this.items[i]);
	            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

	            if (tn === tagName && ns === NS.HTML) {
	                return true;
	            }

	            if ((tn === $.BUTTON && ns === NS.HTML) || isScopingElement(tn, ns)) {
	                return false;
	            }
	        }

	        return true;
	    }

	    hasInTableScope(tagName) {
	        for (let i = this.stackTop; i >= 0; i--) {
	            const tn = this.treeAdapter.getTagName(this.items[i]);
	            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

	            if (ns !== NS.HTML) {
	                continue;
	            }

	            if (tn === tagName) {
	                return true;
	            }

	            if (tn === $.TABLE || tn === $.TEMPLATE || tn === $.HTML) {
	                return false;
	            }
	        }

	        return true;
	    }

	    hasTableBodyContextInTableScope() {
	        for (let i = this.stackTop; i >= 0; i--) {
	            const tn = this.treeAdapter.getTagName(this.items[i]);
	            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

	            if (ns !== NS.HTML) {
	                continue;
	            }

	            if (tn === $.TBODY || tn === $.THEAD || tn === $.TFOOT) {
	                return true;
	            }

	            if (tn === $.TABLE || tn === $.HTML) {
	                return false;
	            }
	        }

	        return true;
	    }

	    hasInSelectScope(tagName) {
	        for (let i = this.stackTop; i >= 0; i--) {
	            const tn = this.treeAdapter.getTagName(this.items[i]);
	            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

	            if (ns !== NS.HTML) {
	                continue;
	            }

	            if (tn === tagName) {
	                return true;
	            }

	            if (tn !== $.OPTION && tn !== $.OPTGROUP) {
	                return false;
	            }
	        }

	        return true;
	    }

	    //Implied end tags
	    generateImpliedEndTags() {
	        while (isImpliedEndTagRequired(this.currentTagName)) {
	            this.pop();
	        }
	    }

	    generateImpliedEndTagsThoroughly() {
	        while (isImpliedEndTagRequiredThoroughly(this.currentTagName)) {
	            this.pop();
	        }
	    }

	    generateImpliedEndTagsWithExclusion(exclusionTagName) {
	        while (isImpliedEndTagRequired(this.currentTagName) && this.currentTagName !== exclusionTagName) {
	            this.pop();
	        }
	    }
	}

	openElementStack = OpenElementStack;
	return openElementStack;
}

var formattingElementList;
var hasRequiredFormattingElementList;

function requireFormattingElementList () {
	if (hasRequiredFormattingElementList) return formattingElementList;
	hasRequiredFormattingElementList = 1;

	//Const
	const NOAH_ARK_CAPACITY = 3;

	//List of formatting elements
	class FormattingElementList {
	    constructor(treeAdapter) {
	        this.length = 0;
	        this.entries = [];
	        this.treeAdapter = treeAdapter;
	        this.bookmark = null;
	    }

	    //Noah Ark's condition
	    //OPTIMIZATION: at first we try to find possible candidates for exclusion using
	    //lightweight heuristics without thorough attributes check.
	    _getNoahArkConditionCandidates(newElement) {
	        const candidates = [];

	        if (this.length >= NOAH_ARK_CAPACITY) {
	            const neAttrsLength = this.treeAdapter.getAttrList(newElement).length;
	            const neTagName = this.treeAdapter.getTagName(newElement);
	            const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);

	            for (let i = this.length - 1; i >= 0; i--) {
	                const entry = this.entries[i];

	                if (entry.type === FormattingElementList.MARKER_ENTRY) {
	                    break;
	                }

	                const element = entry.element;
	                const elementAttrs = this.treeAdapter.getAttrList(element);

	                const isCandidate =
	                    this.treeAdapter.getTagName(element) === neTagName &&
	                    this.treeAdapter.getNamespaceURI(element) === neNamespaceURI &&
	                    elementAttrs.length === neAttrsLength;

	                if (isCandidate) {
	                    candidates.push({ idx: i, attrs: elementAttrs });
	                }
	            }
	        }

	        return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;
	    }

	    _ensureNoahArkCondition(newElement) {
	        const candidates = this._getNoahArkConditionCandidates(newElement);
	        let cLength = candidates.length;

	        if (cLength) {
	            const neAttrs = this.treeAdapter.getAttrList(newElement);
	            const neAttrsLength = neAttrs.length;
	            const neAttrsMap = Object.create(null);

	            //NOTE: build attrs map for the new element so we can perform fast lookups
	            for (let i = 0; i < neAttrsLength; i++) {
	                const neAttr = neAttrs[i];

	                neAttrsMap[neAttr.name] = neAttr.value;
	            }

	            for (let i = 0; i < neAttrsLength; i++) {
	                for (let j = 0; j < cLength; j++) {
	                    const cAttr = candidates[j].attrs[i];

	                    if (neAttrsMap[cAttr.name] !== cAttr.value) {
	                        candidates.splice(j, 1);
	                        cLength--;
	                    }

	                    if (candidates.length < NOAH_ARK_CAPACITY) {
	                        return;
	                    }
	                }
	            }

	            //NOTE: remove bottommost candidates until Noah's Ark condition will not be met
	            for (let i = cLength - 1; i >= NOAH_ARK_CAPACITY - 1; i--) {
	                this.entries.splice(candidates[i].idx, 1);
	                this.length--;
	            }
	        }
	    }

	    //Mutations
	    insertMarker() {
	        this.entries.push({ type: FormattingElementList.MARKER_ENTRY });
	        this.length++;
	    }

	    pushElement(element, token) {
	        this._ensureNoahArkCondition(element);

	        this.entries.push({
	            type: FormattingElementList.ELEMENT_ENTRY,
	            element: element,
	            token: token
	        });

	        this.length++;
	    }

	    insertElementAfterBookmark(element, token) {
	        let bookmarkIdx = this.length - 1;

	        for (; bookmarkIdx >= 0; bookmarkIdx--) {
	            if (this.entries[bookmarkIdx] === this.bookmark) {
	                break;
	            }
	        }

	        this.entries.splice(bookmarkIdx + 1, 0, {
	            type: FormattingElementList.ELEMENT_ENTRY,
	            element: element,
	            token: token
	        });

	        this.length++;
	    }

	    removeEntry(entry) {
	        for (let i = this.length - 1; i >= 0; i--) {
	            if (this.entries[i] === entry) {
	                this.entries.splice(i, 1);
	                this.length--;
	                break;
	            }
	        }
	    }

	    clearToLastMarker() {
	        while (this.length) {
	            const entry = this.entries.pop();

	            this.length--;

	            if (entry.type === FormattingElementList.MARKER_ENTRY) {
	                break;
	            }
	        }
	    }

	    //Search
	    getElementEntryInScopeWithTagName(tagName) {
	        for (let i = this.length - 1; i >= 0; i--) {
	            const entry = this.entries[i];

	            if (entry.type === FormattingElementList.MARKER_ENTRY) {
	                return null;
	            }

	            if (this.treeAdapter.getTagName(entry.element) === tagName) {
	                return entry;
	            }
	        }

	        return null;
	    }

	    getElementEntry(element) {
	        for (let i = this.length - 1; i >= 0; i--) {
	            const entry = this.entries[i];

	            if (entry.type === FormattingElementList.ELEMENT_ENTRY && entry.element === element) {
	                return entry;
	            }
	        }

	        return null;
	    }
	}

	//Entry types
	FormattingElementList.MARKER_ENTRY = 'MARKER_ENTRY';
	FormattingElementList.ELEMENT_ENTRY = 'ELEMENT_ENTRY';

	formattingElementList = FormattingElementList;
	return formattingElementList;
}

var mixin;
var hasRequiredMixin;

function requireMixin () {
	if (hasRequiredMixin) return mixin;
	hasRequiredMixin = 1;

	class Mixin {
	    constructor(host) {
	        const originalMethods = {};
	        const overriddenMethods = this._getOverriddenMethods(this, originalMethods);

	        for (const key of Object.keys(overriddenMethods)) {
	            if (typeof overriddenMethods[key] === 'function') {
	                originalMethods[key] = host[key];
	                host[key] = overriddenMethods[key];
	            }
	        }
	    }

	    _getOverriddenMethods() {
	        throw new Error('Not implemented');
	    }
	}

	Mixin.install = function(host, Ctor, opts) {
	    if (!host.__mixins) {
	        host.__mixins = [];
	    }

	    for (let i = 0; i < host.__mixins.length; i++) {
	        if (host.__mixins[i].constructor === Ctor) {
	            return host.__mixins[i];
	        }
	    }

	    const mixin = new Ctor(host, opts);

	    host.__mixins.push(mixin);

	    return mixin;
	};

	mixin = Mixin;
	return mixin;
}

var preprocessorMixin$1;
var hasRequiredPreprocessorMixin$1;

function requirePreprocessorMixin$1 () {
	if (hasRequiredPreprocessorMixin$1) return preprocessorMixin$1;
	hasRequiredPreprocessorMixin$1 = 1;

	const Mixin = requireMixin();

	class PositionTrackingPreprocessorMixin extends Mixin {
	    constructor(preprocessor) {
	        super(preprocessor);

	        this.preprocessor = preprocessor;
	        this.isEol = false;
	        this.lineStartPos = 0;
	        this.droppedBufferSize = 0;

	        this.offset = 0;
	        this.col = 0;
	        this.line = 1;
	    }

	    _getOverriddenMethods(mxn, orig) {
	        return {
	            advance() {
	                const pos = this.pos + 1;
	                const ch = this.html[pos];

	                //NOTE: LF should be in the last column of the line
	                if (mxn.isEol) {
	                    mxn.isEol = false;
	                    mxn.line++;
	                    mxn.lineStartPos = pos;
	                }

	                if (ch === '\n' || (ch === '\r' && this.html[pos + 1] !== '\n')) {
	                    mxn.isEol = true;
	                }

	                mxn.col = pos - mxn.lineStartPos + 1;
	                mxn.offset = mxn.droppedBufferSize + pos;

	                return orig.advance.call(this);
	            },

	            retreat() {
	                orig.retreat.call(this);

	                mxn.isEol = false;
	                mxn.col = this.pos - mxn.lineStartPos + 1;
	            },

	            dropParsedChunk() {
	                const prevPos = this.pos;

	                orig.dropParsedChunk.call(this);

	                const reduction = prevPos - this.pos;

	                mxn.lineStartPos -= reduction;
	                mxn.droppedBufferSize += reduction;
	                mxn.offset = mxn.droppedBufferSize + this.pos;
	            }
	        };
	    }
	}

	preprocessorMixin$1 = PositionTrackingPreprocessorMixin;
	return preprocessorMixin$1;
}

var tokenizerMixin$1;
var hasRequiredTokenizerMixin$1;

function requireTokenizerMixin$1 () {
	if (hasRequiredTokenizerMixin$1) return tokenizerMixin$1;
	hasRequiredTokenizerMixin$1 = 1;

	const Mixin = requireMixin();
	const Tokenizer = requireTokenizer();
	const PositionTrackingPreprocessorMixin = requirePreprocessorMixin$1();

	class LocationInfoTokenizerMixin extends Mixin {
	    constructor(tokenizer) {
	        super(tokenizer);

	        this.tokenizer = tokenizer;
	        this.posTracker = Mixin.install(tokenizer.preprocessor, PositionTrackingPreprocessorMixin);
	        this.currentAttrLocation = null;
	        this.ctLoc = null;
	    }

	    _getCurrentLocation() {
	        return {
	            startLine: this.posTracker.line,
	            startCol: this.posTracker.col,
	            startOffset: this.posTracker.offset,
	            endLine: -1,
	            endCol: -1,
	            endOffset: -1
	        };
	    }

	    _attachCurrentAttrLocationInfo() {
	        this.currentAttrLocation.endLine = this.posTracker.line;
	        this.currentAttrLocation.endCol = this.posTracker.col;
	        this.currentAttrLocation.endOffset = this.posTracker.offset;

	        const currentToken = this.tokenizer.currentToken;
	        const currentAttr = this.tokenizer.currentAttr;

	        if (!currentToken.location.attrs) {
	            currentToken.location.attrs = Object.create(null);
	        }

	        currentToken.location.attrs[currentAttr.name] = this.currentAttrLocation;
	    }

	    _getOverriddenMethods(mxn, orig) {
	        const methods = {
	            _createStartTagToken() {
	                orig._createStartTagToken.call(this);
	                this.currentToken.location = mxn.ctLoc;
	            },

	            _createEndTagToken() {
	                orig._createEndTagToken.call(this);
	                this.currentToken.location = mxn.ctLoc;
	            },

	            _createCommentToken() {
	                orig._createCommentToken.call(this);
	                this.currentToken.location = mxn.ctLoc;
	            },

	            _createDoctypeToken(initialName) {
	                orig._createDoctypeToken.call(this, initialName);
	                this.currentToken.location = mxn.ctLoc;
	            },

	            _createCharacterToken(type, ch) {
	                orig._createCharacterToken.call(this, type, ch);
	                this.currentCharacterToken.location = mxn.ctLoc;
	            },

	            _createEOFToken() {
	                orig._createEOFToken.call(this);
	                this.currentToken.location = mxn._getCurrentLocation();
	            },

	            _createAttr(attrNameFirstCh) {
	                orig._createAttr.call(this, attrNameFirstCh);
	                mxn.currentAttrLocation = mxn._getCurrentLocation();
	            },

	            _leaveAttrName(toState) {
	                orig._leaveAttrName.call(this, toState);
	                mxn._attachCurrentAttrLocationInfo();
	            },

	            _leaveAttrValue(toState) {
	                orig._leaveAttrValue.call(this, toState);
	                mxn._attachCurrentAttrLocationInfo();
	            },

	            _emitCurrentToken() {
	                const ctLoc = this.currentToken.location;

	                //NOTE: if we have pending character token make it's end location equal to the
	                //current token's start location.
	                if (this.currentCharacterToken) {
	                    this.currentCharacterToken.location.endLine = ctLoc.startLine;
	                    this.currentCharacterToken.location.endCol = ctLoc.startCol;
	                    this.currentCharacterToken.location.endOffset = ctLoc.startOffset;
	                }

	                if (this.currentToken.type === Tokenizer.EOF_TOKEN) {
	                    ctLoc.endLine = ctLoc.startLine;
	                    ctLoc.endCol = ctLoc.startCol;
	                    ctLoc.endOffset = ctLoc.startOffset;
	                } else {
	                    ctLoc.endLine = mxn.posTracker.line;
	                    ctLoc.endCol = mxn.posTracker.col + 1;
	                    ctLoc.endOffset = mxn.posTracker.offset + 1;
	                }

	                orig._emitCurrentToken.call(this);
	            },

	            _emitCurrentCharacterToken() {
	                const ctLoc = this.currentCharacterToken && this.currentCharacterToken.location;

	                //NOTE: if we have character token and it's location wasn't set in the _emitCurrentToken(),
	                //then set it's location at the current preprocessor position.
	                //We don't need to increment preprocessor position, since character token
	                //emission is always forced by the start of the next character token here.
	                //So, we already have advanced position.
	                if (ctLoc && ctLoc.endOffset === -1) {
	                    ctLoc.endLine = mxn.posTracker.line;
	                    ctLoc.endCol = mxn.posTracker.col;
	                    ctLoc.endOffset = mxn.posTracker.offset;
	                }

	                orig._emitCurrentCharacterToken.call(this);
	            }
	        };

	        //NOTE: patch initial states for each mode to obtain token start position
	        Object.keys(Tokenizer.MODE).forEach(modeName => {
	            const state = Tokenizer.MODE[modeName];

	            methods[state] = function(cp) {
	                mxn.ctLoc = mxn._getCurrentLocation();
	                orig[state].call(this, cp);
	            };
	        });

	        return methods;
	    }
	}

	tokenizerMixin$1 = LocationInfoTokenizerMixin;
	return tokenizerMixin$1;
}

var openElementStackMixin;
var hasRequiredOpenElementStackMixin;

function requireOpenElementStackMixin () {
	if (hasRequiredOpenElementStackMixin) return openElementStackMixin;
	hasRequiredOpenElementStackMixin = 1;

	const Mixin = requireMixin();

	class LocationInfoOpenElementStackMixin extends Mixin {
	    constructor(stack, opts) {
	        super(stack);

	        this.onItemPop = opts.onItemPop;
	    }

	    _getOverriddenMethods(mxn, orig) {
	        return {
	            pop() {
	                mxn.onItemPop(this.current);
	                orig.pop.call(this);
	            },

	            popAllUpToHtmlElement() {
	                for (let i = this.stackTop; i > 0; i--) {
	                    mxn.onItemPop(this.items[i]);
	                }

	                orig.popAllUpToHtmlElement.call(this);
	            },

	            remove(element) {
	                mxn.onItemPop(this.current);
	                orig.remove.call(this, element);
	            }
	        };
	    }
	}

	openElementStackMixin = LocationInfoOpenElementStackMixin;
	return openElementStackMixin;
}

var parserMixin$1;
var hasRequiredParserMixin$1;

function requireParserMixin$1 () {
	if (hasRequiredParserMixin$1) return parserMixin$1;
	hasRequiredParserMixin$1 = 1;

	const Mixin = requireMixin();
	const Tokenizer = requireTokenizer();
	const LocationInfoTokenizerMixin = requireTokenizerMixin$1();
	const LocationInfoOpenElementStackMixin = requireOpenElementStackMixin();
	const HTML = requireHtml();

	//Aliases
	const $ = HTML.TAG_NAMES;

	class LocationInfoParserMixin extends Mixin {
	    constructor(parser) {
	        super(parser);

	        this.parser = parser;
	        this.treeAdapter = this.parser.treeAdapter;
	        this.posTracker = null;
	        this.lastStartTagToken = null;
	        this.lastFosterParentingLocation = null;
	        this.currentToken = null;
	    }

	    _setStartLocation(element) {
	        let loc = null;

	        if (this.lastStartTagToken) {
	            loc = Object.assign({}, this.lastStartTagToken.location);
	            loc.startTag = this.lastStartTagToken.location;
	        }

	        this.treeAdapter.setNodeSourceCodeLocation(element, loc);
	    }

	    _setEndLocation(element, closingToken) {
	        const loc = this.treeAdapter.getNodeSourceCodeLocation(element);

	        if (loc) {
	            if (closingToken.location) {
	                const ctLoc = closingToken.location;
	                const tn = this.treeAdapter.getTagName(element);

	                // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
	                // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
	                const isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;

	                if (isClosingEndTag) {
	                    loc.endTag = Object.assign({}, ctLoc);
	                    loc.endLine = ctLoc.endLine;
	                    loc.endCol = ctLoc.endCol;
	                    loc.endOffset = ctLoc.endOffset;
	                } else {
	                    loc.endLine = ctLoc.startLine;
	                    loc.endCol = ctLoc.startCol;
	                    loc.endOffset = ctLoc.startOffset;
	                }
	            }
	        }
	    }

	    _getOverriddenMethods(mxn, orig) {
	        return {
	            _bootstrap(document, fragmentContext) {
	                orig._bootstrap.call(this, document, fragmentContext);

	                mxn.lastStartTagToken = null;
	                mxn.lastFosterParentingLocation = null;
	                mxn.currentToken = null;

	                const tokenizerMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);

	                mxn.posTracker = tokenizerMixin.posTracker;

	                Mixin.install(this.openElements, LocationInfoOpenElementStackMixin, {
	                    onItemPop: function(element) {
	                        mxn._setEndLocation(element, mxn.currentToken);
	                    }
	                });
	            },

	            _runParsingLoop(scriptHandler) {
	                orig._runParsingLoop.call(this, scriptHandler);

	                // NOTE: generate location info for elements
	                // that remains on open element stack
	                for (let i = this.openElements.stackTop; i >= 0; i--) {
	                    mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);
	                }
	            },

	            //Token processing
	            _processTokenInForeignContent(token) {
	                mxn.currentToken = token;
	                orig._processTokenInForeignContent.call(this, token);
	            },

	            _processToken(token) {
	                mxn.currentToken = token;
	                orig._processToken.call(this, token);

	                //NOTE: <body> and <html> are never popped from the stack, so we need to updated
	                //their end location explicitly.
	                const requireExplicitUpdate =
	                    token.type === Tokenizer.END_TAG_TOKEN &&
	                    (token.tagName === $.HTML || (token.tagName === $.BODY && this.openElements.hasInScope($.BODY)));

	                if (requireExplicitUpdate) {
	                    for (let i = this.openElements.stackTop; i >= 0; i--) {
	                        const element = this.openElements.items[i];

	                        if (this.treeAdapter.getTagName(element) === token.tagName) {
	                            mxn._setEndLocation(element, token);
	                            break;
	                        }
	                    }
	                }
	            },

	            //Doctype
	            _setDocumentType(token) {
	                orig._setDocumentType.call(this, token);

	                const documentChildren = this.treeAdapter.getChildNodes(this.document);
	                const cnLength = documentChildren.length;

	                for (let i = 0; i < cnLength; i++) {
	                    const node = documentChildren[i];

	                    if (this.treeAdapter.isDocumentTypeNode(node)) {
	                        this.treeAdapter.setNodeSourceCodeLocation(node, token.location);
	                        break;
	                    }
	                }
	            },

	            //Elements
	            _attachElementToTree(element) {
	                //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.
	                //So we will use token location stored in this methods for the element.
	                mxn._setStartLocation(element);
	                mxn.lastStartTagToken = null;
	                orig._attachElementToTree.call(this, element);
	            },

	            _appendElement(token, namespaceURI) {
	                mxn.lastStartTagToken = token;
	                orig._appendElement.call(this, token, namespaceURI);
	            },

	            _insertElement(token, namespaceURI) {
	                mxn.lastStartTagToken = token;
	                orig._insertElement.call(this, token, namespaceURI);
	            },

	            _insertTemplate(token) {
	                mxn.lastStartTagToken = token;
	                orig._insertTemplate.call(this, token);

	                const tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);

	                this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);
	            },

	            _insertFakeRootElement() {
	                orig._insertFakeRootElement.call(this);
	                this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);
	            },

	            //Comments
	            _appendCommentNode(token, parent) {
	                orig._appendCommentNode.call(this, token, parent);

	                const children = this.treeAdapter.getChildNodes(parent);
	                const commentNode = children[children.length - 1];

	                this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
	            },

	            //Text
	            _findFosterParentingLocation() {
	                //NOTE: store last foster parenting location, so we will be able to find inserted text
	                //in case of foster parenting
	                mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);

	                return mxn.lastFosterParentingLocation;
	            },

	            _insertCharacters(token) {
	                orig._insertCharacters.call(this, token);

	                const hasFosterParent = this._shouldFosterParentOnInsertion();

	                const parent =
	                    (hasFosterParent && mxn.lastFosterParentingLocation.parent) ||
	                    this.openElements.currentTmplContent ||
	                    this.openElements.current;

	                const siblings = this.treeAdapter.getChildNodes(parent);

	                const textNodeIdx =
	                    hasFosterParent && mxn.lastFosterParentingLocation.beforeElement
	                        ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1
	                        : siblings.length - 1;

	                const textNode = siblings[textNodeIdx];

	                //NOTE: if we have location assigned by another token, then just update end position
	                const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);

	                if (tnLoc) {
	                    tnLoc.endLine = token.location.endLine;
	                    tnLoc.endCol = token.location.endCol;
	                    tnLoc.endOffset = token.location.endOffset;
	                } else {
	                    this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
	                }
	            }
	        };
	    }
	}

	parserMixin$1 = LocationInfoParserMixin;
	return parserMixin$1;
}

var mixinBase;
var hasRequiredMixinBase;

function requireMixinBase () {
	if (hasRequiredMixinBase) return mixinBase;
	hasRequiredMixinBase = 1;

	const Mixin = requireMixin();

	class ErrorReportingMixinBase extends Mixin {
	    constructor(host, opts) {
	        super(host);

	        this.posTracker = null;
	        this.onParseError = opts.onParseError;
	    }

	    _setErrorLocation(err) {
	        err.startLine = err.endLine = this.posTracker.line;
	        err.startCol = err.endCol = this.posTracker.col;
	        err.startOffset = err.endOffset = this.posTracker.offset;
	    }

	    _reportError(code) {
	        const err = {
	            code: code,
	            startLine: -1,
	            startCol: -1,
	            startOffset: -1,
	            endLine: -1,
	            endCol: -1,
	            endOffset: -1
	        };

	        this._setErrorLocation(err);
	        this.onParseError(err);
	    }

	    _getOverriddenMethods(mxn) {
	        return {
	            _err(code) {
	                mxn._reportError(code);
	            }
	        };
	    }
	}

	mixinBase = ErrorReportingMixinBase;
	return mixinBase;
}

var preprocessorMixin;
var hasRequiredPreprocessorMixin;

function requirePreprocessorMixin () {
	if (hasRequiredPreprocessorMixin) return preprocessorMixin;
	hasRequiredPreprocessorMixin = 1;

	const ErrorReportingMixinBase = requireMixinBase();
	const PositionTrackingPreprocessorMixin = requirePreprocessorMixin$1();
	const Mixin = requireMixin();

	class ErrorReportingPreprocessorMixin extends ErrorReportingMixinBase {
	    constructor(preprocessor, opts) {
	        super(preprocessor, opts);

	        this.posTracker = Mixin.install(preprocessor, PositionTrackingPreprocessorMixin);
	        this.lastErrOffset = -1;
	    }

	    _reportError(code) {
	        //NOTE: avoid reporting error twice on advance/retreat
	        if (this.lastErrOffset !== this.posTracker.offset) {
	            this.lastErrOffset = this.posTracker.offset;
	            super._reportError(code);
	        }
	    }
	}

	preprocessorMixin = ErrorReportingPreprocessorMixin;
	return preprocessorMixin;
}

var tokenizerMixin;
var hasRequiredTokenizerMixin;

function requireTokenizerMixin () {
	if (hasRequiredTokenizerMixin) return tokenizerMixin;
	hasRequiredTokenizerMixin = 1;

	const ErrorReportingMixinBase = requireMixinBase();
	const ErrorReportingPreprocessorMixin = requirePreprocessorMixin();
	const Mixin = requireMixin();

	class ErrorReportingTokenizerMixin extends ErrorReportingMixinBase {
	    constructor(tokenizer, opts) {
	        super(tokenizer, opts);

	        const preprocessorMixin = Mixin.install(tokenizer.preprocessor, ErrorReportingPreprocessorMixin, opts);

	        this.posTracker = preprocessorMixin.posTracker;
	    }
	}

	tokenizerMixin = ErrorReportingTokenizerMixin;
	return tokenizerMixin;
}

var parserMixin;
var hasRequiredParserMixin;

function requireParserMixin () {
	if (hasRequiredParserMixin) return parserMixin;
	hasRequiredParserMixin = 1;

	const ErrorReportingMixinBase = requireMixinBase();
	const ErrorReportingTokenizerMixin = requireTokenizerMixin();
	const LocationInfoTokenizerMixin = requireTokenizerMixin$1();
	const Mixin = requireMixin();

	class ErrorReportingParserMixin extends ErrorReportingMixinBase {
	    constructor(parser, opts) {
	        super(parser, opts);

	        this.opts = opts;
	        this.ctLoc = null;
	        this.locBeforeToken = false;
	    }

	    _setErrorLocation(err) {
	        if (this.ctLoc) {
	            err.startLine = this.ctLoc.startLine;
	            err.startCol = this.ctLoc.startCol;
	            err.startOffset = this.ctLoc.startOffset;

	            err.endLine = this.locBeforeToken ? this.ctLoc.startLine : this.ctLoc.endLine;
	            err.endCol = this.locBeforeToken ? this.ctLoc.startCol : this.ctLoc.endCol;
	            err.endOffset = this.locBeforeToken ? this.ctLoc.startOffset : this.ctLoc.endOffset;
	        }
	    }

	    _getOverriddenMethods(mxn, orig) {
	        return {
	            _bootstrap(document, fragmentContext) {
	                orig._bootstrap.call(this, document, fragmentContext);

	                Mixin.install(this.tokenizer, ErrorReportingTokenizerMixin, mxn.opts);
	                Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);
	            },

	            _processInputToken(token) {
	                mxn.ctLoc = token.location;

	                orig._processInputToken.call(this, token);
	            },

	            _err(code, options) {
	                mxn.locBeforeToken = options && options.beforeToken;
	                mxn._reportError(code);
	            }
	        };
	    }
	}

	parserMixin = ErrorReportingParserMixin;
	return parserMixin;
}

var _default = {};

var hasRequired_default;

function require_default () {
	if (hasRequired_default) return _default;
	hasRequired_default = 1;

	const { DOCUMENT_MODE } = requireHtml();

	//Node construction
	_default.createDocument = function() {
	    return {
	        nodeName: '#document',
	        mode: DOCUMENT_MODE.NO_QUIRKS,
	        childNodes: []
	    };
	};

	_default.createDocumentFragment = function() {
	    return {
	        nodeName: '#document-fragment',
	        childNodes: []
	    };
	};

	_default.createElement = function(tagName, namespaceURI, attrs) {
	    return {
	        nodeName: tagName,
	        tagName: tagName,
	        attrs: attrs,
	        namespaceURI: namespaceURI,
	        childNodes: [],
	        parentNode: null
	    };
	};

	_default.createCommentNode = function(data) {
	    return {
	        nodeName: '#comment',
	        data: data,
	        parentNode: null
	    };
	};

	const createTextNode = function(value) {
	    return {
	        nodeName: '#text',
	        value: value,
	        parentNode: null
	    };
	};

	//Tree mutation
	const appendChild = (_default.appendChild = function(parentNode, newNode) {
	    parentNode.childNodes.push(newNode);
	    newNode.parentNode = parentNode;
	});

	const insertBefore = (_default.insertBefore = function(parentNode, newNode, referenceNode) {
	    const insertionIdx = parentNode.childNodes.indexOf(referenceNode);

	    parentNode.childNodes.splice(insertionIdx, 0, newNode);
	    newNode.parentNode = parentNode;
	});

	_default.setTemplateContent = function(templateElement, contentElement) {
	    templateElement.content = contentElement;
	};

	_default.getTemplateContent = function(templateElement) {
	    return templateElement.content;
	};

	_default.setDocumentType = function(document, name, publicId, systemId) {
	    let doctypeNode = null;

	    for (let i = 0; i < document.childNodes.length; i++) {
	        if (document.childNodes[i].nodeName === '#documentType') {
	            doctypeNode = document.childNodes[i];
	            break;
	        }
	    }

	    if (doctypeNode) {
	        doctypeNode.name = name;
	        doctypeNode.publicId = publicId;
	        doctypeNode.systemId = systemId;
	    } else {
	        appendChild(document, {
	            nodeName: '#documentType',
	            name: name,
	            publicId: publicId,
	            systemId: systemId
	        });
	    }
	};

	_default.setDocumentMode = function(document, mode) {
	    document.mode = mode;
	};

	_default.getDocumentMode = function(document) {
	    return document.mode;
	};

	_default.detachNode = function(node) {
	    if (node.parentNode) {
	        const idx = node.parentNode.childNodes.indexOf(node);

	        node.parentNode.childNodes.splice(idx, 1);
	        node.parentNode = null;
	    }
	};

	_default.insertText = function(parentNode, text) {
	    if (parentNode.childNodes.length) {
	        const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];

	        if (prevNode.nodeName === '#text') {
	            prevNode.value += text;
	            return;
	        }
	    }

	    appendChild(parentNode, createTextNode(text));
	};

	_default.insertTextBefore = function(parentNode, text, referenceNode) {
	    const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];

	    if (prevNode && prevNode.nodeName === '#text') {
	        prevNode.value += text;
	    } else {
	        insertBefore(parentNode, createTextNode(text), referenceNode);
	    }
	};

	_default.adoptAttributes = function(recipient, attrs) {
	    const recipientAttrsMap = [];

	    for (let i = 0; i < recipient.attrs.length; i++) {
	        recipientAttrsMap.push(recipient.attrs[i].name);
	    }

	    for (let j = 0; j < attrs.length; j++) {
	        if (recipientAttrsMap.indexOf(attrs[j].name) === -1) {
	            recipient.attrs.push(attrs[j]);
	        }
	    }
	};

	//Tree traversing
	_default.getFirstChild = function(node) {
	    return node.childNodes[0];
	};

	_default.getChildNodes = function(node) {
	    return node.childNodes;
	};

	_default.getParentNode = function(node) {
	    return node.parentNode;
	};

	_default.getAttrList = function(element) {
	    return element.attrs;
	};

	//Node data
	_default.getTagName = function(element) {
	    return element.tagName;
	};

	_default.getNamespaceURI = function(element) {
	    return element.namespaceURI;
	};

	_default.getTextNodeContent = function(textNode) {
	    return textNode.value;
	};

	_default.getCommentNodeContent = function(commentNode) {
	    return commentNode.data;
	};

	_default.getDocumentTypeNodeName = function(doctypeNode) {
	    return doctypeNode.name;
	};

	_default.getDocumentTypeNodePublicId = function(doctypeNode) {
	    return doctypeNode.publicId;
	};

	_default.getDocumentTypeNodeSystemId = function(doctypeNode) {
	    return doctypeNode.systemId;
	};

	//Node types
	_default.isTextNode = function(node) {
	    return node.nodeName === '#text';
	};

	_default.isCommentNode = function(node) {
	    return node.nodeName === '#comment';
	};

	_default.isDocumentTypeNode = function(node) {
	    return node.nodeName === '#documentType';
	};

	_default.isElementNode = function(node) {
	    return !!node.tagName;
	};

	// Source code location
	_default.setNodeSourceCodeLocation = function(node, location) {
	    node.sourceCodeLocation = location;
	};

	_default.getNodeSourceCodeLocation = function(node) {
	    return node.sourceCodeLocation;
	};
	return _default;
}

var mergeOptions;
var hasRequiredMergeOptions;

function requireMergeOptions () {
	if (hasRequiredMergeOptions) return mergeOptions;
	hasRequiredMergeOptions = 1;

	mergeOptions = function mergeOptions(defaults, options) {
	    options = options || Object.create(null);

	    return [defaults, options].reduce((merged, optObj) => {
	        Object.keys(optObj).forEach(key => {
	            merged[key] = optObj[key];
	        });

	        return merged;
	    }, Object.create(null));
	};
	return mergeOptions;
}

var doctype$1 = {};

var hasRequiredDoctype$1;

function requireDoctype$1 () {
	if (hasRequiredDoctype$1) return doctype$1;
	hasRequiredDoctype$1 = 1;

	const { DOCUMENT_MODE } = requireHtml();

	//Const
	const VALID_DOCTYPE_NAME = 'html';
	const VALID_SYSTEM_ID = 'about:legacy-compat';
	const QUIRKS_MODE_SYSTEM_ID = 'http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd';

	const QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
	    '+//silmaril//dtd html pro v0r11 19970101//',
	    '-//as//dtd html 3.0 aswedit + extensions//',
	    '-//advasoft ltd//dtd html 3.0 aswedit + extensions//',
	    '-//ietf//dtd html 2.0 level 1//',
	    '-//ietf//dtd html 2.0 level 2//',
	    '-//ietf//dtd html 2.0 strict level 1//',
	    '-//ietf//dtd html 2.0 strict level 2//',
	    '-//ietf//dtd html 2.0 strict//',
	    '-//ietf//dtd html 2.0//',
	    '-//ietf//dtd html 2.1e//',
	    '-//ietf//dtd html 3.0//',
	    '-//ietf//dtd html 3.2 final//',
	    '-//ietf//dtd html 3.2//',
	    '-//ietf//dtd html 3//',
	    '-//ietf//dtd html level 0//',
	    '-//ietf//dtd html level 1//',
	    '-//ietf//dtd html level 2//',
	    '-//ietf//dtd html level 3//',
	    '-//ietf//dtd html strict level 0//',
	    '-//ietf//dtd html strict level 1//',
	    '-//ietf//dtd html strict level 2//',
	    '-//ietf//dtd html strict level 3//',
	    '-//ietf//dtd html strict//',
	    '-//ietf//dtd html//',
	    '-//metrius//dtd metrius presentational//',
	    '-//microsoft//dtd internet explorer 2.0 html strict//',
	    '-//microsoft//dtd internet explorer 2.0 html//',
	    '-//microsoft//dtd internet explorer 2.0 tables//',
	    '-//microsoft//dtd internet explorer 3.0 html strict//',
	    '-//microsoft//dtd internet explorer 3.0 html//',
	    '-//microsoft//dtd internet explorer 3.0 tables//',
	    '-//netscape comm. corp.//dtd html//',
	    '-//netscape comm. corp.//dtd strict html//',
	    "-//o'reilly and associates//dtd html 2.0//",
	    "-//o'reilly and associates//dtd html extended 1.0//",
	    "-//o'reilly and associates//dtd html extended relaxed 1.0//",
	    '-//sq//dtd html 2.0 hotmetal + extensions//',
	    '-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//',
	    '-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//',
	    '-//spyglass//dtd html 2.0 extended//',
	    '-//sun microsystems corp.//dtd hotjava html//',
	    '-//sun microsystems corp.//dtd hotjava strict html//',
	    '-//w3c//dtd html 3 1995-03-24//',
	    '-//w3c//dtd html 3.2 draft//',
	    '-//w3c//dtd html 3.2 final//',
	    '-//w3c//dtd html 3.2//',
	    '-//w3c//dtd html 3.2s draft//',
	    '-//w3c//dtd html 4.0 frameset//',
	    '-//w3c//dtd html 4.0 transitional//',
	    '-//w3c//dtd html experimental 19960712//',
	    '-//w3c//dtd html experimental 970421//',
	    '-//w3c//dtd w3 html//',
	    '-//w3o//dtd w3 html 3.0//',
	    '-//webtechs//dtd mozilla html 2.0//',
	    '-//webtechs//dtd mozilla html//'
	];

	const QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = QUIRKS_MODE_PUBLIC_ID_PREFIXES.concat([
	    '-//w3c//dtd html 4.01 frameset//',
	    '-//w3c//dtd html 4.01 transitional//'
	]);

	const QUIRKS_MODE_PUBLIC_IDS = ['-//w3o//dtd w3 html strict 3.0//en//', '-/w3c/dtd html 4.0 transitional/en', 'html'];
	const LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ['-//w3c//dtd xhtml 1.0 frameset//', '-//w3c//dtd xhtml 1.0 transitional//'];

	const LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = LIMITED_QUIRKS_PUBLIC_ID_PREFIXES.concat([
	    '-//w3c//dtd html 4.01 frameset//',
	    '-//w3c//dtd html 4.01 transitional//'
	]);

	//Utils
	function enquoteDoctypeId(id) {
	    const quote = id.indexOf('"') !== -1 ? "'" : '"';

	    return quote + id + quote;
	}

	function hasPrefix(publicId, prefixes) {
	    for (let i = 0; i < prefixes.length; i++) {
	        if (publicId.indexOf(prefixes[i]) === 0) {
	            return true;
	        }
	    }

	    return false;
	}

	//API
	doctype$1.isConforming = function(token) {
	    return (
	        token.name === VALID_DOCTYPE_NAME &&
	        token.publicId === null &&
	        (token.systemId === null || token.systemId === VALID_SYSTEM_ID)
	    );
	};

	doctype$1.getDocumentMode = function(token) {
	    if (token.name !== VALID_DOCTYPE_NAME) {
	        return DOCUMENT_MODE.QUIRKS;
	    }

	    const systemId = token.systemId;

	    if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
	        return DOCUMENT_MODE.QUIRKS;
	    }

	    let publicId = token.publicId;

	    if (publicId !== null) {
	        publicId = publicId.toLowerCase();

	        if (QUIRKS_MODE_PUBLIC_IDS.indexOf(publicId) > -1) {
	            return DOCUMENT_MODE.QUIRKS;
	        }

	        let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;

	        if (hasPrefix(publicId, prefixes)) {
	            return DOCUMENT_MODE.QUIRKS;
	        }

	        prefixes =
	            systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;

	        if (hasPrefix(publicId, prefixes)) {
	            return DOCUMENT_MODE.LIMITED_QUIRKS;
	        }
	    }

	    return DOCUMENT_MODE.NO_QUIRKS;
	};

	doctype$1.serializeContent = function(name, publicId, systemId) {
	    let str = '!DOCTYPE ';

	    if (name) {
	        str += name;
	    }

	    if (publicId) {
	        str += ' PUBLIC ' + enquoteDoctypeId(publicId);
	    } else if (systemId) {
	        str += ' SYSTEM';
	    }

	    if (systemId !== null) {
	        str += ' ' + enquoteDoctypeId(systemId);
	    }

	    return str;
	};
	return doctype$1;
}

var foreignContent = {};

var hasRequiredForeignContent;

function requireForeignContent () {
	if (hasRequiredForeignContent) return foreignContent;
	hasRequiredForeignContent = 1;

	const Tokenizer = requireTokenizer();
	const HTML = requireHtml();

	//Aliases
	const $ = HTML.TAG_NAMES;
	const NS = HTML.NAMESPACES;
	const ATTRS = HTML.ATTRS;

	//MIME types
	const MIME_TYPES = {
	    TEXT_HTML: 'text/html',
	    APPLICATION_XML: 'application/xhtml+xml'
	};

	//Attributes
	const DEFINITION_URL_ATTR = 'definitionurl';
	const ADJUSTED_DEFINITION_URL_ATTR = 'definitionURL';
	const SVG_ATTRS_ADJUSTMENT_MAP = {
	    attributename: 'attributeName',
	    attributetype: 'attributeType',
	    basefrequency: 'baseFrequency',
	    baseprofile: 'baseProfile',
	    calcmode: 'calcMode',
	    clippathunits: 'clipPathUnits',
	    diffuseconstant: 'diffuseConstant',
	    edgemode: 'edgeMode',
	    filterunits: 'filterUnits',
	    glyphref: 'glyphRef',
	    gradienttransform: 'gradientTransform',
	    gradientunits: 'gradientUnits',
	    kernelmatrix: 'kernelMatrix',
	    kernelunitlength: 'kernelUnitLength',
	    keypoints: 'keyPoints',
	    keysplines: 'keySplines',
	    keytimes: 'keyTimes',
	    lengthadjust: 'lengthAdjust',
	    limitingconeangle: 'limitingConeAngle',
	    markerheight: 'markerHeight',
	    markerunits: 'markerUnits',
	    markerwidth: 'markerWidth',
	    maskcontentunits: 'maskContentUnits',
	    maskunits: 'maskUnits',
	    numoctaves: 'numOctaves',
	    pathlength: 'pathLength',
	    patterncontentunits: 'patternContentUnits',
	    patterntransform: 'patternTransform',
	    patternunits: 'patternUnits',
	    pointsatx: 'pointsAtX',
	    pointsaty: 'pointsAtY',
	    pointsatz: 'pointsAtZ',
	    preservealpha: 'preserveAlpha',
	    preserveaspectratio: 'preserveAspectRatio',
	    primitiveunits: 'primitiveUnits',
	    refx: 'refX',
	    refy: 'refY',
	    repeatcount: 'repeatCount',
	    repeatdur: 'repeatDur',
	    requiredextensions: 'requiredExtensions',
	    requiredfeatures: 'requiredFeatures',
	    specularconstant: 'specularConstant',
	    specularexponent: 'specularExponent',
	    spreadmethod: 'spreadMethod',
	    startoffset: 'startOffset',
	    stddeviation: 'stdDeviation',
	    stitchtiles: 'stitchTiles',
	    surfacescale: 'surfaceScale',
	    systemlanguage: 'systemLanguage',
	    tablevalues: 'tableValues',
	    targetx: 'targetX',
	    targety: 'targetY',
	    textlength: 'textLength',
	    viewbox: 'viewBox',
	    viewtarget: 'viewTarget',
	    xchannelselector: 'xChannelSelector',
	    ychannelselector: 'yChannelSelector',
	    zoomandpan: 'zoomAndPan'
	};

	const XML_ATTRS_ADJUSTMENT_MAP = {
	    'xlink:actuate': { prefix: 'xlink', name: 'actuate', namespace: NS.XLINK },
	    'xlink:arcrole': { prefix: 'xlink', name: 'arcrole', namespace: NS.XLINK },
	    'xlink:href': { prefix: 'xlink', name: 'href', namespace: NS.XLINK },
	    'xlink:role': { prefix: 'xlink', name: 'role', namespace: NS.XLINK },
	    'xlink:show': { prefix: 'xlink', name: 'show', namespace: NS.XLINK },
	    'xlink:title': { prefix: 'xlink', name: 'title', namespace: NS.XLINK },
	    'xlink:type': { prefix: 'xlink', name: 'type', namespace: NS.XLINK },
	    'xml:base': { prefix: 'xml', name: 'base', namespace: NS.XML },
	    'xml:lang': { prefix: 'xml', name: 'lang', namespace: NS.XML },
	    'xml:space': { prefix: 'xml', name: 'space', namespace: NS.XML },
	    xmlns: { prefix: '', name: 'xmlns', namespace: NS.XMLNS },
	    'xmlns:xlink': { prefix: 'xmlns', name: 'xlink', namespace: NS.XMLNS }
	};

	//SVG tag names adjustment map
	const SVG_TAG_NAMES_ADJUSTMENT_MAP = (foreignContent.SVG_TAG_NAMES_ADJUSTMENT_MAP = {
	    altglyph: 'altGlyph',
	    altglyphdef: 'altGlyphDef',
	    altglyphitem: 'altGlyphItem',
	    animatecolor: 'animateColor',
	    animatemotion: 'animateMotion',
	    animatetransform: 'animateTransform',
	    clippath: 'clipPath',
	    feblend: 'feBlend',
	    fecolormatrix: 'feColorMatrix',
	    fecomponenttransfer: 'feComponentTransfer',
	    fecomposite: 'feComposite',
	    feconvolvematrix: 'feConvolveMatrix',
	    fediffuselighting: 'feDiffuseLighting',
	    fedisplacementmap: 'feDisplacementMap',
	    fedistantlight: 'feDistantLight',
	    feflood: 'feFlood',
	    fefunca: 'feFuncA',
	    fefuncb: 'feFuncB',
	    fefuncg: 'feFuncG',
	    fefuncr: 'feFuncR',
	    fegaussianblur: 'feGaussianBlur',
	    feimage: 'feImage',
	    femerge: 'feMerge',
	    femergenode: 'feMergeNode',
	    femorphology: 'feMorphology',
	    feoffset: 'feOffset',
	    fepointlight: 'fePointLight',
	    fespecularlighting: 'feSpecularLighting',
	    fespotlight: 'feSpotLight',
	    fetile: 'feTile',
	    feturbulence: 'feTurbulence',
	    foreignobject: 'foreignObject',
	    glyphref: 'glyphRef',
	    lineargradient: 'linearGradient',
	    radialgradient: 'radialGradient',
	    textpath: 'textPath'
	});

	//Tags that causes exit from foreign content
	const EXITS_FOREIGN_CONTENT = {
	    [$.B]: true,
	    [$.BIG]: true,
	    [$.BLOCKQUOTE]: true,
	    [$.BODY]: true,
	    [$.BR]: true,
	    [$.CENTER]: true,
	    [$.CODE]: true,
	    [$.DD]: true,
	    [$.DIV]: true,
	    [$.DL]: true,
	    [$.DT]: true,
	    [$.EM]: true,
	    [$.EMBED]: true,
	    [$.H1]: true,
	    [$.H2]: true,
	    [$.H3]: true,
	    [$.H4]: true,
	    [$.H5]: true,
	    [$.H6]: true,
	    [$.HEAD]: true,
	    [$.HR]: true,
	    [$.I]: true,
	    [$.IMG]: true,
	    [$.LI]: true,
	    [$.LISTING]: true,
	    [$.MENU]: true,
	    [$.META]: true,
	    [$.NOBR]: true,
	    [$.OL]: true,
	    [$.P]: true,
	    [$.PRE]: true,
	    [$.RUBY]: true,
	    [$.S]: true,
	    [$.SMALL]: true,
	    [$.SPAN]: true,
	    [$.STRONG]: true,
	    [$.STRIKE]: true,
	    [$.SUB]: true,
	    [$.SUP]: true,
	    [$.TABLE]: true,
	    [$.TT]: true,
	    [$.U]: true,
	    [$.UL]: true,
	    [$.VAR]: true
	};

	//Check exit from foreign content
	foreignContent.causesExit = function(startTagToken) {
	    const tn = startTagToken.tagName;
	    const isFontWithAttrs =
	        tn === $.FONT &&
	        (Tokenizer.getTokenAttr(startTagToken, ATTRS.COLOR) !== null ||
	            Tokenizer.getTokenAttr(startTagToken, ATTRS.SIZE) !== null ||
	            Tokenizer.getTokenAttr(startTagToken, ATTRS.FACE) !== null);

	    return isFontWithAttrs ? true : EXITS_FOREIGN_CONTENT[tn];
	};

	//Token adjustments
	foreignContent.adjustTokenMathMLAttrs = function(token) {
	    for (let i = 0; i < token.attrs.length; i++) {
	        if (token.attrs[i].name === DEFINITION_URL_ATTR) {
	            token.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR;
	            break;
	        }
	    }
	};

	foreignContent.adjustTokenSVGAttrs = function(token) {
	    for (let i = 0; i < token.attrs.length; i++) {
	        const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP[token.attrs[i].name];

	        if (adjustedAttrName) {
	            token.attrs[i].name = adjustedAttrName;
	        }
	    }
	};

	foreignContent.adjustTokenXMLAttrs = function(token) {
	    for (let i = 0; i < token.attrs.length; i++) {
	        const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP[token.attrs[i].name];

	        if (adjustedAttrEntry) {
	            token.attrs[i].prefix = adjustedAttrEntry.prefix;
	            token.attrs[i].name = adjustedAttrEntry.name;
	            token.attrs[i].namespace = adjustedAttrEntry.namespace;
	        }
	    }
	};

	foreignContent.adjustTokenSVGTagName = function(token) {
	    const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP[token.tagName];

	    if (adjustedTagName) {
	        token.tagName = adjustedTagName;
	    }
	};

	//Integration points
	function isMathMLTextIntegrationPoint(tn, ns) {
	    return ns === NS.MATHML && (tn === $.MI || tn === $.MO || tn === $.MN || tn === $.MS || tn === $.MTEXT);
	}

	function isHtmlIntegrationPoint(tn, ns, attrs) {
	    if (ns === NS.MATHML && tn === $.ANNOTATION_XML) {
	        for (let i = 0; i < attrs.length; i++) {
	            if (attrs[i].name === ATTRS.ENCODING) {
	                const value = attrs[i].value.toLowerCase();

	                return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
	            }
	        }
	    }

	    return ns === NS.SVG && (tn === $.FOREIGN_OBJECT || tn === $.DESC || tn === $.TITLE);
	}

	foreignContent.isIntegrationPoint = function(tn, ns, attrs, foreignNS) {
	    if ((!foreignNS || foreignNS === NS.HTML) && isHtmlIntegrationPoint(tn, ns, attrs)) {
	        return true;
	    }

	    if ((!foreignNS || foreignNS === NS.MATHML) && isMathMLTextIntegrationPoint(tn, ns)) {
	        return true;
	    }

	    return false;
	};
	return foreignContent;
}

var parser;
var hasRequiredParser;

function requireParser () {
	if (hasRequiredParser) return parser;
	hasRequiredParser = 1;

	const Tokenizer = requireTokenizer();
	const OpenElementStack = requireOpenElementStack();
	const FormattingElementList = requireFormattingElementList();
	const LocationInfoParserMixin = requireParserMixin$1();
	const ErrorReportingParserMixin = requireParserMixin();
	const Mixin = requireMixin();
	const defaultTreeAdapter = require_default();
	const mergeOptions = requireMergeOptions();
	const doctype = requireDoctype$1();
	const foreignContent = requireForeignContent();
	const ERR = requireErrorCodes();
	const unicode = requireUnicode();
	const HTML = requireHtml();

	//Aliases
	const $ = HTML.TAG_NAMES;
	const NS = HTML.NAMESPACES;
	const ATTRS = HTML.ATTRS;

	const DEFAULT_OPTIONS = {
	    scriptingEnabled: true,
	    sourceCodeLocationInfo: false,
	    onParseError: null,
	    treeAdapter: defaultTreeAdapter
	};

	//Misc constants
	const HIDDEN_INPUT_TYPE = 'hidden';

	//Adoption agency loops iteration count
	const AA_OUTER_LOOP_ITER = 8;
	const AA_INNER_LOOP_ITER = 3;

	//Insertion modes
	const INITIAL_MODE = 'INITIAL_MODE';
	const BEFORE_HTML_MODE = 'BEFORE_HTML_MODE';
	const BEFORE_HEAD_MODE = 'BEFORE_HEAD_MODE';
	const IN_HEAD_MODE = 'IN_HEAD_MODE';
	const IN_HEAD_NO_SCRIPT_MODE = 'IN_HEAD_NO_SCRIPT_MODE';
	const AFTER_HEAD_MODE = 'AFTER_HEAD_MODE';
	const IN_BODY_MODE = 'IN_BODY_MODE';
	const TEXT_MODE = 'TEXT_MODE';
	const IN_TABLE_MODE = 'IN_TABLE_MODE';
	const IN_TABLE_TEXT_MODE = 'IN_TABLE_TEXT_MODE';
	const IN_CAPTION_MODE = 'IN_CAPTION_MODE';
	const IN_COLUMN_GROUP_MODE = 'IN_COLUMN_GROUP_MODE';
	const IN_TABLE_BODY_MODE = 'IN_TABLE_BODY_MODE';
	const IN_ROW_MODE = 'IN_ROW_MODE';
	const IN_CELL_MODE = 'IN_CELL_MODE';
	const IN_SELECT_MODE = 'IN_SELECT_MODE';
	const IN_SELECT_IN_TABLE_MODE = 'IN_SELECT_IN_TABLE_MODE';
	const IN_TEMPLATE_MODE = 'IN_TEMPLATE_MODE';
	const AFTER_BODY_MODE = 'AFTER_BODY_MODE';
	const IN_FRAMESET_MODE = 'IN_FRAMESET_MODE';
	const AFTER_FRAMESET_MODE = 'AFTER_FRAMESET_MODE';
	const AFTER_AFTER_BODY_MODE = 'AFTER_AFTER_BODY_MODE';
	const AFTER_AFTER_FRAMESET_MODE = 'AFTER_AFTER_FRAMESET_MODE';

	//Insertion mode reset map
	const INSERTION_MODE_RESET_MAP = {
	    [$.TR]: IN_ROW_MODE,
	    [$.TBODY]: IN_TABLE_BODY_MODE,
	    [$.THEAD]: IN_TABLE_BODY_MODE,
	    [$.TFOOT]: IN_TABLE_BODY_MODE,
	    [$.CAPTION]: IN_CAPTION_MODE,
	    [$.COLGROUP]: IN_COLUMN_GROUP_MODE,
	    [$.TABLE]: IN_TABLE_MODE,
	    [$.BODY]: IN_BODY_MODE,
	    [$.FRAMESET]: IN_FRAMESET_MODE
	};

	//Template insertion mode switch map
	const TEMPLATE_INSERTION_MODE_SWITCH_MAP = {
	    [$.CAPTION]: IN_TABLE_MODE,
	    [$.COLGROUP]: IN_TABLE_MODE,
	    [$.TBODY]: IN_TABLE_MODE,
	    [$.TFOOT]: IN_TABLE_MODE,
	    [$.THEAD]: IN_TABLE_MODE,
	    [$.COL]: IN_COLUMN_GROUP_MODE,
	    [$.TR]: IN_TABLE_BODY_MODE,
	    [$.TD]: IN_ROW_MODE,
	    [$.TH]: IN_ROW_MODE
	};

	//Token handlers map for insertion modes
	const TOKEN_HANDLERS = {
	    [INITIAL_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: tokenInInitialMode,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInInitialMode,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: doctypeInInitialMode,
	        [Tokenizer.START_TAG_TOKEN]: tokenInInitialMode,
	        [Tokenizer.END_TAG_TOKEN]: tokenInInitialMode,
	        [Tokenizer.EOF_TOKEN]: tokenInInitialMode
	    },
	    [BEFORE_HTML_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHtml,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHtml,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagBeforeHtml,
	        [Tokenizer.END_TAG_TOKEN]: endTagBeforeHtml,
	        [Tokenizer.EOF_TOKEN]: tokenBeforeHtml
	    },
	    [BEFORE_HEAD_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHead,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHead,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
	        [Tokenizer.START_TAG_TOKEN]: startTagBeforeHead,
	        [Tokenizer.END_TAG_TOKEN]: endTagBeforeHead,
	        [Tokenizer.EOF_TOKEN]: tokenBeforeHead
	    },
	    [IN_HEAD_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: tokenInHead,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHead,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
	        [Tokenizer.START_TAG_TOKEN]: startTagInHead,
	        [Tokenizer.END_TAG_TOKEN]: endTagInHead,
	        [Tokenizer.EOF_TOKEN]: tokenInHead
	    },
	    [IN_HEAD_NO_SCRIPT_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: tokenInHeadNoScript,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHeadNoScript,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
	        [Tokenizer.START_TAG_TOKEN]: startTagInHeadNoScript,
	        [Tokenizer.END_TAG_TOKEN]: endTagInHeadNoScript,
	        [Tokenizer.EOF_TOKEN]: tokenInHeadNoScript
	    },
	    [AFTER_HEAD_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: tokenAfterHead,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterHead,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
	        [Tokenizer.START_TAG_TOKEN]: startTagAfterHead,
	        [Tokenizer.END_TAG_TOKEN]: endTagAfterHead,
	        [Tokenizer.EOF_TOKEN]: tokenAfterHead
	    },
	    [IN_BODY_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: characterInBody,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagInBody,
	        [Tokenizer.END_TAG_TOKEN]: endTagInBody,
	        [Tokenizer.EOF_TOKEN]: eofInBody
	    },
	    [TEXT_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.COMMENT_TOKEN]: ignoreToken,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: ignoreToken,
	        [Tokenizer.END_TAG_TOKEN]: endTagInText,
	        [Tokenizer.EOF_TOKEN]: eofInText
	    },
	    [IN_TABLE_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: characterInTable,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagInTable,
	        [Tokenizer.END_TAG_TOKEN]: endTagInTable,
	        [Tokenizer.EOF_TOKEN]: eofInBody
	    },
	    [IN_TABLE_TEXT_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: characterInTableText,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInTableText,
	        [Tokenizer.COMMENT_TOKEN]: tokenInTableText,
	        [Tokenizer.DOCTYPE_TOKEN]: tokenInTableText,
	        [Tokenizer.START_TAG_TOKEN]: tokenInTableText,
	        [Tokenizer.END_TAG_TOKEN]: tokenInTableText,
	        [Tokenizer.EOF_TOKEN]: tokenInTableText
	    },
	    [IN_CAPTION_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: characterInBody,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagInCaption,
	        [Tokenizer.END_TAG_TOKEN]: endTagInCaption,
	        [Tokenizer.EOF_TOKEN]: eofInBody
	    },
	    [IN_COLUMN_GROUP_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: tokenInColumnGroup,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInColumnGroup,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagInColumnGroup,
	        [Tokenizer.END_TAG_TOKEN]: endTagInColumnGroup,
	        [Tokenizer.EOF_TOKEN]: eofInBody
	    },
	    [IN_TABLE_BODY_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: characterInTable,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagInTableBody,
	        [Tokenizer.END_TAG_TOKEN]: endTagInTableBody,
	        [Tokenizer.EOF_TOKEN]: eofInBody
	    },
	    [IN_ROW_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: characterInTable,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagInRow,
	        [Tokenizer.END_TAG_TOKEN]: endTagInRow,
	        [Tokenizer.EOF_TOKEN]: eofInBody
	    },
	    [IN_CELL_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: characterInBody,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagInCell,
	        [Tokenizer.END_TAG_TOKEN]: endTagInCell,
	        [Tokenizer.EOF_TOKEN]: eofInBody
	    },
	    [IN_SELECT_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagInSelect,
	        [Tokenizer.END_TAG_TOKEN]: endTagInSelect,
	        [Tokenizer.EOF_TOKEN]: eofInBody
	    },
	    [IN_SELECT_IN_TABLE_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagInSelectInTable,
	        [Tokenizer.END_TAG_TOKEN]: endTagInSelectInTable,
	        [Tokenizer.EOF_TOKEN]: eofInBody
	    },
	    [IN_TEMPLATE_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: characterInBody,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagInTemplate,
	        [Tokenizer.END_TAG_TOKEN]: endTagInTemplate,
	        [Tokenizer.EOF_TOKEN]: eofInTemplate
	    },
	    [AFTER_BODY_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: tokenAfterBody,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterBody,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
	        [Tokenizer.COMMENT_TOKEN]: appendCommentToRootHtmlElement,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagAfterBody,
	        [Tokenizer.END_TAG_TOKEN]: endTagAfterBody,
	        [Tokenizer.EOF_TOKEN]: stopParsing
	    },
	    [IN_FRAMESET_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagInFrameset,
	        [Tokenizer.END_TAG_TOKEN]: endTagInFrameset,
	        [Tokenizer.EOF_TOKEN]: stopParsing
	    },
	    [AFTER_FRAMESET_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
	        [Tokenizer.COMMENT_TOKEN]: appendComment,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagAfterFrameset,
	        [Tokenizer.END_TAG_TOKEN]: endTagAfterFrameset,
	        [Tokenizer.EOF_TOKEN]: stopParsing
	    },
	    [AFTER_AFTER_BODY_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: tokenAfterAfterBody,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterAfterBody,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
	        [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterBody,
	        [Tokenizer.END_TAG_TOKEN]: tokenAfterAfterBody,
	        [Tokenizer.EOF_TOKEN]: stopParsing
	    },
	    [AFTER_AFTER_FRAMESET_MODE]: {
	        [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
	        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
	        [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,
	        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
	        [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterFrameset,
	        [Tokenizer.END_TAG_TOKEN]: ignoreToken,
	        [Tokenizer.EOF_TOKEN]: stopParsing
	    }
	};

	//Parser
	class Parser {
	    constructor(options) {
	        this.options = mergeOptions(DEFAULT_OPTIONS, options);

	        this.treeAdapter = this.options.treeAdapter;
	        this.pendingScript = null;

	        if (this.options.sourceCodeLocationInfo) {
	            Mixin.install(this, LocationInfoParserMixin);
	        }

	        if (this.options.onParseError) {
	            Mixin.install(this, ErrorReportingParserMixin, { onParseError: this.options.onParseError });
	        }
	    }

	    // API
	    parse(html) {
	        const document = this.treeAdapter.createDocument();

	        this._bootstrap(document, null);
	        this.tokenizer.write(html, true);
	        this._runParsingLoop(null);

	        return document;
	    }

	    parseFragment(html, fragmentContext) {
	        //NOTE: use <template> element as a fragment context if context element was not provided,
	        //so we will parse in "forgiving" manner
	        if (!fragmentContext) {
	            fragmentContext = this.treeAdapter.createElement($.TEMPLATE, NS.HTML, []);
	        }

	        //NOTE: create fake element which will be used as 'document' for fragment parsing.
	        //This is important for jsdom there 'document' can't be recreated, therefore
	        //fragment parsing causes messing of the main `document`.
	        const documentMock = this.treeAdapter.createElement('documentmock', NS.HTML, []);

	        this._bootstrap(documentMock, fragmentContext);

	        if (this.treeAdapter.getTagName(fragmentContext) === $.TEMPLATE) {
	            this._pushTmplInsertionMode(IN_TEMPLATE_MODE);
	        }

	        this._initTokenizerForFragmentParsing();
	        this._insertFakeRootElement();
	        this._resetInsertionMode();
	        this._findFormInFragmentContext();
	        this.tokenizer.write(html, true);
	        this._runParsingLoop(null);

	        const rootElement = this.treeAdapter.getFirstChild(documentMock);
	        const fragment = this.treeAdapter.createDocumentFragment();

	        this._adoptNodes(rootElement, fragment);

	        return fragment;
	    }

	    //Bootstrap parser
	    _bootstrap(document, fragmentContext) {
	        this.tokenizer = new Tokenizer(this.options);

	        this.stopped = false;

	        this.insertionMode = INITIAL_MODE;
	        this.originalInsertionMode = '';

	        this.document = document;
	        this.fragmentContext = fragmentContext;

	        this.headElement = null;
	        this.formElement = null;

	        this.openElements = new OpenElementStack(this.document, this.treeAdapter);
	        this.activeFormattingElements = new FormattingElementList(this.treeAdapter);

	        this.tmplInsertionModeStack = [];
	        this.tmplInsertionModeStackTop = -1;
	        this.currentTmplInsertionMode = null;

	        this.pendingCharacterTokens = [];
	        this.hasNonWhitespacePendingCharacterToken = false;

	        this.framesetOk = true;
	        this.skipNextNewLine = false;
	        this.fosterParentingEnabled = false;
	    }

	    //Errors
	    _err() {
	        // NOTE: err reporting is noop by default. Enabled by mixin.
	    }

	    //Parsing loop
	    _runParsingLoop(scriptHandler) {
	        while (!this.stopped) {
	            this._setupTokenizerCDATAMode();

	            const token = this.tokenizer.getNextToken();

	            if (token.type === Tokenizer.HIBERNATION_TOKEN) {
	                break;
	            }

	            if (this.skipNextNewLine) {
	                this.skipNextNewLine = false;

	                if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN && token.chars[0] === '\n') {
	                    if (token.chars.length === 1) {
	                        continue;
	                    }

	                    token.chars = token.chars.substr(1);
	                }
	            }

	            this._processInputToken(token);

	            if (scriptHandler && this.pendingScript) {
	                break;
	            }
	        }
	    }

	    runParsingLoopForCurrentChunk(writeCallback, scriptHandler) {
	        this._runParsingLoop(scriptHandler);

	        if (scriptHandler && this.pendingScript) {
	            const script = this.pendingScript;

	            this.pendingScript = null;

	            scriptHandler(script);

	            return;
	        }

	        if (writeCallback) {
	            writeCallback();
	        }
	    }

	    //Text parsing
	    _setupTokenizerCDATAMode() {
	        const current = this._getAdjustedCurrentElement();

	        this.tokenizer.allowCDATA =
	            current &&
	            current !== this.document &&
	            this.treeAdapter.getNamespaceURI(current) !== NS.HTML &&
	            !this._isIntegrationPoint(current);
	    }

	    _switchToTextParsing(currentToken, nextTokenizerState) {
	        this._insertElement(currentToken, NS.HTML);
	        this.tokenizer.state = nextTokenizerState;
	        this.originalInsertionMode = this.insertionMode;
	        this.insertionMode = TEXT_MODE;
	    }

	    switchToPlaintextParsing() {
	        this.insertionMode = TEXT_MODE;
	        this.originalInsertionMode = IN_BODY_MODE;
	        this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
	    }

	    //Fragment parsing
	    _getAdjustedCurrentElement() {
	        return this.openElements.stackTop === 0 && this.fragmentContext
	            ? this.fragmentContext
	            : this.openElements.current;
	    }

	    _findFormInFragmentContext() {
	        let node = this.fragmentContext;

	        do {
	            if (this.treeAdapter.getTagName(node) === $.FORM) {
	                this.formElement = node;
	                break;
	            }

	            node = this.treeAdapter.getParentNode(node);
	        } while (node);
	    }

	    _initTokenizerForFragmentParsing() {
	        if (this.treeAdapter.getNamespaceURI(this.fragmentContext) === NS.HTML) {
	            const tn = this.treeAdapter.getTagName(this.fragmentContext);

	            if (tn === $.TITLE || tn === $.TEXTAREA) {
	                this.tokenizer.state = Tokenizer.MODE.RCDATA;
	            } else if (
	                tn === $.STYLE ||
	                tn === $.XMP ||
	                tn === $.IFRAME ||
	                tn === $.NOEMBED ||
	                tn === $.NOFRAMES ||
	                tn === $.NOSCRIPT
	            ) {
	                this.tokenizer.state = Tokenizer.MODE.RAWTEXT;
	            } else if (tn === $.SCRIPT) {
	                this.tokenizer.state = Tokenizer.MODE.SCRIPT_DATA;
	            } else if (tn === $.PLAINTEXT) {
	                this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
	            }
	        }
	    }

	    //Tree mutation
	    _setDocumentType(token) {
	        const name = token.name || '';
	        const publicId = token.publicId || '';
	        const systemId = token.systemId || '';

	        this.treeAdapter.setDocumentType(this.document, name, publicId, systemId);
	    }

	    _attachElementToTree(element) {
	        if (this._shouldFosterParentOnInsertion()) {
	            this._fosterParentElement(element);
	        } else {
	            const parent = this.openElements.currentTmplContent || this.openElements.current;

	            this.treeAdapter.appendChild(parent, element);
	        }
	    }

	    _appendElement(token, namespaceURI) {
	        const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);

	        this._attachElementToTree(element);
	    }

	    _insertElement(token, namespaceURI) {
	        const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);

	        this._attachElementToTree(element);
	        this.openElements.push(element);
	    }

	    _insertFakeElement(tagName) {
	        const element = this.treeAdapter.createElement(tagName, NS.HTML, []);

	        this._attachElementToTree(element);
	        this.openElements.push(element);
	    }

	    _insertTemplate(token) {
	        const tmpl = this.treeAdapter.createElement(token.tagName, NS.HTML, token.attrs);
	        const content = this.treeAdapter.createDocumentFragment();

	        this.treeAdapter.setTemplateContent(tmpl, content);
	        this._attachElementToTree(tmpl);
	        this.openElements.push(tmpl);
	    }

	    _insertFakeRootElement() {
	        const element = this.treeAdapter.createElement($.HTML, NS.HTML, []);

	        this.treeAdapter.appendChild(this.openElements.current, element);
	        this.openElements.push(element);
	    }

	    _appendCommentNode(token, parent) {
	        const commentNode = this.treeAdapter.createCommentNode(token.data);

	        this.treeAdapter.appendChild(parent, commentNode);
	    }

	    _insertCharacters(token) {
	        if (this._shouldFosterParentOnInsertion()) {
	            this._fosterParentText(token.chars);
	        } else {
	            const parent = this.openElements.currentTmplContent || this.openElements.current;

	            this.treeAdapter.insertText(parent, token.chars);
	        }
	    }

	    _adoptNodes(donor, recipient) {
	        for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
	            this.treeAdapter.detachNode(child);
	            this.treeAdapter.appendChild(recipient, child);
	        }
	    }

	    //Token processing
	    _shouldProcessTokenInForeignContent(token) {
	        const current = this._getAdjustedCurrentElement();

	        if (!current || current === this.document) {
	            return false;
	        }

	        const ns = this.treeAdapter.getNamespaceURI(current);

	        if (ns === NS.HTML) {
	            return false;
	        }

	        if (
	            this.treeAdapter.getTagName(current) === $.ANNOTATION_XML &&
	            ns === NS.MATHML &&
	            token.type === Tokenizer.START_TAG_TOKEN &&
	            token.tagName === $.SVG
	        ) {
	            return false;
	        }

	        const isCharacterToken =
	            token.type === Tokenizer.CHARACTER_TOKEN ||
	            token.type === Tokenizer.NULL_CHARACTER_TOKEN ||
	            token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN;

	        const isMathMLTextStartTag =
	            token.type === Tokenizer.START_TAG_TOKEN && token.tagName !== $.MGLYPH && token.tagName !== $.MALIGNMARK;

	        if ((isMathMLTextStartTag || isCharacterToken) && this._isIntegrationPoint(current, NS.MATHML)) {
	            return false;
	        }

	        if (
	            (token.type === Tokenizer.START_TAG_TOKEN || isCharacterToken) &&
	            this._isIntegrationPoint(current, NS.HTML)
	        ) {
	            return false;
	        }

	        return token.type !== Tokenizer.EOF_TOKEN;
	    }

	    _processToken(token) {
	        TOKEN_HANDLERS[this.insertionMode][token.type](this, token);
	    }

	    _processTokenInBodyMode(token) {
	        TOKEN_HANDLERS[IN_BODY_MODE][token.type](this, token);
	    }

	    _processTokenInForeignContent(token) {
	        if (token.type === Tokenizer.CHARACTER_TOKEN) {
	            characterInForeignContent(this, token);
	        } else if (token.type === Tokenizer.NULL_CHARACTER_TOKEN) {
	            nullCharacterInForeignContent(this, token);
	        } else if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN) {
	            insertCharacters(this, token);
	        } else if (token.type === Tokenizer.COMMENT_TOKEN) {
	            appendComment(this, token);
	        } else if (token.type === Tokenizer.START_TAG_TOKEN) {
	            startTagInForeignContent(this, token);
	        } else if (token.type === Tokenizer.END_TAG_TOKEN) {
	            endTagInForeignContent(this, token);
	        }
	    }

	    _processInputToken(token) {
	        if (this._shouldProcessTokenInForeignContent(token)) {
	            this._processTokenInForeignContent(token);
	        } else {
	            this._processToken(token);
	        }

	        if (token.type === Tokenizer.START_TAG_TOKEN && token.selfClosing && !token.ackSelfClosing) {
	            this._err(ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
	        }
	    }

	    //Integration points
	    _isIntegrationPoint(element, foreignNS) {
	        const tn = this.treeAdapter.getTagName(element);
	        const ns = this.treeAdapter.getNamespaceURI(element);
	        const attrs = this.treeAdapter.getAttrList(element);

	        return foreignContent.isIntegrationPoint(tn, ns, attrs, foreignNS);
	    }

	    //Active formatting elements reconstruction
	    _reconstructActiveFormattingElements() {
	        const listLength = this.activeFormattingElements.length;

	        if (listLength) {
	            let unopenIdx = listLength;
	            let entry = null;

	            do {
	                unopenIdx--;
	                entry = this.activeFormattingElements.entries[unopenIdx];

	                if (entry.type === FormattingElementList.MARKER_ENTRY || this.openElements.contains(entry.element)) {
	                    unopenIdx++;
	                    break;
	                }
	            } while (unopenIdx > 0);

	            for (let i = unopenIdx; i < listLength; i++) {
	                entry = this.activeFormattingElements.entries[i];
	                this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
	                entry.element = this.openElements.current;
	            }
	        }
	    }

	    //Close elements
	    _closeTableCell() {
	        this.openElements.generateImpliedEndTags();
	        this.openElements.popUntilTableCellPopped();
	        this.activeFormattingElements.clearToLastMarker();
	        this.insertionMode = IN_ROW_MODE;
	    }

	    _closePElement() {
	        this.openElements.generateImpliedEndTagsWithExclusion($.P);
	        this.openElements.popUntilTagNamePopped($.P);
	    }

	    //Insertion modes
	    _resetInsertionMode() {
	        for (let i = this.openElements.stackTop, last = false; i >= 0; i--) {
	            let element = this.openElements.items[i];

	            if (i === 0) {
	                last = true;

	                if (this.fragmentContext) {
	                    element = this.fragmentContext;
	                }
	            }

	            const tn = this.treeAdapter.getTagName(element);
	            const newInsertionMode = INSERTION_MODE_RESET_MAP[tn];

	            if (newInsertionMode) {
	                this.insertionMode = newInsertionMode;
	                break;
	            } else if (!last && (tn === $.TD || tn === $.TH)) {
	                this.insertionMode = IN_CELL_MODE;
	                break;
	            } else if (!last && tn === $.HEAD) {
	                this.insertionMode = IN_HEAD_MODE;
	                break;
	            } else if (tn === $.SELECT) {
	                this._resetInsertionModeForSelect(i);
	                break;
	            } else if (tn === $.TEMPLATE) {
	                this.insertionMode = this.currentTmplInsertionMode;
	                break;
	            } else if (tn === $.HTML) {
	                this.insertionMode = this.headElement ? AFTER_HEAD_MODE : BEFORE_HEAD_MODE;
	                break;
	            } else if (last) {
	                this.insertionMode = IN_BODY_MODE;
	                break;
	            }
	        }
	    }

	    _resetInsertionModeForSelect(selectIdx) {
	        if (selectIdx > 0) {
	            for (let i = selectIdx - 1; i > 0; i--) {
	                const ancestor = this.openElements.items[i];
	                const tn = this.treeAdapter.getTagName(ancestor);

	                if (tn === $.TEMPLATE) {
	                    break;
	                } else if (tn === $.TABLE) {
	                    this.insertionMode = IN_SELECT_IN_TABLE_MODE;
	                    return;
	                }
	            }
	        }

	        this.insertionMode = IN_SELECT_MODE;
	    }

	    _pushTmplInsertionMode(mode) {
	        this.tmplInsertionModeStack.push(mode);
	        this.tmplInsertionModeStackTop++;
	        this.currentTmplInsertionMode = mode;
	    }

	    _popTmplInsertionMode() {
	        this.tmplInsertionModeStack.pop();
	        this.tmplInsertionModeStackTop--;
	        this.currentTmplInsertionMode = this.tmplInsertionModeStack[this.tmplInsertionModeStackTop];
	    }

	    //Foster parenting
	    _isElementCausesFosterParenting(element) {
	        const tn = this.treeAdapter.getTagName(element);

	        return tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR;
	    }

	    _shouldFosterParentOnInsertion() {
	        return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.current);
	    }

	    _findFosterParentingLocation() {
	        const location = {
	            parent: null,
	            beforeElement: null
	        };

	        for (let i = this.openElements.stackTop; i >= 0; i--) {
	            const openElement = this.openElements.items[i];
	            const tn = this.treeAdapter.getTagName(openElement);
	            const ns = this.treeAdapter.getNamespaceURI(openElement);

	            if (tn === $.TEMPLATE && ns === NS.HTML) {
	                location.parent = this.treeAdapter.getTemplateContent(openElement);
	                break;
	            } else if (tn === $.TABLE) {
	                location.parent = this.treeAdapter.getParentNode(openElement);

	                if (location.parent) {
	                    location.beforeElement = openElement;
	                } else {
	                    location.parent = this.openElements.items[i - 1];
	                }

	                break;
	            }
	        }

	        if (!location.parent) {
	            location.parent = this.openElements.items[0];
	        }

	        return location;
	    }

	    _fosterParentElement(element) {
	        const location = this._findFosterParentingLocation();

	        if (location.beforeElement) {
	            this.treeAdapter.insertBefore(location.parent, element, location.beforeElement);
	        } else {
	            this.treeAdapter.appendChild(location.parent, element);
	        }
	    }

	    _fosterParentText(chars) {
	        const location = this._findFosterParentingLocation();

	        if (location.beforeElement) {
	            this.treeAdapter.insertTextBefore(location.parent, chars, location.beforeElement);
	        } else {
	            this.treeAdapter.insertText(location.parent, chars);
	        }
	    }

	    //Special elements
	    _isSpecialElement(element) {
	        const tn = this.treeAdapter.getTagName(element);
	        const ns = this.treeAdapter.getNamespaceURI(element);

	        return HTML.SPECIAL_ELEMENTS[ns][tn];
	    }
	}

	parser = Parser;

	//Adoption agency algorithm
	//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#adoptionAgency)
	//------------------------------------------------------------------

	//Steps 5-8 of the algorithm
	function aaObtainFormattingElementEntry(p, token) {
	    let formattingElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);

	    if (formattingElementEntry) {
	        if (!p.openElements.contains(formattingElementEntry.element)) {
	            p.activeFormattingElements.removeEntry(formattingElementEntry);
	            formattingElementEntry = null;
	        } else if (!p.openElements.hasInScope(token.tagName)) {
	            formattingElementEntry = null;
	        }
	    } else {
	        genericEndTagInBody(p, token);
	    }

	    return formattingElementEntry;
	}

	//Steps 9 and 10 of the algorithm
	function aaObtainFurthestBlock(p, formattingElementEntry) {
	    let furthestBlock = null;

	    for (let i = p.openElements.stackTop; i >= 0; i--) {
	        const element = p.openElements.items[i];

	        if (element === formattingElementEntry.element) {
	            break;
	        }

	        if (p._isSpecialElement(element)) {
	            furthestBlock = element;
	        }
	    }

	    if (!furthestBlock) {
	        p.openElements.popUntilElementPopped(formattingElementEntry.element);
	        p.activeFormattingElements.removeEntry(formattingElementEntry);
	    }

	    return furthestBlock;
	}

	//Step 13 of the algorithm
	function aaInnerLoop(p, furthestBlock, formattingElement) {
	    let lastElement = furthestBlock;
	    let nextElement = p.openElements.getCommonAncestor(furthestBlock);

	    for (let i = 0, element = nextElement; element !== formattingElement; i++, element = nextElement) {
	        //NOTE: store next element for the next loop iteration (it may be deleted from the stack by step 9.5)
	        nextElement = p.openElements.getCommonAncestor(element);

	        const elementEntry = p.activeFormattingElements.getElementEntry(element);
	        const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER;
	        const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;

	        if (shouldRemoveFromOpenElements) {
	            if (counterOverflow) {
	                p.activeFormattingElements.removeEntry(elementEntry);
	            }

	            p.openElements.remove(element);
	        } else {
	            element = aaRecreateElementFromEntry(p, elementEntry);

	            if (lastElement === furthestBlock) {
	                p.activeFormattingElements.bookmark = elementEntry;
	            }

	            p.treeAdapter.detachNode(lastElement);
	            p.treeAdapter.appendChild(element, lastElement);
	            lastElement = element;
	        }
	    }

	    return lastElement;
	}

	//Step 13.7 of the algorithm
	function aaRecreateElementFromEntry(p, elementEntry) {
	    const ns = p.treeAdapter.getNamespaceURI(elementEntry.element);
	    const newElement = p.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);

	    p.openElements.replace(elementEntry.element, newElement);
	    elementEntry.element = newElement;

	    return newElement;
	}

	//Step 14 of the algorithm
	function aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement) {
	    if (p._isElementCausesFosterParenting(commonAncestor)) {
	        p._fosterParentElement(lastElement);
	    } else {
	        const tn = p.treeAdapter.getTagName(commonAncestor);
	        const ns = p.treeAdapter.getNamespaceURI(commonAncestor);

	        if (tn === $.TEMPLATE && ns === NS.HTML) {
	            commonAncestor = p.treeAdapter.getTemplateContent(commonAncestor);
	        }

	        p.treeAdapter.appendChild(commonAncestor, lastElement);
	    }
	}

	//Steps 15-19 of the algorithm
	function aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry) {
	    const ns = p.treeAdapter.getNamespaceURI(formattingElementEntry.element);
	    const token = formattingElementEntry.token;
	    const newElement = p.treeAdapter.createElement(token.tagName, ns, token.attrs);

	    p._adoptNodes(furthestBlock, newElement);
	    p.treeAdapter.appendChild(furthestBlock, newElement);

	    p.activeFormattingElements.insertElementAfterBookmark(newElement, formattingElementEntry.token);
	    p.activeFormattingElements.removeEntry(formattingElementEntry);

	    p.openElements.remove(formattingElementEntry.element);
	    p.openElements.insertAfter(furthestBlock, newElement);
	}

	//Algorithm entry point
	function callAdoptionAgency(p, token) {
	    let formattingElementEntry;

	    for (let i = 0; i < AA_OUTER_LOOP_ITER; i++) {
	        formattingElementEntry = aaObtainFormattingElementEntry(p, token);

	        if (!formattingElementEntry) {
	            break;
	        }

	        const furthestBlock = aaObtainFurthestBlock(p, formattingElementEntry);

	        if (!furthestBlock) {
	            break;
	        }

	        p.activeFormattingElements.bookmark = formattingElementEntry;

	        const lastElement = aaInnerLoop(p, furthestBlock, formattingElementEntry.element);
	        const commonAncestor = p.openElements.getCommonAncestor(formattingElementEntry.element);

	        p.treeAdapter.detachNode(lastElement);
	        aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement);
	        aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry);
	    }
	}

	//Generic token handlers
	//------------------------------------------------------------------
	function ignoreToken() {
	    //NOTE: do nothing =)
	}

	function misplacedDoctype(p) {
	    p._err(ERR.misplacedDoctype);
	}

	function appendComment(p, token) {
	    p._appendCommentNode(token, p.openElements.currentTmplContent || p.openElements.current);
	}

	function appendCommentToRootHtmlElement(p, token) {
	    p._appendCommentNode(token, p.openElements.items[0]);
	}

	function appendCommentToDocument(p, token) {
	    p._appendCommentNode(token, p.document);
	}

	function insertCharacters(p, token) {
	    p._insertCharacters(token);
	}

	function stopParsing(p) {
	    p.stopped = true;
	}

	// The "initial" insertion mode
	//------------------------------------------------------------------
	function doctypeInInitialMode(p, token) {
	    p._setDocumentType(token);

	    const mode = token.forceQuirks ? HTML.DOCUMENT_MODE.QUIRKS : doctype.getDocumentMode(token);

	    if (!doctype.isConforming(token)) {
	        p._err(ERR.nonConformingDoctype);
	    }

	    p.treeAdapter.setDocumentMode(p.document, mode);

	    p.insertionMode = BEFORE_HTML_MODE;
	}

	function tokenInInitialMode(p, token) {
	    p._err(ERR.missingDoctype, { beforeToken: true });
	    p.treeAdapter.setDocumentMode(p.document, HTML.DOCUMENT_MODE.QUIRKS);
	    p.insertionMode = BEFORE_HTML_MODE;
	    p._processToken(token);
	}

	// The "before html" insertion mode
	//------------------------------------------------------------------
	function startTagBeforeHtml(p, token) {
	    if (token.tagName === $.HTML) {
	        p._insertElement(token, NS.HTML);
	        p.insertionMode = BEFORE_HEAD_MODE;
	    } else {
	        tokenBeforeHtml(p, token);
	    }
	}

	function endTagBeforeHtml(p, token) {
	    const tn = token.tagName;

	    if (tn === $.HTML || tn === $.HEAD || tn === $.BODY || tn === $.BR) {
	        tokenBeforeHtml(p, token);
	    }
	}

	function tokenBeforeHtml(p, token) {
	    p._insertFakeRootElement();
	    p.insertionMode = BEFORE_HEAD_MODE;
	    p._processToken(token);
	}

	// The "before head" insertion mode
	//------------------------------------------------------------------
	function startTagBeforeHead(p, token) {
	    const tn = token.tagName;

	    if (tn === $.HTML) {
	        startTagInBody(p, token);
	    } else if (tn === $.HEAD) {
	        p._insertElement(token, NS.HTML);
	        p.headElement = p.openElements.current;
	        p.insertionMode = IN_HEAD_MODE;
	    } else {
	        tokenBeforeHead(p, token);
	    }
	}

	function endTagBeforeHead(p, token) {
	    const tn = token.tagName;

	    if (tn === $.HEAD || tn === $.BODY || tn === $.HTML || tn === $.BR) {
	        tokenBeforeHead(p, token);
	    } else {
	        p._err(ERR.endTagWithoutMatchingOpenElement);
	    }
	}

	function tokenBeforeHead(p, token) {
	    p._insertFakeElement($.HEAD);
	    p.headElement = p.openElements.current;
	    p.insertionMode = IN_HEAD_MODE;
	    p._processToken(token);
	}

	// The "in head" insertion mode
	//------------------------------------------------------------------
	function startTagInHead(p, token) {
	    const tn = token.tagName;

	    if (tn === $.HTML) {
	        startTagInBody(p, token);
	    } else if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META) {
	        p._appendElement(token, NS.HTML);
	        token.ackSelfClosing = true;
	    } else if (tn === $.TITLE) {
	        p._switchToTextParsing(token, Tokenizer.MODE.RCDATA);
	    } else if (tn === $.NOSCRIPT) {
	        if (p.options.scriptingEnabled) {
	            p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
	        } else {
	            p._insertElement(token, NS.HTML);
	            p.insertionMode = IN_HEAD_NO_SCRIPT_MODE;
	        }
	    } else if (tn === $.NOFRAMES || tn === $.STYLE) {
	        p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
	    } else if (tn === $.SCRIPT) {
	        p._switchToTextParsing(token, Tokenizer.MODE.SCRIPT_DATA);
	    } else if (tn === $.TEMPLATE) {
	        p._insertTemplate(token, NS.HTML);
	        p.activeFormattingElements.insertMarker();
	        p.framesetOk = false;
	        p.insertionMode = IN_TEMPLATE_MODE;
	        p._pushTmplInsertionMode(IN_TEMPLATE_MODE);
	    } else if (tn === $.HEAD) {
	        p._err(ERR.misplacedStartTagForHeadElement);
	    } else {
	        tokenInHead(p, token);
	    }
	}

	function endTagInHead(p, token) {
	    const tn = token.tagName;

	    if (tn === $.HEAD) {
	        p.openElements.pop();
	        p.insertionMode = AFTER_HEAD_MODE;
	    } else if (tn === $.BODY || tn === $.BR || tn === $.HTML) {
	        tokenInHead(p, token);
	    } else if (tn === $.TEMPLATE) {
	        if (p.openElements.tmplCount > 0) {
	            p.openElements.generateImpliedEndTagsThoroughly();

	            if (p.openElements.currentTagName !== $.TEMPLATE) {
	                p._err(ERR.closingOfElementWithOpenChildElements);
	            }

	            p.openElements.popUntilTagNamePopped($.TEMPLATE);
	            p.activeFormattingElements.clearToLastMarker();
	            p._popTmplInsertionMode();
	            p._resetInsertionMode();
	        } else {
	            p._err(ERR.endTagWithoutMatchingOpenElement);
	        }
	    } else {
	        p._err(ERR.endTagWithoutMatchingOpenElement);
	    }
	}

	function tokenInHead(p, token) {
	    p.openElements.pop();
	    p.insertionMode = AFTER_HEAD_MODE;
	    p._processToken(token);
	}

	// The "in head no script" insertion mode
	//------------------------------------------------------------------
	function startTagInHeadNoScript(p, token) {
	    const tn = token.tagName;

	    if (tn === $.HTML) {
	        startTagInBody(p, token);
	    } else if (
	        tn === $.BASEFONT ||
	        tn === $.BGSOUND ||
	        tn === $.HEAD ||
	        tn === $.LINK ||
	        tn === $.META ||
	        tn === $.NOFRAMES ||
	        tn === $.STYLE
	    ) {
	        startTagInHead(p, token);
	    } else if (tn === $.NOSCRIPT) {
	        p._err(ERR.nestedNoscriptInHead);
	    } else {
	        tokenInHeadNoScript(p, token);
	    }
	}

	function endTagInHeadNoScript(p, token) {
	    const tn = token.tagName;

	    if (tn === $.NOSCRIPT) {
	        p.openElements.pop();
	        p.insertionMode = IN_HEAD_MODE;
	    } else if (tn === $.BR) {
	        tokenInHeadNoScript(p, token);
	    } else {
	        p._err(ERR.endTagWithoutMatchingOpenElement);
	    }
	}

	function tokenInHeadNoScript(p, token) {
	    const errCode =
	        token.type === Tokenizer.EOF_TOKEN ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;

	    p._err(errCode);
	    p.openElements.pop();
	    p.insertionMode = IN_HEAD_MODE;
	    p._processToken(token);
	}

	// The "after head" insertion mode
	//------------------------------------------------------------------
	function startTagAfterHead(p, token) {
	    const tn = token.tagName;

	    if (tn === $.HTML) {
	        startTagInBody(p, token);
	    } else if (tn === $.BODY) {
	        p._insertElement(token, NS.HTML);
	        p.framesetOk = false;
	        p.insertionMode = IN_BODY_MODE;
	    } else if (tn === $.FRAMESET) {
	        p._insertElement(token, NS.HTML);
	        p.insertionMode = IN_FRAMESET_MODE;
	    } else if (
	        tn === $.BASE ||
	        tn === $.BASEFONT ||
	        tn === $.BGSOUND ||
	        tn === $.LINK ||
	        tn === $.META ||
	        tn === $.NOFRAMES ||
	        tn === $.SCRIPT ||
	        tn === $.STYLE ||
	        tn === $.TEMPLATE ||
	        tn === $.TITLE
	    ) {
	        p._err(ERR.abandonedHeadElementChild);
	        p.openElements.push(p.headElement);
	        startTagInHead(p, token);
	        p.openElements.remove(p.headElement);
	    } else if (tn === $.HEAD) {
	        p._err(ERR.misplacedStartTagForHeadElement);
	    } else {
	        tokenAfterHead(p, token);
	    }
	}

	function endTagAfterHead(p, token) {
	    const tn = token.tagName;

	    if (tn === $.BODY || tn === $.HTML || tn === $.BR) {
	        tokenAfterHead(p, token);
	    } else if (tn === $.TEMPLATE) {
	        endTagInHead(p, token);
	    } else {
	        p._err(ERR.endTagWithoutMatchingOpenElement);
	    }
	}

	function tokenAfterHead(p, token) {
	    p._insertFakeElement($.BODY);
	    p.insertionMode = IN_BODY_MODE;
	    p._processToken(token);
	}

	// The "in body" insertion mode
	//------------------------------------------------------------------
	function whitespaceCharacterInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    p._insertCharacters(token);
	}

	function characterInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    p._insertCharacters(token);
	    p.framesetOk = false;
	}

	function htmlStartTagInBody(p, token) {
	    if (p.openElements.tmplCount === 0) {
	        p.treeAdapter.adoptAttributes(p.openElements.items[0], token.attrs);
	    }
	}

	function bodyStartTagInBody(p, token) {
	    const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();

	    if (bodyElement && p.openElements.tmplCount === 0) {
	        p.framesetOk = false;
	        p.treeAdapter.adoptAttributes(bodyElement, token.attrs);
	    }
	}

	function framesetStartTagInBody(p, token) {
	    const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();

	    if (p.framesetOk && bodyElement) {
	        p.treeAdapter.detachNode(bodyElement);
	        p.openElements.popAllUpToHtmlElement();
	        p._insertElement(token, NS.HTML);
	        p.insertionMode = IN_FRAMESET_MODE;
	    }
	}

	function addressStartTagInBody(p, token) {
	    if (p.openElements.hasInButtonScope($.P)) {
	        p._closePElement();
	    }

	    p._insertElement(token, NS.HTML);
	}

	function numberedHeaderStartTagInBody(p, token) {
	    if (p.openElements.hasInButtonScope($.P)) {
	        p._closePElement();
	    }

	    const tn = p.openElements.currentTagName;

	    if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {
	        p.openElements.pop();
	    }

	    p._insertElement(token, NS.HTML);
	}

	function preStartTagInBody(p, token) {
	    if (p.openElements.hasInButtonScope($.P)) {
	        p._closePElement();
	    }

	    p._insertElement(token, NS.HTML);
	    //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move
	    //on to the next one. (Newlines at the start of pre blocks are ignored as an authoring convenience.)
	    p.skipNextNewLine = true;
	    p.framesetOk = false;
	}

	function formStartTagInBody(p, token) {
	    const inTemplate = p.openElements.tmplCount > 0;

	    if (!p.formElement || inTemplate) {
	        if (p.openElements.hasInButtonScope($.P)) {
	            p._closePElement();
	        }

	        p._insertElement(token, NS.HTML);

	        if (!inTemplate) {
	            p.formElement = p.openElements.current;
	        }
	    }
	}

	function listItemStartTagInBody(p, token) {
	    p.framesetOk = false;

	    const tn = token.tagName;

	    for (let i = p.openElements.stackTop; i >= 0; i--) {
	        const element = p.openElements.items[i];
	        const elementTn = p.treeAdapter.getTagName(element);
	        let closeTn = null;

	        if (tn === $.LI && elementTn === $.LI) {
	            closeTn = $.LI;
	        } else if ((tn === $.DD || tn === $.DT) && (elementTn === $.DD || elementTn === $.DT)) {
	            closeTn = elementTn;
	        }

	        if (closeTn) {
	            p.openElements.generateImpliedEndTagsWithExclusion(closeTn);
	            p.openElements.popUntilTagNamePopped(closeTn);
	            break;
	        }

	        if (elementTn !== $.ADDRESS && elementTn !== $.DIV && elementTn !== $.P && p._isSpecialElement(element)) {
	            break;
	        }
	    }

	    if (p.openElements.hasInButtonScope($.P)) {
	        p._closePElement();
	    }

	    p._insertElement(token, NS.HTML);
	}

	function plaintextStartTagInBody(p, token) {
	    if (p.openElements.hasInButtonScope($.P)) {
	        p._closePElement();
	    }

	    p._insertElement(token, NS.HTML);
	    p.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
	}

	function buttonStartTagInBody(p, token) {
	    if (p.openElements.hasInScope($.BUTTON)) {
	        p.openElements.generateImpliedEndTags();
	        p.openElements.popUntilTagNamePopped($.BUTTON);
	    }

	    p._reconstructActiveFormattingElements();
	    p._insertElement(token, NS.HTML);
	    p.framesetOk = false;
	}

	function aStartTagInBody(p, token) {
	    const activeElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName($.A);

	    if (activeElementEntry) {
	        callAdoptionAgency(p, token);
	        p.openElements.remove(activeElementEntry.element);
	        p.activeFormattingElements.removeEntry(activeElementEntry);
	    }

	    p._reconstructActiveFormattingElements();
	    p._insertElement(token, NS.HTML);
	    p.activeFormattingElements.pushElement(p.openElements.current, token);
	}

	function bStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    p._insertElement(token, NS.HTML);
	    p.activeFormattingElements.pushElement(p.openElements.current, token);
	}

	function nobrStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();

	    if (p.openElements.hasInScope($.NOBR)) {
	        callAdoptionAgency(p, token);
	        p._reconstructActiveFormattingElements();
	    }

	    p._insertElement(token, NS.HTML);
	    p.activeFormattingElements.pushElement(p.openElements.current, token);
	}

	function appletStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    p._insertElement(token, NS.HTML);
	    p.activeFormattingElements.insertMarker();
	    p.framesetOk = false;
	}

	function tableStartTagInBody(p, token) {
	    if (
	        p.treeAdapter.getDocumentMode(p.document) !== HTML.DOCUMENT_MODE.QUIRKS &&
	        p.openElements.hasInButtonScope($.P)
	    ) {
	        p._closePElement();
	    }

	    p._insertElement(token, NS.HTML);
	    p.framesetOk = false;
	    p.insertionMode = IN_TABLE_MODE;
	}

	function areaStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    p._appendElement(token, NS.HTML);
	    p.framesetOk = false;
	    token.ackSelfClosing = true;
	}

	function inputStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    p._appendElement(token, NS.HTML);

	    const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);

	    if (!inputType || inputType.toLowerCase() !== HIDDEN_INPUT_TYPE) {
	        p.framesetOk = false;
	    }

	    token.ackSelfClosing = true;
	}

	function paramStartTagInBody(p, token) {
	    p._appendElement(token, NS.HTML);
	    token.ackSelfClosing = true;
	}

	function hrStartTagInBody(p, token) {
	    if (p.openElements.hasInButtonScope($.P)) {
	        p._closePElement();
	    }

	    p._appendElement(token, NS.HTML);
	    p.framesetOk = false;
	    p.ackSelfClosing = true;
	}

	function imageStartTagInBody(p, token) {
	    token.tagName = $.IMG;
	    areaStartTagInBody(p, token);
	}

	function textareaStartTagInBody(p, token) {
	    p._insertElement(token, NS.HTML);
	    //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move
	    //on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)
	    p.skipNextNewLine = true;
	    p.tokenizer.state = Tokenizer.MODE.RCDATA;
	    p.originalInsertionMode = p.insertionMode;
	    p.framesetOk = false;
	    p.insertionMode = TEXT_MODE;
	}

	function xmpStartTagInBody(p, token) {
	    if (p.openElements.hasInButtonScope($.P)) {
	        p._closePElement();
	    }

	    p._reconstructActiveFormattingElements();
	    p.framesetOk = false;
	    p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
	}

	function iframeStartTagInBody(p, token) {
	    p.framesetOk = false;
	    p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
	}

	//NOTE: here we assume that we always act as an user agent with enabled plugins, so we parse
	//<noembed> as a rawtext.
	function noembedStartTagInBody(p, token) {
	    p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
	}

	function selectStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    p._insertElement(token, NS.HTML);
	    p.framesetOk = false;

	    if (
	        p.insertionMode === IN_TABLE_MODE ||
	        p.insertionMode === IN_CAPTION_MODE ||
	        p.insertionMode === IN_TABLE_BODY_MODE ||
	        p.insertionMode === IN_ROW_MODE ||
	        p.insertionMode === IN_CELL_MODE
	    ) {
	        p.insertionMode = IN_SELECT_IN_TABLE_MODE;
	    } else {
	        p.insertionMode = IN_SELECT_MODE;
	    }
	}

	function optgroupStartTagInBody(p, token) {
	    if (p.openElements.currentTagName === $.OPTION) {
	        p.openElements.pop();
	    }

	    p._reconstructActiveFormattingElements();
	    p._insertElement(token, NS.HTML);
	}

	function rbStartTagInBody(p, token) {
	    if (p.openElements.hasInScope($.RUBY)) {
	        p.openElements.generateImpliedEndTags();
	    }

	    p._insertElement(token, NS.HTML);
	}

	function rtStartTagInBody(p, token) {
	    if (p.openElements.hasInScope($.RUBY)) {
	        p.openElements.generateImpliedEndTagsWithExclusion($.RTC);
	    }

	    p._insertElement(token, NS.HTML);
	}

	function menuStartTagInBody(p, token) {
	    if (p.openElements.hasInButtonScope($.P)) {
	        p._closePElement();
	    }

	    p._insertElement(token, NS.HTML);
	}

	function mathStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();

	    foreignContent.adjustTokenMathMLAttrs(token);
	    foreignContent.adjustTokenXMLAttrs(token);

	    if (token.selfClosing) {
	        p._appendElement(token, NS.MATHML);
	    } else {
	        p._insertElement(token, NS.MATHML);
	    }

	    token.ackSelfClosing = true;
	}

	function svgStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();

	    foreignContent.adjustTokenSVGAttrs(token);
	    foreignContent.adjustTokenXMLAttrs(token);

	    if (token.selfClosing) {
	        p._appendElement(token, NS.SVG);
	    } else {
	        p._insertElement(token, NS.SVG);
	    }

	    token.ackSelfClosing = true;
	}

	function genericStartTagInBody(p, token) {
	    p._reconstructActiveFormattingElements();
	    p._insertElement(token, NS.HTML);
	}

	//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.
	//It's faster than using dictionary.
	function startTagInBody(p, token) {
	    const tn = token.tagName;

	    switch (tn.length) {
	        case 1:
	            if (tn === $.I || tn === $.S || tn === $.B || tn === $.U) {
	                bStartTagInBody(p, token);
	            } else if (tn === $.P) {
	                addressStartTagInBody(p, token);
	            } else if (tn === $.A) {
	                aStartTagInBody(p, token);
	            } else {
	                genericStartTagInBody(p, token);
	            }

	            break;

	        case 2:
	            if (tn === $.DL || tn === $.OL || tn === $.UL) {
	                addressStartTagInBody(p, token);
	            } else if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {
	                numberedHeaderStartTagInBody(p, token);
	            } else if (tn === $.LI || tn === $.DD || tn === $.DT) {
	                listItemStartTagInBody(p, token);
	            } else if (tn === $.EM || tn === $.TT) {
	                bStartTagInBody(p, token);
	            } else if (tn === $.BR) {
	                areaStartTagInBody(p, token);
	            } else if (tn === $.HR) {
	                hrStartTagInBody(p, token);
	            } else if (tn === $.RB) {
	                rbStartTagInBody(p, token);
	            } else if (tn === $.RT || tn === $.RP) {
	                rtStartTagInBody(p, token);
	            } else if (tn !== $.TH && tn !== $.TD && tn !== $.TR) {
	                genericStartTagInBody(p, token);
	            }

	            break;

	        case 3:
	            if (tn === $.DIV || tn === $.DIR || tn === $.NAV) {
	                addressStartTagInBody(p, token);
	            } else if (tn === $.PRE) {
	                preStartTagInBody(p, token);
	            } else if (tn === $.BIG) {
	                bStartTagInBody(p, token);
	            } else if (tn === $.IMG || tn === $.WBR) {
	                areaStartTagInBody(p, token);
	            } else if (tn === $.XMP) {
	                xmpStartTagInBody(p, token);
	            } else if (tn === $.SVG) {
	                svgStartTagInBody(p, token);
	            } else if (tn === $.RTC) {
	                rbStartTagInBody(p, token);
	            } else if (tn !== $.COL) {
	                genericStartTagInBody(p, token);
	            }

	            break;

	        case 4:
	            if (tn === $.HTML) {
	                htmlStartTagInBody(p, token);
	            } else if (tn === $.BASE || tn === $.LINK || tn === $.META) {
	                startTagInHead(p, token);
	            } else if (tn === $.BODY) {
	                bodyStartTagInBody(p, token);
	            } else if (tn === $.MAIN || tn === $.MENU) {
	                addressStartTagInBody(p, token);
	            } else if (tn === $.FORM) {
	                formStartTagInBody(p, token);
	            } else if (tn === $.CODE || tn === $.FONT) {
	                bStartTagInBody(p, token);
	            } else if (tn === $.NOBR) {
	                nobrStartTagInBody(p, token);
	            } else if (tn === $.AREA) {
	                areaStartTagInBody(p, token);
	            } else if (tn === $.MATH) {
	                mathStartTagInBody(p, token);
	            } else if (tn === $.MENU) {
	                menuStartTagInBody(p, token);
	            } else if (tn !== $.HEAD) {
	                genericStartTagInBody(p, token);
	            }

	            break;

	        case 5:
	            if (tn === $.STYLE || tn === $.TITLE) {
	                startTagInHead(p, token);
	            } else if (tn === $.ASIDE) {
	                addressStartTagInBody(p, token);
	            } else if (tn === $.SMALL) {
	                bStartTagInBody(p, token);
	            } else if (tn === $.TABLE) {
	                tableStartTagInBody(p, token);
	            } else if (tn === $.EMBED) {
	                areaStartTagInBody(p, token);
	            } else if (tn === $.INPUT) {
	                inputStartTagInBody(p, token);
	            } else if (tn === $.PARAM || tn === $.TRACK) {
	                paramStartTagInBody(p, token);
	            } else if (tn === $.IMAGE) {
	                imageStartTagInBody(p, token);
	            } else if (tn !== $.FRAME && tn !== $.TBODY && tn !== $.TFOOT && tn !== $.THEAD) {
	                genericStartTagInBody(p, token);
	            }

	            break;

	        case 6:
	            if (tn === $.SCRIPT) {
	                startTagInHead(p, token);
	            } else if (
	                tn === $.CENTER ||
	                tn === $.FIGURE ||
	                tn === $.FOOTER ||
	                tn === $.HEADER ||
	                tn === $.HGROUP ||
	                tn === $.DIALOG
	            ) {
	                addressStartTagInBody(p, token);
	            } else if (tn === $.BUTTON) {
	                buttonStartTagInBody(p, token);
	            } else if (tn === $.STRIKE || tn === $.STRONG) {
	                bStartTagInBody(p, token);
	            } else if (tn === $.APPLET || tn === $.OBJECT) {
	                appletStartTagInBody(p, token);
	            } else if (tn === $.KEYGEN) {
	                areaStartTagInBody(p, token);
	            } else if (tn === $.SOURCE) {
	                paramStartTagInBody(p, token);
	            } else if (tn === $.IFRAME) {
	                iframeStartTagInBody(p, token);
	            } else if (tn === $.SELECT) {
	                selectStartTagInBody(p, token);
	            } else if (tn === $.OPTION) {
	                optgroupStartTagInBody(p, token);
	            } else {
	                genericStartTagInBody(p, token);
	            }

	            break;

	        case 7:
	            if (tn === $.BGSOUND) {
	                startTagInHead(p, token);
	            } else if (
	                tn === $.DETAILS ||
	                tn === $.ADDRESS ||
	                tn === $.ARTICLE ||
	                tn === $.SECTION ||
	                tn === $.SUMMARY
	            ) {
	                addressStartTagInBody(p, token);
	            } else if (tn === $.LISTING) {
	                preStartTagInBody(p, token);
	            } else if (tn === $.MARQUEE) {
	                appletStartTagInBody(p, token);
	            } else if (tn === $.NOEMBED) {
	                noembedStartTagInBody(p, token);
	            } else if (tn !== $.CAPTION) {
	                genericStartTagInBody(p, token);
	            }

	            break;

	        case 8:
	            if (tn === $.BASEFONT) {
	                startTagInHead(p, token);
	            } else if (tn === $.FRAMESET) {
	                framesetStartTagInBody(p, token);
	            } else if (tn === $.FIELDSET) {
	                addressStartTagInBody(p, token);
	            } else if (tn === $.TEXTAREA) {
	                textareaStartTagInBody(p, token);
	            } else if (tn === $.TEMPLATE) {
	                startTagInHead(p, token);
	            } else if (tn === $.NOSCRIPT) {
	                if (p.options.scriptingEnabled) {
	                    noembedStartTagInBody(p, token);
	                } else {
	                    genericStartTagInBody(p, token);
	                }
	            } else if (tn === $.OPTGROUP) {
	                optgroupStartTagInBody(p, token);
	            } else if (tn !== $.COLGROUP) {
	                genericStartTagInBody(p, token);
	            }

	            break;

	        case 9:
	            if (tn === $.PLAINTEXT) {
	                plaintextStartTagInBody(p, token);
	            } else {
	                genericStartTagInBody(p, token);
	            }

	            break;

	        case 10:
	            if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION) {
	                addressStartTagInBody(p, token);
	            } else {
	                genericStartTagInBody(p, token);
	            }

	            break;

	        default:
	            genericStartTagInBody(p, token);
	    }
	}

	function bodyEndTagInBody(p) {
	    if (p.openElements.hasInScope($.BODY)) {
	        p.insertionMode = AFTER_BODY_MODE;
	    }
	}

	function htmlEndTagInBody(p, token) {
	    if (p.openElements.hasInScope($.BODY)) {
	        p.insertionMode = AFTER_BODY_MODE;
	        p._processToken(token);
	    }
	}

	function addressEndTagInBody(p, token) {
	    const tn = token.tagName;

	    if (p.openElements.hasInScope(tn)) {
	        p.openElements.generateImpliedEndTags();
	        p.openElements.popUntilTagNamePopped(tn);
	    }
	}

	function formEndTagInBody(p) {
	    const inTemplate = p.openElements.tmplCount > 0;
	    const formElement = p.formElement;

	    if (!inTemplate) {
	        p.formElement = null;
	    }

	    if ((formElement || inTemplate) && p.openElements.hasInScope($.FORM)) {
	        p.openElements.generateImpliedEndTags();

	        if (inTemplate) {
	            p.openElements.popUntilTagNamePopped($.FORM);
	        } else {
	            p.openElements.remove(formElement);
	        }
	    }
	}

	function pEndTagInBody(p) {
	    if (!p.openElements.hasInButtonScope($.P)) {
	        p._insertFakeElement($.P);
	    }

	    p._closePElement();
	}

	function liEndTagInBody(p) {
	    if (p.openElements.hasInListItemScope($.LI)) {
	        p.openElements.generateImpliedEndTagsWithExclusion($.LI);
	        p.openElements.popUntilTagNamePopped($.LI);
	    }
	}

	function ddEndTagInBody(p, token) {
	    const tn = token.tagName;

	    if (p.openElements.hasInScope(tn)) {
	        p.openElements.generateImpliedEndTagsWithExclusion(tn);
	        p.openElements.popUntilTagNamePopped(tn);
	    }
	}

	function numberedHeaderEndTagInBody(p) {
	    if (p.openElements.hasNumberedHeaderInScope()) {
	        p.openElements.generateImpliedEndTags();
	        p.openElements.popUntilNumberedHeaderPopped();
	    }
	}

	function appletEndTagInBody(p, token) {
	    const tn = token.tagName;

	    if (p.openElements.hasInScope(tn)) {
	        p.openElements.generateImpliedEndTags();
	        p.openElements.popUntilTagNamePopped(tn);
	        p.activeFormattingElements.clearToLastMarker();
	    }
	}

	function brEndTagInBody(p) {
	    p._reconstructActiveFormattingElements();
	    p._insertFakeElement($.BR);
	    p.openElements.pop();
	    p.framesetOk = false;
	}

	function genericEndTagInBody(p, token) {
	    const tn = token.tagName;

	    for (let i = p.openElements.stackTop; i > 0; i--) {
	        const element = p.openElements.items[i];

	        if (p.treeAdapter.getTagName(element) === tn) {
	            p.openElements.generateImpliedEndTagsWithExclusion(tn);
	            p.openElements.popUntilElementPopped(element);
	            break;
	        }

	        if (p._isSpecialElement(element)) {
	            break;
	        }
	    }
	}

	//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.
	//It's faster than using dictionary.
	function endTagInBody(p, token) {
	    const tn = token.tagName;

	    switch (tn.length) {
	        case 1:
	            if (tn === $.A || tn === $.B || tn === $.I || tn === $.S || tn === $.U) {
	                callAdoptionAgency(p, token);
	            } else if (tn === $.P) {
	                pEndTagInBody(p);
	            } else {
	                genericEndTagInBody(p, token);
	            }

	            break;

	        case 2:
	            if (tn === $.DL || tn === $.UL || tn === $.OL) {
	                addressEndTagInBody(p, token);
	            } else if (tn === $.LI) {
	                liEndTagInBody(p);
	            } else if (tn === $.DD || tn === $.DT) {
	                ddEndTagInBody(p, token);
	            } else if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {
	                numberedHeaderEndTagInBody(p);
	            } else if (tn === $.BR) {
	                brEndTagInBody(p);
	            } else if (tn === $.EM || tn === $.TT) {
	                callAdoptionAgency(p, token);
	            } else {
	                genericEndTagInBody(p, token);
	            }

	            break;

	        case 3:
	            if (tn === $.BIG) {
	                callAdoptionAgency(p, token);
	            } else if (tn === $.DIR || tn === $.DIV || tn === $.NAV || tn === $.PRE) {
	                addressEndTagInBody(p, token);
	            } else {
	                genericEndTagInBody(p, token);
	            }

	            break;

	        case 4:
	            if (tn === $.BODY) {
	                bodyEndTagInBody(p);
	            } else if (tn === $.HTML) {
	                htmlEndTagInBody(p, token);
	            } else if (tn === $.FORM) {
	                formEndTagInBody(p);
	            } else if (tn === $.CODE || tn === $.FONT || tn === $.NOBR) {
	                callAdoptionAgency(p, token);
	            } else if (tn === $.MAIN || tn === $.MENU) {
	                addressEndTagInBody(p, token);
	            } else {
	                genericEndTagInBody(p, token);
	            }

	            break;

	        case 5:
	            if (tn === $.ASIDE) {
	                addressEndTagInBody(p, token);
	            } else if (tn === $.SMALL) {
	                callAdoptionAgency(p, token);
	            } else {
	                genericEndTagInBody(p, token);
	            }

	            break;

	        case 6:
	            if (
	                tn === $.CENTER ||
	                tn === $.FIGURE ||
	                tn === $.FOOTER ||
	                tn === $.HEADER ||
	                tn === $.HGROUP ||
	                tn === $.DIALOG
	            ) {
	                addressEndTagInBody(p, token);
	            } else if (tn === $.APPLET || tn === $.OBJECT) {
	                appletEndTagInBody(p, token);
	            } else if (tn === $.STRIKE || tn === $.STRONG) {
	                callAdoptionAgency(p, token);
	            } else {
	                genericEndTagInBody(p, token);
	            }

	            break;

	        case 7:
	            if (
	                tn === $.ADDRESS ||
	                tn === $.ARTICLE ||
	                tn === $.DETAILS ||
	                tn === $.SECTION ||
	                tn === $.SUMMARY ||
	                tn === $.LISTING
	            ) {
	                addressEndTagInBody(p, token);
	            } else if (tn === $.MARQUEE) {
	                appletEndTagInBody(p, token);
	            } else {
	                genericEndTagInBody(p, token);
	            }

	            break;

	        case 8:
	            if (tn === $.FIELDSET) {
	                addressEndTagInBody(p, token);
	            } else if (tn === $.TEMPLATE) {
	                endTagInHead(p, token);
	            } else {
	                genericEndTagInBody(p, token);
	            }

	            break;

	        case 10:
	            if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION) {
	                addressEndTagInBody(p, token);
	            } else {
	                genericEndTagInBody(p, token);
	            }

	            break;

	        default:
	            genericEndTagInBody(p, token);
	    }
	}

	function eofInBody(p, token) {
	    if (p.tmplInsertionModeStackTop > -1) {
	        eofInTemplate(p, token);
	    } else {
	        p.stopped = true;
	    }
	}

	// The "text" insertion mode
	//------------------------------------------------------------------
	function endTagInText(p, token) {
	    if (token.tagName === $.SCRIPT) {
	        p.pendingScript = p.openElements.current;
	    }

	    p.openElements.pop();
	    p.insertionMode = p.originalInsertionMode;
	}

	function eofInText(p, token) {
	    p._err(ERR.eofInElementThatCanContainOnlyText);
	    p.openElements.pop();
	    p.insertionMode = p.originalInsertionMode;
	    p._processToken(token);
	}

	// The "in table" insertion mode
	//------------------------------------------------------------------
	function characterInTable(p, token) {
	    const curTn = p.openElements.currentTagName;

	    if (curTn === $.TABLE || curTn === $.TBODY || curTn === $.TFOOT || curTn === $.THEAD || curTn === $.TR) {
	        p.pendingCharacterTokens = [];
	        p.hasNonWhitespacePendingCharacterToken = false;
	        p.originalInsertionMode = p.insertionMode;
	        p.insertionMode = IN_TABLE_TEXT_MODE;
	        p._processToken(token);
	    } else {
	        tokenInTable(p, token);
	    }
	}

	function captionStartTagInTable(p, token) {
	    p.openElements.clearBackToTableContext();
	    p.activeFormattingElements.insertMarker();
	    p._insertElement(token, NS.HTML);
	    p.insertionMode = IN_CAPTION_MODE;
	}

	function colgroupStartTagInTable(p, token) {
	    p.openElements.clearBackToTableContext();
	    p._insertElement(token, NS.HTML);
	    p.insertionMode = IN_COLUMN_GROUP_MODE;
	}

	function colStartTagInTable(p, token) {
	    p.openElements.clearBackToTableContext();
	    p._insertFakeElement($.COLGROUP);
	    p.insertionMode = IN_COLUMN_GROUP_MODE;
	    p._processToken(token);
	}

	function tbodyStartTagInTable(p, token) {
	    p.openElements.clearBackToTableContext();
	    p._insertElement(token, NS.HTML);
	    p.insertionMode = IN_TABLE_BODY_MODE;
	}

	function tdStartTagInTable(p, token) {
	    p.openElements.clearBackToTableContext();
	    p._insertFakeElement($.TBODY);
	    p.insertionMode = IN_TABLE_BODY_MODE;
	    p._processToken(token);
	}

	function tableStartTagInTable(p, token) {
	    if (p.openElements.hasInTableScope($.TABLE)) {
	        p.openElements.popUntilTagNamePopped($.TABLE);
	        p._resetInsertionMode();
	        p._processToken(token);
	    }
	}

	function inputStartTagInTable(p, token) {
	    const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);

	    if (inputType && inputType.toLowerCase() === HIDDEN_INPUT_TYPE) {
	        p._appendElement(token, NS.HTML);
	    } else {
	        tokenInTable(p, token);
	    }

	    token.ackSelfClosing = true;
	}

	function formStartTagInTable(p, token) {
	    if (!p.formElement && p.openElements.tmplCount === 0) {
	        p._insertElement(token, NS.HTML);
	        p.formElement = p.openElements.current;
	        p.openElements.pop();
	    }
	}

	function startTagInTable(p, token) {
	    const tn = token.tagName;

	    switch (tn.length) {
	        case 2:
	            if (tn === $.TD || tn === $.TH || tn === $.TR) {
	                tdStartTagInTable(p, token);
	            } else {
	                tokenInTable(p, token);
	            }

	            break;

	        case 3:
	            if (tn === $.COL) {
	                colStartTagInTable(p, token);
	            } else {
	                tokenInTable(p, token);
	            }

	            break;

	        case 4:
	            if (tn === $.FORM) {
	                formStartTagInTable(p, token);
	            } else {
	                tokenInTable(p, token);
	            }

	            break;

	        case 5:
	            if (tn === $.TABLE) {
	                tableStartTagInTable(p, token);
	            } else if (tn === $.STYLE) {
	                startTagInHead(p, token);
	            } else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
	                tbodyStartTagInTable(p, token);
	            } else if (tn === $.INPUT) {
	                inputStartTagInTable(p, token);
	            } else {
	                tokenInTable(p, token);
	            }

	            break;

	        case 6:
	            if (tn === $.SCRIPT) {
	                startTagInHead(p, token);
	            } else {
	                tokenInTable(p, token);
	            }

	            break;

	        case 7:
	            if (tn === $.CAPTION) {
	                captionStartTagInTable(p, token);
	            } else {
	                tokenInTable(p, token);
	            }

	            break;

	        case 8:
	            if (tn === $.COLGROUP) {
	                colgroupStartTagInTable(p, token);
	            } else if (tn === $.TEMPLATE) {
	                startTagInHead(p, token);
	            } else {
	                tokenInTable(p, token);
	            }

	            break;

	        default:
	            tokenInTable(p, token);
	    }
	}

	function endTagInTable(p, token) {
	    const tn = token.tagName;

	    if (tn === $.TABLE) {
	        if (p.openElements.hasInTableScope($.TABLE)) {
	            p.openElements.popUntilTagNamePopped($.TABLE);
	            p._resetInsertionMode();
	        }
	    } else if (tn === $.TEMPLATE) {
	        endTagInHead(p, token);
	    } else if (
	        tn !== $.BODY &&
	        tn !== $.CAPTION &&
	        tn !== $.COL &&
	        tn !== $.COLGROUP &&
	        tn !== $.HTML &&
	        tn !== $.TBODY &&
	        tn !== $.TD &&
	        tn !== $.TFOOT &&
	        tn !== $.TH &&
	        tn !== $.THEAD &&
	        tn !== $.TR
	    ) {
	        tokenInTable(p, token);
	    }
	}

	function tokenInTable(p, token) {
	    const savedFosterParentingState = p.fosterParentingEnabled;

	    p.fosterParentingEnabled = true;
	    p._processTokenInBodyMode(token);
	    p.fosterParentingEnabled = savedFosterParentingState;
	}

	// The "in table text" insertion mode
	//------------------------------------------------------------------
	function whitespaceCharacterInTableText(p, token) {
	    p.pendingCharacterTokens.push(token);
	}

	function characterInTableText(p, token) {
	    p.pendingCharacterTokens.push(token);
	    p.hasNonWhitespacePendingCharacterToken = true;
	}

	function tokenInTableText(p, token) {
	    let i = 0;

	    if (p.hasNonWhitespacePendingCharacterToken) {
	        for (; i < p.pendingCharacterTokens.length; i++) {
	            tokenInTable(p, p.pendingCharacterTokens[i]);
	        }
	    } else {
	        for (; i < p.pendingCharacterTokens.length; i++) {
	            p._insertCharacters(p.pendingCharacterTokens[i]);
	        }
	    }

	    p.insertionMode = p.originalInsertionMode;
	    p._processToken(token);
	}

	// The "in caption" insertion mode
	//------------------------------------------------------------------
	function startTagInCaption(p, token) {
	    const tn = token.tagName;

	    if (
	        tn === $.CAPTION ||
	        tn === $.COL ||
	        tn === $.COLGROUP ||
	        tn === $.TBODY ||
	        tn === $.TD ||
	        tn === $.TFOOT ||
	        tn === $.TH ||
	        tn === $.THEAD ||
	        tn === $.TR
	    ) {
	        if (p.openElements.hasInTableScope($.CAPTION)) {
	            p.openElements.generateImpliedEndTags();
	            p.openElements.popUntilTagNamePopped($.CAPTION);
	            p.activeFormattingElements.clearToLastMarker();
	            p.insertionMode = IN_TABLE_MODE;
	            p._processToken(token);
	        }
	    } else {
	        startTagInBody(p, token);
	    }
	}

	function endTagInCaption(p, token) {
	    const tn = token.tagName;

	    if (tn === $.CAPTION || tn === $.TABLE) {
	        if (p.openElements.hasInTableScope($.CAPTION)) {
	            p.openElements.generateImpliedEndTags();
	            p.openElements.popUntilTagNamePopped($.CAPTION);
	            p.activeFormattingElements.clearToLastMarker();
	            p.insertionMode = IN_TABLE_MODE;

	            if (tn === $.TABLE) {
	                p._processToken(token);
	            }
	        }
	    } else if (
	        tn !== $.BODY &&
	        tn !== $.COL &&
	        tn !== $.COLGROUP &&
	        tn !== $.HTML &&
	        tn !== $.TBODY &&
	        tn !== $.TD &&
	        tn !== $.TFOOT &&
	        tn !== $.TH &&
	        tn !== $.THEAD &&
	        tn !== $.TR
	    ) {
	        endTagInBody(p, token);
	    }
	}

	// The "in column group" insertion mode
	//------------------------------------------------------------------
	function startTagInColumnGroup(p, token) {
	    const tn = token.tagName;

	    if (tn === $.HTML) {
	        startTagInBody(p, token);
	    } else if (tn === $.COL) {
	        p._appendElement(token, NS.HTML);
	        token.ackSelfClosing = true;
	    } else if (tn === $.TEMPLATE) {
	        startTagInHead(p, token);
	    } else {
	        tokenInColumnGroup(p, token);
	    }
	}

	function endTagInColumnGroup(p, token) {
	    const tn = token.tagName;

	    if (tn === $.COLGROUP) {
	        if (p.openElements.currentTagName === $.COLGROUP) {
	            p.openElements.pop();
	            p.insertionMode = IN_TABLE_MODE;
	        }
	    } else if (tn === $.TEMPLATE) {
	        endTagInHead(p, token);
	    } else if (tn !== $.COL) {
	        tokenInColumnGroup(p, token);
	    }
	}

	function tokenInColumnGroup(p, token) {
	    if (p.openElements.currentTagName === $.COLGROUP) {
	        p.openElements.pop();
	        p.insertionMode = IN_TABLE_MODE;
	        p._processToken(token);
	    }
	}

	// The "in table body" insertion mode
	//------------------------------------------------------------------
	function startTagInTableBody(p, token) {
	    const tn = token.tagName;

	    if (tn === $.TR) {
	        p.openElements.clearBackToTableBodyContext();
	        p._insertElement(token, NS.HTML);
	        p.insertionMode = IN_ROW_MODE;
	    } else if (tn === $.TH || tn === $.TD) {
	        p.openElements.clearBackToTableBodyContext();
	        p._insertFakeElement($.TR);
	        p.insertionMode = IN_ROW_MODE;
	        p._processToken(token);
	    } else if (
	        tn === $.CAPTION ||
	        tn === $.COL ||
	        tn === $.COLGROUP ||
	        tn === $.TBODY ||
	        tn === $.TFOOT ||
	        tn === $.THEAD
	    ) {
	        if (p.openElements.hasTableBodyContextInTableScope()) {
	            p.openElements.clearBackToTableBodyContext();
	            p.openElements.pop();
	            p.insertionMode = IN_TABLE_MODE;
	            p._processToken(token);
	        }
	    } else {
	        startTagInTable(p, token);
	    }
	}

	function endTagInTableBody(p, token) {
	    const tn = token.tagName;

	    if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
	        if (p.openElements.hasInTableScope(tn)) {
	            p.openElements.clearBackToTableBodyContext();
	            p.openElements.pop();
	            p.insertionMode = IN_TABLE_MODE;
	        }
	    } else if (tn === $.TABLE) {
	        if (p.openElements.hasTableBodyContextInTableScope()) {
	            p.openElements.clearBackToTableBodyContext();
	            p.openElements.pop();
	            p.insertionMode = IN_TABLE_MODE;
	            p._processToken(token);
	        }
	    } else if (
	        (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP) ||
	        (tn !== $.HTML && tn !== $.TD && tn !== $.TH && tn !== $.TR)
	    ) {
	        endTagInTable(p, token);
	    }
	}

	// The "in row" insertion mode
	//------------------------------------------------------------------
	function startTagInRow(p, token) {
	    const tn = token.tagName;

	    if (tn === $.TH || tn === $.TD) {
	        p.openElements.clearBackToTableRowContext();
	        p._insertElement(token, NS.HTML);
	        p.insertionMode = IN_CELL_MODE;
	        p.activeFormattingElements.insertMarker();
	    } else if (
	        tn === $.CAPTION ||
	        tn === $.COL ||
	        tn === $.COLGROUP ||
	        tn === $.TBODY ||
	        tn === $.TFOOT ||
	        tn === $.THEAD ||
	        tn === $.TR
	    ) {
	        if (p.openElements.hasInTableScope($.TR)) {
	            p.openElements.clearBackToTableRowContext();
	            p.openElements.pop();
	            p.insertionMode = IN_TABLE_BODY_MODE;
	            p._processToken(token);
	        }
	    } else {
	        startTagInTable(p, token);
	    }
	}

	function endTagInRow(p, token) {
	    const tn = token.tagName;

	    if (tn === $.TR) {
	        if (p.openElements.hasInTableScope($.TR)) {
	            p.openElements.clearBackToTableRowContext();
	            p.openElements.pop();
	            p.insertionMode = IN_TABLE_BODY_MODE;
	        }
	    } else if (tn === $.TABLE) {
	        if (p.openElements.hasInTableScope($.TR)) {
	            p.openElements.clearBackToTableRowContext();
	            p.openElements.pop();
	            p.insertionMode = IN_TABLE_BODY_MODE;
	            p._processToken(token);
	        }
	    } else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
	        if (p.openElements.hasInTableScope(tn) || p.openElements.hasInTableScope($.TR)) {
	            p.openElements.clearBackToTableRowContext();
	            p.openElements.pop();
	            p.insertionMode = IN_TABLE_BODY_MODE;
	            p._processToken(token);
	        }
	    } else if (
	        (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP) ||
	        (tn !== $.HTML && tn !== $.TD && tn !== $.TH)
	    ) {
	        endTagInTable(p, token);
	    }
	}

	// The "in cell" insertion mode
	//------------------------------------------------------------------
	function startTagInCell(p, token) {
	    const tn = token.tagName;

	    if (
	        tn === $.CAPTION ||
	        tn === $.COL ||
	        tn === $.COLGROUP ||
	        tn === $.TBODY ||
	        tn === $.TD ||
	        tn === $.TFOOT ||
	        tn === $.TH ||
	        tn === $.THEAD ||
	        tn === $.TR
	    ) {
	        if (p.openElements.hasInTableScope($.TD) || p.openElements.hasInTableScope($.TH)) {
	            p._closeTableCell();
	            p._processToken(token);
	        }
	    } else {
	        startTagInBody(p, token);
	    }
	}

	function endTagInCell(p, token) {
	    const tn = token.tagName;

	    if (tn === $.TD || tn === $.TH) {
	        if (p.openElements.hasInTableScope(tn)) {
	            p.openElements.generateImpliedEndTags();
	            p.openElements.popUntilTagNamePopped(tn);
	            p.activeFormattingElements.clearToLastMarker();
	            p.insertionMode = IN_ROW_MODE;
	        }
	    } else if (tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR) {
	        if (p.openElements.hasInTableScope(tn)) {
	            p._closeTableCell();
	            p._processToken(token);
	        }
	    } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML) {
	        endTagInBody(p, token);
	    }
	}

	// The "in select" insertion mode
	//------------------------------------------------------------------
	function startTagInSelect(p, token) {
	    const tn = token.tagName;

	    if (tn === $.HTML) {
	        startTagInBody(p, token);
	    } else if (tn === $.OPTION) {
	        if (p.openElements.currentTagName === $.OPTION) {
	            p.openElements.pop();
	        }

	        p._insertElement(token, NS.HTML);
	    } else if (tn === $.OPTGROUP) {
	        if (p.openElements.currentTagName === $.OPTION) {
	            p.openElements.pop();
	        }

	        if (p.openElements.currentTagName === $.OPTGROUP) {
	            p.openElements.pop();
	        }

	        p._insertElement(token, NS.HTML);
	    } else if (tn === $.INPUT || tn === $.KEYGEN || tn === $.TEXTAREA || tn === $.SELECT) {
	        if (p.openElements.hasInSelectScope($.SELECT)) {
	            p.openElements.popUntilTagNamePopped($.SELECT);
	            p._resetInsertionMode();

	            if (tn !== $.SELECT) {
	                p._processToken(token);
	            }
	        }
	    } else if (tn === $.SCRIPT || tn === $.TEMPLATE) {
	        startTagInHead(p, token);
	    }
	}

	function endTagInSelect(p, token) {
	    const tn = token.tagName;

	    if (tn === $.OPTGROUP) {
	        const prevOpenElement = p.openElements.items[p.openElements.stackTop - 1];
	        const prevOpenElementTn = prevOpenElement && p.treeAdapter.getTagName(prevOpenElement);

	        if (p.openElements.currentTagName === $.OPTION && prevOpenElementTn === $.OPTGROUP) {
	            p.openElements.pop();
	        }

	        if (p.openElements.currentTagName === $.OPTGROUP) {
	            p.openElements.pop();
	        }
	    } else if (tn === $.OPTION) {
	        if (p.openElements.currentTagName === $.OPTION) {
	            p.openElements.pop();
	        }
	    } else if (tn === $.SELECT && p.openElements.hasInSelectScope($.SELECT)) {
	        p.openElements.popUntilTagNamePopped($.SELECT);
	        p._resetInsertionMode();
	    } else if (tn === $.TEMPLATE) {
	        endTagInHead(p, token);
	    }
	}

	//12.2.5.4.17 The "in select in table" insertion mode
	//------------------------------------------------------------------
	function startTagInSelectInTable(p, token) {
	    const tn = token.tagName;

	    if (
	        tn === $.CAPTION ||
	        tn === $.TABLE ||
	        tn === $.TBODY ||
	        tn === $.TFOOT ||
	        tn === $.THEAD ||
	        tn === $.TR ||
	        tn === $.TD ||
	        tn === $.TH
	    ) {
	        p.openElements.popUntilTagNamePopped($.SELECT);
	        p._resetInsertionMode();
	        p._processToken(token);
	    } else {
	        startTagInSelect(p, token);
	    }
	}

	function endTagInSelectInTable(p, token) {
	    const tn = token.tagName;

	    if (
	        tn === $.CAPTION ||
	        tn === $.TABLE ||
	        tn === $.TBODY ||
	        tn === $.TFOOT ||
	        tn === $.THEAD ||
	        tn === $.TR ||
	        tn === $.TD ||
	        tn === $.TH
	    ) {
	        if (p.openElements.hasInTableScope(tn)) {
	            p.openElements.popUntilTagNamePopped($.SELECT);
	            p._resetInsertionMode();
	            p._processToken(token);
	        }
	    } else {
	        endTagInSelect(p, token);
	    }
	}

	// The "in template" insertion mode
	//------------------------------------------------------------------
	function startTagInTemplate(p, token) {
	    const tn = token.tagName;

	    if (
	        tn === $.BASE ||
	        tn === $.BASEFONT ||
	        tn === $.BGSOUND ||
	        tn === $.LINK ||
	        tn === $.META ||
	        tn === $.NOFRAMES ||
	        tn === $.SCRIPT ||
	        tn === $.STYLE ||
	        tn === $.TEMPLATE ||
	        tn === $.TITLE
	    ) {
	        startTagInHead(p, token);
	    } else {
	        const newInsertionMode = TEMPLATE_INSERTION_MODE_SWITCH_MAP[tn] || IN_BODY_MODE;

	        p._popTmplInsertionMode();
	        p._pushTmplInsertionMode(newInsertionMode);
	        p.insertionMode = newInsertionMode;
	        p._processToken(token);
	    }
	}

	function endTagInTemplate(p, token) {
	    if (token.tagName === $.TEMPLATE) {
	        endTagInHead(p, token);
	    }
	}

	function eofInTemplate(p, token) {
	    if (p.openElements.tmplCount > 0) {
	        p.openElements.popUntilTagNamePopped($.TEMPLATE);
	        p.activeFormattingElements.clearToLastMarker();
	        p._popTmplInsertionMode();
	        p._resetInsertionMode();
	        p._processToken(token);
	    } else {
	        p.stopped = true;
	    }
	}

	// The "after body" insertion mode
	//------------------------------------------------------------------
	function startTagAfterBody(p, token) {
	    if (token.tagName === $.HTML) {
	        startTagInBody(p, token);
	    } else {
	        tokenAfterBody(p, token);
	    }
	}

	function endTagAfterBody(p, token) {
	    if (token.tagName === $.HTML) {
	        if (!p.fragmentContext) {
	            p.insertionMode = AFTER_AFTER_BODY_MODE;
	        }
	    } else {
	        tokenAfterBody(p, token);
	    }
	}

	function tokenAfterBody(p, token) {
	    p.insertionMode = IN_BODY_MODE;
	    p._processToken(token);
	}

	// The "in frameset" insertion mode
	//------------------------------------------------------------------
	function startTagInFrameset(p, token) {
	    const tn = token.tagName;

	    if (tn === $.HTML) {
	        startTagInBody(p, token);
	    } else if (tn === $.FRAMESET) {
	        p._insertElement(token, NS.HTML);
	    } else if (tn === $.FRAME) {
	        p._appendElement(token, NS.HTML);
	        token.ackSelfClosing = true;
	    } else if (tn === $.NOFRAMES) {
	        startTagInHead(p, token);
	    }
	}

	function endTagInFrameset(p, token) {
	    if (token.tagName === $.FRAMESET && !p.openElements.isRootHtmlElementCurrent()) {
	        p.openElements.pop();

	        if (!p.fragmentContext && p.openElements.currentTagName !== $.FRAMESET) {
	            p.insertionMode = AFTER_FRAMESET_MODE;
	        }
	    }
	}

	// The "after frameset" insertion mode
	//------------------------------------------------------------------
	function startTagAfterFrameset(p, token) {
	    const tn = token.tagName;

	    if (tn === $.HTML) {
	        startTagInBody(p, token);
	    } else if (tn === $.NOFRAMES) {
	        startTagInHead(p, token);
	    }
	}

	function endTagAfterFrameset(p, token) {
	    if (token.tagName === $.HTML) {
	        p.insertionMode = AFTER_AFTER_FRAMESET_MODE;
	    }
	}

	// The "after after body" insertion mode
	//------------------------------------------------------------------
	function startTagAfterAfterBody(p, token) {
	    if (token.tagName === $.HTML) {
	        startTagInBody(p, token);
	    } else {
	        tokenAfterAfterBody(p, token);
	    }
	}

	function tokenAfterAfterBody(p, token) {
	    p.insertionMode = IN_BODY_MODE;
	    p._processToken(token);
	}

	// The "after after frameset" insertion mode
	//------------------------------------------------------------------
	function startTagAfterAfterFrameset(p, token) {
	    const tn = token.tagName;

	    if (tn === $.HTML) {
	        startTagInBody(p, token);
	    } else if (tn === $.NOFRAMES) {
	        startTagInHead(p, token);
	    }
	}

	// The rules for parsing tokens in foreign content
	//------------------------------------------------------------------
	function nullCharacterInForeignContent(p, token) {
	    token.chars = unicode.REPLACEMENT_CHARACTER;
	    p._insertCharacters(token);
	}

	function characterInForeignContent(p, token) {
	    p._insertCharacters(token);
	    p.framesetOk = false;
	}

	function startTagInForeignContent(p, token) {
	    if (foreignContent.causesExit(token) && !p.fragmentContext) {
	        while (
	            p.treeAdapter.getNamespaceURI(p.openElements.current) !== NS.HTML &&
	            !p._isIntegrationPoint(p.openElements.current)
	        ) {
	            p.openElements.pop();
	        }

	        p._processToken(token);
	    } else {
	        const current = p._getAdjustedCurrentElement();
	        const currentNs = p.treeAdapter.getNamespaceURI(current);

	        if (currentNs === NS.MATHML) {
	            foreignContent.adjustTokenMathMLAttrs(token);
	        } else if (currentNs === NS.SVG) {
	            foreignContent.adjustTokenSVGTagName(token);
	            foreignContent.adjustTokenSVGAttrs(token);
	        }

	        foreignContent.adjustTokenXMLAttrs(token);

	        if (token.selfClosing) {
	            p._appendElement(token, currentNs);
	        } else {
	            p._insertElement(token, currentNs);
	        }

	        token.ackSelfClosing = true;
	    }
	}

	function endTagInForeignContent(p, token) {
	    for (let i = p.openElements.stackTop; i > 0; i--) {
	        const element = p.openElements.items[i];

	        if (p.treeAdapter.getNamespaceURI(element) === NS.HTML) {
	            p._processToken(token);
	            break;
	        }

	        if (p.treeAdapter.getTagName(element).toLowerCase() === token.tagName) {
	            p.openElements.popUntilElementPopped(element);
	            break;
	        }
	    }
	}
	return parser;
}

const classId = "classID";
const dataType = "datatype";
const itemId = "itemID";
const strokeDashArray = "strokeDasharray";
const strokeDashOffset = "strokeDashoffset";
const strokeLineCap = "strokeLinecap";
const strokeLineJoin = "strokeLinejoin";
const strokeMiterLimit = "strokeMiterlimit";
const typeOf = "typeof";
const xLinkActuate = "xlinkActuate";
const xLinkArcRole = "xlinkArcrole";
const xLinkHref = "xlinkHref";
const xLinkRole = "xlinkRole";
const xLinkShow = "xlinkShow";
const xLinkTitle = "xlinkTitle";
const xLinkType = "xlinkType";
const xmlnsXLink = "xmlnsXlink";
var require$$3 = {
	classId: classId,
	dataType: dataType,
	itemId: itemId,
	strokeDashArray: strokeDashArray,
	strokeDashOffset: strokeDashOffset,
	strokeLineCap: strokeLineCap,
	strokeLineJoin: strokeLineJoin,
	strokeMiterLimit: strokeMiterLimit,
	typeOf: typeOf,
	xLinkActuate: xLinkActuate,
	xLinkArcRole: xLinkArcRole,
	xLinkHref: xLinkHref,
	xLinkRole: xLinkRole,
	xLinkShow: xLinkShow,
	xLinkTitle: xLinkTitle,
	xLinkType: xLinkType,
	xmlnsXLink: xmlnsXLink
};

var inlineStyleParser;
var hasRequiredInlineStyleParser;

function requireInlineStyleParser () {
	if (hasRequiredInlineStyleParser) return inlineStyleParser;
	hasRequiredInlineStyleParser = 1;
	// http://www.w3.org/TR/CSS21/grammar.html
	// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
	var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;

	var NEWLINE_REGEX = /\n/g;
	var WHITESPACE_REGEX = /^\s*/;

	// declaration
	var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
	var COLON_REGEX = /^:\s*/;
	var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
	var SEMICOLON_REGEX = /^[;\s]*/;

	// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill
	var TRIM_REGEX = /^\s+|\s+$/g;

	// strings
	var NEWLINE = '\n';
	var FORWARD_SLASH = '/';
	var ASTERISK = '*';
	var EMPTY_STRING = '';

	// types
	var TYPE_COMMENT = 'comment';
	var TYPE_DECLARATION = 'declaration';

	/**
	 * @param {String} style
	 * @param {Object} [options]
	 * @return {Object[]}
	 * @throws {TypeError}
	 * @throws {Error}
	 */
	inlineStyleParser = function(style, options) {
	  if (typeof style !== 'string') {
	    throw new TypeError('First argument must be a string');
	  }

	  if (!style) return [];

	  options = options || {};

	  /**
	   * Positional.
	   */
	  var lineno = 1;
	  var column = 1;

	  /**
	   * Update lineno and column based on `str`.
	   *
	   * @param {String} str
	   */
	  function updatePosition(str) {
	    var lines = str.match(NEWLINE_REGEX);
	    if (lines) lineno += lines.length;
	    var i = str.lastIndexOf(NEWLINE);
	    column = ~i ? str.length - i : column + str.length;
	  }

	  /**
	   * Mark position and patch `node.position`.
	   *
	   * @return {Function}
	   */
	  function position() {
	    var start = { line: lineno, column: column };
	    return function(node) {
	      node.position = new Position(start);
	      whitespace();
	      return node;
	    };
	  }

	  /**
	   * Store position information for a node.
	   *
	   * @constructor
	   * @property {Object} start
	   * @property {Object} end
	   * @property {undefined|String} source
	   */
	  function Position(start) {
	    this.start = start;
	    this.end = { line: lineno, column: column };
	    this.source = options.source;
	  }

	  /**
	   * Non-enumerable source string.
	   */
	  Position.prototype.content = style;

	  /**
	   * Error `msg`.
	   *
	   * @param {String} msg
	   * @throws {Error}
	   */
	  function error(msg) {
	    var err = new Error(
	      options.source + ':' + lineno + ':' + column + ': ' + msg
	    );
	    err.reason = msg;
	    err.filename = options.source;
	    err.line = lineno;
	    err.column = column;
	    err.source = style;

	    if (options.silent) ; else {
	      throw err;
	    }
	  }

	  /**
	   * Match `re` and return captures.
	   *
	   * @param {RegExp} re
	   * @return {undefined|Array}
	   */
	  function match(re) {
	    var m = re.exec(style);
	    if (!m) return;
	    var str = m[0];
	    updatePosition(str);
	    style = style.slice(str.length);
	    return m;
	  }

	  /**
	   * Parse whitespace.
	   */
	  function whitespace() {
	    match(WHITESPACE_REGEX);
	  }

	  /**
	   * Parse comments.
	   *
	   * @param {Object[]} [rules]
	   * @return {Object[]}
	   */
	  function comments(rules) {
	    var c;
	    rules = rules || [];
	    while ((c = comment())) {
	      if (c !== false) {
	        rules.push(c);
	      }
	    }
	    return rules;
	  }

	  /**
	   * Parse comment.
	   *
	   * @return {Object}
	   * @throws {Error}
	   */
	  function comment() {
	    var pos = position();
	    if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;

	    var i = 2;
	    while (
	      EMPTY_STRING != style.charAt(i) &&
	      (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))
	    ) {
	      ++i;
	    }
	    i += 2;

	    if (EMPTY_STRING === style.charAt(i - 1)) {
	      return error('End of comment missing');
	    }

	    var str = style.slice(2, i - 2);
	    column += 2;
	    updatePosition(str);
	    style = style.slice(i);
	    column += 2;

	    return pos({
	      type: TYPE_COMMENT,
	      comment: str
	    });
	  }

	  /**
	   * Parse declaration.
	   *
	   * @return {Object}
	   * @throws {Error}
	   */
	  function declaration() {
	    var pos = position();

	    // prop
	    var prop = match(PROPERTY_REGEX);
	    if (!prop) return;
	    comment();

	    // :
	    if (!match(COLON_REGEX)) return error("property missing ':'");

	    // val
	    var val = match(VALUE_REGEX);

	    var ret = pos({
	      type: TYPE_DECLARATION,
	      property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
	      value: val
	        ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING))
	        : EMPTY_STRING
	    });

	    // ;
	    match(SEMICOLON_REGEX);

	    return ret;
	  }

	  /**
	   * Parse declarations.
	   *
	   * @return {Object[]}
	   */
	  function declarations() {
	    var decls = [];

	    comments(decls);

	    // declarations
	    var decl;
	    while ((decl = declaration())) {
	      if (decl !== false) {
	        decls.push(decl);
	        comments(decls);
	      }
	    }

	    return decls;
	  }

	  whitespace();
	  return declarations();
	};

	/**
	 * Trim `str`.
	 *
	 * @param {String} str
	 * @return {String}
	 */
	function trim(str) {
	  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
	}
	return inlineStyleParser;
}

var styleToObject;
var hasRequiredStyleToObject;

function requireStyleToObject () {
	if (hasRequiredStyleToObject) return styleToObject;
	hasRequiredStyleToObject = 1;
	var parse = requireInlineStyleParser();

	/**
	 * Parses inline style to object.
	 *
	 * @example
	 * // returns { 'line-height': '42' }
	 * StyleToObject('line-height: 42;');
	 *
	 * @param  {String}      style      - The inline style.
	 * @param  {Function}    [iterator] - The iterator function.
	 * @return {null|Object}
	 */
	function StyleToObject(style, iterator) {
	  var output = null;
	  if (!style || typeof style !== 'string') {
	    return output;
	  }

	  var declaration;
	  var declarations = parse(style);
	  var hasIterator = typeof iterator === 'function';
	  var property;
	  var value;

	  for (var i = 0, len = declarations.length; i < len; i++) {
	    declaration = declarations[i];
	    property = declaration.property;
	    value = declaration.value;

	    if (hasIterator) {
	      iterator(property, value, declaration);
	    } else if (value) {
	      output || (output = {});
	      output[property] = value;
	    }
	  }

	  return output;
	}

	styleToObject = StyleToObject;
	return styleToObject;
}

var convert_1;
var hasRequiredConvert;

function requireConvert () {
	if (hasRequiredConvert) return convert_1;
	hasRequiredConvert = 1;

	convert_1 = convert;

	function convert(test) {
	  if (typeof test === 'string') {
	    return typeFactory(test)
	  }

	  if (test === null || test === undefined) {
	    return ok
	  }

	  if (typeof test === 'object') {
	    return ('length' in test ? anyFactory : matchesFactory)(test)
	  }

	  if (typeof test === 'function') {
	    return test
	  }

	  throw new Error('Expected function, string, or object as test')
	}

	function convertAll(tests) {
	  var results = [];
	  var length = tests.length;
	  var index = -1;

	  while (++index < length) {
	    results[index] = convert(tests[index]);
	  }

	  return results
	}

	// Utility assert each property in `test` is represented in `node`, and each
	// values are strictly equal.
	function matchesFactory(test) {
	  return matches

	  function matches(node) {
	    var key;

	    for (key in test) {
	      if (node[key] !== test[key]) {
	        return false
	      }
	    }

	    return true
	  }
	}

	function anyFactory(tests) {
	  var checks = convertAll(tests);
	  var length = checks.length;

	  return matches

	  function matches() {
	    var index = -1;

	    while (++index < length) {
	      if (checks[index].apply(this, arguments)) {
	        return true
	      }
	    }

	    return false
	  }
	}

	// Utility to convert a string into a function which checks a given node’s type
	// for said string.
	function typeFactory(test) {
	  return type

	  function type(node) {
	    return Boolean(node && node.type === test)
	  }
	}

	// Utility to return true.
	function ok() {
	  return true
	}
	return convert_1;
}

var hastToHyperscript;
var hasRequiredHastToHyperscript;

function requireHastToHyperscript () {
	if (hasRequiredHastToHyperscript) return hastToHyperscript;
	hasRequiredHastToHyperscript = 1;

	var html = requireHtml$4();
	var svg = requireSvg$1();
	var find = requireFind();
	var hastToReact = require$$3;
	var spaces = requireSpaceSeparatedTokens();
	var commas = requireCommaSeparatedTokens();
	var style = requireStyleToObject();
	var ns = require$$5$1;
	var convert = requireConvert();

	var root = convert('root');
	var element = convert('element');
	var text = convert('text');

	var dashes = /-([a-z])/g;

	hastToHyperscript = wrapper;

	function wrapper(h, node, options) {
	  var settings = options || {};
	  var prefix;
	  var r;
	  var v;
	  var vd;

	  if (typeof h !== 'function') {
	    throw new Error('h is not a function')
	  }

	  if (typeof settings === 'string' || typeof settings === 'boolean') {
	    prefix = settings;
	    settings = {};
	  } else {
	    prefix = settings.prefix;
	  }

	  r = react(h);
	  v = vue(h);
	  vd = vdom(h);

	  if (prefix === null || prefix === undefined) {
	    prefix = r === true || v === true || vd === true ? 'h-' : false;
	  }

	  if (root(node)) {
	    if (node.children.length === 1 && element(node.children[0])) {
	      node = node.children[0];
	    } else {
	      node = {
	        type: 'element',
	        tagName: 'div',
	        properties: {},
	        children: node.children
	      };
	    }
	  } else if (!element(node)) {
	    throw new Error(
	      'Expected root or element, not `' + ((node && node.type) || node) + '`'
	    )
	  }

	  return toH(h, node, {
	    schema: settings.space === 'svg' ? svg : html,
	    prefix: prefix,
	    key: 0,
	    react: r,
	    vue: v,
	    vdom: vd,
	    hyperscript: hyperscript(h)
	  })
	}

	// Transform a hast node through a hyperscript interface to *anything*!
	function toH(h, node, ctx) {
	  var parentSchema = ctx.schema;
	  var schema = parentSchema;
	  var name = node.tagName;
	  var properties;
	  var attributes;
	  var children;
	  var property;
	  var elements;
	  var length;
	  var index;
	  var value;
	  var result;

	  if (parentSchema.space === 'html' && name.toLowerCase() === 'svg') {
	    schema = svg;
	    ctx.schema = schema;
	  }

	  if (ctx.vdom === true && schema.space === 'html') {
	    name = name.toUpperCase();
	  }

	  properties = node.properties;
	  attributes = {};

	  for (property in properties) {
	    addAttribute(attributes, property, properties[property], ctx);
	  }

	  if (
	    typeof attributes.style === 'string' &&
	    (ctx.vdom === true || ctx.vue === true || ctx.react === true)
	  ) {
	    // VDOM, Vue, and React accept `style` as object.
	    attributes.style = parseStyle(attributes.style, name);
	  }

	  if (ctx.prefix) {
	    ctx.key++;
	    attributes.key = ctx.prefix + ctx.key;
	  }

	  if (ctx.vdom && schema.space !== 'html') {
	    attributes.namespace = ns[schema.space];
	  }

	  elements = [];
	  children = node.children;
	  length = children ? children.length : 0;
	  index = -1;

	  while (++index < length) {
	    value = children[index];

	    if (element(value)) {
	      elements.push(toH(h, value, ctx));
	    } else if (text(value)) {
	      elements.push(value.value);
	    }
	  }

	  // Ensure no React warnings are triggered for void elements having children
	  // passed in.
	  result =
	    elements.length === 0 ? h(name, attributes) : h(name, attributes, elements);

	  // Restore parent schema.
	  ctx.schema = parentSchema;

	  return result
	}

	function addAttribute(props, prop, value, ctx) {
	  var hyperlike = ctx.hyperscript || ctx.vdom || ctx.vue;
	  var schema = ctx.schema;
	  var info = find(schema, prop);
	  var subprop;

	  // Ignore nully and `NaN` values.
	  // Ignore `false` and falsey known booleans for hyperlike DSLs.
	  if (
	    value === null ||
	    value === undefined ||
	    value !== value ||
	    (hyperlike && value === false) ||
	    (hyperlike && info.boolean && !value)
	  ) {
	    return
	  }

	  if (value !== null && typeof value === 'object' && 'length' in value) {
	    // Accept `array`.
	    // Most props are space-separated.
	    value = (info.commaSeparated ? commas : spaces).stringify(value);
	  }

	  // Treat `true` and truthy known booleans.
	  if (info.boolean && ctx.hyperscript === true) {
	    value = '';
	  }

	  if (ctx.vue) {
	    if (prop !== 'style') {
	      subprop = 'attrs';
	    }
	  } else if (!info.mustUseProperty) {
	    if (ctx.vdom === true) {
	      subprop = 'attributes';
	    } else if (ctx.hyperscript === true) {
	      subprop = 'attrs';
	    }
	  }

	  if (subprop) {
	    if (props[subprop] === undefined) {
	      props[subprop] = {};
	    }

	    props[subprop][info.attribute] = value;
	  } else if (ctx.react && info.space) {
	    props[hastToReact[info.property] || info.property] = value;
	  } else {
	    props[info.attribute] = value;
	  }
	}

	// Check if `h` is `react.createElement`.
	function react(h) {
	  var node = h && h('div');
	  return Boolean(
	    node && ('_owner' in node || '_store' in node) && node.key === null
	  )
	}

	// Check if `h` is `hyperscript`.
	function hyperscript(h) {
	  return Boolean(h && h.context && h.cleanup)
	}

	// Check if `h` is `virtual-dom/h`.
	function vdom(h) {
	  return h && h('div').type === 'VirtualNode'
	}

	function vue(h) {
	  var node = h && h('div');
	  return Boolean(node && node.context && node.context._isVue)
	}

	function parseStyle(value, tagName) {
	  var result = {};

	  try {
	    style(value, iterator);
	  } catch (error) {
	    error.message =
	      tagName + '[style]' + error.message.slice('undefined'.length);
	    throw error
	  }

	  return result

	  function iterator(name, value) {
	    result[styleCase(name)] = value;
	  }
	}

	function styleCase(val) {
	  if (val.slice(0, 4) === '-ms-') {
	    val = 'ms-' + val.slice(4);
	  }

	  return val.replace(dashes, styleReplacer)
	}

	function styleReplacer($0, $1) {
	  return $1.toUpperCase()
	}
	return hastToHyperscript;
}

var zwitch;
var hasRequiredZwitch;

function requireZwitch () {
	if (hasRequiredZwitch) return zwitch;
	hasRequiredZwitch = 1;

	zwitch = factory;

	var noop = Function.prototype;
	var own = {}.hasOwnProperty;

	// Handle values based on a property.
	function factory(key, options) {
	  var settings = options || {};

	  function one(value) {
	    var fn = one.invalid;
	    var handlers = one.handlers;

	    if (value && own.call(value, key)) {
	      fn = own.call(handlers, value[key]) ? handlers[value[key]] : one.unknown;
	    }

	    return (fn || noop).apply(this, arguments)
	  }

	  one.handlers = settings.handlers || {};
	  one.invalid = settings.invalid;
	  one.unknown = settings.unknown;

	  return one
	}
	return zwitch;
}

var hastUtilToParse5;
var hasRequiredHastUtilToParse5;

function requireHastUtilToParse5 () {
	if (hasRequiredHastUtilToParse5) return hastUtilToParse5;
	hasRequiredHastUtilToParse5 = 1;

	var xtend = requireImmutable();
	var html = requireHtml$4();
	var svg = requireSvg$1();
	var find = requireFind();
	var toH = requireHastToHyperscript();
	var ns = require$$5$1;
	var zwitch = requireZwitch();

	hastUtilToParse5 = transform;

	var ignoredSpaces = ['svg', 'html'];

	var one = zwitch('type');

	one.handlers.root = root;
	one.handlers.element = element;
	one.handlers.text = text;
	one.handlers.comment = comment;
	one.handlers.doctype = doctype;

	// Transform a tree from hast to Parse5’s AST.
	function transform(tree, space) {
	  return one(tree, space === 'svg' ? svg : html)
	}

	function root(node, schema) {
	  var data = node.data || {};
	  var mode = data.quirksMode ? 'quirks' : 'no-quirks';

	  return patch(node, {nodeName: '#document', mode: mode}, schema)
	}

	function fragment(node, schema) {
	  return patch(node, {nodeName: '#document-fragment'}, schema)
	}

	function doctype(node, schema) {
	  return patch(
	    node,
	    {
	      nodeName: '#documentType',
	      name: node.name,
	      publicId: node.public || '',
	      systemId: node.system || ''
	    },
	    schema
	  )
	}

	function text(node, schema) {
	  return patch(node, {nodeName: '#text', value: node.value}, schema)
	}

	function comment(node, schema) {
	  return patch(node, {nodeName: '#comment', data: node.value}, schema)
	}

	function element(node, schema) {
	  var space = schema.space;
	  var shallow = xtend(node, {children: []});

	  return toH(h, shallow, {space: space})

	  function h(name, attrs) {
	    var values = [];
	    var p5;
	    var attr;
	    var value;
	    var key;
	    var info;
	    var pos;

	    for (key in attrs) {
	      info = find(schema, key);
	      attr = attrs[key];

	      if (attr === false || (info.boolean && !attr)) {
	        continue
	      }

	      value = {name: key, value: attr === true ? '' : String(attr)};

	      if (info.space && ignoredSpaces.indexOf(info.space) === -1) {
	        pos = key.indexOf(':');

	        if (pos === -1) {
	          value.prefix = '';
	        } else {
	          value.name = key.slice(pos + 1);
	          value.prefix = key.slice(0, pos);
	        }

	        value.namespace = ns[info.space];
	      }

	      values.push(value);
	    }

	    p5 = patch(node, {nodeName: name, tagName: name, attrs: values}, schema);

	    if (name === 'template') {
	      p5.content = fragment(shallow.content, schema);
	    }

	    return p5
	  }
	}

	// Patch specific properties.
	function patch(node, p5, parentSchema) {
	  var schema = parentSchema;
	  var position = node.position;
	  var children = node.children;
	  var childNodes = [];
	  var length = children ? children.length : 0;
	  var index = -1;
	  var child;

	  if (node.type === 'element') {
	    if (schema.space === 'html' && node.tagName === 'svg') {
	      schema = svg;
	    }

	    p5.namespaceURI = ns[schema.space];
	  }

	  while (++index < length) {
	    child = one(children[index], schema);
	    child.parentNode = p5;
	    childNodes[index] = child;
	  }

	  if (node.type === 'element' || node.type === 'root') {
	    p5.childNodes = childNodes;
	  }

	  if (position && position.start && position.end) {
	    p5.sourceCodeLocation = {
	      startLine: position.start.line,
	      startCol: position.start.column,
	      startOffset: position.start.offset,
	      endLine: position.end.line,
	      endCol: position.end.column,
	      endOffset: position.end.offset
	    };
	  }

	  return p5
	}
	return hastUtilToParse5;
}

var require$$2 = [
	"area",
	"base",
	"basefont",
	"bgsound",
	"br",
	"col",
	"command",
	"embed",
	"frame",
	"hr",
	"image",
	"img",
	"input",
	"isindex",
	"keygen",
	"link",
	"menuitem",
	"meta",
	"nextid",
	"param",
	"source",
	"track",
	"wbr"
];

var hastUtilRaw;
var hasRequiredHastUtilRaw;

function requireHastUtilRaw () {
	if (hasRequiredHastUtilRaw) return hastUtilRaw;
	hasRequiredHastUtilRaw = 1;

	var Parser = requireParser();
	var pos = requireUnistUtilPosition();
	var fromParse5 = requireHastUtilFromParse5();
	var toParse5 = requireHastUtilToParse5();
	var voids = require$$2;
	var ns = require$$5$1;
	var zwitch = requireZwitch();
	var xtend = requireImmutable();

	hastUtilRaw = wrap;

	var inTemplateMode = 'IN_TEMPLATE_MODE';
	var dataState = 'DATA_STATE';
	var characterToken = 'CHARACTER_TOKEN';
	var startTagToken = 'START_TAG_TOKEN';
	var endTagToken = 'END_TAG_TOKEN';
	var commentToken = 'COMMENT_TOKEN';
	var doctypeToken = 'DOCTYPE_TOKEN';

	var parseOptions = {
	  sourceCodeLocationInfo: true,
	  scriptingEnabled: false
	};

	function wrap(tree, file) {
	  var parser = new Parser(parseOptions);
	  var one = zwitch('type');
	  var tokenizer;
	  var preprocessor;
	  var posTracker;
	  var locationTracker;
	  var result;

	  one.handlers.root = root;
	  one.handlers.element = element;
	  one.handlers.text = text;
	  one.handlers.comment = comment;
	  one.handlers.doctype = doctype;
	  one.handlers.raw = raw;
	  one.unknown = unknown;

	  result = fromParse5(documentMode(tree) ? document() : fragment(), file);

	  // Unpack if possible and when not given a `root`.
	  if (tree.type !== 'root' && result.children.length === 1) {
	    return result.children[0]
	  }

	  return result

	  function fragment() {
	    var context;
	    var mock;
	    var doc;

	    context = {
	      nodeName: 'template',
	      tagName: 'template',
	      attrs: [],
	      namespaceURI: ns.html,
	      childNodes: []
	    };

	    mock = {
	      nodeName: 'documentmock',
	      tagName: 'documentmock',
	      attrs: [],
	      namespaceURI: ns.html,
	      childNodes: []
	    };

	    doc = {
	      nodeName: '#document-fragment',
	      childNodes: []
	    };

	    parser._bootstrap(mock, context);
	    parser._pushTmplInsertionMode(inTemplateMode);
	    parser._initTokenizerForFragmentParsing();
	    parser._insertFakeRootElement();
	    parser._resetInsertionMode();
	    parser._findFormInFragmentContext();

	    tokenizer = parser.tokenizer;
	    preprocessor = tokenizer.preprocessor;
	    locationTracker = tokenizer.__mixins[0];
	    posTracker = locationTracker.posTracker;

	    one(tree);

	    parser._adoptNodes(mock.childNodes[0], doc);

	    return doc
	  }

	  function document() {
	    var doc = parser.treeAdapter.createDocument();

	    parser._bootstrap(doc, null);
	    tokenizer = parser.tokenizer;
	    preprocessor = tokenizer.preprocessor;
	    locationTracker = tokenizer.__mixins[0];
	    posTracker = locationTracker.posTracker;

	    one(tree);

	    return doc
	  }

	  function all(nodes) {
	    var length = 0;
	    var index = -1;

	    /* istanbul ignore else - invalid nodes, see rehypejs/rehype-raw#7. */
	    if (nodes) {
	      length = nodes.length;
	    }

	    while (++index < length) {
	      one(nodes[index]);
	    }
	  }

	  function root(node) {
	    all(node.children);
	  }

	  function element(node) {
	    var empty = voids.indexOf(node.tagName) !== -1;

	    parser._processToken(startTag(node), ns.html);

	    all(node.children);

	    if (!empty) {
	      parser._processToken(endTag(node));

	      // Put the parser back in the data state: some elements, like textareas
	      // and iframes, change the state.
	      // See <syntax-tree/hast-util-raw#7>.
	      // See <https://github.com/inikulin/parse5/blob/2528196/packages/parse5/lib/tokenizer/index.js#L222>.
	      tokenizer.state = dataState;
	    }
	  }

	  function text(node) {
	    parser._processToken({
	      type: characterToken,
	      chars: node.value,
	      location: createParse5Location(node)
	    });
	  }

	  function doctype(node) {
	    var p5 = toParse5(node);

	    parser._processToken({
	      type: doctypeToken,
	      name: p5.name,
	      forceQuirks: false,
	      publicId: p5.publicId,
	      systemId: p5.systemId,
	      location: createParse5Location(node)
	    });
	  }

	  function comment(node) {
	    parser._processToken({
	      type: commentToken,
	      data: node.value,
	      location: createParse5Location(node)
	    });
	  }

	  function raw(node) {
	    var start = pos.start(node);
	    var token;

	    // Reset preprocessor:
	    // See: <https://github.com/inikulin/parse5/blob/0491902/packages/parse5/lib/tokenizer/preprocessor.js>.
	    preprocessor.html = null;
	    preprocessor.endOfChunkHit = false;
	    preprocessor.lastChunkWritten = false;
	    preprocessor.lastCharPos = -1;
	    preprocessor.pos = -1;

	    // Reset preprocessor mixin:
	    // See: <https://github.com/inikulin/parse5/blob/0491902/packages/parse5/lib/extensions/position-tracking/preprocessor-mixin.js>.
	    posTracker.droppedBufferSize = 0;
	    posTracker.line = start.line;
	    posTracker.col = 1;
	    posTracker.offset = 0;
	    posTracker.lineStartPos = -start.column + 1;
	    posTracker.droppedBufferSize = start.offset;

	    // Reset location tracker:
	    // See: <https://github.com/inikulin/parse5/blob/0491902/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js>.
	    locationTracker.currentAttrLocation = null;
	    locationTracker.ctLoc = createParse5Location(node);

	    // See the code for `parse` and `parseFragment`:
	    // See: <https://github.com/inikulin/parse5/blob/0491902/packages/parse5/lib/parser/index.js#L371>.
	    tokenizer.write(node.value);
	    parser._runParsingLoop(null);

	    // Process final characters if they’re still there after hibernating.
	    // Similar to:
	    // See: <https://github.com/inikulin/parse5/blob/3bfa7d9/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js#L95>.
	    token = tokenizer.currentCharacterToken;

	    if (token) {
	      token.location.endLine = posTracker.line;
	      token.location.endCol = posTracker.col + 1;
	      token.location.endOffset = posTracker.offset + 1;
	      parser._processToken(token);
	    }

	    // Reset tokenizer:
	    // See: <https://github.com/inikulin/parse5/blob/8b0048e/packages/parse5/lib/tokenizer/index.js#L215>.
	    tokenizer.currentToken = null;
	    tokenizer.currentCharacterToken = null;
	    tokenizer.currentAttr = null;
	  }
	}

	function startTag(node) {
	  var location = createParse5Location(node);

	  location.startTag = xtend(location);

	  return {
	    type: startTagToken,
	    tagName: node.tagName,
	    selfClosing: false,
	    attrs: attributes(node),
	    location: location
	  }
	}

	function attributes(node) {
	  return toParse5({
	    tagName: node.tagName,
	    type: 'element',
	    properties: node.properties
	  }).attrs
	}

	function endTag(node) {
	  var location = createParse5Location(node);

	  location.endTag = xtend(location);

	  return {
	    type: endTagToken,
	    tagName: node.tagName,
	    attrs: [],
	    location: location
	  }
	}

	function unknown(node) {
	  throw new Error('Cannot compile `' + node.type + '` node')
	}

	function documentMode(node) {
	  var head = node.type === 'root' ? node.children[0] : node;

	  return head && (head.type === 'doctype' || head.tagName === 'html')
	}

	function createParse5Location(node) {
	  var start = pos.start(node);
	  var end = pos.end(node);

	  return {
	    startLine: start.line,
	    startCol: start.column,
	    startOffset: start.offset,
	    endLine: end.line,
	    endCol: end.column,
	    endOffset: end.offset
	  }
	}
	return hastUtilRaw;
}

var rehypeRaw;
var hasRequiredRehypeRaw;

function requireRehypeRaw () {
	if (hasRequiredRehypeRaw) return rehypeRaw;
	hasRequiredRehypeRaw = 1;

	var util = requireHastUtilRaw();

	rehypeRaw = raw;

	function raw() {
	  return util
	}
	return rehypeRaw;
}

var rehypeRawExports = requireRehypeRaw();
var raw$1 = /*@__PURE__*/getDefaultExportFromCjs(rehypeRawExports);

var omission = {};

var hastUtilIsElement;
var hasRequiredHastUtilIsElement;

function requireHastUtilIsElement () {
	if (hasRequiredHastUtilIsElement) return hastUtilIsElement;
	hasRequiredHastUtilIsElement = 1;

	hastUtilIsElement = isElement;

	// Check if if `node` is an `element` and, if `tagNames` is given, `node`
	// matches them `tagNames`.
	function isElement(node, tagNames) {
	  var name;

	  if (
	    !(
	      tagNames === null ||
	      tagNames === undefined ||
	      typeof tagNames === 'string' ||
	      (typeof tagNames === 'object' && tagNames.length !== 0)
	    )
	  ) {
	    throw new Error(
	      'Expected `string` or `Array.<string>` for `tagNames`, not `' +
	        tagNames +
	        '`'
	    )
	  }

	  if (
	    !node ||
	    typeof node !== 'object' ||
	    node.type !== 'element' ||
	    typeof node.tagName !== 'string'
	  ) {
	    return false
	  }

	  if (tagNames === null || tagNames === undefined) {
	    return true
	  }

	  name = node.tagName;

	  if (typeof tagNames === 'string') {
	    return name === tagNames
	  }

	  return tagNames.indexOf(name) !== -1
	}
	return hastUtilIsElement;
}

var siblings = {};

var hastUtilWhitespace;
var hasRequiredHastUtilWhitespace;

function requireHastUtilWhitespace () {
	if (hasRequiredHastUtilWhitespace) return hastUtilWhitespace;
	hasRequiredHastUtilWhitespace = 1;

	hastUtilWhitespace = interElementWhiteSpace;

	// HTML white-space expression.
	// See <https://html.spec.whatwg.org/#space-character>.
	var re = /[ \t\n\f\r]/g;

	function interElementWhiteSpace(node) {
	  var value;

	  if (node && typeof node === 'object' && node.type === 'text') {
	    value = node.value || '';
	  } else if (typeof node === 'string') {
	    value = node;
	  } else {
	    return false
	  }

	  return value.replace(re, '') === ''
	}
	return hastUtilWhitespace;
}

var hasRequiredSiblings;

function requireSiblings () {
	if (hasRequiredSiblings) return siblings;
	hasRequiredSiblings = 1;

	var whiteSpace = requireHastUtilWhitespace();

	siblings.before = siblings$1(-1);
	siblings.after = siblings$1(1);

	// Factory to check siblings in a direction.
	function siblings$1(increment) {
	  return sibling

	  // Find applicable siblings in a direction.
	  function sibling(parent, index, includeWhiteSpace) {
	    var siblings = parent && parent.children;
	    var offset = index + increment;
	    var next = siblings && siblings[offset];

	    if (!includeWhiteSpace) {
	      while (next && whiteSpace(next)) {
	        offset += increment;
	        next = siblings[offset];
	      }
	    }

	    return next
	  }
	}
	return siblings;
}

var first_1;
var hasRequiredFirst;

function requireFirst () {
	if (hasRequiredFirst) return first_1;
	hasRequiredFirst = 1;

	var after = requireSiblings().after;

	first_1 = first;

	// Get the first child in `parent`.
	function first(parent, includeWhiteSpace) {
	  return after(parent, -1, includeWhiteSpace)
	}
	return first_1;
}

var place_1;
var hasRequiredPlace;

function requirePlace () {
	if (hasRequiredPlace) return place_1;
	hasRequiredPlace = 1;

	place_1 = place;

	// Get the position of `node` in `parent`.
	function place(parent, child) {
	  return parent && parent.children && parent.children.indexOf(child)
	}
	return place_1;
}

var whiteSpaceStart_1;
var hasRequiredWhiteSpaceStart;

function requireWhiteSpaceStart () {
	if (hasRequiredWhiteSpaceStart) return whiteSpaceStart_1;
	hasRequiredWhiteSpaceStart = 1;

	var convert = requireConvert$1();
	var whiteSpace = requireHastUtilWhitespace();

	whiteSpaceStart_1 = whiteSpaceStart;

	var isText = convert('text');

	// Check if `node` starts with white-space.
	function whiteSpaceStart(node) {
	  return isText(node) && whiteSpace(node.value.charAt(0))
	}
	return whiteSpaceStart_1;
}

var omission_1;
var hasRequiredOmission$1;

function requireOmission$1 () {
	if (hasRequiredOmission$1) return omission_1;
	hasRequiredOmission$1 = 1;

	omission_1 = omission;

	var own = {}.hasOwnProperty;

	// Factory to check if a given node can have a tag omitted.
	function omission(handlers) {
	  return omit

	  // Check if a given node can have a tag omitted.
	  function omit(node, index, parent) {
	    var name = node.tagName;

	    return own.call(handlers, name)
	      ? handlers[name](node, index, parent)
	      : false
	  }
	}
	return omission_1;
}

var closing;
var hasRequiredClosing;

function requireClosing () {
	if (hasRequiredClosing) return closing;
	hasRequiredClosing = 1;

	var convert = requireConvert$1();
	var element = requireHastUtilIsElement();
	var whiteSpaceStart = requireWhiteSpaceStart();
	var after = requireSiblings().after;
	var omission = requireOmission$1();

	var isComment = convert('comment');

	var optionGroup = 'optgroup';
	var options = ['option'].concat(optionGroup);
	var dataListItem = ['dt', 'dd'];
	var listItem = 'li';
	var menuContent = ['menuitem', 'hr', 'menu'];
	var ruby = ['rp', 'rt'];
	var tableContainer = ['tbody', 'tfoot'];
	var tableRow = 'tr';
	var tableCell = ['td', 'th'];

	var confusingParagraphParent = [
	  'a',
	  'audio',
	  'del',
	  'ins',
	  'map',
	  'noscript',
	  'video'
	];

	var clearParagraphSibling = [
	  'address',
	  'article',
	  'aside',
	  'blockquote',
	  'details',
	  'div',
	  'dl',
	  'fieldset',
	  'figcaption',
	  'figure',
	  'footer',
	  'form',
	  'h1',
	  'h2',
	  'h3',
	  'h4',
	  'h5',
	  'h6',
	  'header',
	  'hgroup',
	  'hr',
	  'main',
	  'menu',
	  'nav',
	  'ol',
	  'p',
	  'pre',
	  'section',
	  'table',
	  'ul'
	];

	closing = omission({
	  html: html,
	  head: headOrColgroupOrCaption,
	  body: body,
	  p: p,
	  li: li,
	  dt: dt,
	  dd: dd,
	  rt: rubyElement,
	  rp: rubyElement,
	  optgroup: optgroup,
	  option: option,
	  menuitem: menuitem,
	  colgroup: headOrColgroupOrCaption,
	  caption: headOrColgroupOrCaption,
	  thead: thead,
	  tbody: tbody,
	  tfoot: tfoot,
	  tr: tr,
	  td: cells,
	  th: cells
	});

	// Macro for `</head>`, `</colgroup>`, and `</caption>`.
	function headOrColgroupOrCaption(node, index, parent) {
	  var next = after(parent, index, true);
	  return !next || (!isComment(next) && !whiteSpaceStart(next))
	}

	// Whether to omit `</html>`.
	function html(node, index, parent) {
	  var next = after(parent, index);
	  return !next || !isComment(next)
	}

	// Whether to omit `</body>`.
	function body(node, index, parent) {
	  var next = after(parent, index);
	  return !next || !isComment(next)
	}

	// Whether to omit `</p>`.
	function p(node, index, parent) {
	  var next = after(parent, index);
	  return next
	    ? element(next, clearParagraphSibling)
	    : !parent || !element(parent, confusingParagraphParent)
	}

	// Whether to omit `</li>`.
	function li(node, index, parent) {
	  var next = after(parent, index);
	  return !next || element(next, listItem)
	}

	// Whether to omit `</dt>`.
	function dt(node, index, parent) {
	  var next = after(parent, index);
	  return next && element(next, dataListItem)
	}

	// Whether to omit `</dd>`.
	function dd(node, index, parent) {
	  var next = after(parent, index);
	  return !next || element(next, dataListItem)
	}

	// Whether to omit `</rt>` or `</rp>`.
	function rubyElement(node, index, parent) {
	  var next = after(parent, index);
	  return !next || element(next, ruby)
	}

	// Whether to omit `</optgroup>`.
	function optgroup(node, index, parent) {
	  var next = after(parent, index);
	  return !next || element(next, optionGroup)
	}

	// Whether to omit `</option>`.
	function option(node, index, parent) {
	  var next = after(parent, index);
	  return !next || element(next, options)
	}

	// Whether to omit `</menuitem>`.
	function menuitem(node, index, parent) {
	  var next = after(parent, index);
	  return !next || element(next, menuContent)
	}

	// Whether to omit `</thead>`.
	function thead(node, index, parent) {
	  var next = after(parent, index);
	  return next && element(next, tableContainer)
	}

	// Whether to omit `</tbody>`.
	function tbody(node, index, parent) {
	  var next = after(parent, index);
	  return !next || element(next, tableContainer)
	}

	// Whether to omit `</tfoot>`.
	function tfoot(node, index, parent) {
	  return !after(parent, index)
	}

	// Whether to omit `</tr>`.
	function tr(node, index, parent) {
	  var next = after(parent, index);
	  return !next || element(next, tableRow)
	}

	// Whether to omit `</td>` or `</th>`.
	function cells(node, index, parent) {
	  var next = after(parent, index);
	  return !next || element(next, tableCell)
	}
	return closing;
}

var opening;
var hasRequiredOpening;

function requireOpening () {
	if (hasRequiredOpening) return opening;
	hasRequiredOpening = 1;

	var convert = requireConvert$1();
	var element = requireHastUtilIsElement();
	var before = requireSiblings().before;
	var first = requireFirst();
	var place = requirePlace();
	var whiteSpaceStart = requireWhiteSpaceStart();
	var closing = requireClosing();
	var omission = requireOmission$1();

	var isComment = convert('comment');

	var uniqueHeadMetadata = ['title', 'base'];
	var meta = ['meta', 'link', 'script', 'style', 'template'];
	var tableContainers = ['thead', 'tbody'];
	var tableRow = 'tr';

	opening = omission({
	  html: html,
	  head: head,
	  body: body,
	  colgroup: colgroup,
	  tbody: tbody
	});

	// Whether to omit `<html>`.
	function html(node) {
	  var head = first(node);
	  return !head || !isComment(head)
	}

	// Whether to omit `<head>`.
	function head(node) {
	  var children = node.children;
	  var length = children.length;
	  var seen = [];
	  var index = -1;
	  var child;
	  var name;

	  while (++index < length) {
	    child = children[index];
	    name = child.tagName;

	    if (element(child, uniqueHeadMetadata)) {
	      if (seen.indexOf(name) !== -1) {
	        return false
	      }

	      seen.push(name);
	    }
	  }

	  return length !== 0
	}

	// Whether to omit `<body>`.
	function body(node) {
	  var head = first(node, true);

	  return (
	    !head ||
	    (!isComment(head) && !whiteSpaceStart(head) && !element(head, meta))
	  )
	}

	// Whether to omit `<colgroup>`.
	// The spec describes some logic for the opening tag, but it’s easier to
	// implement in the closing tag, to the same effect, so we handle it there
	// instead.
	function colgroup(node, index, parent) {
	  var previous = before(parent, index);
	  var head = first(node, true);

	  // Previous colgroup was already omitted.
	  if (
	    element(previous, 'colgroup') &&
	    closing(previous, place(parent, previous), parent)
	  ) {
	    return false
	  }

	  return head && element(head, 'col')
	}

	// Whether to omit `<tbody>`.
	function tbody(node, index, parent) {
	  var previous = before(parent, index);
	  var head = first(node);

	  // Previous table section was already omitted.
	  if (
	    element(previous, tableContainers) &&
	    closing(previous, place(parent, previous), parent)
	  ) {
	    return false
	  }

	  return head && element(head, tableRow)
	}
	return opening;
}

var hasRequiredOmission;

function requireOmission () {
	if (hasRequiredOmission) return omission;
	hasRequiredOmission = 1;
	omission.opening = requireOpening();
	omission.closing = requireClosing();
	return omission;
}

var all_1;
var hasRequiredAll;

function requireAll () {
	if (hasRequiredAll) return all_1;
	hasRequiredAll = 1;

	var one = requireOne();

	all_1 = all;

	// Serialize all children of `parent`.
	function all(ctx, parent) {
	  var children = parent && parent.children;
	  var length = children && children.length;
	  var index = -1;
	  var results = [];

	  while (++index < length) {
	    results[index] = one(ctx, children[index], index, parent);
	  }

	  return results.join('')
	}
	return all_1;
}

const nbsp = " ";
const iexcl = "¡";
const cent = "¢";
const pound = "£";
const curren = "¤";
const yen = "¥";
const brvbar = "¦";
const sect = "§";
const uml = "¨";
const copy = "©";
const ordf = "ª";
const laquo = "«";
const not = "¬";
const shy = "­";
const reg = "®";
const macr = "¯";
const deg = "°";
const plusmn = "±";
const sup2 = "²";
const sup3 = "³";
const acute = "´";
const micro = "µ";
const para = "¶";
const middot = "·";
const cedil = "¸";
const sup1 = "¹";
const ordm = "º";
const raquo = "»";
const frac14 = "¼";
const frac12 = "½";
const frac34 = "¾";
const iquest = "¿";
const Agrave = "À";
const Aacute = "Á";
const Acirc = "Â";
const Atilde = "Ã";
const Auml = "Ä";
const Aring = "Å";
const AElig = "Æ";
const Ccedil = "Ç";
const Egrave = "È";
const Eacute = "É";
const Ecirc = "Ê";
const Euml = "Ë";
const Igrave = "Ì";
const Iacute = "Í";
const Icirc = "Î";
const Iuml = "Ï";
const ETH = "Ð";
const Ntilde = "Ñ";
const Ograve = "Ò";
const Oacute = "Ó";
const Ocirc = "Ô";
const Otilde = "Õ";
const Ouml = "Ö";
const times = "×";
const Oslash = "Ø";
const Ugrave = "Ù";
const Uacute = "Ú";
const Ucirc = "Û";
const Uuml = "Ü";
const Yacute = "Ý";
const THORN = "Þ";
const szlig = "ß";
const agrave = "à";
const aacute = "á";
const acirc = "â";
const atilde = "ã";
const auml = "ä";
const aring = "å";
const aelig = "æ";
const ccedil = "ç";
const egrave = "è";
const eacute = "é";
const ecirc = "ê";
const euml = "ë";
const igrave = "ì";
const iacute = "í";
const icirc = "î";
const iuml = "ï";
const eth = "ð";
const ntilde = "ñ";
const ograve = "ò";
const oacute = "ó";
const ocirc = "ô";
const otilde = "õ";
const ouml = "ö";
const divide = "÷";
const oslash = "ø";
const ugrave = "ù";
const uacute = "ú";
const ucirc = "û";
const uuml = "ü";
const yacute = "ý";
const thorn = "þ";
const yuml = "ÿ";
const fnof = "ƒ";
const Alpha = "Α";
const Beta = "Β";
const Gamma = "Γ";
const Delta = "Δ";
const Epsilon = "Ε";
const Zeta = "Ζ";
const Eta = "Η";
const Theta = "Θ";
const Iota = "Ι";
const Kappa = "Κ";
const Lambda = "Λ";
const Mu = "Μ";
const Nu = "Ν";
const Xi = "Ξ";
const Omicron = "Ο";
const Pi = "Π";
const Rho = "Ρ";
const Sigma = "Σ";
const Tau = "Τ";
const Upsilon = "Υ";
const Phi = "Φ";
const Chi = "Χ";
const Psi = "Ψ";
const Omega = "Ω";
const alpha = "α";
const beta = "β";
const gamma = "γ";
const delta = "δ";
const epsilon = "ε";
const zeta = "ζ";
const eta = "η";
const theta = "θ";
const iota = "ι";
const kappa = "κ";
const lambda = "λ";
const mu = "μ";
const nu = "ν";
const xi = "ξ";
const omicron = "ο";
const pi = "π";
const rho = "ρ";
const sigmaf = "ς";
const sigma = "σ";
const tau = "τ";
const upsilon = "υ";
const phi = "φ";
const chi = "χ";
const psi = "ψ";
const omega = "ω";
const thetasym = "ϑ";
const upsih = "ϒ";
const piv = "ϖ";
const bull = "•";
const hellip = "…";
const prime = "′";
const Prime = "″";
const oline = "‾";
const frasl = "⁄";
const weierp = "℘";
const image = "ℑ";
const real = "ℜ";
const trade = "™";
const alefsym = "ℵ";
const larr = "←";
const uarr = "↑";
const rarr = "→";
const darr = "↓";
const harr = "↔";
const crarr = "↵";
const lArr = "⇐";
const uArr = "⇑";
const rArr = "⇒";
const dArr = "⇓";
const hArr = "⇔";
const forall = "∀";
const part = "∂";
const exist = "∃";
const empty = "∅";
const nabla = "∇";
const isin = "∈";
const notin = "∉";
const ni = "∋";
const prod = "∏";
const sum = "∑";
const minus = "−";
const lowast = "∗";
const radic = "√";
const prop = "∝";
const infin = "∞";
const ang = "∠";
const and = "∧";
const or = "∨";
const cap = "∩";
const cup = "∪";
const int = "∫";
const there4 = "∴";
const sim = "∼";
const cong = "≅";
const asymp = "≈";
const ne = "≠";
const equiv = "≡";
const le = "≤";
const ge = "≥";
const sub = "⊂";
const sup = "⊃";
const nsub = "⊄";
const sube = "⊆";
const supe = "⊇";
const oplus = "⊕";
const otimes = "⊗";
const perp = "⊥";
const sdot = "⋅";
const lceil = "⌈";
const rceil = "⌉";
const lfloor = "⌊";
const rfloor = "⌋";
const lang = "〈";
const rang = "〉";
const loz = "◊";
const spades = "♠";
const clubs = "♣";
const hearts = "♥";
const diams = "♦";
const quot = "\"";
const amp = "&";
const lt = "<";
const gt = ">";
const OElig = "Œ";
const oelig = "œ";
const Scaron = "Š";
const scaron = "š";
const Yuml = "Ÿ";
const circ = "ˆ";
const tilde = "˜";
const ensp = " ";
const emsp = " ";
const thinsp = " ";
const zwnj = "‌";
const zwj = "‍";
const lrm = "‎";
const rlm = "‏";
const ndash = "–";
const mdash = "—";
const lsquo = "‘";
const rsquo = "’";
const sbquo = "‚";
const ldquo = "“";
const rdquo = "”";
const bdquo = "„";
const dagger = "†";
const Dagger = "‡";
const permil = "‰";
const lsaquo = "‹";
const rsaquo = "›";
const euro = "€";
var require$$0 = {
	nbsp: nbsp,
	iexcl: iexcl,
	cent: cent,
	pound: pound,
	curren: curren,
	yen: yen,
	brvbar: brvbar,
	sect: sect,
	uml: uml,
	copy: copy,
	ordf: ordf,
	laquo: laquo,
	not: not,
	shy: shy,
	reg: reg,
	macr: macr,
	deg: deg,
	plusmn: plusmn,
	sup2: sup2,
	sup3: sup3,
	acute: acute,
	micro: micro,
	para: para,
	middot: middot,
	cedil: cedil,
	sup1: sup1,
	ordm: ordm,
	raquo: raquo,
	frac14: frac14,
	frac12: frac12,
	frac34: frac34,
	iquest: iquest,
	Agrave: Agrave,
	Aacute: Aacute,
	Acirc: Acirc,
	Atilde: Atilde,
	Auml: Auml,
	Aring: Aring,
	AElig: AElig,
	Ccedil: Ccedil,
	Egrave: Egrave,
	Eacute: Eacute,
	Ecirc: Ecirc,
	Euml: Euml,
	Igrave: Igrave,
	Iacute: Iacute,
	Icirc: Icirc,
	Iuml: Iuml,
	ETH: ETH,
	Ntilde: Ntilde,
	Ograve: Ograve,
	Oacute: Oacute,
	Ocirc: Ocirc,
	Otilde: Otilde,
	Ouml: Ouml,
	times: times,
	Oslash: Oslash,
	Ugrave: Ugrave,
	Uacute: Uacute,
	Ucirc: Ucirc,
	Uuml: Uuml,
	Yacute: Yacute,
	THORN: THORN,
	szlig: szlig,
	agrave: agrave,
	aacute: aacute,
	acirc: acirc,
	atilde: atilde,
	auml: auml,
	aring: aring,
	aelig: aelig,
	ccedil: ccedil,
	egrave: egrave,
	eacute: eacute,
	ecirc: ecirc,
	euml: euml,
	igrave: igrave,
	iacute: iacute,
	icirc: icirc,
	iuml: iuml,
	eth: eth,
	ntilde: ntilde,
	ograve: ograve,
	oacute: oacute,
	ocirc: ocirc,
	otilde: otilde,
	ouml: ouml,
	divide: divide,
	oslash: oslash,
	ugrave: ugrave,
	uacute: uacute,
	ucirc: ucirc,
	uuml: uuml,
	yacute: yacute,
	thorn: thorn,
	yuml: yuml,
	fnof: fnof,
	Alpha: Alpha,
	Beta: Beta,
	Gamma: Gamma,
	Delta: Delta,
	Epsilon: Epsilon,
	Zeta: Zeta,
	Eta: Eta,
	Theta: Theta,
	Iota: Iota,
	Kappa: Kappa,
	Lambda: Lambda,
	Mu: Mu,
	Nu: Nu,
	Xi: Xi,
	Omicron: Omicron,
	Pi: Pi,
	Rho: Rho,
	Sigma: Sigma,
	Tau: Tau,
	Upsilon: Upsilon,
	Phi: Phi,
	Chi: Chi,
	Psi: Psi,
	Omega: Omega,
	alpha: alpha,
	beta: beta,
	gamma: gamma,
	delta: delta,
	epsilon: epsilon,
	zeta: zeta,
	eta: eta,
	theta: theta,
	iota: iota,
	kappa: kappa,
	lambda: lambda,
	mu: mu,
	nu: nu,
	xi: xi,
	omicron: omicron,
	pi: pi,
	rho: rho,
	sigmaf: sigmaf,
	sigma: sigma,
	tau: tau,
	upsilon: upsilon,
	phi: phi,
	chi: chi,
	psi: psi,
	omega: omega,
	thetasym: thetasym,
	upsih: upsih,
	piv: piv,
	bull: bull,
	hellip: hellip,
	prime: prime,
	Prime: Prime,
	oline: oline,
	frasl: frasl,
	weierp: weierp,
	image: image,
	real: real,
	trade: trade,
	alefsym: alefsym,
	larr: larr,
	uarr: uarr,
	rarr: rarr,
	darr: darr,
	harr: harr,
	crarr: crarr,
	lArr: lArr,
	uArr: uArr,
	rArr: rArr,
	dArr: dArr,
	hArr: hArr,
	forall: forall,
	part: part,
	exist: exist,
	empty: empty,
	nabla: nabla,
	isin: isin,
	notin: notin,
	ni: ni,
	prod: prod,
	sum: sum,
	minus: minus,
	lowast: lowast,
	radic: radic,
	prop: prop,
	infin: infin,
	ang: ang,
	and: and,
	or: or,
	cap: cap,
	cup: cup,
	int: int,
	there4: there4,
	sim: sim,
	cong: cong,
	asymp: asymp,
	ne: ne,
	equiv: equiv,
	le: le,
	ge: ge,
	sub: sub,
	sup: sup,
	nsub: nsub,
	sube: sube,
	supe: supe,
	oplus: oplus,
	otimes: otimes,
	perp: perp,
	sdot: sdot,
	lceil: lceil,
	rceil: rceil,
	lfloor: lfloor,
	rfloor: rfloor,
	lang: lang,
	rang: rang,
	loz: loz,
	spades: spades,
	clubs: clubs,
	hearts: hearts,
	diams: diams,
	quot: quot,
	amp: amp,
	lt: lt,
	gt: gt,
	OElig: OElig,
	oelig: oelig,
	Scaron: Scaron,
	scaron: scaron,
	Yuml: Yuml,
	circ: circ,
	tilde: tilde,
	ensp: ensp,
	emsp: emsp,
	thinsp: thinsp,
	zwnj: zwnj,
	zwj: zwj,
	lrm: lrm,
	rlm: rlm,
	ndash: ndash,
	mdash: mdash,
	lsquo: lsquo,
	rsquo: rsquo,
	sbquo: sbquo,
	ldquo: ldquo,
	rdquo: rdquo,
	bdquo: bdquo,
	dagger: dagger,
	Dagger: Dagger,
	permil: permil,
	lsaquo: lsaquo,
	rsaquo: rsaquo,
	euro: euro
};

var require$$5 = [
	"cent",
	"copy",
	"divide",
	"gt",
	"lt",
	"not",
	"para",
	"times"
];

var stringifyEntities;
var hasRequiredStringifyEntities;

function requireStringifyEntities () {
	if (hasRequiredStringifyEntities) return stringifyEntities;
	hasRequiredStringifyEntities = 1;

	var entities = require$$0;
	var legacy = require$$1$2;
	var hexadecimal = requireIsHexadecimal();
	var decimal = requireIsDecimal();
	var alphanumerical = requireIsAlphanumerical();
	var dangerous = require$$5;

	stringifyEntities = encode;
	encode.escape = escape;

	var own = {}.hasOwnProperty;

	// Characters
	var equalsTo = 61;

	// List of enforced escapes.
	var escapes = ['"', "'", '<', '>', '&', '`'];

	// Map of characters to names.
	var characters = construct();

	// Default escapes.
	var defaultEscapes = toExpression(escapes);

	// Surrogate pairs.
	var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;

	// Non-ASCII characters.
	// eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
	var bmp = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;

	// Encode special characters in `value`.
	function encode(value, options) {
	  var settings = options || {};
	  var subset = settings.subset;
	  var set = subset ? toExpression(subset) : defaultEscapes;
	  var escapeOnly = settings.escapeOnly;
	  var omit = settings.omitOptionalSemicolons;

	  value = value.replace(set, replace);

	  if (subset || escapeOnly) {
	    return value
	  }

	  return value
	    .replace(surrogatePair, replaceSurrogatePair)
	    .replace(bmp, replace)

	  function replaceSurrogatePair(pair, pos, slice) {
	    return toHexReference(
	      (pair.charCodeAt(0) - 0xd800) * 0x400 +
	        pair.charCodeAt(1) -
	        0xdc00 +
	        0x10000,
	      slice.charCodeAt(pos + 2),
	      omit
	    )
	  }

	  function replace(char, pos, slice) {
	    return one(char, slice.charCodeAt(pos + 1), settings)
	  }
	}

	// Shortcut to escape special characters in HTML.
	function escape(value) {
	  return encode(value, {escapeOnly: true, useNamedReferences: true})
	}

	// Encode `char` according to `options`.
	function one(char, next, options) {
	  var shortest = options.useShortestReferences;
	  var omit = options.omitOptionalSemicolons;
	  var named;
	  var code;
	  var numeric;
	  var decimal;

	  if ((shortest || options.useNamedReferences) && own.call(characters, char)) {
	    named = toNamed(characters[char], next, omit, options.attribute);
	  }

	  if (shortest || !named) {
	    code = char.charCodeAt(0);
	    numeric = toHexReference(code, next, omit);

	    // Use the shortest numeric reference when requested.
	    // A simple algorithm would use decimal for all code points under 100, as
	    // those are shorter than hexadecimal:
	    //
	    // * `&#99;` vs `&#x63;` (decimal shorter)
	    // * `&#100;` vs `&#x64;` (equal)
	    //
	    // However, because we take `next` into consideration when `omit` is used,
	    // And it would be possible that decimals are shorter on bigger values as
	    // well if `next` is hexadecimal but not decimal, we instead compare both.
	    if (shortest) {
	      decimal = toDecimalReference(code, next, omit);

	      if (decimal.length < numeric.length) {
	        numeric = decimal;
	      }
	    }
	  }

	  if (named && (!shortest || named.length < numeric.length)) {
	    return named
	  }

	  return numeric
	}

	// Transform `code` into an entity.
	function toNamed(name, next, omit, attribute) {
	  var value = '&' + name;

	  if (
	    omit &&
	    own.call(legacy, name) &&
	    dangerous.indexOf(name) === -1 &&
	    (!attribute || (next && next !== equalsTo && !alphanumerical(next)))
	  ) {
	    return value
	  }

	  return value + ';'
	}

	// Transform `code` into a hexadecimal character reference.
	function toHexReference(code, next, omit) {
	  var value = '&#x' + code.toString(16).toUpperCase();
	  return omit && next && !hexadecimal(next) ? value : value + ';'
	}

	// Transform `code` into a decimal character reference.
	function toDecimalReference(code, next, omit) {
	  var value = '&#' + String(code);
	  return omit && next && !decimal(next) ? value : value + ';'
	}

	// Create an expression for `characters`.
	function toExpression(characters) {
	  return new RegExp('[' + characters.join('') + ']', 'g')
	}

	// Construct the map.
	function construct() {
	  var chars = {};
	  var name;

	  for (name in entities) {
	    chars[entities[name]] = name;
	  }

	  return chars
	}
	return stringifyEntities;
}

var text;
var hasRequiredText;

function requireText () {
	if (hasRequiredText) return text;
	hasRequiredText = 1;

	var xtend = requireImmutable();
	var entities = requireStringifyEntities();

	text = serializeText;

	function serializeText(ctx, node, index, parent) {
	  var value = node.value;

	  return isLiteral(parent)
	    ? value
	    : entities(value, xtend(ctx.entities, {subset: ['<', '&']}))
	}

	// Check if content of `node` should be escaped.
	function isLiteral(node) {
	  return node && (node.tagName === 'script' || node.tagName === 'style')
	}
	return text;
}

var constants;
var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;

	// Characters.
	var nil = '\0';
	var ampersand = '&';
	var space = ' ';
	var tab = '\t';
	var graveAccent = '`';
	var quotationMark = '"';
	var apostrophe = "'";
	var equalsTo = '=';
	var lessThan = '<';
	var greaterThan = '>';
	var slash = '/';
	var lineFeed = '\n';
	var carriageReturn = '\r';
	var formFeed = '\f';

	var whitespace = [space, tab, lineFeed, carriageReturn, formFeed];

	// See: <https://html.spec.whatwg.org/#attribute-name-state>.
	var name = whitespace.concat(ampersand, slash, greaterThan, equalsTo);

	// See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
	var unquoted = whitespace.concat(ampersand, greaterThan);
	var unquotedSafe = unquoted.concat(
	  nil,
	  quotationMark,
	  apostrophe,
	  lessThan,
	  equalsTo,
	  graveAccent
	);

	// See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
	var singleQuoted = [ampersand, apostrophe];

	// See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
	var doubleQuoted = [ampersand, quotationMark];

	// Maps of subsets.
	// Each value is a matrix of tuples.
	// The first value causes parse errors, the second is valid.
	// Of both values, the first value is unsafe, and the second is safe.
	constants = {
	  name: [
	    [name, name.concat(quotationMark, apostrophe, graveAccent)],
	    [
	      name.concat(nil, quotationMark, apostrophe, lessThan),
	      name.concat(nil, quotationMark, apostrophe, lessThan, graveAccent)
	    ]
	  ],
	  unquoted: [
	    [unquoted, unquotedSafe],
	    [unquotedSafe, unquotedSafe]
	  ],
	  single: [
	    [singleQuoted, singleQuoted.concat(quotationMark, graveAccent)],
	    [
	      singleQuoted.concat(nil),
	      singleQuoted.concat(nil, quotationMark, graveAccent)
	    ]
	  ],
	  double: [
	    [doubleQuoted, doubleQuoted.concat(apostrophe, graveAccent)],
	    [
	      doubleQuoted.concat(nil),
	      doubleQuoted.concat(nil, apostrophe, graveAccent)
	    ]
	  ]
	};
	return constants;
}

var element;
var hasRequiredElement;

function requireElement () {
	if (hasRequiredElement) return element;
	hasRequiredElement = 1;

	var xtend = requireImmutable();
	var svg = requireSvg$1();
	var find = requireFind();
	var spaces = requireSpaceSeparatedTokens().stringify;
	var commas = requireCommaSeparatedTokens().stringify;
	var entities = requireStringifyEntities();
	var ccount = requireCcount();
	var all = requireAll();
	var constants = requireConstants();

	element = serializeElement;

	var space = ' ';
	var quotationMark = '"';
	var apostrophe = "'";
	var equalsTo = '=';
	var lessThan = '<';
	var greaterThan = '>';
	var slash = '/';

	// eslint-disable-next-line complexity
	function serializeElement(ctx, node, index, parent) {
	  var parentSchema = ctx.schema;
	  var name = node.tagName;
	  var value = '';
	  var selfClosing;
	  var close;
	  var omit;
	  var root = node;
	  var content;
	  var attrs;
	  var last;

	  if (parentSchema.space === 'html' && name === 'svg') {
	    ctx.schema = svg;
	  }

	  attrs = serializeAttributes(ctx, node.properties);

	  if (ctx.schema.space === 'svg') {
	    omit = false;
	    close = true;
	    selfClosing = ctx.closeEmpty;
	  } else {
	    omit = ctx.omit;
	    close = ctx.close;
	    selfClosing = ctx.voids.indexOf(name.toLowerCase()) !== -1;

	    if (name === 'template') {
	      root = node.content;
	    }
	  }

	  content = all(ctx, root);

	  // If the node is categorised as void, but it has children, remove the
	  // categorisation.
	  // This enables for example `menuitem`s, which are void in W3C HTML but not
	  // void in WHATWG HTML, to be stringified properly.
	  selfClosing = content ? false : selfClosing;

	  if (attrs || !omit || !omit.opening(node, index, parent)) {
	    value = lessThan + name + (attrs ? space + attrs : '');

	    if (selfClosing && close) {
	      last = attrs.charAt(attrs.length - 1);
	      if (
	        !ctx.tightClose ||
	        last === slash ||
	        (ctx.schema.space === 'svg' &&
	          last &&
	          last !== quotationMark &&
	          last !== apostrophe)
	      ) {
	        value += space;
	      }

	      value += slash;
	    }

	    value += greaterThan;
	  }

	  value += content;

	  if (!selfClosing && (!omit || !omit.closing(node, index, parent))) {
	    value += lessThan + slash + name + greaterThan;
	  }

	  ctx.schema = parentSchema;

	  return value
	}

	function serializeAttributes(ctx, props) {
	  var values = [];
	  var key;
	  var value;
	  var result;
	  var length;
	  var index;
	  var last;

	  for (key in props) {
	    value = props[key];

	    if (value === null || value === undefined) {
	      continue
	    }

	    result = serializeAttribute(ctx, key, value);

	    if (result) {
	      values.push(result);
	    }
	  }

	  length = values.length;
	  index = -1;

	  while (++index < length) {
	    result = values[index];
	    last = null;

	    if (ctx.tight) {
	      last = result.charAt(result.length - 1);
	    }

	    // In tight mode, don’t add a space after quoted attributes.
	    if (index !== length - 1 && last !== quotationMark && last !== apostrophe) {
	      values[index] = result + space;
	    }
	  }

	  return values.join('')
	}

	function serializeAttribute(ctx, key, value) {
	  var schema = ctx.schema;
	  var info = find(schema, key);
	  var name = info.attribute;

	  if (info.overloadedBoolean && (value === name || value === '')) {
	    value = true;
	  } else if (
	    info.boolean ||
	    (info.overloadedBoolean && typeof value !== 'string')
	  ) {
	    value = Boolean(value);
	  }

	  if (
	    value === null ||
	    value === undefined ||
	    value === false ||
	    (typeof value === 'number' && isNaN(value))
	  ) {
	    return ''
	  }

	  name = serializeAttributeName(ctx, name);

	  if (value === true) {
	    // There is currently only one boolean property in SVG: `[download]` on
	    // `<a>`.
	    // This property does not seem to work in browsers (FF, Sa, Ch), so I can’t
	    // test if dropping the value works.
	    // But I assume that it should:
	    //
	    // ```html
	    // <!doctype html>
	    // <svg viewBox="0 0 100 100">
	    //   <a href=https://example.com download>
	    //     <circle cx=50 cy=40 r=35 />
	    //   </a>
	    // </svg>
	    // ```
	    //
	    // See: <https://github.com/wooorm/property-information/blob/master/lib/svg.js>
	    return name
	  }

	  return name + serializeAttributeValue(ctx, key, value, info)
	}

	function serializeAttributeName(ctx, name) {
	  // Always encode without parse errors in non-HTML.
	  var valid = ctx.schema.space === 'html' ? ctx.valid : 1;
	  var subset = constants.name[valid][ctx.safe];

	  return entities(name, xtend(ctx.entities, {subset: subset}))
	}

	function serializeAttributeValue(ctx, key, value, info) {
	  var options = ctx.entities;
	  var quote = ctx.quote;
	  var alternative = ctx.alternative;
	  var smart = ctx.smart;
	  var unquoted;
	  var subset;

	  if (typeof value === 'object' && 'length' in value) {
	    // `spaces` doesn’t accept a second argument, but it’s given here just to
	    // keep the code cleaner.
	    value = (info.commaSeparated ? commas : spaces)(value, {
	      padLeft: !ctx.tightLists
	    });
	  }

	  value = String(value);

	  if (value || !ctx.collapseEmpty) {
	    unquoted = value;

	    // Check unquoted value.
	    if (ctx.unquoted) {
	      subset = constants.unquoted[ctx.valid][ctx.safe];
	      unquoted = entities(
	        value,
	        xtend(options, {subset: subset, attribute: true})
	      );
	    }

	    // If `value` contains entities when unquoted…
	    if (!ctx.unquoted || unquoted !== value) {
	      // If the alternative is less common than `quote`, switch.
	      if (smart && ccount(value, quote) > ccount(value, alternative)) {
	        quote = alternative;
	      }

	      subset = quote === apostrophe ? constants.single : constants.double;
	      // Always encode without parse errors in non-HTML.
	      subset = subset[ctx.schema.space === 'html' ? ctx.valid : 1][ctx.safe];

	      value = entities(value, xtend(options, {subset: subset, attribute: true}));

	      value = quote + value + quote;
	    }

	    // Don’t add a `=` for unquoted empties.
	    value = value ? equalsTo + value : value;
	  }

	  return value
	}
	return element;
}

var doctype;
var hasRequiredDoctype;

function requireDoctype () {
	if (hasRequiredDoctype) return doctype;
	hasRequiredDoctype = 1;

	var xtend = requireImmutable();
	var ccount = requireCcount();
	var entities = requireStringifyEntities();

	doctype = serializeDoctype;

	var docLower = 'doctype';
	var docUpper = docLower.toUpperCase();

	function serializeDoctype(ctx, node) {
	  var doc = ctx.upperDoctype ? docUpper : docLower;
	  var sep = ctx.tightDoctype ? '' : ' ';
	  var name = node.name;
	  var pub = node.public;
	  var sys = node.system;
	  var parts = ['<!' + doc];

	  if (name) {
	    parts.push(sep, name);

	    if (pub !== null && pub !== undefined) {
	      parts.push(' public', sep, quote(ctx, pub));
	    } else if (sys !== null && sys !== undefined) {
	      parts.push(' system');
	    }

	    if (sys !== null && sys !== undefined) {
	      parts.push(sep, quote(ctx, sys));
	    }
	  }

	  return parts.join('') + '>'
	}

	function quote(ctx, value) {
	  var primary = ctx.quote;
	  var secondary = ctx.alternative;
	  var string = String(value);
	  var quote =
	    ccount(string, primary) > ccount(string, secondary) ? secondary : primary;

	  return (
	    quote +
	    // Prevent breaking out of doctype.
	    entities(string, xtend(ctx.entities, {subset: ['<', '&', quote]})) +
	    quote
	  )
	}
	return doctype;
}

var comment;
var hasRequiredComment;

function requireComment () {
	if (hasRequiredComment) return comment;
	hasRequiredComment = 1;

	var xtend = requireImmutable();
	var entities = requireStringifyEntities();

	comment = serializeComment;

	// See: <https://html.spec.whatwg.org/multipage/syntax.html#comments>
	var breakout = /^>|^->|<!--|-->|--!>|<!-$/g;
	var subset = ['<', '>'];
	var bogusSubset = ['>'];

	function serializeComment(ctx, node) {
	  var value = node.value;

	  if (ctx.bogusComments) {
	    return (
	      '<?' + entities(value, xtend(ctx.entities, {subset: bogusSubset})) + '>'
	    )
	  }

	  return '<!--' + value.replace(breakout, encode) + '-->'

	  function encode($0) {
	    return entities($0, xtend(ctx.entities, {subset: subset}))
	  }
	}
	return comment;
}

var raw;
var hasRequiredRaw;

function requireRaw () {
	if (hasRequiredRaw) return raw;
	hasRequiredRaw = 1;

	var text = requireText();

	raw = serializeRaw;

	function serializeRaw(ctx, node) {
	  return ctx.dangerous ? node.value : text(ctx, node)
	}
	return raw;
}

var one;
var hasRequiredOne;

function requireOne () {
	if (hasRequiredOne) return one;
	hasRequiredOne = 1;

	one = serialize;

	var own = {}.hasOwnProperty;

	var handlers = {};

	handlers.root = requireAll();
	handlers.text = requireText();
	handlers.element = requireElement();
	handlers.doctype = requireDoctype();
	handlers.comment = requireComment();
	handlers.raw = requireRaw();

	function serialize(ctx, node, index, parent) {
	  var type = node && node.type;

	  if (!type) {
	    throw new Error('Expected node, not `' + node + '`')
	  }

	  if (!own.call(handlers, type)) {
	    throw new Error('Cannot compile unknown node `' + type + '`')
	  }

	  return handlers[type](ctx, node, index, parent)
	}
	return one;
}

var lib;
var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib;
	hasRequiredLib = 1;

	var html = requireHtml$4();
	var svg = requireSvg$1();
	var voids = require$$2;
	var omission = requireOmission();
	var one = requireOne();

	lib = toHtml;

	var quotationMark = '"';
	var apostrophe = "'";

	var deprecationWarningIssued = false;

	function toHtml(node, options) {
	  var settings = options || {};
	  var quote = settings.quote || quotationMark;
	  var alternative = quote === quotationMark ? apostrophe : quotationMark;
	  var smart = settings.quoteSmart;
	  var value =
	    node && typeof node === 'object' && 'length' in node
	      ? {type: 'root', children: node}
	      : node;

	  if (quote !== quotationMark && quote !== apostrophe) {
	    throw new Error(
	      'Invalid quote `' +
	        quote +
	        '`, expected `' +
	        apostrophe +
	        '` or `' +
	        quotationMark +
	        '`'
	    )
	  }

	  if (settings.allowDangerousHTML !== undefined) {
	    if (!deprecationWarningIssued) {
	      deprecationWarningIssued = true;
	      console.warn(
	        'Deprecation warning: `allowDangerousHTML` is a nonstandard option, use `allowDangerousHtml` instead'
	      );
	    }
	  }

	  return one(
	    {
	      valid: settings.allowParseErrors ? 0 : 1,
	      safe: settings.allowDangerousCharacters ? 0 : 1,
	      schema: settings.space === 'svg' ? svg : html,
	      omit: settings.omitOptionalTags && omission,
	      quote: quote,
	      alternative: alternative,
	      smart: smart,
	      unquoted: Boolean(settings.preferUnquoted),
	      tight: settings.tightAttributes,
	      upperDoctype: Boolean(settings.upperDoctype),
	      tightDoctype: Boolean(settings.tightDoctype),
	      bogusComments: Boolean(settings.bogusComments),
	      tightLists: settings.tightCommaSeparatedLists,
	      tightClose: settings.tightSelfClosing,
	      collapseEmpty: settings.collapseEmptyAttributes,
	      dangerous: settings.allowDangerousHtml || settings.allowDangerousHTML,
	      voids: settings.voids || voids.concat(),
	      entities: settings.entities || {},
	      close: settings.closeSelfClosing,
	      closeEmpty: settings.closeEmptyElements
	    },
	    value
	  )
	}
	return lib;
}

var hastUtilToHtml;
var hasRequiredHastUtilToHtml;

function requireHastUtilToHtml () {
	if (hasRequiredHastUtilToHtml) return hastUtilToHtml;
	hasRequiredHastUtilToHtml = 1;
	hastUtilToHtml = requireLib();
	return hastUtilToHtml;
}

var rehypeStringify;
var hasRequiredRehypeStringify;

function requireRehypeStringify () {
	if (hasRequiredRehypeStringify) return rehypeStringify;
	hasRequiredRehypeStringify = 1;

	var toHTML = requireHastUtilToHtml();

	rehypeStringify = stringify;

	function stringify(config) {
	  var settings = Object.assign({}, config, this.data('settings'));

	  this.Compiler = compiler;

	  function compiler(tree) {
	    return toHTML(tree, settings)
	  }
	}
	return rehypeStringify;
}

var rehypeStringifyExports = requireRehypeStringify();
var html = /*@__PURE__*/getDefaultExportFromCjs(rehypeStringifyExports);

var unistUtilVisitExports = requireUnistUtilVisit();
var visit = /*@__PURE__*/getDefaultExportFromCjs(unistUtilVisitExports);

function saveFrontmatter() {
    return transformer$2;
}
function transformer$2(tree, file) {
    return visit(tree, 'yaml', storeData(file));
}
const storeData = (file) => (item) => {
    file.data.frontmatter = item.data.parsedValue;
};

var unistUtilMap;
var hasRequiredUnistUtilMap;

function requireUnistUtilMap () {
	if (hasRequiredUnistUtilMap) return unistUtilMap;
	hasRequiredUnistUtilMap = 1;

	var assign = requireObjectAssign();

	unistUtilMap = map;

	function map(tree, iteratee) {
	  return preorder(tree, null, null)

	  function preorder(node, index, parent) {
	    var children = node.children;
	    var newNode = assign({}, iteratee(node, index, parent));

	    if (children) {
	      newNode.children = children.map(bound);
	    }

	    return newNode

	    function bound(child, index) {
	      return preorder(child, index, node)
	    }
	  }
	}
	return unistUtilMap;
}

var unistUtilMapExports = requireUnistUtilMap();
var map = /*@__PURE__*/getDefaultExportFromCjs(unistUtilMapExports);

function kompendiumCode() {
    return transformer$1;
}
function transformer$1(tree) {
    return map(tree, mapCodeNode$1);
}
function mapCodeNode$1(node) {
    if (node.type !== 'element') {
        return node;
    }
    if (node.tagName !== 'code') {
        return node;
    }
    const language = getLanguage(node.properties);
    if (!language) {
        return node;
    }
    return {
        ...node,
        type: 'element',
        tagName: 'kompendium-code',
        properties: {
            language: language,
        },
        children: [],
    };
}
function getLanguage(props) {
    if (!props) {
        return;
    }
    if (!('className' in props)) {
        return;
    }
    const languageClass = props.className.find((name) => name.startsWith('language-'));
    if (!languageClass) {
        return;
    }
    return languageClass.replace('language-', '');
}

var unistUtilFlatmap;
var hasRequiredUnistUtilFlatmap;

function requireUnistUtilFlatmap () {
	if (hasRequiredUnistUtilFlatmap) return unistUtilFlatmap;
	hasRequiredUnistUtilFlatmap = 1;
	unistUtilFlatmap = flatMap;

	function flatMap(ast, fn) {
	  return transform(ast, 0, null)[0]

	  function transform(node, index, parent) {
	    if (node.children) {
	      var out = [];
	      for (var i = 0, n = node.children.length; i < n; i++) {
	        var xs = transform(node.children[i], i, node);
	        if (xs) {
	          for (var j = 0, m = xs.length; j < m; j++) {
	            out.push(xs[j]);
	          }
	        }
	      }
	      node.children = out;
	    }

	    return fn(node, index, parent)
	  }
	}
	return unistUtilFlatmap;
}

var unistUtilFlatmapExports = requireUnistUtilFlatmap();
var flatMap = /*@__PURE__*/getDefaultExportFromCjs(unistUtilFlatmapExports);

function typeLinks(options = {}) {
    return transformer(options.types);
}
const transformer = (types = []) => (tree) => {
    if (types.length === 0) {
        return tree;
    }
    return flatMap(tree, mapCodeNode(types));
};
const mapCodeNode = (types = []) => (node, _, parent) => {
    var _a;
    if (node.type !== 'text') {
        return [node];
    }
    if (parent.tagName !== 'code') {
        return [node];
    }
    if (((_a = parent.parent) === null || _a === void 0 ? void 0 : _a.tagName) === 'pre') {
        return [node];
    }
    return wrapText(node, types);
};
function wrapText(node, types = []) {
    return splitTypeString(node.value).map(createNode(types));
}
const createNode = (types = []) => (type) => {
    if (!types.includes(type)) {
        return createTextNode(type);
    }
    return createLinkNode(type);
};
function createTextNode(text) {
    return {
        type: 'text',
        value: text,
    };
}
function createLinkNode(type) {
    return {
        type: 'element',
        tagName: 'a',
        properties: {
            href: `#/type/${type}`,
        },
        children: [
            {
                type: 'text',
                value: type,
            },
        ],
    };
}
function splitTypeString(typeString) {
    const pattern = /(\b\w+\b)+/g;
    const types = typeString.match(pattern);
    const result = [];
    let currentString = typeString;
    types.forEach((type) => {
        const index = currentString.indexOf(type);
        if (index > 0) {
            result.push(currentString.substr(0, index));
        }
        result.push(type);
        currentString = currentString.substr(index + type.length);
    });
    if (currentString.length > 0) {
        result.push(currentString);
    }
    return result;
}

async function markdownToHtml(text, types = []) {
    return new Promise((resolve) => {
        unified()
            .use(markdown)
            .use(frontmatter)
            .use(parseFrontmatter)
            .use(saveFrontmatter)
            .use(admonitions, { icons: 'none' })
            .use(remark2rehype, { allowDangerousHtml: true })
            .use(raw$1)
            .use(typeLinks, { types: types })
            .use(kompendiumCode)
            .use(html)
            .process(text, (_, file) => {
            resolve(file);
        });
    });
}

const markdownCss = "*,*::before,*::after{box-sizing:border-box}ul[class],ol[class]{padding:0}body,h1,h2,h3,h4,p,ul[class],ol[class],li,figure,figcaption,blockquote,dl,dd{margin:0}ul[class],ol[class]{list-style:none}a:not([class]){text-decoration-skip-ink:auto}img{max-width:100%}input,button,textarea,select{font:inherit}@media (prefers-reduced-motion: reduce){*{animation-duration:0.01ms !important;animation-iteration-count:1 !important;transition-duration:0.01ms !important;scroll-behavior:auto !important}}p,a,li{font-size:0.9375rem}h1,h2,h3,h4,h5,h6{margin-bottom:0.5rem;font-weight:normal;font-weight:500}h1{font-size:2rem;line-height:2.25rem;margin-top:1.5rem;letter-spacing:-0.0625rem;font-weight:400}h2{font-size:1.625rem;line-height:1.25rem;margin-top:1.25rem;margin-bottom:1rem}h3{font-size:1.375rem;line-height:1.5rem;margin-top:1rem}h4{font-size:1.25rem;line-height:1.25rem;margin-top:1rem}h5{font-size:1.125rem;line-height:1.125rem;margin-top:0.75rem}h6{font-size:1rem;font-variant:all-small-caps;letter-spacing:0.0625rem}p,blockquote{margin-top:0;margin-bottom:0.5rem}p:only-child,blockquote:only-child{margin-bottom:0}a{transition:color 0.2s ease;color:rgb(var(--kompendium-color-blue-default));text-decoration:none;border-radius:0.125rem}a:hover{color:rgb(var(--kompendium-color-blue-light))}a:focus{outline:none}a:focus-visible{outline:none;box-shadow:var(--kompendium-shadow-depth-8-focused)}ul{list-style:none}ul li{position:relative;margin-left:0.75rem}ul li:before{content:\"\";position:absolute;left:-0.5rem;top:0.625rem;width:0.25rem;height:0.25rem;border-radius:50%;background-color:rgb(var(--kompendium-contrast-700));display:block}ol{list-style:decimal inside}ol,ul{padding-left:0;margin-top:0}ul ul,ul ol,ol ol,ol ul{margin:0.9375rem 0 0.9375rem 1.875rem;font-size:90%}li{margin-bottom:0.625rem}th,td{padding:0.75rem 1rem;text-align:left;border-bottom:1px solid rgb(var(--kompendium-contrast-600))}th:first-child,td:first-child{padding-left:0}th:last-child,td:last-child{padding-right:0}hr{margin:1.75rem 0 2rem 0;border-width:0;border-top:1px solid rgb(var(--kompendium-contrast-600))}kbd{font-family:var(--kompendium-font-code);font-size:0.875rem;font-weight:600;color:rgb(var(--kompendium-contrast-1000));background-color:rgb(var(--kompendium-contrast-200));white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:normal;padding:0.125rem 0.5rem;margin:0 0.25rem;box-shadow:var(--kompendium-button-shadow-normal), 0 0.03125rem 0.21875rem 0 rgba(var(--kompendium-contrast-100), 0.5) inset;border-radius:0.25rem;border-style:solid;border-color:rgba(var(--kompendium-contrast-600), 0.8);border-width:0 1px 0.125rem 1px}@media (prefers-color-scheme: dark){kbd:not([data-theme=force-light]){background-color:rgb(var(--kompendium-contrast-200));color:rgb(var(--kompendium-contrast-1100));border-color:rgba(var(--kompendium-contrast-500), 0.8)}}kbd[data-theme=force-dark]{background-color:rgb(var(--kompendium-contrast-200));color:rgb(var(--kompendium-contrast-1100));border-color:rgba(var(--kompendium-contrast-500), 0.8)}@media (prefers-color-scheme: dark){:host(:not([data-theme=force-light])) kbd{background-color:rgb(var(--kompendium-contrast-200));color:rgb(var(--kompendium-contrast-1100));border-color:rgba(var(--kompendium-contrast-500), 0.8)}}:host([data-theme=force-dark]) kbd{background-color:rgb(var(--kompendium-contrast-200));color:rgb(var(--kompendium-contrast-1100));border-color:rgba(var(--kompendium-contrast-500), 0.8)}:host{display:block}pre,code{font-family:var(--kompendium-font-code);border-radius:0.25rem;font-size:0.6875rem}pre a,code a{font-size:0.6875rem}code{background:rgba(var(--kompendium-contrast-1100), 0.05);border:1px solid rgba(var(--kompendium-contrast-1100), 0.1);padding:0.125rem 0.3125rem;margin:0 0.125rem;white-space:pre-wrap;color:rgb(var(--kompendium-contrast-1100))}pre>code{display:block;padding:0.625rem 0.6375rem;white-space:pre-wrap}.value--false code{color:rgb(var(--kompendium-color-code-magenta));border-color:rgba(var(--kompendium-color-code-magenta), 0.2);background-color:rgba(var(--kompendium-color-code-magenta), 0.1)}.value--true code{color:rgb(var(--kompendium-color-code-green-dark));border-color:rgba(var(--kompendium-color-code-green-dark), 0.2);background-color:rgba(var(--kompendium-color-code-green-dark), 0.1)}dl{display:grid;grid-template-columns:1fr 2fr;grid-template-rows:1fr;margin-bottom:2rem;border:1px solid rgb(var(--kompendium-contrast-500));border-radius:0.375rem;background-color:rgb(var(--kompendium-contrast-300))}dl dt,dl dd{padding:0.375rem 0.5rem;font-size:0.875rem}dl dt:nth-of-type(even),dl dd:nth-of-type(even){background-color:rgb(var(--kompendium-contrast-400))}dl dt:first-child{border-top-left-radius:0.375rem}dl dt:last-child{border-bottom-left-radius:0.375rem}dl dd:first-child{border-top-right-radius:0.375rem}dl dd:last-child{border-bottom-right-radius:0.375rem}dl,dt,dd{transition:background-color 0.3s ease 0.05s, border-color 0.3s ease 0.05s}:root[data-theme=system-default]{color-scheme:dark light}:root[data-theme=force-light]{color-scheme:light}:root[data-theme=force-dark]{color-scheme:dark}:root{--kompendium-color-primary:33, 150, 243;--kompendium-color-error:229, 115, 115;--kompendium-color-white:255, 255, 255;--kompendium-color-black:0, 0, 0;--kompendium-contrast-100:255, 255, 255;--kompendium-contrast-200:250, 250, 251;--kompendium-contrast-300:246, 246, 247;--kompendium-contrast-400:241, 241, 243;--kompendium-contrast-500:237, 237, 238;--kompendium-contrast-600:232, 232, 234;--kompendium-contrast-700:209, 209, 213;--kompendium-contrast-800:186, 186, 192;--kompendium-contrast-900:140, 140, 150;--kompendium-contrast-1000:117, 117, 128;--kompendium-contrast-1100:94, 94, 108;--kompendium-contrast-1200:71, 71, 86;--kompendium-contrast-1300:48, 48, 66;--kompendium-contrast-1400:39, 39, 57;--kompendium-contrast-1500:35, 35, 53;--kompendium-contrast-1600:25, 25, 44;--kompendium-contrast-1700:20, 20, 37;--kompendium-color-red-light:229, 115, 115;--kompendium-color-red-default:244, 67, 54;--kompendium-color-blue-light:100, 181, 246;--kompendium-color-blue-default:33, 150, 243;--kompendium-color-green-light:129, 199, 132;--kompendium-color-green-default:76, 175, 80;--kompendium-color-amber-light:255, 213, 79;--kompendium-color-amber-default:255, 193, 7;--kompendium-color-orange-light:255, 183, 77;--kompendium-color-orange-default:255, 152, 0}@media (prefers-color-scheme: dark){:root:not([data-theme=force-light]){--kompendium-color-primary:30, 136, 229;--kompendium-color-error:229, 57, 53;--kompendium-contrast-100:20, 20, 37;--kompendium-contrast-200:25, 25, 44;--kompendium-contrast-300:35, 35, 53;--kompendium-contrast-400:39, 39, 57;--kompendium-contrast-500:48, 48, 66;--kompendium-contrast-600:71, 71, 86;--kompendium-contrast-700:94, 94, 108;--kompendium-contrast-800:117, 117, 128;--kompendium-contrast-900:140, 140, 150;--kompendium-contrast-1000:186, 186, 192;--kompendium-contrast-1100:209, 209, 213;--kompendium-contrast-1200:232, 232, 234;--kompendium-contrast-1300:237, 237, 238;--kompendium-contrast-1400:241, 241, 243;--kompendium-contrast-1500:246, 246, 247;--kompendium-contrast-1600:250, 250, 251;--kompendium-contrast-1700:255, 255, 255;--kompendium-color-red-light:240, 87, 80;--kompendium-color-red-default:229, 57, 53;--kompendium-color-blue-light:66, 165, 245;--kompendium-color-blue-default:30, 136, 229;--kompendium-color-green-light:102, 187, 106;--kompendium-color-green-default:67, 160, 71;--kompendium-color-amber-light:255, 207, 61;--kompendium-color-amber-default:255, 176, 59;--kompendium-color-orange-light:255, 167, 38;--kompendium-color-orange-default:251, 140, 0}}:root[data-theme=force-dark]{--kompendium-color-primary:30, 136, 229;--kompendium-color-error:229, 57, 53;--kompendium-contrast-100:20, 20, 37;--kompendium-contrast-200:25, 25, 44;--kompendium-contrast-300:35, 35, 53;--kompendium-contrast-400:39, 39, 57;--kompendium-contrast-500:48, 48, 66;--kompendium-contrast-600:71, 71, 86;--kompendium-contrast-700:94, 94, 108;--kompendium-contrast-800:117, 117, 128;--kompendium-contrast-900:140, 140, 150;--kompendium-contrast-1000:186, 186, 192;--kompendium-contrast-1100:209, 209, 213;--kompendium-contrast-1200:232, 232, 234;--kompendium-contrast-1300:237, 237, 238;--kompendium-contrast-1400:241, 241, 243;--kompendium-contrast-1500:246, 246, 247;--kompendium-contrast-1600:250, 250, 251;--kompendium-contrast-1700:255, 255, 255;--kompendium-color-red-light:240, 87, 80;--kompendium-color-red-default:229, 57, 53;--kompendium-color-blue-light:66, 165, 245;--kompendium-color-blue-default:30, 136, 229;--kompendium-color-green-light:102, 187, 106;--kompendium-color-green-default:67, 160, 71;--kompendium-color-amber-light:255, 207, 61;--kompendium-color-amber-default:255, 176, 59;--kompendium-color-orange-light:255, 167, 38;--kompendium-color-orange-default:251, 140, 0}@media (prefers-color-scheme: dark){:host(:not([data-theme=force-light])) :root{--kompendium-color-primary:30, 136, 229;--kompendium-color-error:229, 57, 53;--kompendium-contrast-100:20, 20, 37;--kompendium-contrast-200:25, 25, 44;--kompendium-contrast-300:35, 35, 53;--kompendium-contrast-400:39, 39, 57;--kompendium-contrast-500:48, 48, 66;--kompendium-contrast-600:71, 71, 86;--kompendium-contrast-700:94, 94, 108;--kompendium-contrast-800:117, 117, 128;--kompendium-contrast-900:140, 140, 150;--kompendium-contrast-1000:186, 186, 192;--kompendium-contrast-1100:209, 209, 213;--kompendium-contrast-1200:232, 232, 234;--kompendium-contrast-1300:237, 237, 238;--kompendium-contrast-1400:241, 241, 243;--kompendium-contrast-1500:246, 246, 247;--kompendium-contrast-1600:250, 250, 251;--kompendium-contrast-1700:255, 255, 255;--kompendium-color-red-light:240, 87, 80;--kompendium-color-red-default:229, 57, 53;--kompendium-color-blue-light:66, 165, 245;--kompendium-color-blue-default:30, 136, 229;--kompendium-color-green-light:102, 187, 106;--kompendium-color-green-default:67, 160, 71;--kompendium-color-amber-light:255, 207, 61;--kompendium-color-amber-default:255, 176, 59;--kompendium-color-orange-light:255, 167, 38;--kompendium-color-orange-default:251, 140, 0}}:host([data-theme=force-dark]) :root{--kompendium-color-primary:30, 136, 229;--kompendium-color-error:229, 57, 53;--kompendium-contrast-100:20, 20, 37;--kompendium-contrast-200:25, 25, 44;--kompendium-contrast-300:35, 35, 53;--kompendium-contrast-400:39, 39, 57;--kompendium-contrast-500:48, 48, 66;--kompendium-contrast-600:71, 71, 86;--kompendium-contrast-700:94, 94, 108;--kompendium-contrast-800:117, 117, 128;--kompendium-contrast-900:140, 140, 150;--kompendium-contrast-1000:186, 186, 192;--kompendium-contrast-1100:209, 209, 213;--kompendium-contrast-1200:232, 232, 234;--kompendium-contrast-1300:237, 237, 238;--kompendium-contrast-1400:241, 241, 243;--kompendium-contrast-1500:246, 246, 247;--kompendium-contrast-1600:250, 250, 251;--kompendium-contrast-1700:255, 255, 255;--kompendium-color-red-light:240, 87, 80;--kompendium-color-red-default:229, 57, 53;--kompendium-color-blue-light:66, 165, 245;--kompendium-color-blue-default:30, 136, 229;--kompendium-color-green-light:102, 187, 106;--kompendium-color-green-default:67, 160, 71;--kompendium-color-amber-light:255, 207, 61;--kompendium-color-amber-default:255, 176, 59;--kompendium-color-orange-light:255, 167, 38;--kompendium-color-orange-default:251, 140, 0}:root{--kompendium-color-code-pink:216, 27, 96;--kompendium-color-code-magenta:156, 22, 87;--kompendium-color-code-blue:33, 150, 243;--kompendium-color-code-orange:245, 124, 0;--kompendium-color-code-yellow:255, 87, 34;--kompendium-color-code-purple:149, 117, 205;--kompendium-color-code-green-light:53, 196, 84;--kompendium-color-code-green-dark:85, 139, 47;--kompendium-color-code-turquoise:0, 151, 167;--kompendium-color-code-gray-lighter:71, 71, 86;--kompendium-color-code-gray-light:var(--kompendium-contrast-1100);--kompendium-color-code-gray-dark:var(--kompendium-contrast-1200);--kompendium-color-code-background:var(--kompendium-contrast-200)}@media (prefers-color-scheme: dark){:root:not([data-theme=force-light]){--kompendium-color-code-pink:226, 119, 122;--kompendium-color-code-magenta:232, 62, 140;--kompendium-color-code-blue:97, 150, 204;--kompendium-color-code-orange:255, 152, 0;--kompendium-color-code-yellow:255, 213, 79;--kompendium-color-code-purple:206, 147, 216;--kompendium-color-code-green-light:174, 213, 129;--kompendium-color-code-green-dark:53, 196, 84;--kompendium-color-code-turquoise:103, 205, 204;--kompendium-color-code-gray-lighter:117, 117, 128}}:root[data-theme=force-dark]{--kompendium-color-code-pink:226, 119, 122;--kompendium-color-code-magenta:232, 62, 140;--kompendium-color-code-blue:97, 150, 204;--kompendium-color-code-orange:255, 152, 0;--kompendium-color-code-yellow:255, 213, 79;--kompendium-color-code-purple:206, 147, 216;--kompendium-color-code-green-light:174, 213, 129;--kompendium-color-code-green-dark:53, 196, 84;--kompendium-color-code-turquoise:103, 205, 204;--kompendium-color-code-gray-lighter:117, 117, 128}@media (prefers-color-scheme: dark){:host(:not([data-theme=force-light])) :root{--kompendium-color-code-pink:226, 119, 122;--kompendium-color-code-magenta:232, 62, 140;--kompendium-color-code-blue:97, 150, 204;--kompendium-color-code-orange:255, 152, 0;--kompendium-color-code-yellow:255, 213, 79;--kompendium-color-code-purple:206, 147, 216;--kompendium-color-code-green-light:174, 213, 129;--kompendium-color-code-green-dark:53, 196, 84;--kompendium-color-code-turquoise:103, 205, 204;--kompendium-color-code-gray-lighter:117, 117, 128}}:host([data-theme=force-dark]) :root{--kompendium-color-code-pink:226, 119, 122;--kompendium-color-code-magenta:232, 62, 140;--kompendium-color-code-blue:97, 150, 204;--kompendium-color-code-orange:255, 152, 0;--kompendium-color-code-yellow:255, 213, 79;--kompendium-color-code-purple:206, 147, 216;--kompendium-color-code-green-light:174, 213, 129;--kompendium-color-code-green-dark:53, 196, 84;--kompendium-color-code-turquoise:103, 205, 204;--kompendium-color-code-gray-lighter:117, 117, 128}.admonition{--size-of-admonition-icon:2.5rem;--border-radius-of-admonition-icon:0.5rem;border-radius:var(--border-radius-of-admonition-icon);background-color:rgb(var(--kompendium-contrast-400));margin:0.75rem 0 1rem 0;padding:0.5rem 0.5rem 0.75rem 0.5rem;position:relative}.admonition:before{content:\"\";width:var(--size-of-admonition-icon);position:absolute;left:0;top:0;bottom:0;display:block;border-radius:var(--border-radius-of-admonition-icon) 0 0 var(--border-radius-of-admonition-icon);background-position:top center;background-repeat:no-repeat;background-size:contain;background-color:#eaeaea}.admonition-tip:before{background-image:url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" fill-rule=\"evenodd\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"1.5\" clip-rule=\"evenodd\" viewBox=\"0 0 400 400\"><defs/><path fill=\"none\" d=\"M0 0h400v400H0z\"/><circle cx=\"200\" cy=\"200\" r=\"140.5\" fill=\"%23ffd54f\" fill-opacity=\".2\"/><circle cx=\"200\" cy=\"200\" r=\"119.072\" fill=\"%23ffd54f\" fill-opacity=\".3\"/><circle cx=\"200\" cy=\"200\" r=\"99.5\" fill=\"%23ffd54f\"/><path fill=\"%23fff\" fill-rule=\"nonzero\" d=\"M265.384 201.1c0-38.426-33.52-69.494-72.764-64.589-28.615 3.27-52.325 26.163-57.231 54.778-3.27 21.257 4.088 41.696 17.17 55.595 9.81 9.811 14.716 22.892 14.716 36.791h65.406c0-13.081 4.906-26.98 13.899-35.973 11.446-13.082 18.804-28.616 18.804-46.602z\"/><path fill=\"none\" stroke=\"%23ffd54f\" stroke-width=\"8\" d=\"M213.2 194.58C224 188 238 196 231.751 204.881c-9.583 13.619-57.987 11.566-63.709-1.805-3.689-8.622 8.958-14.076 19.439-8.496C196.151 199.196 200.5 207 200.5 224v4\"/><path fill=\"%23446c80\" fill-rule=\"nonzero\" d=\"M232.681 283.675h-65.406c0 18.532 14.171 32.703 32.703 32.703 18.532 0 32.703-14.171 32.703-32.703z\"/></svg>');background-color:rgba(var(--kompendium-color-code-yellow), 0.2)}.admonition-note:before{background-image:url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" fill-rule=\"evenodd\" stroke-linejoin=\"round\" stroke-miterlimit=\"2\" clip-rule=\"evenodd\" viewBox=\"0 0 400 400\"><defs/><path fill=\"none\" d=\"M0 0h400v400H0z\"/><circle cx=\"200\" cy=\"200\" r=\"119.072\" fill=\"%2381c784\" fill-opacity=\".3\"/><circle cx=\"200\" cy=\"200\" r=\"99.5\" fill=\"%2381c784\"/><path fill=\"%23fff\" d=\"M200.011 145.221c-5.042 0-9.129 4.136-9.129 9.102v54.834a9.094 9.094 0 009.129 9.103c5.043 0 9.13-4.136 9.13-9.103v-54.834a9.093 9.093 0 00-9.13-9.102zm0 109.558a9.13 9.13 0 009.13-9.13 9.129 9.129 0 00-9.13-9.129 9.129 9.129 0 00-9.129 9.129 9.129 9.129 0 009.129 9.13z\"/></svg>');background-color:rgba(var(--kompendium-color-code-green-dark), 0.1)}.admonition-warning:before{background-image:url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" fill-rule=\"evenodd\" stroke-linejoin=\"round\" stroke-miterlimit=\"2\" clip-rule=\"evenodd\" viewBox=\"0 0 400 400\"><defs/><path fill=\"none\" d=\"M0 0h400v400H0z\"/><path fill=\"%23f44336\" d=\"M187.167 113.32c7.091-11.474 18.606-11.446 25.681 0l87.906 142.221c9.467 15.317 2.571 27.734-15.394 27.734H114.655c-17.97 0-24.892-12.367-15.395-27.734l87.907-142.221z\"/><path fill=\"%23fff\" d=\"M200.011 155.052c-5.042 0-9.129 4.136-9.129 9.103v54.833a9.094 9.094 0 009.129 9.103c5.043 0 9.13-4.136 9.13-9.103v-54.833a9.093 9.093 0 00-9.13-9.103zm0 109.558a9.13 9.13 0 009.13-9.13 9.129 9.129 0 00-9.13-9.129 9.129 9.129 0 00-9.129 9.129 9.129 9.129 0 009.129 9.13z\"/></svg>');background-color:rgba(var(--kompendium-color-code-pink), 0.2)}.admonition-danger:before{background-image:url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" fill-rule=\"evenodd\" stroke-linejoin=\"round\" stroke-miterlimit=\"2\" clip-rule=\"evenodd\" viewBox=\"0 0 400 400\"><defs/><path fill=\"none\" d=\"M0 0h400v400H0z\"/><path fill=\"%23446c80\" d=\"M100.7 233.141c-5.6-12.935-8.7-27.173-8.7-42.122C92 131.954 140.393 84 200 84s108 47.954 108 107.019c0 14.949-3.1 29.187-8.7 42.122-4.582 26.722-21.33 48.534-43.425 57.687v12.728c0 10.357-8.485 18.764-18.935 18.764-9.066 0-16.653-6.327-18.504-14.765-1.962 8.291-9.477 14.47-18.436 14.47-9.012 0-16.562-6.251-18.47-14.615-1.909 8.364-9.459 14.615-18.47 14.615-10.45 0-18.935-8.407-18.935-18.764v-12.433c-22.096-9.154-38.844-30.967-43.425-57.687z\"/><path fill=\"%23fff\" fill-opacity=\".2\" d=\"M213.322 264.164c-3.328 3.135-23.317 3.135-26.644 0-3.332-3.136-3.332-4.928 0-11.199 2.328-4.703 9.832-17.022 13.322-17.022 3.489 0 10.993 12.319 13.322 17.022 3.331 6.271 3.331 8.063 0 11.199z\"/><path fill=\"%23fff\" d=\"M150.179 213.14c12.03 0 21.797 9.678 21.797 21.599s-9.767 21.599-21.797 21.599c-12.03 0-21.797-9.678-21.797-21.599s9.767-21.599 21.797-21.599zm100.844 12.114l8.678-8.598c2.635-2.612 6.896-2.624 9.557.014 2.644 2.619 2.618 6.891.015 9.47l-8.678 8.599 8.678 8.599a6.637 6.637 0 01-.015 9.47c-2.643 2.619-6.954 2.594-9.557.014l-8.678-8.598-8.677 8.598c-2.635 2.612-6.896 2.624-9.558-.014-2.643-2.619-2.617-6.89-.014-9.47l8.678-8.599-8.678-8.599a6.638 6.638 0 01.014-9.47c2.644-2.619 6.954-2.594 9.558-.014l8.677 8.598z\"/></svg>');background-color:rgba(var(--kompendium-color-code-gray-dark), 0.1)}.admonition-info:before{background-image:url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" fill-rule=\"evenodd\" stroke-linejoin=\"round\" stroke-miterlimit=\"2\" clip-rule=\"evenodd\" viewBox=\"0 0 400 400\"><defs/><path fill=\"none\" d=\"M0 0h400v400H0z\"/><path fill=\"%232196f3\" fill-rule=\"nonzero\" d=\"M229.238 275.304c-.075.025-6.987 2.325-12.987 2.325-3.312 0-4.65-.687-5.075-.987-2.1-1.463-6-4.2.675-17.5l12.5-24.924c7.412-14.8 8.512-29.112 3.062-40.312-4.45-9.162-12.987-15.449-23.999-17.699a59.668 59.668 0 00-11.975-1.213c-23.112 0-38.674 13.5-39.324 14.075a6.262 6.262 0 00-1.275 7.825 6.244 6.244 0 007.438 2.775c.062-.025 6.987-2.338 12.987-2.338 3.287 0 4.612.688 5.025.975 2.112 1.475 6.024 4.25-.638 17.525l-12.499 24.937c-7.425 14.812-8.513 29.124-3.063 40.311 4.45 9.162 12.975 15.449 24.012 17.699 3.925.788 7.95 1.213 11.925 1.213 23.124 0 38.698-13.5 39.348-14.075 2.238-1.962 2.763-5.25 1.275-7.825-1.5-2.562-4.612-3.712-7.412-2.787zm-10.487-175.295c17.247 0 31.249 14.002 31.249 31.249s-14.002 31.249-31.249 31.249-31.249-14.002-31.249-31.249 14.002-31.249 31.249-31.249z\"/></svg>');background-color:rgba(var(--kompendium-color-code-turquoise), 0.2)}.admonition-important:before{background-image:url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" fill-rule=\"evenodd\" stroke-linejoin=\"round\" stroke-miterlimit=\"2\" clip-rule=\"evenodd\" viewBox=\"0 0 400 400\"><defs/><path fill=\"none\" d=\"M0 0h400v400H0z\"/><path fill=\"%23ffd54f\" fill-rule=\"nonzero\" d=\"M254.158 293c-2.499 0-4.941-.558-7.205-1.628a9.33 9.33 0 01-1.16-.569l-45.807-26.132-45.806 26.143c-.39.223-.781.413-1.182.591-5.443 2.543-12.101 1.941-16.964-1.595-5.231-3.792-7.819-10.406-6.536-16.83l10.674-51.773c-4.172-3.793-10.73-9.76-17.868-16.251l-21.135-19.239a8.364 8.364 0 01-.87-.915c-4.183-4.416-5.677-10.818-3.792-16.64 1.929-5.845 6.915-10.172 12.937-11.254.38-.089.748-.156 1.138-.201l52.431-5.811 21.705-48.07a7.66 7.66 0 01.669-1.227A16.72 16.72 0 01199.986 93c6.057 0 11.644 3.324 14.6 8.588.234.402.457.814.669 1.249l21.727 48.093 52.431 5.811c.379.033.759.1 1.16.189 6.012 1.116 10.997 5.421 12.916 11.287 1.896 5.811.39 12.247-3.793 16.663-.267.29-.568.603-.87.87l-39.014 35.512 10.674 51.662c1.26 6.547-1.316 13.139-6.58 16.942a16.602 16.602 0 01-9.748 3.134z\"/><circle cx=\"255.5\" cy=\"127.5\" r=\"14.5\" fill=\"%23ffd54f\" fill-opacity=\".5\"/><circle cx=\"144.5\" cy=\"127.5\" r=\"14.5\" fill=\"%23ffd54f\" fill-opacity=\".5\"/><circle cx=\"287.5\" cy=\"229.5\" r=\"14.5\" fill=\"%23ffd54f\" fill-opacity=\".5\"/><circle cx=\"113.5\" cy=\"229.5\" r=\"14.5\" fill=\"%23ffd54f\" fill-opacity=\".5\"/><circle cx=\"200\" cy=\"297.5\" r=\"14.5\" fill=\"%23ffd54f\" fill-opacity=\".5\"/></svg>');background-color:rgba(var(--kompendium-color-code-gray-dark), 0.4)}.admonition-heading{margin-bottom:0.375rem}.admonition-heading h5{color:rgb(var(--kompendium-contrast-1100));margin:0;font-size:0.9375rem;padding:0.125rem 0 0 var(--size-of-admonition-icon)}.admonition-heading h5::first-letter{text-transform:capitalize}.admonition-content{padding-left:var(--size-of-admonition-icon)}.admonition-content p:first-child{margin-top:0}.admonition-content p:only-child{margin-bottom:0}@media (max-width: 600px){.admonition{--size-of-admonition-icon:2rem}}blockquote{border-left-color:rgb(var(--kompendium-contrast-700));border-left-style:solid;border-left-width:0.25rem;color:rgb(var(--kompendium-contrast-1100));padding-left:1rem}";

const Markdown = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
    }
    componentDidLoad() {
        this.renderMarkdown();
    }
    componentDidUpdate() {
        this.renderMarkdown();
    }
    async renderMarkdown() {
        const types = getTypes();
        const file = await markdownToHtml(this.text, types);
        this.host.shadowRoot.querySelector('#root').innerHTML =
            file === null || file === void 0 ? void 0 : file.toString();
    }
    render() {
        return h("div", { key: 'a26da8feaabfd7d048c1413770ee5e7cef07c711', id: "root" });
    }
    get host() { return getElement(this); }
};
Markdown.style = markdownCss;

export { Markdown as kompendium_markdown };
//# sourceMappingURL=kompendium-markdown.entry.js.map
