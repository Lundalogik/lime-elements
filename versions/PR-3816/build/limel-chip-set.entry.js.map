{"version":3,"names":["handleKeyboardEvent","event","this","textValue","length","_a","value","isArrowLeft","key","ARROW_LEFT","isArrowRight","ARROW_RIGHT","isEnter","ENTER","isDelete","DELETE","isBackspace","BACKSPACE","isEscape","ESCAPE","handleLeft","handleRight","handleEnter","handleDelete","handleBackspace","handleEscape","host","preventDefault","inputChipIndexSelected","emitInteraction","removeChip","repeat","id","chipSetCss","ChipSet","constructor","hostRef","handleKeyDown","renderContent","type","renderInputChips","map","renderChip","getValue","chip","Object","assign","selected","selectedChipIds","includes","floatLabelAbove","editMode","readonly","hasHelperText","helperText","undefined","renderHelperLine","maxItems","h","maxLength","invalid","isInvalid","catchInputChipClicks","Lime","isSelectableChip","updateSelectedChipIds","change","emit","handleRemoveChip","detail","identifier","newValue","filter","clearAllChipsLabel","translate","get","language","labelId","createRandomString","bind","renderInputChip","isFull","handleTextFieldFocus","handleInputBlur","handleTextInput","inputFieldOnChange","inputHidden","handleDeleteAllIconClick","renderDelimiter","connectedCallback","initialize","async","emptyInput","disabled","shadowRoot","querySelector","focus","startEdit","syncEmptyInput","componentDidLoad","triggerIconColorWarning","mdcTextField","MDCTextField","componentDidUpdate","input","disconnectedCallback","destroy","render","classes","leadingIcon","clearAllButton","label","required","hasValue","hasLeadingIcon","hasFloatingLabel","slot","getContentProps","class","onClick","role","handleChangeChips","oldValue","isEqual","tabIndex","inputType","hidden","onBlur","onFocus","onKeyDown","onInput","onChange","placeholder","searchLabel","autocomplete","renderLeadingIcon","renderClearAllChipsButton","blurred","stopPropagation","emptyInputOnBlur","setTimeout","stopEdit","target","trim","interact","chipType","chipProps","getChipProps","index","chips","isLastChip","removable","text","icon","image","badge","loading","menuItems","onRemove","href","link","getHref","getTarget","updateChoiceTypeSelectedIds","updateFilterTypeSelectedIds","isChipSelected","removeChipIdFromSelectedChipIds","addChipIdToSelectedChipIds","chipId","name","tabindex","title","delimiter","iconFillColor","iconBackgroundColor","iconTitle","console","warn"],"sources":["./src/components/chip-set/chip-set-input-helpers.ts","./src/components/chip-set/chip-set.scss?tag=limel-chip-set&encapsulation=shadow","./src/components/chip-set/chip-set.tsx"],"sourcesContent":["import {\n    ARROW_LEFT,\n    ARROW_RIGHT,\n    BACKSPACE,\n    DELETE,\n    ENTER,\n    ESCAPE,\n} from '../../util/keycodes';\n\n/**\n * Key handler for the input field.\n * Lets the user select, activate, and remove chips with the keyboard.\n *\n * @param event - event\n \n */\nexport function handleKeyboardEvent(event: KeyboardEvent) {\n    if (this.textValue.length > 0) {\n        // If there is any text in the input field, keyboard input should\n        // navigate the text, not the chips.\n        return;\n    }\n\n    if (!this.value?.length) {\n        // If there are no chips, there is nothing to select.\n        return;\n    }\n\n    const isArrowLeft = event.key === ARROW_LEFT;\n    const isArrowRight = event.key === ARROW_RIGHT;\n    const isEnter = event.key === ENTER;\n    const isDelete = event.key === DELETE;\n    const isBackspace = event.key === BACKSPACE;\n    const isEscape = event.key === ESCAPE;\n\n    if (isArrowLeft) {\n        return handleLeft(this, event);\n    }\n\n    if (isArrowRight) {\n        return handleRight(this, event);\n    }\n\n    if (isEnter) {\n        return handleEnter(this, event);\n    }\n\n    if (isDelete) {\n        return handleDelete(this, event);\n    }\n\n    if (isBackspace) {\n        return handleBackspace(this, event);\n    }\n\n    if (isEscape) {\n        return handleEscape(this, event);\n    }\n}\n\nfunction handleLeft(host, event) {\n    event.preventDefault();\n    if (host.inputChipIndexSelected === null) {\n        host.inputChipIndexSelected = host.value.length - 1;\n\n        return;\n    }\n\n    if (host.inputChipIndexSelected <= 0) {\n        return;\n    }\n\n    host.inputChipIndexSelected -= 1;\n}\n\nfunction handleRight(host, event) {\n    event.preventDefault();\n    if (host.inputChipIndexSelected === null) {\n        host.inputChipIndexSelected = 0;\n\n        return;\n    }\n\n    if (host.inputChipIndexSelected >= host.value.length - 1) {\n        return;\n    }\n\n    host.inputChipIndexSelected += 1;\n}\n\nfunction handleEnter(host, event) {\n    if (host.inputChipIndexSelected !== null) {\n        event.preventDefault();\n        host.emitInteraction(host.value[host.inputChipIndexSelected]);\n    }\n}\n\nfunction handleEscape(host, event) {\n    if (host.inputChipIndexSelected !== null) {\n        event.preventDefault();\n        host.inputChipIndexSelected = null;\n    }\n}\n\nfunction handleDelete(host, event) {\n    if (host.inputChipIndexSelected !== null) {\n        event.preventDefault();\n        removeChip(host);\n    }\n}\n\nfunction handleBackspace(host, event) {\n    if (host.inputChipIndexSelected !== null) {\n        event.preventDefault();\n        removeChip(host);\n    } else if (!event.repeat) {\n        host.inputChipIndexSelected = host.value.length - 1;\n    }\n}\n\nfunction removeChip(host) {\n    if (host.inputChipIndexSelected !== null) {\n        host.removeChip(host.value[host.inputChipIndexSelected].id);\n        host.inputChipIndexSelected = null;\n    }\n}\n","@use '../../style/functions';\n@use '../../style/internal/shared_input-select-picker';\n@use '../../style/mixins';\n\n@use '@material/textfield';\n@use '@material/textfield/icon';\n\n/**\n * @prop --icon-background-color: Background color of the icon. Defaults to transparent.\n * @prop --icon-color: Color of the icon. Defaults to `rgb(var(--contrast-1100))`.\n * @prop --background-color: Background color of the field when type is set to input.\n * @prop --background-color-disabled: Background color of the field when type is set to input and the component is disabled or readonly.\n * @prop --input-chip-set-selected-chip-color: Color of the highlight around selected chips in input chip-sets.\n */\n\n@include textfield.core-styles;\n@include icon.icon-core-styles;\n\n@include shared_input-select-picker.leading-icon;\n\n$height-of-chip-set-input: functions.pxToRem(36);\n$leading-icon-space: 1.5rem;\n\n:host(limel-chip-set) {\n    isolation: isolate;\n}\n\n:host(limel-chip-set[type='input']) {\n    limel-notched-outline {\n        [slot='content'] {\n            min-height: shared_input-select-picker.$height-of-mdc-text-field;\n        }\n    }\n}\n\n:host(limel-chip-set:not([type='input'])) {\n    .limel-notched-outline {\n        --limel-notched-outline-border-color: transparent;\n        --limel-notched-outline-background-color: transparent;\n    }\n}\n\n.mdc-chip-set {\n    display: flex;\n    flex-wrap: wrap;\n    align-items: center;\n    gap: 0.5rem;\n    min-height: shared_input-select-picker.$height-of-mdc-text-field;\n    position: relative;\n\n    &.mdc-chip-set--input {\n        padding: 0.4rem 0.5rem;\n        width: 100%;\n    }\n\n    &.has-clear-all-button {\n        &.mdc-chip-set--input {\n            padding-right: functions.pxToRem(\n                32\n            ); // This leaves space for \"clear all\" button and avoids overlapping with chips\n        }\n    }\n}\n\n.mdc-text-field__input {\n    .mdc-text-field:not(.mdc-text-field--disabled) & {\n        color: shared_input-select-picker.$input-text-color;\n        font-size: var(--limel-theme-default-font-size) !important;\n        font-family: inherit !important;\n    }\n    .mdc-text-field.mdc-text-field--disabled & {\n        color: shared_input-select-picker.$input-text-color-disabled;\n    }\n}\n\n.mdc-text-field {\n    height: auto;\n    cursor: text;\n    flex-wrap: wrap;\n    row-gap: 0.5rem;\n\n    .mdc-text-field__input {\n        @include shared_input-select-picker.input-field-placeholder;\n\n        width: auto;\n        padding: 0 0.5rem;\n\n        flex-grow: 1;\n        flex-shrink: 0;\n\n        &.hidden {\n            // This class is added, as soon as there is a chip selected and displayed\n            // This input field should not be visually visible as it breaks the UI in some cases\n            // But it should be rendered to be able to tab between fields and do other keyboard commands /Kia\n            transition: all 0s;\n            opacity: 0;\n            position: absolute;\n            z-index: -100; // to let users interact with chips, in case they're covered\n        }\n        &[type='search'] {\n            -webkit-appearance: textfield; // Removes the default magnifying glass icon on iOS which appears automatically on input fields with type of search\n            background-color: transparent; // overides styles caused by previous line\n\n            &::-webkit-search-cancel-button {\n                display: none; // removes the default X button\n            }\n        }\n    }\n}\n\n.clear-all-button {\n    @include mixins.clear-all-button;\n    @include mixins.visualize-keyboard-focus;\n\n    position: absolute;\n    right: 0.5rem;\n    top: calc(#{shared_input-select-picker.$height-of-mdc-text-field} / 4);\n\n    opacity: 0; // Is hidden, but can receive focus (such as when navigating through tab indexes).\n\n    &:focus,\n    .has-chips:not(.disabled):hover &,\n    .has-chips:not(.disabled).mdc-text-field--focused & {\n        opacity: 1;\n        outline: none;\n    }\n\n    .mdc-chip-set:not(.has-chips) &,\n    .has-chips.disabled & {\n        display: none; // Won't receive focus when disabled\n    }\n}\n\n.has-leading-icon {\n    &:not(.has-chips) {\n        .mdc-text-field__input {\n            padding-left: $leading-icon-space;\n        }\n    }\n\n    limel-chip {\n        &:first-of-type {\n            margin-left: 1.5rem;\n        }\n    }\n\n    .search-icon {\n        transition: transform 0.2s ease;\n        position: absolute;\n        top: functions.pxToRem(9);\n        left: 0.25rem;\n    }\n\n    limel-icon {\n        background-color: transparent;\n    }\n}\n\n.delimiter {\n    opacity: 0.5;\n    padding: 0 functions.pxToRem(2);\n    color: var(--limel-theme-on-surface-color);\n}\n\nlimel-chip {\n    border-radius: 2rem;\n\n    &.can-be-removed {\n        // When chip is selected with keyboard (backspace / arrow-keys) to be deleted\n        box-shadow: var(--shadow-depth-8-error);\n    }\n}\n\n@import './partial-styles/_readonly';\n@import './partial-styles/_helper-text';\n","import { Chip, ChipType } from '../chip-set/chip.types';\nimport { Languages } from '../date-picker/date.types';\nimport { MDCTextField } from '@material/textfield';\nimport {\n    Component,\n    Element,\n    Event,\n    EventEmitter,\n    h,\n    Method,\n    Prop,\n    State,\n    Watch,\n} from '@stencil/core';\nimport { handleKeyboardEvent } from './chip-set-input-helpers';\nimport translate from '../../global/translations';\nimport { getHref, getTarget } from '../../util/link-helper';\nimport { isEqual } from 'lodash-es';\nimport { LimelChipCustomEvent } from '../../components';\nimport { createRandomString } from '../../util/random-string';\n\n/**\n * :::note\n * **Regarding `click` and `interact` events:**\n *\n * The `interact` event is emitted when a chip is interacted with, and is\n * the recommended way to listen for chip interactions.\n *\n * However, if you need to handle clicks differently depending on which chip\n * was clicked, or whether the click was on a chip or elsewhere, you need to\n * listen to the native `click` event instead.\n *\n * Native `click` events are passed through, and if the click came from\n * a chip, the chip object is available in the event object under\n * `<event object>.Lime.chip`.\n *\n * Example usage:\n * ```ts\n * private handleClick(event: Event) {\n *     if (event && 'Lime' in event && (event.Lime as any).chip) {\n *         if ((event.Lime as { chip: Chip }).chip.href) {\n *             // Chip has href, so let the browser open the link.\n *             return;\n *         }\n *         // handle click on chip without href\n *     } else {\n *         // handle click elsewhere\n *     }\n * }\n * ```\n * :::\n *\n * @exampleComponent limel-example-chip-set\n * @exampleComponent limel-example-chip-set-choice\n * @exampleComponent limel-example-chip-set-filter\n * @exampleComponent limel-example-chip-set-filter-badge\n * @exampleComponent limel-example-chip-set-input\n * @exampleComponent limel-example-chip-set-input-type-with-menu-items\n * @exampleComponent limel-example-chip-set-input-type-text\n * @exampleComponent limel-example-chip-set-input-type-search\n * @exampleComponent limel-example-chip-icon-color\n * @exampleComponent limel-example-chip-set-image\n * @exampleComponent limel-example-chip-set-composite\n */\n@Component({\n    tag: 'limel-chip-set',\n    shadow: { delegatesFocus: true },\n    styleUrl: 'chip-set.scss',\n})\nexport class ChipSet {\n    /**\n     * List of chips for the set\n     */\n    @Prop()\n    public value: Chip[] = [];\n\n    /**\n     * Type of chip set\n     *\n     * - `choice` renders a set of selectable chips where only one is selectable. The `removable` property is ignored\n     * - `filter` renders a set of selectable chips where all are selectable.\n     * - `input` renders a set of chips that can be used in conjunction with an input field\n     *\n     * If no type is set, a basic set of chips without additional functionality will be rendered\n     */\n    @Prop({ reflect: true })\n    public type?: 'choice' | 'filter' | 'input';\n\n    /**\n     * Label for the chip-set\n     */\n    @Prop({ reflect: true })\n    public label: string;\n\n    /**\n     * Optional helper text to display below the chipset.\n     * When type is `input`, the helper text is displayed below the\n     * input field when it has focus.\n     * When type is not `input`, the helper text is always displayed\n     * if the device is touch screen; otherwise it is shown when chip-set\n     * is hovered or focused using keyboard navigation.\n     */\n    @Prop({ reflect: true })\n    public helperText: string;\n\n    /**\n     * True if the chip set should be disabled\n     */\n    @Prop({ reflect: true })\n    public disabled: boolean = false;\n\n    /**\n     * For chip-sets of type `input`, set to `true` to disable adding and\n     * removing chips, but allow interaction with existing chips in the set.\n     * For any other types, setting either `readonly` or `disabled` disables\n     * the chip-set.\n     */\n    @Prop({ reflect: true })\n    public readonly: boolean = false;\n\n    /**\n     * Set to `true` to indicate that the current value of the input field is\n     * invalid.\n     */\n    @Prop({ reflect: true })\n    public invalid = false;\n\n    /**\n     * For chip-sets of type `input`. Value to use for the `type` attribute on the\n     * input field inside the chip-set.\n     */\n    @Prop({ reflect: true })\n    public inputType: 'search' | 'text' = 'text';\n\n    /**\n     * For chip-sets of type `input`. Limits the maximum number of chips.\n     * When the value is `0` or not set, no limit is applied.\n     */\n    @Prop({ reflect: true })\n    public maxItems: number;\n\n    /**\n     * True if the control requires a value\n     */\n    @Prop({ reflect: true })\n    public required: boolean = false;\n\n    /**\n     * Search label to display when type is `input` and component is in search mode\n     */\n    @Prop({ reflect: true })\n    public searchLabel: string;\n\n    /**\n     * Whether the input field should be emptied when the chip-set loses focus.\n     */\n    @Prop({ reflect: true })\n    public emptyInputOnBlur: boolean = true;\n\n    /**\n     * Whether the \"Clear all\" buttons should be shown\n     */\n    @Prop()\n    public clearAllButton: boolean = true;\n\n    /**\n     * For chip-sets of type `input`. When the value is null, no leading icon is used.\n     * Leading icon to show to the far left in the text field\n     */\n    @Prop({ reflect: true })\n    public leadingIcon: string = null;\n\n    /**\n     * For chip-set of type `input`. Sets delimiters between chips.\n     */\n    @Prop({ reflect: true })\n    public delimiter: string = null;\n\n    /**\n     * For chip-set of type `input`, defines whether the input field should have autocomplete enabled.\n     * Read more about the `autocomplete` attribute\n     * [here](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete).\n     */\n    @Prop({ reflect: true })\n    public autocomplete: string = 'off';\n\n    /**\n     * Defines the language for translations.\n     * Will translate the translatable strings on the components. For example, the clear all chips label.\n     */\n    @Prop()\n    public language: Languages = 'en';\n\n    /**\n     * Dispatched when a chip is interacted with\n     */\n    @Event()\n    private readonly interact: EventEmitter<Chip>;\n\n    /**\n     * Dispatched when a chip is selected/deselected\n     */\n    @Event()\n    private readonly change: EventEmitter<Chip | Chip[]>;\n\n    /**\n     * Emitted when an input chip set has received focus and editing in the text field has started\n     */\n    @Event()\n    private readonly startEdit: EventEmitter<void>;\n\n    /**\n     * Emitted when an input chip set has lost focus and editing in the text field has ended\n     */\n    @Event()\n    private readonly stopEdit: EventEmitter<void>;\n\n    /**\n     * Dispatched when the input is changed for type `input`\n     */\n    @Event()\n    private readonly input: EventEmitter<string>;\n\n    @Element()\n    private readonly host: HTMLLimelChipSetElement;\n\n    @State()\n    private editMode: boolean = false;\n\n    @State()\n    private textValue: string = '';\n\n    @State()\n    private blurred: boolean = false;\n\n    @State()\n    private inputChipIndexSelected: number = null;\n\n    @State()\n    private selectedChipIds: Array<string | number>;\n\n    private mdcTextField: MDCTextField;\n    private readonly handleKeyDown = handleKeyboardEvent;\n    private labelId: string;\n\n    constructor() {\n        this.labelId = createRandomString();\n        this.renderChip = this.renderChip.bind(this);\n        this.renderInputChip = this.renderInputChip.bind(this);\n        this.isFull = this.isFull.bind(this);\n        this.handleTextFieldFocus = this.handleTextFieldFocus.bind(this);\n        this.handleInputBlur = this.handleInputBlur.bind(this);\n        this.handleTextInput = this.handleTextInput.bind(this);\n        this.inputFieldOnChange = this.inputFieldOnChange.bind(this);\n        this.handleKeyDown = this.handleKeyDown.bind(this);\n        this.inputHidden = this.inputHidden.bind(this);\n        this.handleDeleteAllIconClick =\n            this.handleDeleteAllIconClick.bind(this);\n        this.renderDelimiter = this.renderDelimiter.bind(this);\n    }\n\n    public connectedCallback() {\n        this.initialize();\n    }\n\n    private initialize() {\n        if (this.value.length > 0) {\n            this.selectedChipIds = this.value\n                .filter((chip) => chip.selected)\n                .map((chip) => chip.id);\n        }\n    }\n\n    /**\n     * Used to find out whether the chip-set is in edit mode.\n     *\n     * @returns `true` if the chip-set is in edit mode, `false` otherwise.\n     */\n    @Method()\n    public async getEditMode(): Promise<boolean> {\n        return this.editMode;\n    }\n\n    /**\n     * Used to set focus to the chip-set input field.\n     *\n     * @param emptyInput - if `true`, any text in the input is discarded\n     * @returns does not return anything, but methods have to be async\n     */\n    @Method()\n    public async setFocus(emptyInput: boolean = false) {\n        if (this.disabled || this.readonly) {\n            return;\n        }\n\n        this.editMode = true;\n        if (emptyInput) {\n            this.textValue = '';\n        }\n\n        this.host.shadowRoot.querySelector('input').focus();\n        this.startEdit.emit();\n    }\n\n    /**\n     * Used to empty the input field. Used in conjunction with `emptyInputOnBlur` to let the\n     * consumer control when the input is emptied.\n     *\n     * @returns does not return anything, but methods have to be async\n     */\n    @Method()\n    public async emptyInput() {\n        this.syncEmptyInput();\n    }\n\n    public componentDidLoad() {\n        this.triggerIconColorWarning(this.value);\n\n        if (this.type === 'input') {\n            this.mdcTextField = new MDCTextField(\n                this.host.shadowRoot.querySelector('.mdc-text-field')\n            );\n        }\n    }\n\n    public componentDidUpdate() {\n        const input = this.host.shadowRoot.querySelector('input');\n        if (input && this.editMode) {\n            input.focus();\n        }\n    }\n\n    public disconnectedCallback() {\n        if (this.mdcTextField) {\n            this.mdcTextField.destroy();\n        }\n    }\n\n    public render() {\n        const classes = {\n            'mdc-chip-set': true,\n            'mdc-text-field--with-trailing-icon': true,\n            disabled: this.disabled || this.readonly,\n        };\n\n        if (this.type) {\n            classes[`mdc-chip-set--${this.type}`] = true;\n        }\n\n        if (this.type === 'input') {\n            Object.assign(classes, {\n                'mdc-text-field': true,\n                'mdc-text-field--outlined': true,\n                'mdc-chip-set--input': true,\n                'lime-text-field--readonly': this.readonly,\n                'has-chips': this.value.length > 0,\n                'has-leading-icon': this.leadingIcon !== null,\n                'has-clear-all-button': this.clearAllButton,\n            });\n        }\n\n        const value = this.getValue();\n\n        return [\n            <limel-notched-outline\n                labelId={this.labelId}\n                label={this.label}\n                required={this.required}\n                invalid={this.invalid || this.isInvalid()}\n                disabled={this.disabled}\n                readonly={this.readonly}\n                hasValue={!!this.value?.length}\n                hasLeadingIcon={!!this.leadingIcon}\n                hasFloatingLabel={this.floatLabelAbove()}\n            >\n                <div slot=\"content\" {...this.getContentProps()} class={classes}>\n                    {this.renderContent(value)}\n                </div>\n            </limel-notched-outline>,\n            this.renderHelperLine(),\n        ];\n    }\n\n    private getContentProps() {\n        if (this.type === 'input') {\n            return {\n                onClick: this.handleTextFieldFocus,\n            };\n        }\n\n        return {\n            role: 'grid',\n        };\n    }\n\n    private renderContent = (value: Chip[]) => {\n        if (this.type === 'input') {\n            return this.renderInputChips();\n        }\n\n        return value.map(this.renderChip);\n    };\n\n    private readonly getValue = () => {\n        return this.value.map((chip) => ({\n            ...chip,\n            ...(this.type && {\n                selected: this.selectedChipIds.includes(chip.id),\n            }),\n        }));\n    };\n\n    @Watch('value')\n    protected handleChangeChips(newValue: Chip[], oldValue: Chip[]) {\n        if (isEqual(newValue, oldValue)) {\n            return;\n        }\n\n        this.syncEmptyInput();\n        this.initialize();\n    }\n\n    private renderInputChips() {\n        return [\n            this.value.map(this.renderInputChip),\n            <input\n                tabIndex={this.disabled || this.readonly ? -1 : 0}\n                type={this.inputType}\n                id={this.labelId}\n                disabled={this.readonly || this.disabled}\n                class={{\n                    'mdc-text-field__input': true,\n                    hidden: this.inputHidden(),\n                }}\n                value={this.textValue}\n                onBlur={this.handleInputBlur}\n                onFocus={this.handleTextFieldFocus}\n                onKeyDown={this.handleKeyDown}\n                onInput={this.handleTextInput}\n                // Some browsers emit a change event on input elements, we need to stop\n                // that event from propagating since we are emitting our own change event\n                onChange={this.inputFieldOnChange}\n                placeholder={this.isFull() ? '' : this.searchLabel}\n                readonly={this.isFull()}\n                autocomplete={this.autocomplete}\n            />,\n            this.renderLeadingIcon(),\n            this.renderClearAllChipsButton(),\n        ];\n    }\n\n    private readonly floatLabelAbove = () => {\n        if (\n            this.value.length > 0 ||\n            this.editMode ||\n            this.readonly ||\n            this.textValue\n        ) {\n            return true;\n        }\n    };\n\n    private isFull(): boolean {\n        return !!this.maxItems && this.value.length >= this.maxItems;\n    }\n\n    private isInvalid() {\n        if (this.readonly) {\n            // A readonly field can never be invalid.\n            return false;\n        }\n\n        if (this.invalid) {\n            return true;\n        }\n\n        if (!this.required) {\n            return false;\n        }\n\n        if (!this.blurred) {\n            return false;\n        }\n\n        return !this.value?.length;\n    }\n\n    private inputFieldOnChange(event) {\n        event.stopPropagation();\n    }\n\n    /**\n     * Enter edit mode when the text field receives focus. When editMode is true, the input element will be visible\n     */\n    private handleTextFieldFocus() {\n        if (this.disabled || this.readonly) {\n            return;\n        }\n\n        if (this.editMode) {\n            return;\n        }\n\n        this.editMode = true;\n        this.startEdit.emit();\n    }\n\n    /**\n     * Exit edit mode when the input element loses focus. This makes sure the input element does not take up any\n     * additional space when the user it not typing anything\n     */\n    private handleInputBlur() {\n        if (this.emptyInputOnBlur) {\n            this.syncEmptyInput();\n        }\n\n        this.editMode = false;\n        this.blurred = true;\n        this.inputChipIndexSelected = null;\n\n        // This timeout is needed in order to let a new element receive focus\n        setTimeout(() => {\n            this.stopEdit.emit();\n        }, 0);\n    }\n\n    private syncEmptyInput() {\n        this.textValue = '';\n    }\n\n    private inputHidden() {\n        if (this.editMode) {\n            return this.isFull();\n        }\n\n        // If there are chips in the picker, hide the input to avoid the input\n        // being placed on a new line and adding ugly space beneath the chips.\n        // If there are no chips, show the input, or the picker will look weird.\n        return !!this.value?.length;\n    }\n\n    private handleTextInput(event) {\n        event.stopPropagation();\n        this.inputChipIndexSelected = null;\n        this.textValue = event.target.value;\n        this.input.emit(event.target.value?.trim());\n    }\n\n    private emitInteraction(chip: Chip) {\n        this.interact.emit(chip);\n    }\n\n    private renderChip(chip: Chip) {\n        const chipType: ChipType =\n            this.type === 'filter' ? 'filter' : 'default';\n\n        const chipProps = this.getChipProps(chip, chipType);\n\n        return <limel-chip {...chipProps} />;\n    }\n\n    private readonly hasHelperText = () => {\n        return this.helperText !== null && this.helperText !== undefined;\n    };\n\n    private readonly renderHelperLine = () => {\n        const maxItems = this.maxItems === 1 ? undefined : this.maxItems;\n\n        if (!maxItems && !this.hasHelperText()) {\n            return;\n        }\n\n        return (\n            <limel-helper-line\n                length={this.value.length}\n                maxLength={maxItems}\n                helperText={this.helperText}\n                invalid={this.isInvalid()}\n            />\n        );\n    };\n\n    private renderInputChip(chip: Chip, index: number, chips: Chip[]) {\n        const chipProps = this.getChipProps(chip, 'default');\n        const isLastChip = index === chips.length - 1;\n\n        return [\n            <limel-chip\n                key={chip.id}\n                class={{\n                    'can-be-removed': this.inputChipIndexSelected === index,\n                }}\n                {...chipProps}\n            />,\n            !(isLastChip && this.inputHidden()) && this.renderDelimiter(),\n        ];\n    }\n\n    private getChipProps(chip: Chip, chipType: ChipType) {\n        const removable =\n            this.type === 'input' && chip.removable && !this.readonly;\n        const readonly = this.readonly && this.type !== 'input';\n\n        return {\n            role: 'row',\n            identifier: chip.id,\n            text: chip.text,\n            icon: chip.icon,\n            image: chip.image,\n            badge: chip.badge,\n            selected: chip.selected,\n            disabled: this.disabled,\n            loading: chip.loading,\n            readonly: readonly,\n            type: chipType,\n            removable: removable,\n            menuItems: chip.menuItems,\n            onClick: this.catchInputChipClicks(chip),\n            onRemove: this.handleRemoveChip,\n            ...(chip.href && {\n                link: {\n                    href: getHref(chip.href),\n                    target: getTarget(chip.href),\n                },\n            }),\n        };\n    }\n\n    private readonly catchInputChipClicks = (chip: Chip) => (event: Event) => {\n        /*\n         * We need to add the `chip` to the event object so that the consumer\n         * can get the chip object when the chip is clicked.\n         * This is necessary for the consumer to be able to handle the click\n         * event itself, based on which chip was clicked, or whether the click\n         * was on a chip or elsewhere. The reason the consumer can't just look\n         * at the event target is that that information is hidden by the\n         * shadow DOM.\n         *\n         * See documentation for the `interact` event for more information.\n         */\n        (event as any).Lime = { chip: chip };\n\n        if (this.isSelectableChip(chip)) {\n            this.updateSelectedChipIds(chip);\n            this.change.emit(chip);\n        }\n\n        this.emitInteraction(chip);\n    };\n\n    private isSelectableChip(chip: Chip): boolean {\n        return this.type !== 'input' && 'selected' in chip;\n    }\n\n    private updateSelectedChipIds(chip: Chip): void {\n        chip.selected = !chip.selected;\n        const id = chip.id;\n        if (this.type === 'choice') {\n            this.updateChoiceTypeSelectedIds(id);\n        } else {\n            this.updateFilterTypeSelectedIds(id);\n        }\n    }\n\n    private updateChoiceTypeSelectedIds(id: number | string): void {\n        this.selectedChipIds = this.isChipSelected(id) ? [] : [id];\n    }\n\n    private isChipSelected(id: number | string): boolean {\n        return this.selectedChipIds.includes(id);\n    }\n\n    private updateFilterTypeSelectedIds(id: number | string): void {\n        if (this.isChipSelected(id)) {\n            this.removeChipIdFromSelectedChipIds(id);\n        } else {\n            this.addChipIdToSelectedChipIds(id);\n        }\n    }\n\n    private removeChipIdFromSelectedChipIds(id: number | string): void {\n        this.selectedChipIds = this.selectedChipIds.filter(\n            (chipId) => chipId !== id\n        );\n    }\n\n    private addChipIdToSelectedChipIds(id: number | string): void {\n        this.selectedChipIds = [...this.selectedChipIds, id];\n    }\n\n    private readonly handleRemoveChip = (\n        event: LimelChipCustomEvent<string | number>\n    ) => {\n        this.removeChip(event.detail);\n    };\n\n    private readonly removeChip = (identifier: string | number) => {\n        const newValue = this.value.filter((chip) => {\n            return chip.id !== identifier;\n        });\n        this.change.emit(newValue);\n    };\n\n    private renderLeadingIcon() {\n        if (!this.leadingIcon) {\n            return;\n        }\n\n        return (\n            <i class=\"mdc-text-field__icon search-icon\">\n                <limel-icon name={this.leadingIcon} />\n            </i>\n        );\n    }\n\n    private renderClearAllChipsButton() {\n        if (this.disabled || this.readonly || !this.clearAllButton) {\n            return;\n        }\n\n        return (\n            <a\n                href=\"\"\n                onClick={this.handleDeleteAllIconClick}\n                class=\"mdc-text-field__icon clear-all-button\"\n                tabindex=\"0\"\n                role=\"button\"\n                title={this.clearAllChipsLabel()}\n                aria-label={this.clearAllChipsLabel()}\n            />\n        );\n    }\n\n    private readonly clearAllChipsLabel = (): string => {\n        return translate.get('chip-set.clear-all', this.language);\n    };\n\n    private handleDeleteAllIconClick(event: Event) {\n        event.preventDefault();\n        this.change.emit([]);\n    }\n\n    private renderDelimiter() {\n        if (!this.delimiter) {\n            return;\n        }\n\n        return <div class=\"delimiter\">{this.delimiter}</div>;\n    }\n\n    private triggerIconColorWarning(value: Chip[]) {\n        for (const chip of value) {\n            if (\n                chip.icon &&\n                (chip.iconFillColor ||\n                    chip.iconBackgroundColor ||\n                    chip.iconTitle)\n            ) {\n                console.warn(\n                    \"The `iconFillColor`, `iconBackgroundColor`, and `iconTitle` props are deprecated now! Use the new `Icon` interface and instead of `iconColor: 'color-name', `iconBackgroundColor: 'color-name', and `iconTitle: 'title'`, write `icon { name: 'icon-name', color: 'color-name', backgroundColor: 'color-name', title: 'title' }`.\"\n                );\n            }\n        }\n    }\n}\n"],"mappings":"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"}