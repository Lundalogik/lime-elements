{"version":3,"names":["checkboxCss","Checkbox","this","shouldReinitialize","id","createRandomString","helperTextId","destroyMDCInstances","input","getCheckboxElement","dataset","indeterminate","isInvalid","invalid","required","modified","checked","initialize","_b","_a","limelCheckbox","shadowRoot","querySelector","onChange","event","stopPropagation","currentTarget","isChecked","change","emit","handleCheckedChange","newValue","handleIndeterminateChange","handleReadonlyChange","componentDidRender","connectedCallback","componentDidLoad","disconnectedCallback","render","h","CheckboxTemplate","disabled","readonly","label","readonlyLabels","helperText","dynamicLabelCss","DynamicLabel","labels","find","l","value","renderIcon","icon","defaultLabel","renderLabel","text","iconName","getIconName","iconColor","iconBackgroundColor","color","backgroundColor","iconProps","role","name","style","Object","assign"],"sources":["./src/components/checkbox/checkbox.scss?tag=limel-checkbox&encapsulation=shadow","./src/components/checkbox/checkbox.tsx","./src/components/dynamic-label/dynamic-label.scss?tag=limel-dynamic-label&encapsulation=shadow","./src/components/dynamic-label/dynamic-label.tsx"],"sourcesContent":["/**\n* :::important\n* The `CheckboxTemplate` can be imported and used in the HTML of\n* other components, to render a non-functional and decorative checkbox in\n* their UI. An example of this is the list component.\n* This means the content of `CheckboxTemplate` will become a part of the\n* consumer's DOM structure.\n*\n* Additionally, the consumer components' also need to import the current `.scss`\n* file into their own styles file, for the checkbox to be rendered correctly!\n* This means, if the styles in this file are not \"specific\" enough,\n* there is a risk that the consumer component's styles are affected by\n* our styles here.\n*\n* For instance if the consumer has a `<label>` or `<svg>` element,\n* it might unintentionally inherit styles from the checkbox; unless we\n* make the such styles more specific here.\n*\n* Naturally, we cannot mitigate all sorts of potential styling problems.\n* The consumer component should be aware of this issue too.\n* But we can ensure that our styles here both make sense,\n* are readable, and are as specific as possible to avoid unintended side effects.\n* :::\n*/\n\n@use '../../style/mixins';\n\n/**\n* @prop --checkbox-unchecked-border-color: Affects the border color of the default state of the checkbox (when it is not checked). Defaults to `--contrast-900`.\n*/\n\n@forward '../../style/internal/boolean-input.scss';\n\n:host(limel-checkbox) {\n    min-height: var(--limel-checkbox-min-height, 2.5rem); // prevents flickering\n    // when switching between `readonly` and normal states in `limel-checkbox`,\n    // but not where `CheckboxTemplate` is imported & used.\n}\n\n.box {\n    &:after {\n        height: 0.125rem;\n        width: 0.25rem;\n\n        .indeterminate & {\n            opacity: 1;\n            width: calc(var(--limel-boolean-input-box-size) - 0.5rem);\n        }\n    }\n}\n\n.checkbox {\n    --limel-boolean-input-box-border-radius: 0.25rem;\n\n    svg.check-mark {\n        position: absolute;\n        z-index: 1;\n        inset: 0;\n\n        transform: translate3d(-0.125rem, -0.125rem, 0);\n\n        width: var(--limel-boolean-input-box-size);\n        height: var(--limel-boolean-input-box-size);\n\n        padding: 0.25rem;\n\n        color: rgb(var(--color-white));\n        opacity: 0;\n\n        stroke-width: 0.1875rem; // 3px\n        stroke: currentColor;\n        stroke-linecap: round;\n        stroke-linejoin: round;\n\n        path {\n            stroke-dashoffset: 29.7833;\n            stroke-dasharray: 29.7833;\n            transition: stroke-dashoffset 180ms cubic-bezier(0.4, 0, 0.6, 1);\n        }\n    }\n\n    /*\n     * Safari (macOS & iOS, tested on Safari 26) & probably even earlier versions have a\n     * rendering bug where transitions on descendants whose end state is triggered\n     * ONLY via a parent selector using `:has()` may not animate. Instead, Safari\n     * sometimes jumps directly to the final state (or never paints the transition)\n     * until a subsequent layout invalidation (e.g. tab switch, resize) happens.\n     *\n     * Workaround: provide an equivalent selector that does NOT rely on `:has()`,\n     * using the adjacency between the input and the visual box. This ensures the\n     * `stroke-dashoffset` transition for the check mark runs reliably in Safari\n     * while keeping the simpler `:has()` version commented for future re-implementation\n     * or cleanup.\n     *\n     * &:not(.indeterminate):has(input[type='checkbox']:checked) {\n     *     svg.check-mark {\n     *         opacity: 1;\n     *         path {\n     *             stroke-dashoffset: 0;\n     *         }\n     *     }\n     * }\n     * Using the `:has()` selector is more reliable, because it doesn't\n     * depend on the DOM structure (e.g. if the markup changes and the input is\n     * no longer adjacent to the box), but Safari support for `:has()` is still\n     * somewhat inconsistent.\n     */\n\n    &:not(.indeterminate)\n        > input[type='checkbox']:checked\n        + .box\n        svg.check-mark {\n        opacity: 1;\n\n        path {\n            stroke-dashoffset: 0;\n        }\n    }\n}\n\nlimel-dynamic-label {\n    margin-top: 0.375rem;\n    margin-left: -0.25rem;\n}\n\n@include mixins.hide-helper-line-when-not-needed(limel-checkbox);\n","import {\n    Component,\n    Element,\n    Event,\n    EventEmitter,\n    h,\n    Prop,\n    State,\n    Watch,\n} from '@stencil/core';\nimport { createRandomString } from '../../util/random-string';\nimport { CheckboxTemplate } from './checkbox.template';\nimport { Label } from '../dynamic-label/label.types';\n\n/**\n * The Checkbox component is a classic and essential element in UI design that allows\n * users to make multiple selections from a predefined list of options. The Checkbox component is commonly used in forms and settings interfaces to enable users to\n * select one or more items from a list of choices.\n *\n * ## States of a Checkbox\n * When a user clicks or taps on the box, it toggles between two states:\n * Checked and Unchecked.\n *\n * However, a Checkbox can visualize a third state called the \"Indeterminate\" state.\n * In this state, the checkbox appears as a filled box with a horizontal line or dash inside it.\n *\n * The Indeterminate state is typically used when dealing with checkbox groups\n * that have hierarchical relationships or when the group contains sub-items.\n * This state is used to indicate that that some, but not all, of the items in a group are selected.\n *\n * :::important\n * Checkboxes are sometimes used interchangeably with switches in user interfaces.\n * But there is an important difference between the two! Please read our guidelines about\n * [Switch vs. Checkbox](/#/DesignGuidelines/switch-vs-checkbox.md/).\n *\n * @exampleComponent limel-example-checkbox\n * @exampleComponent limel-example-checkbox-helper-text\n * @exampleComponent limel-example-checkbox-readonly\n */\n@Component({\n    tag: 'limel-checkbox',\n    shadow: true,\n    styleUrl: 'checkbox.scss',\n})\nexport class Checkbox {\n    /**\n     * Disables the checkbox when `true`. Works exactly the same as `readonly`.\n     * If either property is `true`, the checkbox will be disabled.\n     */\n    @Prop({ reflect: true })\n    public disabled = false;\n\n    /**\n     * Disables the checkbox when `true`. This visualizes the checkbox slightly differently.\n     * But shows no visual sign indicating that the checkbox is disabled\n     * or can ever become interactable.\n     */\n    @Prop({ reflect: true })\n    public readonly = false;\n\n    /**\n     * Set to `true` to indicate that the current value is invalid.\n     */\n    @Prop({ reflect: true })\n    public invalid: boolean;\n\n    /**\n     * The checkbox label.\n     */\n    @Prop({ reflect: true })\n    public label: string;\n\n    /**\n     * Optional helper text to display below the checkbox\n     */\n    @Prop({ reflect: true })\n    public helperText: string;\n\n    /**\n     * The value of the checkbox. Set to `true` to make the checkbox checked.\n     */\n    @Prop({ reflect: true })\n    public checked = false;\n\n    /**\n     * Enables indeterminate state. Set to `true` to signal indeterminate check.\n     */\n    @Prop({ reflect: true })\n    public indeterminate = false;\n\n    /**\n     * Set to `true` to indicate that the checkbox must be checked.\n     */\n    @Prop({ reflect: true })\n    public required: boolean = false;\n\n    /**\n     * The labels to use to clarify what kind of data is being visualized,\n     * when the component is `readonly`.\n     */\n    @Prop()\n    public readonlyLabels?: Array<Label<boolean>> = [];\n\n    @State()\n    private modified = false;\n    private shouldReinitialize = false;\n\n    /**\n     * Emitted when the input value is changed.\n     */\n    @Event()\n    private change: EventEmitter<boolean>;\n\n    @Element()\n    private limelCheckbox: HTMLLimelCheckboxElement;\n    private id: string = createRandomString();\n    private helperTextId: string = createRandomString();\n\n    @Watch('checked')\n    protected handleCheckedChange(newValue: boolean) {\n        const input = this.getCheckboxElement();\n        if (!input) {\n            return;\n        }\n\n        input.checked = newValue || this.indeterminate;\n    }\n\n    @Watch('indeterminate')\n    protected handleIndeterminateChange(newValue: boolean) {\n        const input = this.getCheckboxElement();\n        if (!input) {\n            return;\n        }\n\n        input.checked = this.checked || newValue;\n        input.indeterminate = newValue;\n    }\n\n    @Watch('readonly')\n    protected handleReadonlyChange() {\n        this.destroyMDCInstances();\n        this.shouldReinitialize = true;\n    }\n\n    componentDidRender() {\n        if (this.shouldReinitialize) {\n            this.initialize();\n            this.shouldReinitialize = false;\n        }\n    }\n\n    public connectedCallback() {\n        this.initialize();\n    }\n\n    public componentDidLoad() {\n        this.initialize();\n    }\n\n    private destroyMDCInstances = () => {\n        const input = this.getCheckboxElement();\n        if (input) {\n            delete input.dataset['indeterminate'];\n            input.indeterminate = false;\n        }\n    };\n\n    public disconnectedCallback() {\n        this.destroyMDCInstances();\n    }\n\n    public render() {\n        return (\n            <CheckboxTemplate\n                disabled={this.disabled || this.readonly}\n                label={this.label}\n                readonlyLabels={this.readonlyLabels}\n                helperText={this.helperText}\n                helperTextId={this.helperTextId}\n                checked={this.checked || this.indeterminate}\n                indeterminate={this.indeterminate}\n                required={this.required}\n                readonly={this.readonly}\n                invalid={this.isInvalid()}\n                onChange={this.onChange}\n                id={this.id}\n            />\n        );\n    }\n\n    private isInvalid = () => {\n        if (this.invalid) {\n            return true;\n        }\n\n        if (this.required && this.modified && !this.checked) {\n            return true;\n        }\n    };\n\n    private initialize = () => {\n        const input = this.getCheckboxElement();\n        if (!input) {\n            return;\n        }\n\n        input.indeterminate = this.indeterminate;\n        input.checked = this.checked || this.indeterminate;\n    };\n\n    private getCheckboxElement = (): HTMLInputElement | null => {\n        return (\n            this.limelCheckbox?.shadowRoot?.querySelector(\n                'input[type=\"checkbox\"]'\n            ) || null\n        );\n    };\n\n    private onChange = (event: Event) => {\n        event.stopPropagation();\n        const input = event.currentTarget as HTMLInputElement;\n        const isChecked = input?.checked ?? this.checked;\n        this.change.emit(isChecked);\n        this.modified = true;\n    };\n}\n","* {\n    box-sizing: border-box;\n    min-width: 0;\n}\n\n:host(limel-dynamic-label) {\n    --limel-dynamic-label-min-height: 1.75rem;\n    display: flex;\n    gap: 0.25rem;\n    align-items: flex-start;\n    border-radius: 0.5rem;\n    min-width: 0;\n}\n\nlimel-icon {\n    --limel-icon-svg-margin: 0.125rem;\n    border-radius: 0.25rem;\n    flex-shrink: 0;\n    width: var(--limel-dynamic-label-min-height);\n    color: rgb(\n        var(--contrast-900)\n    ); // The default `false` color. Will be overwritten by `Icon`\n}\n\nlabel {\n    flex-grow: 1;\n    font-size: var(\n        --limel-theme-default-small-font-size\n    ); // `13px`, Like Checkbox & Switch\n    line-height: normal;\n    color: var(--limel-theme-on-surface-color);\n    padding-top: 0.375rem;\n}\n","import { getIconName } from '../icon/get-icon-props';\nimport { Component, Prop, h } from '@stencil/core';\nimport { Label, LabelValue } from './label.types';\nimport { Icon } from '../../interface';\n\n/**\n * This components displays a different label depending on the current given\n * value. A label can consist of a text and an optional icon. If no matching\n * label is found among the given `labels`, the `defaultLabel` will be displayed.\n *\n * One use case of the component is to enhance the visualization of a `boolean`\n * field like a checkbox or switch in a `readonly` state.\n *\n * The reason we offer this component is that the default styling\n * of the Checkbox or Toggle switch in the `readonly` state may not always\n * provide the best way of _visualizing information_, potentially leading to\n * confusion and negatively affecting the end-users' experience.\n *\n * @exampleComponent limel-example-dynamic-label\n * @exampleComponent limel-example-dynamic-label-readonly-boolean\n */\n@Component({\n    tag: 'limel-dynamic-label',\n    shadow: true,\n    styleUrl: 'dynamic-label.scss',\n})\nexport class DynamicLabel {\n    /**\n     * The current value of the component which is used to match with the given\n     * `labels` to determine what label to display.\n     *\n     * If not matching label is found, the `defaultLabel` is displayed.\n     */\n    @Prop()\n    public value: LabelValue;\n\n    /**\n     * The label to display when no matching value is found in the `labels`\n     * array. This is a fallback label that ensures there's always a label\n     * displayed for the component.\n     */\n    @Prop({ reflect: true })\n    public defaultLabel: Omit<Label, 'value'> = {};\n\n    /**\n     * A list of available labels. Each label has a corresponding value that\n     * will be matched with the current `value` of the component to determine\n     * what label to display.\n     */\n    @Prop()\n    public labels: Label[] = [];\n\n    public render() {\n        const label = this.labels.find((l) => l.value === this.value);\n\n        return [\n            this.renderIcon(label?.icon ?? this.defaultLabel.icon),\n            this.renderLabel(label?.text ?? this.defaultLabel.text),\n        ];\n    }\n\n    private renderIcon(icon?: string | Icon) {\n        const iconName = getIconName(icon);\n        if (!iconName) {\n            return;\n        }\n\n        let iconColor: string | undefined;\n        let iconBackgroundColor: string | undefined;\n\n        if (typeof icon === 'object') {\n            iconColor = icon.color;\n            iconBackgroundColor = icon.backgroundColor;\n        }\n\n        const iconProps = {\n            role: 'presentation',\n            name: iconName,\n            style: {\n                color: iconColor,\n                'background-color': iconBackgroundColor,\n            },\n        };\n\n        return <limel-icon {...iconProps} />;\n    }\n\n    private renderLabel(label: string = '') {\n        return <label>{label}</label>;\n    }\n}\n"],"mappings":"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"}