{"version":3,"names":["chartCss","PERCENT","DEFAULT_INCREMENT_SIZE","Chart","this","handleClick","event","item","getClickableItem","currentTarget","stopPropagation","interact","emit","handleKeyDown","key","preventDefault","Set","componentWillLoad","recalculateRangeData","render","loading","h","limeBranded","Host","style","items","length","toString","renderCaption","renderTableHeader","renderAxises","class","renderItems","renderLegend","accessibleLabel","scope","accessibleItemsLabel","translate","get","language","includes","type","minValue","maxValue","range","lines","adjustedMinRange","Math","floor","axisIncrement","adjustedMaxRange","ceil","value","push","role","label","_a","cumulativeOffset","filter","hiddenItems","has","text","map","index","itemId","createRandomString","sizeAndOffset","calculateSizeAndOffset","size","offset","getItemStyle","getItemClass","id","tabIndex","clickable","onClick","onKeyDown","getItemText","getFormattedValue","renderTooltip","hasColoredItems","some","color","allColorsSame","every","orientation","onLegendClick","handleLegendClick","detail","updatedHiddenItems","delete","add","nextItem","Array","isArray","getMaximumValue","isRangeItem","totalRange","startValue","getMinimumValue","normalizedStart","normalizedEnd","formattedValue","PERCENT_DECIMAL","tooltipProps","helperLabel","elementId","toFixed","Object","assign","openDirection","calculateRange","visibleItems","itemsForCalculation","minRange","min","maxRange","max","totalSum","reduce","sum","finalMaxRange","calculateAxisIncrement","visualMaxValue","visualMinValue","steps","roughStep","magnitude","log10","handleChange","target","dataset","undefined","Number","legendCss","Legend","legendClick","isHidden","cursor","opacity","marginRight"],"sources":["./src/components/chart/chart.scss?tag=limel-chart&encapsulation=shadow","./src/components/chart/chart.tsx","./src/components/chart/legend.scss?tag=limel-legend&encapsulation=shadow","./src/components/chart/legend.tsx"],"sourcesContent":["@use '../../style/mixins';\n$min-item-size: 0.5rem;\n$default-item-color: var(--chart-item-color, rgb(var(--contrast-1100), 0.8));\n\n/**\n* @prop --chart-background-color: Defines the background color of the chart. Defaults to `transparent` for _most_ chart types.\n* @prop --chart-item-color: If no color is defined for chart items, this color will be use. Defaults to `rgb(var(--contrast-1100), 0.8)`.\n* @prop --chart-item-divider-color: Defines the color that visually separates items in some charts, such as `stacked-bar` chart items. Defaults to `rgb(var(--color-white), 0.6)`.\n* @prop --chart-axis-line-color: Defines color of the axis lines. Defaults to `--contrast-900`. Note that lines have opacity as well, and get opaque on hover.\n* @prop --chart-item-border-radius: Defines the roundness of corners of items in a chart. Defaults to different values depending on the chart type. Does not have any effect on `pie` and `doughnut` types.\n*/\n\n:host(limel-chart) {\n    --chart-axis-line-color: var(\n        --limel-chart-axis-line-color,\n        rgb(var(--contrast-900))\n    );\n    box-sizing: border-box;\n    isolation: isolate;\n\n    display: flex;\n    flex-direction: column;\n    gap: 0.5rem;\n    width: 100%;\n    height: 100%;\n    min-width: 0;\n    min-height: 0;\n    padding: var(--limel-chart-padding);\n}\n\ntable {\n    // Since these are mainly \"resets\", no styles should be before them.\n    all: unset;\n    border-collapse: collapse;\n    border-spacing: 0;\n    empty-cells: show;\n\n    position: relative;\n    display: flex;\n    width: 100%;\n    height: 100%;\n    min-width: 0;\n    min-height: 0;\n\n    colgroup,\n    thead,\n    tbody,\n    tr,\n    th,\n    td {\n        all: unset;\n    }\n\n    caption,\n    colgroup,\n    thead,\n    tfoot,\n    th,\n    td {\n        @include mixins.visually-hidden;\n    }\n}\n\n*,\n*:before,\n*:after {\n    box-sizing: border-box;\n}\n\n.chart {\n    position: relative;\n    flex-grow: 1;\n    width: 100%;\n    height: 100%;\n    min-height: 0;\n    min-width: 0;\n\n    &:has(.item:hover),\n    &:has(.item:focus-visible) {\n        .item {\n            opacity: 0.4;\n        }\n    }\n}\n\n.item {\n    @include mixins.visualize-keyboard-focus;\n    transition:\n        background-color 0.2s ease,\n        box-shadow 0.2s ease,\n        filter 0.2s ease,\n        opacity 0.4s ease;\n    cursor: help;\n\n    &:focus-visible,\n    &:hover {\n        opacity: 1 !important;\n    }\n\n    &[role='button'] {\n        cursor: pointer;\n    }\n}\n\nlimel-spinner {\n    margin: auto;\n}\n\n@mixin line(\n    $direction: vertical,\n    $color: rgb(var(--contrast-800), 0.4),\n    $position: center\n) {\n    @if $direction == vertical {\n        background: linear-gradient(to bottom, $color 0%, $color 100%)\n            $position/1px\n            100%\n            no-repeat;\n    } @else if $direction == horizontal {\n        background: linear-gradient(to right, $color 0%, $color 100%)\n            $position/100%\n            1px\n            no-repeat;\n    }\n}\n\n@import './partial-styles/_layout-for-charts-with-x-y-axises';\n@import './partial-styles/_layout-for-charts-with-circular-shape';\n@import './partial-styles/_bar-gantt-dot';\n@import './partial-styles/_area_line';\n@import './partial-styles/_pie-doughnut';\n@import './partial-styles/_ring';\n@import './partial-styles/_stacked-bar';\n@import './partial-styles/_nps';\n@import './partial-styles/_axises';\n","import {\n    Component,\n    Event,\n    EventEmitter,\n    h,\n    Host,\n    Prop,\n    State,\n    Watch,\n} from '@stencil/core';\nimport { Languages } from '../date-picker/date.types';\nimport translate from '../../global/translations';\nimport { createRandomString } from '../../util/random-string';\nimport { ChartItem } from './chart.types';\n\nconst PERCENT = 100;\nconst DEFAULT_INCREMENT_SIZE = 10;\n\n/**\n * A chart is a graphical representation of data, in which\n * visual symbols such as such bars, dots, lines, or slices, represent\n * each data point, in comparison to others.\n *\n * @exampleComponent limel-example-chart-stacked-bar\n * @exampleComponent limel-example-chart-orientation\n * @exampleComponent limel-example-chart-max-value\n * @exampleComponent limel-example-chart-type-bar\n * @exampleComponent limel-example-chart-type-dot\n * @exampleComponent limel-example-chart-type-area\n * @exampleComponent limel-example-chart-type-line\n * @exampleComponent limel-example-chart-type-pie\n * @exampleComponent limel-example-chart-type-doughnut\n * @exampleComponent limel-example-chart-type-ring\n * @exampleComponent limel-example-chart-type-gantt\n * @exampleComponent limel-example-chart-type-nps\n * @exampleComponent limel-example-chart-multi-axis\n * @exampleComponent limel-example-chart-multi-axis-with-negative-start-values\n * @exampleComponent limel-example-chart-multi-axis-area-with-negative-start-values\n * @exampleComponent limel-example-chart-axis-increment\n * @exampleComponent limel-example-chart-clickable-items\n * @exampleComponent limel-example-chart-accessibility\n * @exampleComponent limel-example-chart-styling\n * @exampleComponent limel-example-chart-creative-styling\n * @beta\n */\n\n@Component({\n    tag: 'limel-chart',\n    shadow: true,\n    styleUrl: 'chart.scss',\n})\nexport class Chart {\n    /**\n     * Defines the language for translations.\n     * Will translate the translatable strings on the components.\n     */\n    @Prop({ reflect: true })\n    public language: Languages = 'en';\n\n    /**\n     * Helps users of assistive technologies to understand\n     * the context of the chart, and what is being displayed.\n     */\n    @Prop({ reflect: true })\n    public accessibleLabel?: string;\n\n    /**\n     * Helps users of assistive technologies to understand\n     * what the items in the chart represent.\n     */\n    @Prop({ reflect: true })\n    public accessibleItemsLabel?: string;\n\n    /**\n     * List of items in the chart,\n     * each representing a data point.\n     */\n    @Prop()\n    public items!: ChartItem[];\n\n    /**\n     * Defines how items are visualized in the chart.\n     */\n    @Prop({ reflect: true })\n    public type?:\n        | 'area'\n        | 'bar'\n        | 'doughnut'\n        | 'line'\n        | 'nps'\n        | 'pie'\n        | 'ring'\n        | 'dot'\n        | 'stacked-bar' = 'stacked-bar';\n\n    /**\n     * Defines whether the chart is intended to be displayed wide or tall.\n     * Does not have any effect on chart types which generate circular forms.\n     */\n    @Prop({ reflect: true })\n    public orientation?: 'landscape' | 'portrait' = 'landscape';\n\n    /**\n     * Specifies the range that items' values could be in.\n     * This is used in calculation of the size of the items in the chart.\n     * When not provided, the sum of all values in the items will be considered as the range.\n     */\n    @Prop({ reflect: true })\n    public maxValue?: number;\n\n    /**\n     * Specifies the increment for the axis lines.\n     */\n    @Prop({ reflect: true })\n    public axisIncrement?: number;\n\n    /**\n     * Indicates whether the chart is in a loading state.\n     */\n    @Prop({ reflect: true })\n    public loading: boolean = false;\n\n    private range: {\n        minValue: number;\n        maxValue: number;\n        totalRange: number;\n    };\n\n    @State()\n    private hiddenItems: Set<string> = new Set();\n\n    /**\n     * Fired when a chart item with `clickable` set to `true` is clicked\n     */\n    @Event()\n    public interact: EventEmitter<ChartItem>;\n\n    public componentWillLoad() {\n        this.recalculateRangeData();\n    }\n\n    public render() {\n        if (this.loading) {\n            return <limel-spinner limeBranded={false} />;\n        }\n\n        return (\n            <Host\n            // class={{\n            //     'has-orientation-portrait': this.orientation === 'portrait',\n            // }}\n            >\n                <table\n                    aria-busy={this.loading ? 'true' : 'false'}\n                    aria-live=\"polite\"\n                    style={{\n                        '--limel-chart-number-of-items':\n                            this.items.length.toString(),\n                    }}\n                >\n                    {this.renderCaption()}\n                    {this.renderTableHeader()}\n                    {this.renderAxises()}\n                    <tbody class=\"chart\">{this.renderItems()}</tbody>\n                </table>\n                {this.renderLegend(this.items)}\n            </Host>\n        );\n    }\n\n    private renderCaption() {\n        if (!this.accessibleLabel) {\n            return;\n        }\n\n        return <caption>{this.accessibleLabel}</caption>;\n    }\n\n    private renderTableHeader() {\n        return (\n            <thead>\n                <tr>\n                    <th scope=\"col\">{this.accessibleItemsLabel}</th>\n                    <th scope=\"col\">{translate.get('value', this.language)}</th>\n                </tr>\n            </thead>\n        );\n    }\n\n    private renderAxises() {\n        if (!['bar', 'dot', 'area', 'line'].includes(this.type)) {\n            return;\n        }\n\n        const { minValue, maxValue } = this.range;\n        const lines = [];\n        const adjustedMinRange =\n            Math.floor(minValue / this.axisIncrement) * this.axisIncrement;\n        const adjustedMaxRange =\n            Math.ceil(maxValue / this.axisIncrement) * this.axisIncrement;\n\n        for (\n            let value = adjustedMinRange;\n            value <= adjustedMaxRange;\n            value += this.axisIncrement\n        ) {\n            lines.push(\n                <div\n                    class={{\n                        'axis-line': true,\n                        'zero-line': value === 0,\n                    }}\n                    role=\"presentation\"\n                >\n                    <limel-badge label={value} />\n                </div>\n            );\n        }\n\n        return (\n            <div class=\"axises\" role=\"presentation\">\n                {lines}\n            </div>\n        );\n    }\n\n    private renderItems() {\n        if (!this.items?.length) {\n            return;\n        }\n\n        let cumulativeOffset = 0;\n\n        return this.items\n            .filter((item) => !this.hiddenItems.has(item.text))\n            .map((item, index) => {\n                const itemId = createRandomString();\n                const sizeAndOffset = this.calculateSizeAndOffset(item);\n                const size = sizeAndOffset.size;\n                let offset = sizeAndOffset.offset;\n\n                if (this.type === 'pie' || this.type === 'doughnut') {\n                    offset = cumulativeOffset;\n                    cumulativeOffset += size;\n                }\n\n                return (\n                    <tr\n                        style={this.getItemStyle(item, index, size, offset)}\n                        class={this.getItemClass(item)}\n                        key={itemId}\n                        id={itemId}\n                        data-index={index}\n                        tabIndex={0}\n                        role={item.clickable ? 'button' : null}\n                        onClick={this.handleClick}\n                        onKeyDown={this.handleKeyDown}\n                    >\n                        <th>{this.getItemText(item)}</th>\n                        <td>{this.getFormattedValue(item)}</td>\n                        {this.renderTooltip(item, itemId, size)}\n                    </tr>\n                );\n            });\n    }\n\n    private renderLegend(items: ChartItem[]) {\n        // Only render legend if at least one item has a color\n        const hasColoredItems = items.some((item) => item.color);\n\n        // Check if all colors are the same (no need for legend if they are)\n        const allColorsSame =\n            items.length > 1 &&\n            items.every((item) => item.color === items[0].color);\n\n        if (\n            !hasColoredItems ||\n            this.orientation === 'portrait' ||\n            allColorsSame\n        ) {\n            return;\n        }\n\n        return (\n            <limel-legend\n                items={items}\n                hiddenItems={this.hiddenItems}\n                getItemText={this.getItemText}\n                onLegendClick={(event: CustomEvent<ChartItem>) =>\n                    this.handleLegendClick(event.detail)\n                }\n            />\n        );\n    }\n\n    private handleLegendClick(item: ChartItem) {\n        const updatedHiddenItems = new Set(this.hiddenItems);\n        if (updatedHiddenItems.has(item.text)) {\n            updatedHiddenItems.delete(item.text);\n        } else {\n            updatedHiddenItems.add(item.text);\n        }\n        this.hiddenItems = updatedHiddenItems;\n        this.range = null;\n        this.recalculateRangeData();\n    }\n\n    private getItemStyle(\n        item: ChartItem,\n        index: number,\n        size: number,\n        offset: number\n    ): Record<string, string> {\n        const style: Record<string, string> = {\n            '--limel-chart-item-offset': `${offset}`,\n            '--limel-chart-item-size': `${size}`,\n            '--limel-chart-item-index': `${index}`,\n            '--limel-chart-item-value': `${item.value}`,\n        };\n\n        if (item.color) {\n            style['--limel-chart-item-color'] = item.color;\n        }\n\n        if (this.type === 'line' || this.type === 'area') {\n            const nextItem = this.calculateSizeAndOffset(this.items[index + 1]);\n\n            style['--limel-chart-next-item-size'] = `${nextItem.size}`;\n            style['--limel-chart-next-item-offset'] = `${nextItem.offset}`;\n        }\n\n        return style;\n    }\n\n    private getItemClass(item: ChartItem) {\n        return {\n            item: true,\n            'has-start-value': Array.isArray(item.value),\n            'has-negative-value-only':\n                this.getMaximumValue(item) < 0 && !this.isRangeItem(item),\n        };\n    }\n\n    private calculateSizeAndOffset(item?: ChartItem) {\n        const { minValue, totalRange } = this.range;\n        if (!item) {\n            return {\n                size: 0,\n                offset: 0,\n            };\n        }\n\n        let startValue = 0;\n        if (this.isRangeItem(item)) {\n            startValue = this.getMinimumValue(item);\n        }\n\n        const normalizedStart =\n            ((startValue - minValue) / totalRange) * PERCENT;\n        const normalizedEnd =\n            ((this.getMaximumValue(item) - minValue) / totalRange) * PERCENT;\n\n        return {\n            size: normalizedEnd - normalizedStart,\n            offset: normalizedStart,\n        };\n    }\n\n    private getFormattedValue(item: ChartItem): string {\n        const { value, formattedValue } = item;\n\n        if (formattedValue) {\n            return formattedValue;\n        }\n\n        if (Array.isArray(value)) {\n            return `${value[0]} — ${value[1]}`;\n        }\n\n        return `${value}`;\n    }\n\n    private getItemText(item: ChartItem): string {\n        return item.text;\n    }\n\n    private renderTooltip(item: ChartItem, itemId: string, size: number) {\n        const text = this.getItemText(item);\n        const PERCENT_DECIMAL = 2;\n        const formattedValue = this.getFormattedValue(item);\n\n        const tooltipProps: any = {\n            label: text,\n            helperLabel: formattedValue,\n            elementId: itemId,\n        };\n\n        if (this.type !== 'bar' && this.type !== 'dot' && this.type !== 'nps') {\n            tooltipProps.label = `${text} (${size.toFixed(PERCENT_DECIMAL)}%)`;\n        }\n\n        return (\n            <limel-tooltip\n                {...tooltipProps}\n                openDirection={\n                    this.orientation === 'portrait' ? 'right' : 'top'\n                }\n            />\n        );\n    }\n\n    private calculateRange() {\n        if (this.range) {\n            return this.range;\n        }\n\n        // Use only visible items for range calculation\n        const visibleItems = this.items.filter(\n            (item) => !this.hiddenItems.has(item.text)\n        );\n        const itemsForCalculation =\n            visibleItems.length > 0 ? visibleItems : this.items;\n\n        const minRange = Math.min(\n            0,\n            ...itemsForCalculation.map(this.getMinimumValue)\n        );\n        const maxRange = Math.max(\n            ...itemsForCalculation.map(this.getMaximumValue)\n        );\n        const totalSum = itemsForCalculation.reduce(\n            (sum, item) => sum + this.getMaximumValue(item),\n            0\n        );\n\n        let finalMaxRange = this.maxValue ?? maxRange;\n        if (\n            (this.type === 'pie' || this.type === 'doughnut') &&\n            !this.maxValue\n        ) {\n            finalMaxRange = totalSum;\n        }\n\n        if (!this.axisIncrement) {\n            this.axisIncrement =\n                this.calculateAxisIncrement(itemsForCalculation);\n        }\n\n        const visualMaxValue =\n            Math.ceil(finalMaxRange / this.axisIncrement) * this.axisIncrement;\n        const visualMinValue =\n            Math.floor(minRange / this.axisIncrement) * this.axisIncrement;\n        const totalRange = visualMaxValue - visualMinValue;\n\n        return {\n            minValue: visualMinValue,\n            maxValue: visualMaxValue,\n            totalRange: totalRange,\n        };\n    }\n\n    private calculateAxisIncrement(\n        items: ChartItem[],\n        steps: number = DEFAULT_INCREMENT_SIZE\n    ) {\n        const maxValue = Math.max(\n            ...items.map((item) => {\n                const value = item.value;\n                if (Array.isArray(value)) {\n                    return Math.max(...value);\n                }\n\n                return value;\n            })\n        );\n\n        const roughStep = maxValue / steps;\n\n        const magnitude = 10 ** Math.floor(Math.log10(roughStep));\n\n        return Math.ceil(roughStep / magnitude) * magnitude;\n    }\n\n    private getMinimumValue(item: ChartItem): number {\n        const value = item.value;\n\n        return Array.isArray(value) ? Math.min(...value) : value;\n    }\n\n    private getMaximumValue(item: ChartItem): number {\n        const value = item.value;\n\n        return Array.isArray(value) ? Math.max(...value) : value;\n    }\n\n    private isRangeItem(item: ChartItem): item is ChartItem<[number, number]> {\n        return Array.isArray(item.value);\n    }\n\n    @Watch('items')\n    @Watch('axisIncrement')\n    @Watch('maxValue')\n    handleChange() {\n        this.range = null;\n        this.recalculateRangeData();\n    }\n\n    private recalculateRangeData() {\n        this.range = this.calculateRange();\n    }\n\n    private getClickableItem(target: HTMLElement): ChartItem | undefined {\n        const index = target.dataset.index;\n        if (index === undefined) {\n            return;\n        }\n\n        const item = this.items[Number(index)];\n        if (!item.clickable) {\n            return;\n        }\n\n        return item;\n    }\n\n    private readonly handleClick = (event: MouseEvent) => {\n        const item = this.getClickableItem(event.currentTarget as HTMLElement);\n        if (!item) {\n            return;\n        }\n\n        event.stopPropagation();\n        this.interact.emit(item);\n    };\n\n    private readonly handleKeyDown = (event: KeyboardEvent) => {\n        if (event.key !== 'Enter' && event.key !== ' ') {\n            return;\n        }\n\n        const item = this.getClickableItem(event.currentTarget as HTMLElement);\n        if (!item) {\n            return;\n        }\n\n        event.preventDefault();\n        this.interact.emit(item);\n    };\n}\n","@use '../../style/mixins';\n\n.legend {\n    display: flex;\n    align-self: center;\n    max-width: 80%;\n    font-size: small;\n\n    background-color: rgb(var(--contrast-500));\n    border-radius: 0.5rem;\n    padding: 0.5rem;\n\n    .legend-content {\n        display: flex;\n        width: 100%;\n        overflow-x: auto;\n        gap: 1rem;\n\n        @include mixins.fade-out-overflowed-content-on-edges(horizontally);\n    }\n}\n\n.legend-item {\n    display: flex;\n    align-items: center;\n    gap: 0.25rem;\n    cursor: pointer;\n    user-select: none;\n    white-space: nowrap; // Prevent text wrapping\n    flex-shrink: 0; // Prevent items from shrinking\n\n    &--hidden {\n        opacity: 0.5;\n    }\n\n    limel-badge {\n        transition:\n            opacity 0.2s,\n            filter 0.2s;\n    }\n\n    &:hover limel-badge {\n        filter: brightness(1.2);\n    }\n}\n\n//     // Change to column layout when chart has portrait orientation\n//     :host(.has-orientation-portrait) & {\n//         flex-direction: column;\n//         overflow-x: visible;\n//         overflow-y: auto;\n//         height: 100%;\n//         max-height: 200px; // Limit height for vertical scrolling\n\n//         // Remove horizontal fade and add vertical fade\n//         -webkit-mask-image: none;\n//         mask-image: none;\n//         padding-left: 0;\n//         padding-right: 0;\n\n//         @include mixins.fade-out-overflowed-content-on-edges(vertically);\n//     }\n// }\n\n// // Change to row layout when chart has portrait orientation\n// :host(.has-orientation-portrait) & {\n//     flex-direction: row;\n//     max-width: 100%;\n//     max-height: 250px; // Limit height in portrait mode\n//     align-self: stretch; // Take full width in portrait\n// }\n","import { Component, h, Prop, Event, EventEmitter } from '@stencil/core';\nimport type { ChartItem } from './chart.types';\n\n@Component({\n    tag: 'limel-legend',\n    shadow: true,\n    styleUrl: 'legend.scss',\n})\nexport class Legend {\n    @Prop() items: ChartItem[];\n    @Prop() hiddenItems: Set<string>;\n    @Prop() getItemText: (item: ChartItem) => string = (item) => item.text;\n\n    @Event() legendClick: EventEmitter<ChartItem>;\n\n    private handleLegendClick = (item: ChartItem) => {\n        this.legendClick.emit(item);\n    };\n\n    render() {\n        return (\n            <div class=\"legend\">\n                <div class=\"legend-content\">\n                    {this.items.map((item) => {\n                        const isHidden = this.hiddenItems?.has(item.text);\n                        return (\n                            <div\n                                class={{\n                                    'legend-item': true,\n                                    'legend-item--hidden': isHidden,\n                                }}\n                                key={item.text}\n                                onClick={() => this.handleLegendClick(item)}\n                            >\n                                <limel-badge\n                                    style={{\n                                        '--badge-background-color': item.color,\n                                        cursor: 'pointer',\n                                        opacity: isHidden ? '0.6' : '1',\n                                    }}\n                                />\n                                <span\n                                    style={{\n                                        opacity: isHidden ? '0.6' : '1',\n                                        marginRight: '0.5em',\n                                    }}\n                                >\n                                    {this.getItemText(item)}\n                                </span>\n                                <span\n                                    style={{\n                                        opacity: isHidden ? '0.6' : '1',\n                                    }}\n                                >\n                                    {Array.isArray(item.value)\n                                        ? `${item.value[0]} — ${item.value[1]}`\n                                        : item.value}\n                                </span>\n                            </div>\n                        );\n                    })}\n                </div>\n            </div>\n        );\n    }\n}\n"],"mappings":"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"}