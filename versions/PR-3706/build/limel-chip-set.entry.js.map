{"version":3,"names":["handleKeyboardEvent","event","this","textValue","length","_a","value","isArrowLeft","key","ARROW_LEFT","isArrowRight","ARROW_RIGHT","isEnter","ENTER","isDelete","DELETE","isBackspace","BACKSPACE","isEscape","ESCAPE","handleLeft","handleRight","handleEnter","handleDelete","handleBackspace","handleEscape","host","preventDefault","inputChipIndexSelected","emitInteraction","removeChip","repeat","id","chipSetCss","INPUT_FIELD_TABINDEX","ChipSet","constructor","hostRef","handleKeyDown","renderContent","type","renderInputChips","map","renderChip","getValue","chip","Object","assign","selected","selectedChipIds","includes","floatLabelAbove","editMode","readonly","hasHelperText","helperText","undefined","renderHelperLine","maxItems","h","maxLength","invalid","isInvalid","catchInputChipClicks","Lime","isSelectableChip","updateSelectedChipIds","change","emit","handleRemoveChip","detail","identifier","newValue","filter","clearAllChipsLabel","translate","get","language","labelId","createRandomString","bind","renderInputChip","isFull","handleTextFieldFocus","handleInputBlur","handleTextInput","inputFieldOnChange","inputHidden","handleDeleteAllIconClick","renderDelimiter","connectedCallback","initialize","async","emptyInput","disabled","shadowRoot","querySelector","focus","startEdit","syncEmptyInput","componentDidLoad","triggerIconColorWarning","mdcTextField","MDCTextField","componentDidUpdate","input","disconnectedCallback","destroy","render","classes","leadingIcon","clearAllButton","label","required","hasValue","hasLeadingIcon","hasFloatingLabel","slot","getContentProps","class","onClick","role","handleChangeChips","oldValue","isEqual","tabIndex","inputType","hidden","onBlur","onFocus","onKeyDown","onInput","onChange","placeholder","searchLabel","autocomplete","renderLeadingIcon","renderClearAllChipsButton","blurred","stopPropagation","emptyInputOnBlur","setTimeout","stopEdit","target","trim","interact","chipType","chipProps","getChipProps","index","chips","isLastChip","removable","text","icon","image","badge","loading","menuItems","onRemove","href","link","getHref","getTarget","updateChoiceTypeSelectedIds","updateFilterTypeSelectedIds","isChipSelected","removeChipIdFromSelectedChipIds","addChipIdToSelectedChipIds","chipId","name","tabindex","title","delimiter","iconFillColor","iconBackgroundColor","iconTitle","console","warn"],"sources":["./src/components/chip-set/chip-set-input-helpers.ts","./src/components/chip-set/chip-set.scss?tag=limel-chip-set&encapsulation=shadow","./src/components/chip-set/chip-set.tsx"],"sourcesContent":["import {\n    ARROW_LEFT,\n    ARROW_RIGHT,\n    BACKSPACE,\n    DELETE,\n    ENTER,\n    ESCAPE,\n} from '../../util/keycodes';\n\n/**\n * Key handler for the input field.\n * Lets the user select, activate, and remove chips with the keyboard.\n *\n * @param event - event\n \n */\nexport function handleKeyboardEvent(event: KeyboardEvent) {\n    if (this.textValue.length > 0) {\n        // If there is any text in the input field, keyboard input should\n        // navigate the text, not the chips.\n        return;\n    }\n\n    if (!this.value?.length) {\n        // If there are no chips, there is nothing to select.\n        return;\n    }\n\n    const isArrowLeft = event.key === ARROW_LEFT;\n    const isArrowRight = event.key === ARROW_RIGHT;\n    const isEnter = event.key === ENTER;\n    const isDelete = event.key === DELETE;\n    const isBackspace = event.key === BACKSPACE;\n    const isEscape = event.key === ESCAPE;\n\n    if (isArrowLeft) {\n        return handleLeft(this, event);\n    }\n\n    if (isArrowRight) {\n        return handleRight(this, event);\n    }\n\n    if (isEnter) {\n        return handleEnter(this, event);\n    }\n\n    if (isDelete) {\n        return handleDelete(this, event);\n    }\n\n    if (isBackspace) {\n        return handleBackspace(this, event);\n    }\n\n    if (isEscape) {\n        return handleEscape(this, event);\n    }\n}\n\nfunction handleLeft(host, event) {\n    event.preventDefault();\n    if (host.inputChipIndexSelected === null) {\n        host.inputChipIndexSelected = host.value.length - 1;\n\n        return;\n    }\n\n    if (host.inputChipIndexSelected <= 0) {\n        return;\n    }\n\n    host.inputChipIndexSelected -= 1;\n}\n\nfunction handleRight(host, event) {\n    event.preventDefault();\n    if (host.inputChipIndexSelected === null) {\n        host.inputChipIndexSelected = 0;\n\n        return;\n    }\n\n    if (host.inputChipIndexSelected >= host.value.length - 1) {\n        return;\n    }\n\n    host.inputChipIndexSelected += 1;\n}\n\nfunction handleEnter(host, event) {\n    if (host.inputChipIndexSelected !== null) {\n        event.preventDefault();\n        host.emitInteraction(host.value[host.inputChipIndexSelected]);\n    }\n}\n\nfunction handleEscape(host, event) {\n    if (host.inputChipIndexSelected !== null) {\n        event.preventDefault();\n        host.inputChipIndexSelected = null;\n    }\n}\n\nfunction handleDelete(host, event) {\n    if (host.inputChipIndexSelected !== null) {\n        event.preventDefault();\n        removeChip(host);\n    }\n}\n\nfunction handleBackspace(host, event) {\n    if (host.inputChipIndexSelected !== null) {\n        event.preventDefault();\n        removeChip(host);\n    } else if (!event.repeat) {\n        host.inputChipIndexSelected = host.value.length - 1;\n    }\n}\n\nfunction removeChip(host) {\n    if (host.inputChipIndexSelected !== null) {\n        host.removeChip(host.value[host.inputChipIndexSelected].id);\n        host.inputChipIndexSelected = null;\n    }\n}\n","@use '../../style/functions';\n@use '../../style/internal/shared_input-select-picker';\n@use '../../style/mixins';\n\n@use '@material/textfield';\n@use '@material/textfield/icon';\n\n/**\n * @prop --icon-background-color: Background color of the icon. Defaults to transparent.\n * @prop --icon-color: Color of the icon. Defaults to `rgb(var(--contrast-1100))`.\n * @prop --background-color: Background color of the field when type is set to input.\n * @prop --background-color-disabled: Background color of the field when type is set to input and the component is disabled or readonly.\n * @prop --input-chip-set-selected-chip-color: Color of the highlight around selected chips in input chip-sets.\n */\n\n@include textfield.core-styles;\n@include icon.icon-core-styles;\n\n@include shared_input-select-picker.leading-icon;\n\n$height-of-chip-set-input: functions.pxToRem(36);\n$leading-icon-space: 1.5rem;\n\n:host(limel-chip-set) {\n    isolation: isolate;\n}\n\n:host(limel-chip-set[type='input']) {\n    limel-notched-outline {\n        [slot='content'] {\n            min-height: shared_input-select-picker.$height-of-mdc-text-field;\n        }\n    }\n}\n\n:host(limel-chip-set:not([type='input'])) {\n    .limel-notched-outline {\n        --limel-notched-outline-border-color: transparent;\n        --limel-notched-outline-background-color: transparent;\n    }\n}\n\n.mdc-chip-set {\n    display: flex;\n    flex-wrap: wrap;\n    align-items: center;\n    gap: 0.5rem;\n    min-height: shared_input-select-picker.$height-of-mdc-text-field;\n    position: relative;\n\n    &.mdc-chip-set--input {\n        padding: 0.4rem 0.5rem;\n        width: 100%;\n    }\n\n    &.has-clear-all-button {\n        &.mdc-chip-set--input {\n            padding-right: functions.pxToRem(\n                32\n            ); // This leaves space for \"clear all\" button and avoids overlapping with chips\n        }\n    }\n}\n\n.mdc-text-field__input {\n    .mdc-text-field:not(.mdc-text-field--disabled) & {\n        color: shared_input-select-picker.$input-text-color;\n        font-size: var(--limel-theme-default-font-size) !important;\n        font-family: inherit !important;\n    }\n    .mdc-text-field.mdc-text-field--disabled & {\n        color: shared_input-select-picker.$input-text-color-disabled;\n    }\n}\n\n.mdc-text-field {\n    height: auto;\n    cursor: text;\n    flex-wrap: wrap;\n    row-gap: 0.5rem;\n\n    .mdc-text-field__input {\n        @include shared_input-select-picker.input-field-placeholder;\n\n        width: auto;\n        padding: 0 0.5rem;\n\n        flex-grow: 1;\n        flex-shrink: 0;\n\n        &.hidden {\n            // This class is added, as soon as there is a chip selected and displayed\n            // This input field should not be visually visible as it breaks the UI in some cases\n            // But it should be rendered to be able to tab between fields and do other keyboard commands /Kia\n            transition: all 0s;\n            opacity: 0;\n            position: absolute;\n            z-index: -100; // to let users interact with chips, in case they're covered\n        }\n        &[type='search'] {\n            -webkit-appearance: textfield; // Removes the default magnifying glass icon on iOS which appears automatically on input fields with type of search\n            background-color: transparent; // overides styles caused by previous line\n\n            &::-webkit-search-cancel-button {\n                display: none; // removes the default X button\n            }\n        }\n    }\n}\n\n.clear-all-button {\n    @include mixins.clear-all-button;\n    @include mixins.visualize-keyboard-focus;\n\n    position: absolute;\n    right: 0.5rem;\n    top: calc(#{shared_input-select-picker.$height-of-mdc-text-field} / 4);\n\n    opacity: 0; // Is hidden, but can receive focus (such as when navigating through tab indexes).\n\n    &:focus,\n    .has-chips:not(.disabled):hover &,\n    .has-chips:not(.disabled).mdc-text-field--focused & {\n        opacity: 1;\n        outline: none;\n    }\n\n    .mdc-chip-set:not(.has-chips) &,\n    .has-chips.disabled & {\n        display: none; // Won't receive focus when disabled\n    }\n}\n\n.has-leading-icon {\n    &:not(.has-chips) {\n        .mdc-text-field__input {\n            padding-left: $leading-icon-space;\n        }\n    }\n\n    limel-chip {\n        &:first-of-type {\n            margin-left: 1.5rem;\n        }\n    }\n\n    .search-icon {\n        transition: transform 0.2s ease;\n        position: absolute;\n        top: functions.pxToRem(9);\n        left: 0.25rem;\n    }\n\n    limel-icon {\n        background-color: transparent;\n    }\n}\n\n.delimiter {\n    opacity: 0.5;\n    padding: 0 functions.pxToRem(2);\n    color: var(--limel-theme-on-surface-color);\n}\n\nlimel-chip {\n    border-radius: 2rem;\n\n    &.can-be-removed {\n        // When chip is selected with keyboard (backspace / arrow-keys) to be deleted\n        box-shadow: var(--shadow-depth-8-error);\n    }\n}\n\n@import './partial-styles/_readonly';\n@import './partial-styles/_helper-text';\n","import { Chip, ChipType } from '../chip-set/chip.types';\nimport { Languages } from '../date-picker/date.types';\nimport { MDCTextField } from '@material/textfield';\nimport {\n    Component,\n    Element,\n    Event,\n    EventEmitter,\n    h,\n    Method,\n    Prop,\n    State,\n    Watch,\n} from '@stencil/core';\nimport { handleKeyboardEvent } from './chip-set-input-helpers';\nimport translate from '../../global/translations';\nimport { getHref, getTarget } from '../../util/link-helper';\nimport { isEqual } from 'lodash-es';\nimport { LimelChipCustomEvent } from '../../components';\nimport { createRandomString } from '../../util/random-string';\n\nconst INPUT_FIELD_TABINDEX = 1;\n\n/**\n * :::note\n * **Regarding `click` and `interact` events:**\n *\n * The `interact` event is emitted when a chip is interacted with, and is\n * the recommended way to listen for chip interactions.\n *\n * However, if you need to handle clicks differently depending on which chip\n * was clicked, or whether the click was on a chip or elsewhere, you need to\n * listen to the native `click` event instead.\n *\n * Native `click` events are passed through, and if the click came from\n * a chip, the chip object is available in the event object under\n * `<event object>.Lime.chip`.\n *\n * Example usage:\n * ```ts\n * private handleClick(event: Event) {\n *     if (event && 'Lime' in event && (event.Lime as any).chip) {\n *         if ((event.Lime as { chip: Chip }).chip.href) {\n *             // Chip has href, so let the browser open the link.\n *             return;\n *         }\n *         // handle click on chip without href\n *     } else {\n *         // handle click elsewhere\n *     }\n * }\n * ```\n * :::\n *\n * @exampleComponent limel-example-chip-set\n * @exampleComponent limel-example-chip-set-choice\n * @exampleComponent limel-example-chip-set-filter\n * @exampleComponent limel-example-chip-set-filter-badge\n * @exampleComponent limel-example-chip-set-input\n * @exampleComponent limel-example-chip-set-input-type-with-menu-items\n * @exampleComponent limel-example-chip-set-input-type-text\n * @exampleComponent limel-example-chip-set-input-type-search\n * @exampleComponent limel-example-chip-icon-color\n * @exampleComponent limel-example-chip-set-image\n * @exampleComponent limel-example-chip-set-composite\n */\n@Component({\n    tag: 'limel-chip-set',\n    shadow: true,\n    styleUrl: 'chip-set.scss',\n})\nexport class ChipSet {\n    /**\n     * List of chips for the set\n     */\n    @Prop()\n    public value: Chip[] = [];\n\n    /**\n     * Type of chip set\n     *\n     * - `choice` renders a set of selectable chips where only one is selectable. The `removable` property is ignored\n     * - `filter` renders a set of selectable chips where all are selectable.\n     * - `input` renders a set of chips that can be used in conjunction with an input field\n     *\n     * If no type is set, a basic set of chips without additional functionality will be rendered\n     */\n    @Prop({ reflect: true })\n    public type?: 'choice' | 'filter' | 'input';\n\n    /**\n     * Label for the chip-set\n     */\n    @Prop({ reflect: true })\n    public label: string;\n\n    /**\n     * Optional helper text to display below the chipset.\n     * When type is `input`, the helper text is displayed below the\n     * input field when it has focus.\n     * When type is not `input`, the helper text is always displayed\n     * if the device is touch screen; otherwise it is shown when chip-set\n     * is hovered or focused using keyboard navigation.\n     */\n    @Prop({ reflect: true })\n    public helperText: string;\n\n    /**\n     * True if the chip set should be disabled\n     */\n    @Prop({ reflect: true })\n    public disabled: boolean = false;\n\n    /**\n     * For chip-sets of type `input`, set to `true` to disable adding and\n     * removing chips, but allow interaction with existing chips in the set.\n     * For any other types, setting either `readonly` or `disabled` disables\n     * the chip-set.\n     */\n    @Prop({ reflect: true })\n    public readonly: boolean = false;\n\n    /**\n     * Set to `true` to indicate that the current value of the input field is\n     * invalid.\n     */\n    @Prop({ reflect: true })\n    public invalid = false;\n\n    /**\n     * For chip-sets of type `input`. Value to use for the `type` attribute on the\n     * input field inside the chip-set.\n     */\n    @Prop({ reflect: true })\n    public inputType: 'search' | 'text' = 'text';\n\n    /**\n     * For chip-sets of type `input`. Limits the maximum number of chips.\n     * When the value is `0` or not set, no limit is applied.\n     */\n    @Prop({ reflect: true })\n    public maxItems: number;\n\n    /**\n     * True if the control requires a value\n     */\n    @Prop({ reflect: true })\n    public required: boolean = false;\n\n    /**\n     * Search label to display when type is `input` and component is in search mode\n     */\n    @Prop({ reflect: true })\n    public searchLabel: string;\n\n    /**\n     * Whether the input field should be emptied when the chip-set loses focus.\n     */\n    @Prop({ reflect: true })\n    public emptyInputOnBlur: boolean = true;\n\n    /**\n     * Whether the \"Clear all\" buttons should be shown\n     */\n    @Prop()\n    public clearAllButton: boolean = true;\n\n    /**\n     * For chip-sets of type `input`. When the value is null, no leading icon is used.\n     * Leading icon to show to the far left in the text field\n     */\n    @Prop({ reflect: true })\n    public leadingIcon: string = null;\n\n    /**\n     * For chip-set of type `input`. Sets delimiters between chips.\n     */\n    @Prop({ reflect: true })\n    public delimiter: string = null;\n\n    /**\n     * For chip-set of type `input`, defines whether the input field should have autocomplete enabled.\n     * Read more about the `autocomplete` attribute\n     * [here](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete).\n     */\n    @Prop({ reflect: true })\n    public autocomplete: string = 'off';\n\n    /**\n     * Defines the language for translations.\n     * Will translate the translatable strings on the components. For example, the clear all chips label.\n     */\n    @Prop()\n    public language: Languages = 'en';\n\n    /**\n     * Dispatched when a chip is interacted with\n     */\n    @Event()\n    private readonly interact: EventEmitter<Chip>;\n\n    /**\n     * Dispatched when a chip is selected/deselected\n     */\n    @Event()\n    private readonly change: EventEmitter<Chip | Chip[]>;\n\n    /**\n     * Emitted when an input chip set has received focus and editing in the text field has started\n     */\n    @Event()\n    private readonly startEdit: EventEmitter<void>;\n\n    /**\n     * Emitted when an input chip set has lost focus and editing in the text field has ended\n     */\n    @Event()\n    private readonly stopEdit: EventEmitter<void>;\n\n    /**\n     * Dispatched when the input is changed for type `input`\n     */\n    @Event()\n    private readonly input: EventEmitter<string>;\n\n    @Element()\n    private readonly host: HTMLLimelChipSetElement;\n\n    @State()\n    private editMode: boolean = false;\n\n    @State()\n    private textValue: string = '';\n\n    @State()\n    private blurred: boolean = false;\n\n    @State()\n    private inputChipIndexSelected: number = null;\n\n    @State()\n    private selectedChipIds: Array<string | number>;\n\n    private mdcTextField: MDCTextField;\n    private readonly handleKeyDown = handleKeyboardEvent;\n    private labelId: string;\n\n    constructor() {\n        this.labelId = createRandomString();\n        this.renderChip = this.renderChip.bind(this);\n        this.renderInputChip = this.renderInputChip.bind(this);\n        this.isFull = this.isFull.bind(this);\n        this.handleTextFieldFocus = this.handleTextFieldFocus.bind(this);\n        this.handleInputBlur = this.handleInputBlur.bind(this);\n        this.handleTextInput = this.handleTextInput.bind(this);\n        this.inputFieldOnChange = this.inputFieldOnChange.bind(this);\n        this.handleKeyDown = this.handleKeyDown.bind(this);\n        this.inputHidden = this.inputHidden.bind(this);\n        this.handleDeleteAllIconClick =\n            this.handleDeleteAllIconClick.bind(this);\n        this.renderDelimiter = this.renderDelimiter.bind(this);\n    }\n\n    public connectedCallback() {\n        this.initialize();\n    }\n\n    private initialize() {\n        if (this.value.length > 0) {\n            this.selectedChipIds = this.value\n                .filter((chip) => chip.selected)\n                .map((chip) => chip.id);\n        }\n    }\n\n    /**\n     * Used to find out whether the chip-set is in edit mode.\n     *\n     * @returns `true` if the chip-set is in edit mode, `false` otherwise.\n     */\n    @Method()\n    public async getEditMode(): Promise<boolean> {\n        return this.editMode;\n    }\n\n    /**\n     * Used to set focus to the chip-set input field.\n     *\n     * @param emptyInput - if `true`, any text in the input is discarded\n     * @returns does not return anything, but methods have to be async\n     */\n    @Method()\n    public async setFocus(emptyInput: boolean = false) {\n        if (this.disabled || this.readonly) {\n            return;\n        }\n\n        this.editMode = true;\n        if (emptyInput) {\n            this.textValue = '';\n        }\n\n        this.host.shadowRoot.querySelector('input').focus();\n        this.startEdit.emit();\n    }\n\n    /**\n     * Used to empty the input field. Used in conjunction with `emptyInputOnBlur` to let the\n     * consumer control when the input is emptied.\n     *\n     * @returns does not return anything, but methods have to be async\n     */\n    @Method()\n    public async emptyInput() {\n        this.syncEmptyInput();\n    }\n\n    public componentDidLoad() {\n        this.triggerIconColorWarning(this.value);\n\n        if (this.type === 'input') {\n            this.mdcTextField = new MDCTextField(\n                this.host.shadowRoot.querySelector('.mdc-text-field')\n            );\n        }\n    }\n\n    public componentDidUpdate() {\n        const input = this.host.shadowRoot.querySelector('input');\n        if (input && this.editMode) {\n            input.focus();\n        }\n    }\n\n    public disconnectedCallback() {\n        if (this.mdcTextField) {\n            this.mdcTextField.destroy();\n        }\n    }\n\n    public render() {\n        const classes = {\n            'mdc-chip-set': true,\n            'mdc-text-field--with-trailing-icon': true,\n            disabled: this.disabled || this.readonly,\n        };\n\n        if (this.type) {\n            classes[`mdc-chip-set--${this.type}`] = true;\n        }\n\n        if (this.type === 'input') {\n            Object.assign(classes, {\n                'mdc-text-field': true,\n                'mdc-text-field--outlined': true,\n                'mdc-chip-set--input': true,\n                'lime-text-field--readonly': this.readonly,\n                'has-chips': this.value.length > 0,\n                'has-leading-icon': this.leadingIcon !== null,\n                'has-clear-all-button': this.clearAllButton,\n            });\n        }\n\n        const value = this.getValue();\n\n        return [\n            <limel-notched-outline\n                labelId={this.labelId}\n                label={this.label}\n                required={this.required}\n                invalid={this.invalid || this.isInvalid()}\n                disabled={this.disabled}\n                readonly={this.readonly}\n                hasValue={!!this.value?.length}\n                hasLeadingIcon={!!this.leadingIcon}\n                hasFloatingLabel={this.floatLabelAbove()}\n            >\n                <div slot=\"content\" {...this.getContentProps()} class={classes}>\n                    {this.renderContent(value)}\n                </div>\n            </limel-notched-outline>,\n            this.renderHelperLine(),\n        ];\n    }\n\n    private getContentProps() {\n        if (this.type === 'input') {\n            return {\n                onClick: this.handleTextFieldFocus,\n            };\n        }\n\n        return {\n            role: 'grid',\n        };\n    }\n\n    private renderContent = (value: Chip[]) => {\n        if (this.type === 'input') {\n            return this.renderInputChips();\n        }\n\n        return value.map(this.renderChip);\n    };\n\n    private readonly getValue = () => {\n        return this.value.map((chip) => ({\n            ...chip,\n            ...(this.type && {\n                selected: this.selectedChipIds.includes(chip.id),\n            }),\n        }));\n    };\n\n    @Watch('value')\n    protected handleChangeChips(newValue: Chip[], oldValue: Chip[]) {\n        if (isEqual(newValue, oldValue)) {\n            return;\n        }\n\n        this.syncEmptyInput();\n        this.initialize();\n    }\n\n    private renderInputChips() {\n        return [\n            this.value.map(this.renderInputChip),\n            <input\n                tabIndex={INPUT_FIELD_TABINDEX}\n                type={this.inputType}\n                id={this.labelId}\n                disabled={this.readonly || this.disabled}\n                class={{\n                    'mdc-text-field__input': true,\n                    hidden: this.inputHidden(),\n                }}\n                value={this.textValue}\n                onBlur={this.handleInputBlur}\n                onFocus={this.handleTextFieldFocus}\n                onKeyDown={this.handleKeyDown}\n                onInput={this.handleTextInput}\n                // Some browsers emit a change event on input elements, we need to stop\n                // that event from propagating since we are emitting our own change event\n                onChange={this.inputFieldOnChange}\n                placeholder={this.isFull() ? '' : this.searchLabel}\n                readonly={this.isFull()}\n                autocomplete={this.autocomplete}\n            />,\n            this.renderLeadingIcon(),\n            this.renderClearAllChipsButton(),\n        ];\n    }\n\n    private readonly floatLabelAbove = () => {\n        if (\n            this.value.length > 0 ||\n            this.editMode ||\n            this.readonly ||\n            this.textValue\n        ) {\n            return true;\n        }\n    };\n\n    private isFull(): boolean {\n        return !!this.maxItems && this.value.length >= this.maxItems;\n    }\n\n    private isInvalid() {\n        if (this.readonly) {\n            // A readonly field can never be invalid.\n            return false;\n        }\n\n        if (this.invalid) {\n            return true;\n        }\n\n        if (!this.required) {\n            return false;\n        }\n\n        if (!this.blurred) {\n            return false;\n        }\n\n        return !this.value?.length;\n    }\n\n    private inputFieldOnChange(event) {\n        event.stopPropagation();\n    }\n\n    /**\n     * Enter edit mode when the text field receives focus. When editMode is true, the input element will be visible\n     */\n    private handleTextFieldFocus() {\n        if (this.disabled || this.readonly) {\n            return;\n        }\n\n        if (this.editMode) {\n            return;\n        }\n\n        this.editMode = true;\n        this.startEdit.emit();\n    }\n\n    /**\n     * Exit edit mode when the input element loses focus. This makes sure the input element does not take up any\n     * additional space when the user it not typing anything\n     */\n    private handleInputBlur() {\n        if (this.emptyInputOnBlur) {\n            this.syncEmptyInput();\n        }\n\n        this.editMode = false;\n        this.blurred = true;\n        this.inputChipIndexSelected = null;\n\n        // This timeout is needed in order to let a new element receive focus\n        setTimeout(() => {\n            this.stopEdit.emit();\n        }, 0);\n    }\n\n    private syncEmptyInput() {\n        this.textValue = '';\n    }\n\n    private inputHidden() {\n        if (this.editMode) {\n            return this.isFull();\n        }\n\n        // If there are chips in the picker, hide the input to avoid the input\n        // being placed on a new line and adding ugly space beneath the chips.\n        // If there are no chips, show the input, or the picker will look weird.\n        return !!this.value?.length;\n    }\n\n    private handleTextInput(event) {\n        event.stopPropagation();\n        this.inputChipIndexSelected = null;\n        this.textValue = event.target.value;\n        this.input.emit(event.target.value?.trim());\n    }\n\n    private emitInteraction(chip: Chip) {\n        this.interact.emit(chip);\n    }\n\n    private renderChip(chip: Chip) {\n        const chipType: ChipType =\n            this.type === 'filter' ? 'filter' : 'default';\n\n        const chipProps = this.getChipProps(chip, chipType);\n\n        return <limel-chip {...chipProps} />;\n    }\n\n    private readonly hasHelperText = () => {\n        return this.helperText !== null && this.helperText !== undefined;\n    };\n\n    private readonly renderHelperLine = () => {\n        const maxItems = this.maxItems === 1 ? undefined : this.maxItems;\n\n        if (!maxItems && !this.hasHelperText()) {\n            return;\n        }\n\n        return (\n            <limel-helper-line\n                length={this.value.length}\n                maxLength={maxItems}\n                helperText={this.helperText}\n                invalid={this.isInvalid()}\n            />\n        );\n    };\n\n    private renderInputChip(chip: Chip, index: number, chips: Chip[]) {\n        const chipProps = this.getChipProps(chip, 'default');\n        const isLastChip = index === chips.length - 1;\n\n        return [\n            <limel-chip\n                key={chip.id}\n                class={{\n                    'can-be-removed': this.inputChipIndexSelected === index,\n                }}\n                {...chipProps}\n            />,\n            !(isLastChip && this.inputHidden()) && this.renderDelimiter(),\n        ];\n    }\n\n    private getChipProps(chip: Chip, chipType: ChipType) {\n        const removable =\n            this.type === 'input' && chip.removable && !this.readonly;\n        const readonly = this.readonly && this.type !== 'input';\n\n        return {\n            role: 'row',\n            identifier: chip.id,\n            text: chip.text,\n            icon: chip.icon,\n            image: chip.image,\n            badge: chip.badge,\n            selected: chip.selected,\n            disabled: this.disabled,\n            loading: chip.loading,\n            readonly: readonly,\n            type: chipType,\n            removable: removable,\n            menuItems: chip.menuItems,\n            onClick: this.catchInputChipClicks(chip),\n            onRemove: this.handleRemoveChip,\n            ...(chip.href && {\n                link: {\n                    href: getHref(chip.href),\n                    target: getTarget(chip.href),\n                },\n            }),\n        };\n    }\n\n    private readonly catchInputChipClicks = (chip: Chip) => (event: Event) => {\n        /*\n         * We need to add the `chip` to the event object so that the consumer\n         * can get the chip object when the chip is clicked.\n         * This is necessary for the consumer to be able to handle the click\n         * event itself, based on which chip was clicked, or whether the click\n         * was on a chip or elsewhere. The reason the consumer can't just look\n         * at the event target is that that information is hidden by the\n         * shadow DOM.\n         *\n         * See documentation for the `interact` event for more information.\n         */\n        (event as any).Lime = { chip: chip };\n\n        if (this.isSelectableChip(chip)) {\n            this.updateSelectedChipIds(chip);\n            this.change.emit(chip);\n        }\n\n        this.emitInteraction(chip);\n    };\n\n    private isSelectableChip(chip: Chip): boolean {\n        return this.type !== 'input' && 'selected' in chip;\n    }\n\n    private updateSelectedChipIds(chip: Chip): void {\n        chip.selected = !chip.selected;\n        const id = chip.id;\n        if (this.type === 'choice') {\n            this.updateChoiceTypeSelectedIds(id);\n        } else {\n            this.updateFilterTypeSelectedIds(id);\n        }\n    }\n\n    private updateChoiceTypeSelectedIds(id: number | string): void {\n        this.selectedChipIds = this.isChipSelected(id) ? [] : [id];\n    }\n\n    private isChipSelected(id: number | string): boolean {\n        return this.selectedChipIds.includes(id);\n    }\n\n    private updateFilterTypeSelectedIds(id: number | string): void {\n        if (this.isChipSelected(id)) {\n            this.removeChipIdFromSelectedChipIds(id);\n        } else {\n            this.addChipIdToSelectedChipIds(id);\n        }\n    }\n\n    private removeChipIdFromSelectedChipIds(id: number | string): void {\n        this.selectedChipIds = this.selectedChipIds.filter(\n            (chipId) => chipId !== id\n        );\n    }\n\n    private addChipIdToSelectedChipIds(id: number | string): void {\n        this.selectedChipIds = [...this.selectedChipIds, id];\n    }\n\n    private readonly handleRemoveChip = (\n        event: LimelChipCustomEvent<string | number>\n    ) => {\n        this.removeChip(event.detail);\n    };\n\n    private readonly removeChip = (identifier: string | number) => {\n        const newValue = this.value.filter((chip) => {\n            return chip.id !== identifier;\n        });\n        this.change.emit(newValue);\n    };\n\n    private renderLeadingIcon() {\n        if (!this.leadingIcon) {\n            return;\n        }\n\n        return (\n            <i class=\"mdc-text-field__icon search-icon\">\n                <limel-icon name={this.leadingIcon} />\n            </i>\n        );\n    }\n\n    private renderClearAllChipsButton() {\n        if (this.disabled || this.readonly || !this.clearAllButton) {\n            return;\n        }\n\n        return (\n            <a\n                href=\"\"\n                onClick={this.handleDeleteAllIconClick}\n                class=\"mdc-text-field__icon clear-all-button\"\n                tabindex=\"0\"\n                role=\"button\"\n                title={this.clearAllChipsLabel()}\n                aria-label={this.clearAllChipsLabel()}\n            />\n        );\n    }\n\n    private readonly clearAllChipsLabel = (): string => {\n        return translate.get('chip-set.clear-all', this.language);\n    };\n\n    private handleDeleteAllIconClick(event: Event) {\n        event.preventDefault();\n        this.change.emit([]);\n    }\n\n    private renderDelimiter() {\n        if (!this.delimiter) {\n            return;\n        }\n\n        return <div class=\"delimiter\">{this.delimiter}</div>;\n    }\n\n    private triggerIconColorWarning(value: Chip[]) {\n        for (const chip of value) {\n            if (\n                chip.icon &&\n                (chip.iconFillColor ||\n                    chip.iconBackgroundColor ||\n                    chip.iconTitle)\n            ) {\n                console.warn(\n                    \"The `iconFillColor`, `iconBackgroundColor`, and `iconTitle` props are deprecated now! Use the new `Icon` interface and instead of `iconColor: 'color-name', `iconBackgroundColor: 'color-name', and `iconTitle: 'title'`, write `icon { name: 'icon-name', color: 'color-name', backgroundColor: 'color-name', title: 'title' }`.\"\n                );\n            }\n        }\n    }\n}\n"],"mappings":"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"}