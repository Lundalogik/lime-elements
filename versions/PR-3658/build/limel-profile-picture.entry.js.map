{"version":3,"names":["async","resizeImage","file","options","width","height","fit","type","quality","rename","name","renameWithType","source","loadSource","sx","sy","sw","sh","dx","dy","dw","dh","computeRects","canvas","createCanvas","ctx","get2dContext","clearRect","drawImage","blob","canvasToBlob","File","supportsOffscreen","globalThis","OffscreenCanvas","_a","document","createElement","getContext","alpha","Error","convertToBlob","Promise","resolve","reject","toBlob","createImageBitmap","imageOrientation","error","isDev","_b","process","env","NODE_ENV","console","debug","loadImageElement","url","URL","createObjectURL","img","Image","decoding","src","decode","call","catch","undefined","complete","cleanup","removeEventListener","onLoad","onError","e","addEventListener","revokeObjectURL","tw","th","sRatio","tRatio","cropW","cropH","drawW","drawH","ext","idx","lastIndexOf","base","slice","profilePictureCss","ProfilePicture","this","removeButtonId","createRandomString","browseButtonId","renderHelperText","helperText","h","elementId","label","handleNewFiles","event","stopPropagation","disabled","detail","isTypeAccepted","accept","filesRejected","emit","revokeObjectUrl","imageError","out","resize","fileContent","processed","Object","assign","imageFit","filename","size","contentType","_c","href","objectUrl","change","handleRejectedFiles","handleClear","onImageError","openPopover","isErrorMessagePopoverOpen","onPopoverClose","getTranslation","key","translate","get","language","disconnectedCallback","handleValueChange","currentValue","value","render","hostClassNames","readonly","Host","class","renderAvatar","onFilesSelected","onFilesRejected","required","invalid","renderBrowseButton","renderClearButton","renderSpinner","renderErrorMessage","hasValue","id","loading","getImageSrc","alt","style","renderIcon","icon","getIconName","color","backgroundColor","onClick","getUnsupportedPreviewContext","hasNoSrc","hasLocalFile","isResizeConfigured","shouldShowErrorMessage","errorIcon","errorMessageStyles","maxWidth","borderRadius","open","onClose","slot","elevated","heading"],"sources":["./src/util/image-resize.ts","./src/components/profile-picture/profile-picture.scss?tag=limel-profile-picture&encapsulation=shadow","./src/components/profile-picture/profile-picture.tsx"],"sourcesContent":["/**\n * Image resize utilities\n *\n * Overview\n * --------\n * This module provides a small, dependency-free utility to resize images on the client\n * (in the browser) before uploading. It works by decoding an input `File` to an\n * `ImageBitmap` (or falling back to an `HTMLImageElement`), drawing it onto a\n * `Canvas`/`OffscreenCanvas` with the requested strategy (cover/contain), and\n * then exporting the result to a new `File` with your preferred MIME type and\n * quality.\n *\n * Why resize client-side?\n * - Faster perceived uploads and lower bandwidth usage\n * - Consistent avatar sizes and formats (e.g., JPEG 400x400)\n * - No server-side transformation required for common cases\n *\n * Fit strategies\n * - `cover` (default): The image is scaled to cover the target rectangle, and\n *   the excess parts are center-cropped. Good for avatars.\n * - `contain`: The image is scaled to fit entirely within the target rectangle\n *   without cropping, letterboxing if needed. Good when you must preserve the\n *   entire image.\n *\n * Decoding & EXIF orientation\n * EXIF orientation is a piece of metadata stored inside image files\n * (usually JPEGs) that tells image renderer software how the image should be displayed\n * i.e., whether it should be rotated or flipped. This meta data is normally added\n * to photos by digital cameras and phones.\n * - When available, `createImageBitmap(file, { imageOrientation: 'from-image' })`\n *   is used to automatically respect EXIF orientation.\n * - If not available or it fails (e.g., unsupported format), we fall back to\n *   decoding via an `HTMLImageElement`.\n *\n * OffscreenCanvas\n * - If the environment supports `OffscreenCanvas`, it will be used for the draw\n *   and encode operations for better performance in some cases. Otherwise, a\n *   regular `HTMLCanvasElement` is used.\n *\n * HEIC/HEIF notes\n * - All major browsers except Safari lack native HEIC/HEIF decoding.\n *   In such cases the `resizeImage` function will throw when decoding fails.\n *   The caller should catch and fall back\n *   to using the original file or handle conversion on the server.\n * - If we need guaranteed client-side HEIC->JPEG conversion, we must add a small\n *   library or WASM module; this utility intentionally avoids extra dependencies.\n *\n * Output type & quality\n * - Default output is `image/jpeg` with `quality=0.85`, which is typically\n *   appropriate for avatars. You can switch to `image/png` to preserve\n *   transparency.\n * - The output filename extension is adjusted to match the chosen MIME type by\n *   default (e.g., `.jpg` or `.png`). You can override naming via the `rename`\n *   option.\n *\n * Error handling\n * - Throws if canvas/context cannot be created or if canvas->blob conversion fails.\n * - Decoding failures (unsupported type) will throw; caller can try/catch and\n *   fall back to the original file.\n *\n * Performance tips\n * - Keep target sizes reasonable (e.g., 256–1024 px) to avoid long processing\n *   times on modest devices.\n * - JPEG with quality 0.8–0.9 often strikes a good balance between size and\n *   perceived quality for photos/avatars.\n *\n * Usage examples\n * --------------\n * Basic usage:\n * ```ts\n * import { resizeImage } from '@limetech/lime-elements/util/image-resize';\n *\n * const processed = await resizeImage(file, {\n *   width: 400,\n *   height: 400,\n *   fit: 'cover',         // default; center-crops\n *   type: 'image/jpeg',   // default\n *   quality: 0.85,        // default\n * });\n * // Upload `processed` instead of the original file\n * ```\n *\n * With custom naming:\n * ```ts\n * const processed = await resizeImage(file, {\n *   width: 800,\n *   height: 800,\n *   fit: 'contain',\n *   type: 'image/png',\n *   rename: (name) => name.replace(/\\.[^.]+$/, '') + '_resized.png',\n * });\n * ```\n *\n * In a Stencil component (simplified):\n * ```tsx\n * private async handleFilesSelected(file: File) {\n *   try {\n *     const resized = await resizeImage(file, { width: 400, height: 400 });\n *     // build your FileInfo and emit\n *   } catch {\n *     // fall back to original\n *   }\n * }\n * ```\n */\n// (Removed exported ResizeFit to avoid forcing a public symbol.)\n\n/**\n * Options for client-side image resizing.\n * @beta\n */\nexport type ResizeOptions = {\n    /** Target width in CSS pixels. */\n    width: number;\n    /** Target height in CSS pixels. */\n    height: number;\n    /** Fit strategy; defaults to 'cover'. */\n    fit?: 'cover' | 'contain';\n    /** Output MIME type; 'image/jpeg' by default. */\n    type?: 'image/jpeg' | 'image/png';\n    /** JPEG quality (0..1); used only for 'image/jpeg'. Defaults to 0.85. */\n    quality?: number;\n    /** Optional renaming function. Defaults to changing extension to match MIME. */\n    rename?: (originalName: string) => string;\n};\n\ntype SourceLike = ImageBitmap | HTMLImageElement;\n\n/**\n * Resize an image file on the client using Canvas/OffscreenCanvas.\n * Returns a new File with the requested format and dimensions.\n *\n * Contract\n * - Input: image `File`\n * - Output: resized image as a new `File` with updated `type`, name, and size\n * - Errors: may throw on decode failure or canvas export failure\n *\n * @beta\n * @param file - The image file to resize.\n * @param options - Configuration for the resize operation.\n */\nexport async function resizeImage(\n    file: File,\n    options: ResizeOptions\n): Promise<File> {\n    const {\n        width,\n        height,\n        fit = 'cover',\n        type = 'image/jpeg',\n        quality = 0.85,\n        rename = (name: string) => renameWithType(name, type),\n    } = options;\n\n    const source = await loadSource(file);\n    const { sx, sy, sw, sh, dx, dy, dw, dh } = computeRects(\n        source.width as number,\n        source.height as number,\n        width,\n        height,\n        fit\n    );\n\n    const canvas = createCanvas(width, height);\n    const ctx = get2dContext(canvas);\n    ctx.clearRect(0, 0, width, height);\n    ctx.drawImage(source, sx, sy, sw, sh, dx, dy, dw, dh);\n\n    const blob = await canvasToBlob(canvas, type, quality);\n    const name = rename(file.name);\n    return new File([blob], name, { type });\n}\n\n/** Whether OffscreenCanvas is available in the current environment. */\nfunction supportsOffscreen(): boolean {\n    try {\n        return typeof (globalThis as any).OffscreenCanvas === 'function';\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Create either an OffscreenCanvas or a regular canvas for drawing.\n * @param width - Target width\n * @param height - Target height\n */\nfunction createCanvas(\n    width: number,\n    height: number\n): HTMLCanvasElement | OffscreenCanvas {\n    if (supportsOffscreen()) {\n        return new (globalThis as any).OffscreenCanvas(width, height);\n    }\n\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n}\n\n/**\n * Get the 2D rendering context, throwing a descriptive error if unavailable.\n * @param canvas - The canvas to get context from\n */\nfunction get2dContext(canvas: HTMLCanvasElement | OffscreenCanvas) {\n    const ctx = (canvas as any).getContext('2d', { alpha: true });\n    if (!ctx) {\n        throw new Error('2D canvas context not available');\n    }\n\n    return ctx as CanvasRenderingContext2D;\n}\n\n/**\n * Convert the canvas content to a Blob, supporting both canvas types.\n * @param canvas - The source canvas\n * @param type - Output MIME type\n * @param quality - JPEG quality (0..1)\n */\nfunction canvasToBlob(\n    canvas: HTMLCanvasElement | OffscreenCanvas,\n    type: string,\n    quality: number\n): Promise<Blob> {\n    if ('convertToBlob' in canvas) {\n        return (canvas as OffscreenCanvas).convertToBlob({ type, quality });\n    }\n\n    return new Promise((resolve, reject) => {\n        (canvas as HTMLCanvasElement).toBlob(\n            (blob) => {\n                if (!blob) {\n                    reject(new Error('Failed to create blob from canvas'));\n                    return;\n                }\n                resolve(blob);\n            },\n            type,\n            quality\n        );\n    });\n}\n\n/**\n * Load the image into a decodable source (ImageBitmap preferred).\n * @param file - The input file to decode\n */\n\nasync function loadSource(file: File): Promise<SourceLike> {\n    if (typeof (globalThis as any).createImageBitmap === 'function') {\n        try {\n            return await (globalThis as any).createImageBitmap(file, {\n                imageOrientation: 'from-image',\n            } as any);\n        } catch (error) {\n            // Log for debugging in development, but continue with fallback\n            const isDev =\n                (globalThis as any).process?.env?.NODE_ENV !== 'production';\n\n            if (\n                isDev &&\n                typeof console !== 'undefined' &&\n                typeof console.debug === 'function'\n            ) {\n                console.debug(\n                    'createImageBitmap failed, falling back to HTMLImageElement:',\n                    error\n                );\n            }\n        }\n    }\n\n    return await loadImageElement(file);\n}\n\n/**\n * Decode an image file via HTMLImageElement when ImageBitmap is unavailable.\n * @param file - The input file to decode\n */\nasync function loadImageElement(file: File): Promise<HTMLImageElement> {\n    const url = URL.createObjectURL(file);\n    try {\n        const img = new Image();\n        img.decoding = 'sync';\n        img.src = url;\n        await img.decode?.().catch(() => undefined);\n        if (!img.complete) {\n            await new Promise<void>((resolve, reject) => {\n                const cleanup = () => {\n                    img.removeEventListener('load', onLoad);\n                    img.removeEventListener('error', onError);\n                };\n\n                const onLoad = () => {\n                    cleanup();\n                    resolve();\n                };\n                const onError = (e: Event) => {\n                    cleanup();\n                    reject(e);\n                };\n\n                img.addEventListener('load', onLoad);\n                img.addEventListener('error', onError);\n            });\n        }\n        return img;\n    } finally {\n        URL.revokeObjectURL(url);\n    }\n}\n\n/**\n * Compute source and destination rectangles for drawImage based on the fit mode.\n *\n * Returns sx, sy, sw, sh for the source crop/area and dx, dy, dw, dh for the\n * destination rectangle on the target canvas.\n *\n * @param sw - Source width\n * @param sh - Source height\n * @param tw - Target width\n * @param th - Target height\n * @param fit - Fit mode (cover/contain)\n */\nfunction computeRects(\n    sw: number,\n    sh: number,\n    tw: number,\n    th: number,\n    fit: 'cover' | 'contain'\n) {\n    const sRatio = sw / sh;\n    const tRatio = tw / th;\n\n    if (fit === 'cover') {\n        // scale source to cover target, then center-crop\n        let cropW: number;\n        let cropH: number;\n        if (sRatio > tRatio) {\n            // source is wider than target: crop width\n            cropH = sh;\n            cropW = sh * tRatio;\n        } else {\n            // source is taller than target: crop height\n            cropW = sw;\n            cropH = sw / tRatio;\n        }\n        const sx = (sw - cropW) / 2;\n        const sy = (sh - cropH) / 2;\n        return { sx, sy, sw: cropW, sh: cropH, dx: 0, dy: 0, dw: tw, dh: th };\n    }\n\n    // contain: fit inside, letterbox if needed\n    let drawW: number;\n    let drawH: number;\n    if (sRatio > tRatio) {\n        drawW = tw;\n        drawH = tw / sRatio;\n    } else {\n        drawH = th;\n        drawW = th * sRatio;\n    }\n    const dx = (tw - drawW) / 2;\n    const dy = (th - drawH) / 2;\n\n    return { sx: 0, sy: 0, sw, sh, dx, dy, dw: drawW, dh: drawH };\n}\n\n/**\n * Update filename extension to match the desired MIME type.\n * @param name - Original filename\n * @param type - Output MIME type\n */\nfunction renameWithType(name: string, type: string): string {\n    const ext = type === 'image/png' ? 'png' : 'jpg';\n    const idx = name.lastIndexOf('.');\n    const base = idx > 0 ? name.slice(0, idx) : name;\n    return `${base}.${ext}`;\n}\n","@use '../../style/mixins';\n\n/**\n* @prop --profile-picture-border-radius: Border radius of the profile picture. Defaults to `100vw` to render a circular shape.\n*/\n\n:host(limel-profile-picture) {\n    position: relative;\n\n    display: inline-flex;\n    min-width: 1.5rem;\n    min-height: 1.5rem;\n\n    border-radius: var(--profile-picture-border-radius, 100vw);\n    background-color: rgb(var(--contrast-400));\n}\n\n* {\n    box-sizing: border-box;\n}\n\nlimel-file-dropzone,\nlimel-file-input,\nbutton.avatar {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n\n    width: 100%;\n    height: 100%;\n}\n\nbutton {\n    all: unset;\n    display: block;\n    @include mixins.visualize-keyboard-focus();\n\n    &.avatar {\n        overflow: hidden;\n        border-radius: var(--profile-picture-border-radius, 100vw);\n\n        :host(:not([disabled]):not([disabled='true'])) & {\n            @include mixins.is-flat-clickable();\n        }\n\n        :host([invalid]:not([invalid='false'])) & {\n            box-shadow: var(--shadow-error-state);\n        }\n    }\n\n    &.remove {\n        @include mixins.clear-all-button();\n        position: absolute;\n        top: 0;\n        left: 0;\n        opacity: 0;\n\n        :host(:hover) &,\n        :host(:focus) &,\n        :host(:focus-visible) &,\n        :host(:focus-within) &,\n        :host(:active) & {\n            animation: show 0.4s ease-in-out forwards;\n        }\n    }\n}\n\n@keyframes show {\n    0% {\n        transform: scale(0.9);\n        opacity: 0;\n    }\n    100% {\n        transform: scale(1);\n        opacity: 1;\n    }\n}\n\nbutton.avatar,\nimg,\nlimel-icon {\n    border-radius: var(--profile-picture-border-radius, 100vw);\n}\n\nlimel-icon {\n    width: calc(100% - 1rem);\n    min-width: 1rem;\n    max-width: 4rem;\n    color: var(--limel-theme-text-secondary-on-background-color);\n    margin: auto;\n}\n\nimg {\n    object-fit: var(--limel-profile-picture-object-fit);\n    width: 100%;\n    height: 100%;\n\n    :host(.has-image-error) & {\n        border: 1px dashed rgb(var(--contrast-600));\n        background: url(\"data:image/svg+xml;charset=utf-8, <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8' style='fill-rule:evenodd;'><path fill='rgba(186,186,192,0.16)' d='M0 0h4v4H0zM4 4h4v4H4z'/></svg>\");\n        background-size: 0.5rem;\n    }\n}\n\nlimel-spinner {\n    position: absolute;\n    inset: 0;\n    margin: auto;\n}\n\nlimel-popover {\n    position: absolute;\n    inset: auto 0 0 auto;\n    display: block;\n    width: 2.25rem;\n    height: 2.25rem;\n}\n","import {\n    Component,\n    Event,\n    EventEmitter,\n    h,\n    Host,\n    Prop,\n    State,\n    Watch,\n} from '@stencil/core';\nimport { FileInfo } from '../../global/shared-types/file.types';\nimport { isTypeAccepted } from '../../util/files';\nimport { Icon } from '../../global/shared-types/icon.types';\nimport { getIconName } from '../icon/get-icon-props';\nimport translate from '../../global/translations';\nimport { Languages } from '../date-picker/date.types';\nimport { createRandomString } from '../../util/random-string';\nimport { resizeImage, ResizeOptions } from '../../util/image-resize';\n\n/**\n * This component displays a profile picture, while allowing the user\n * to change it via a file input or drag-and-drop.\n *\n * It supports client-side image resizing and conversion,\n * as well as a simple lazy-loading mechanism.\n *\n * @exampleComponent limel-example-profile-picture-basic\n * @exampleComponent limel-example-profile-picture-helper-text\n * @exampleComponent limel-example-profile-picture-icon\n * @exampleComponent limel-example-profile-picture-with-value\n * @exampleComponent limel-example-profile-picture-loading\n * @exampleComponent limel-example-profile-picture-image-fit\n * @exampleComponent limel-example-profile-picture-composite\n * @exampleComponent limel-example-profile-picture-resize-contain\n * @exampleComponent limel-example-profile-picture-resize-cover\n * @exampleComponent limel-example-profile-picture-resize-fallback\n * @exampleComponent limel-example-profile-picture-styling\n * @beta\n */\n@Component({\n    tag: 'limel-profile-picture',\n    shadow: true,\n    styleUrl: 'profile-picture.scss',\n})\nexport class ProfilePicture {\n    /**\n     * Defines the language for translations.\n     * Will translate the translatable strings on the components.\n     */\n    @Prop({ reflect: true })\n    public language: Languages = 'en';\n\n    /**\n     * Accessible label for the the browse button.\n     */\n    @Prop({ reflect: true })\n    public label: string;\n\n    /**\n     * Placeholder icon of the component, displayed when no image is present.\n     */\n    @Prop()\n    public icon: string | Icon = 'user';\n\n    /**\n     * Helper text shown as a tooltip on hover or focus.\n     */\n    @Prop()\n    public helperText?: string;\n\n    /**\n     * Disables user interaction.\n     * Prevents uploading new pictures or removing existing ones.\n     */\n    @Prop({ reflect: true })\n    public disabled = false;\n\n    /**\n     * Readonly prevents changing the value but allows interaction like focus.\n     */\n    @Prop({ reflect: true })\n    public readonly = false;\n\n    /**\n     * Marks the control as required.\n     */\n    @Prop({ reflect: true })\n    public required = false;\n\n    /**\n     * Marks the control as invalid.\n     */\n    @Prop({ reflect: true })\n    public invalid = false;\n\n    /**\n     * Set to `true` to put the component in the `loading` state,\n     * and render an indeterminate progress indicator inside.\n     * This does _not_ disable the interactivity of the component!\n     */\n    @Prop({ reflect: true })\n    public loading = false;\n\n    /**\n     * Current image to display. Either a URL string or a `FileInfo` with an href.\n     */\n    @Prop()\n    public value?: string | FileInfo;\n\n    /**\n     * How the image should fit within the container.\n     * - `cover` will fill the container and crop excess parts.\n     * - `contain` will scale the image to fit within the container without cropping.\n     */\n    @Prop({ reflect: true })\n    public imageFit: 'cover' | 'contain' = 'cover';\n\n    /**\n     * A comma-separated list of accepted file types.\n     */\n    @Prop({ reflect: true })\n    public accept: string =\n        'image/jpeg,image/png,image/heic,.jpg,.jpeg,.png,.heic';\n\n    /**\n     * Optional client-side resize before emitting the file.\n     * If provided, the selected image will be resized on the client device.\n     * :::note\n     * HEIC may not decode in all browsers; when decoding fails, the original\n     * file will be emitted. See the examples for more info.\n     * :::\n     */\n    @Prop()\n    public resize?: ResizeOptions;\n\n    /**\n     * Emitted when the picture changes (first FileInfo only).\n     */\n    @Event()\n    public change: EventEmitter<FileInfo | undefined>;\n\n    /**\n     * Emitted when a file is rejected by accept filter.\n     */\n    @Event()\n    public filesRejected: EventEmitter<FileInfo[]>;\n\n    @State()\n    private objectUrl?: string;\n\n    @State()\n    private imageError = false;\n\n    @State()\n    private isErrorMessagePopoverOpen = false;\n\n    private removeButtonId = createRandomString();\n    private browseButtonId = createRandomString();\n\n    public disconnectedCallback() {\n        this.revokeObjectUrl();\n    }\n\n    @Watch('value')\n    protected handleValueChange() {\n        // Clear previously created object URL when value changes\n        this.revokeObjectUrl();\n        this.imageError = false;\n\n        // If a new File without href is provided, create an object URL for preview\n        const currentValue = this.value;\n        if (\n            currentValue &&\n            typeof currentValue !== 'string' &&\n            !currentValue.href &&\n            currentValue.fileContent instanceof File\n        ) {\n            this.objectUrl = URL.createObjectURL(currentValue.fileContent);\n        }\n    }\n\n    public render() {\n        const hostClassNames = {\n            'has-image-error': this.imageError,\n        };\n\n        if (this.readonly) {\n            return <Host class={hostClassNames}>{this.renderAvatar()}</Host>;\n        }\n\n        return (\n            <Host class={hostClassNames}>\n                <limel-file-dropzone\n                    disabled={this.disabled}\n                    accept={this.accept}\n                    onFilesSelected={this.handleNewFiles}\n                    onFilesRejected={this.handleRejectedFiles}\n                >\n                    <limel-file-input\n                        accept={this.accept}\n                        disabled={this.disabled}\n                        aria-required={this.required ? 'true' : undefined}\n                        aria-invalid={this.invalid ? 'true' : undefined}\n                    >\n                        {this.renderBrowseButton()}\n                    </limel-file-input>\n                </limel-file-dropzone>\n                {this.renderClearButton()}\n                {this.renderSpinner()}\n                {this.renderErrorMessage()}\n                {this.renderHelperText()}\n            </Host>\n        );\n    }\n\n    private get hasValue(): boolean {\n        if (typeof this.value === 'string') {\n            return !!this.value;\n        }\n\n        if (this.value && (this.value.href || this.value.fileContent)) {\n            return true;\n        }\n\n        return !!this.objectUrl;\n    }\n\n    private renderBrowseButton() {\n        return (\n            <button\n                id={this.browseButtonId}\n                type=\"button\"\n                class=\"avatar\"\n                disabled={this.disabled}\n                aria-label={this.label}\n                aria-busy={this.loading ? 'true' : 'false'}\n                aria-live=\"polite\"\n            >\n                {this.renderAvatar()}\n            </button>\n        );\n    }\n\n    private renderAvatar() {\n        const src = this.getImageSrc();\n\n        if (src) {\n            return (\n                <img\n                    src={src}\n                    alt=\"\"\n                    style={{\n                        '--limel-profile-picture-object-fit': this.imageFit,\n                    }}\n                    loading=\"lazy\"\n                    onError={this.onImageError}\n                />\n            );\n        }\n\n        return this.renderIcon();\n    }\n\n    private renderIcon() {\n        const icon = getIconName(this.icon);\n\n        return (\n            <limel-icon\n                name={icon}\n                style={{\n                    color: `${(this.icon as Icon)?.color}`,\n                    'background-color': `${\n                        (this.icon as Icon)?.backgroundColor\n                    }`,\n                }}\n            />\n        );\n    }\n\n    private renderClearButton() {\n        if (!this.hasValue || this.disabled) {\n            return;\n        }\n\n        return [\n            <button\n                class=\"remove\"\n                type=\"button\"\n                id={this.removeButtonId}\n                onClick={this.handleClear}\n            />,\n            <limel-tooltip\n                label={this.getTranslation('profile-picture.remove')}\n                elementId={this.removeButtonId}\n            />,\n        ];\n    }\n\n    private renderSpinner() {\n        if (!this.loading) {\n            return;\n        }\n\n        return <limel-spinner />;\n    }\n\n    private renderHelperText = () => {\n        if (!this.helperText) {\n            return;\n        }\n\n        return (\n            <limel-tooltip\n                elementId={this.browseButtonId}\n                label={this.helperText}\n            />\n        );\n    };\n\n    // Collects derived flags used for deciding whether to show the unsupported preview message\n    private getUnsupportedPreviewContext() {\n        const currentValue = this.value;\n        const hasNoSrc = !this.getImageSrc();\n        const hasLocalFile = !!(\n            currentValue &&\n            typeof currentValue !== 'string' &&\n            currentValue.fileContent instanceof File &&\n            !currentValue.href\n        );\n        const isResizeConfigured = !!this.resize;\n\n        return { hasNoSrc, hasLocalFile, isResizeConfigured };\n    }\n\n    private shouldShowErrorMessage(): boolean {\n        const { hasNoSrc, hasLocalFile, isResizeConfigured } =\n            this.getUnsupportedPreviewContext();\n\n        return (\n            (hasNoSrc || this.imageError) && hasLocalFile && isResizeConfigured\n        );\n    }\n\n    // Shows a non-intrusive note when there is a File without href and no object URL, which\n    // can happen if the browser failed to decode the source (e.g., HEIC in Chromium).\n    private renderErrorMessage() {\n        if (!this.shouldShowErrorMessage()) {\n            return;\n        }\n\n        const errorIcon = {\n            name: 'error',\n            color: 'rgb(var(--color-orange-dark))',\n        };\n        const errorMessageStyles = {\n            maxWidth: '20rem',\n            borderRadius: '0.75rem',\n        };\n        return (\n            <limel-popover\n                open={this.isErrorMessagePopoverOpen}\n                onClick={this.openPopover}\n                onClose={this.onPopoverClose}\n            >\n                <limel-icon-button\n                    slot=\"trigger\"\n                    elevated={true}\n                    icon={errorIcon}\n                    aria-live=\"polite\"\n                    label={this.getTranslation(\n                        'profile-picture.unsupported-preview.title'\n                    )}\n                />\n                <limel-callout\n                    type=\"warning\"\n                    style={errorMessageStyles}\n                    heading={this.getTranslation(\n                        'profile-picture.unsupported-preview.title'\n                    )}\n                >\n                    {this.getTranslation(\n                        'profile-picture.unsupported-preview.description'\n                    )}\n                </limel-callout>\n            </limel-popover>\n        );\n    }\n\n    private handleNewFiles = async (event: CustomEvent<FileInfo[]>) => {\n        event.stopPropagation();\n        if (this.disabled) {\n            return;\n        }\n\n        const file = event.detail?.[0];\n        if (!file) {\n            return;\n        }\n\n        if (!isTypeAccepted(file, this.accept)) {\n            this.filesRejected.emit([file]);\n            return;\n        }\n\n        this.revokeObjectUrl();\n        this.imageError = false;\n\n        let out = file;\n\n        // Optional client-side resize\n        if (this.resize && file.fileContent instanceof File) {\n            try {\n                const processed = await resizeImage(file.fileContent, {\n                    ...this.resize,\n                    fit: this.resize.fit ?? this.imageFit,\n                });\n                out = {\n                    ...file,\n                    filename: processed.name,\n                    size: processed.size,\n                    contentType: processed.type,\n                    fileContent: processed,\n                };\n            } catch {\n                // Fall back to original file if resize fails\n                out = file;\n            }\n        }\n        // Create an object URL for immediate preview if no href present\n        if (!out.href && out.fileContent instanceof File) {\n            this.objectUrl = URL.createObjectURL(out.fileContent);\n        }\n        this.change.emit(out);\n    };\n\n    private handleRejectedFiles = (event: CustomEvent<FileInfo[]>) => {\n        event.stopPropagation();\n        this.filesRejected.emit(event.detail);\n    };\n\n    private getImageSrc(): string | undefined {\n        if (!this.value) {\n            return this.objectUrl; // Could be set from last selection before parent consumes\n        }\n\n        if (typeof this.value === 'string') {\n            return this.value;\n        }\n\n        if (this.value.href) {\n            return this.value.href;\n        }\n\n        if (this.value.fileContent instanceof File) {\n            return this.objectUrl;\n        }\n\n        return undefined;\n    }\n\n    private revokeObjectUrl() {\n        if (this.objectUrl) {\n            URL.revokeObjectURL(this.objectUrl);\n            this.objectUrl = undefined;\n        }\n    }\n\n    private handleClear = (event: Event) => {\n        event.stopPropagation();\n        this.revokeObjectUrl();\n        this.imageError = false;\n        this.change.emit(undefined);\n    };\n\n    private onImageError = () => {\n        this.imageError = true;\n    };\n\n    private openPopover = (event: MouseEvent) => {\n        event.stopPropagation();\n        this.isErrorMessagePopoverOpen = true;\n    };\n\n    private onPopoverClose = (event: CustomEvent) => {\n        event.stopPropagation();\n        this.isErrorMessagePopoverOpen = false;\n    };\n\n    private getTranslation = (key: string) => {\n        return translate.get(key, this.language);\n    };\n}\n"],"mappings":"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"}