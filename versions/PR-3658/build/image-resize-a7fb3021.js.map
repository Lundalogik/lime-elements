{"version":3,"names":["async","resizeImage","file","options","width","height","fit","type","quality","rename","name","renameWithType","source","loadSource","sx","sy","sw","sh","dx","dy","dw","dh","computeRects","canvas","createCanvas","ctx","get2dContext","clearRect","drawImage","blob","canvasToBlob","File","supportsOffscreen","globalThis","OffscreenCanvas","_a","document","createElement","getContext","alpha","Error","convertToBlob","Promise","resolve","reject","toBlob","opts","imageOrientation","createImageBitmap","error","console","debug","loadImageElement","url","URL","createObjectURL","img","Image","decoding","src","decode","call","catch","undefined","complete","cleanup","removeEventListener","onLoad","onError","e","addEventListener","revokeObjectURL","tw","th","sRatio","tRatio","cropW","cropH","drawW","drawH","ext","idx","lastIndexOf","base","slice"],"sources":["./src/util/image-resize.ts"],"sourcesContent":["/**\n * Image resize utilities\n *\n * Overview\n * --------\n * This module provides a small, dependency-free utility to resize images on the client\n * (in the browser) before uploading. It works by decoding an input `File` to an\n * `ImageBitmap` (or falling back to an `HTMLImageElement`), drawing it onto a\n * `Canvas`/`OffscreenCanvas` with the requested strategy (cover/contain), and\n * then exporting the result to a new `File` with your preferred MIME type and\n * quality.\n *\n * Why resize client-side?\n * - Faster perceived uploads and lower bandwidth usage\n * - Consistent avatar sizes and formats (e.g., JPEG 400x400)\n * - No server-side transformation required for common cases\n *\n * Fit strategies\n * - `cover` (default): The image is scaled to cover the target rectangle, and\n *   the excess parts are center-cropped. Good for avatars.\n * - `contain`: The image is scaled to fit entirely within the target rectangle\n *   without cropping, letterboxing if needed. Good when you must preserve the\n *   entire image.\n *\n * Decoding & EXIF orientation\n * EXIF orientation is a piece of metadata stored inside image files\n * (usually JPEGs) that tells image renderer software how the image should be displayed\n * i.e., whether it should be rotated or flipped. This meta data is normally added\n * to photos by digital cameras and phones.\n * - When available, `createImageBitmap(file, { imageOrientation: 'from-image' })`\n *   is used to automatically respect EXIF orientation.\n * - If not available or it fails (e.g., unsupported format), we fall back to\n *   decoding via an `HTMLImageElement`.\n *\n * OffscreenCanvas\n * - If the environment supports `OffscreenCanvas`, it will be used for the draw\n *   and encode operations for better performance in some cases. Otherwise, a\n *   regular `HTMLCanvasElement` is used.\n *\n * HEIC/HEIF notes\n * - All major browsers except Safari lack native HEIC/HEIF decoding.\n *   In such cases the `resizeImage` function will throw when decoding fails.\n *   The caller should catch and fall back\n *   to using the original file or handle conversion on the server.\n * - If we need guaranteed client-side HEIC->JPEG conversion, we must add a small\n *   library or WASM module; this utility intentionally avoids extra dependencies.\n *\n * Output type & quality\n * - Default output is `image/jpeg` with `quality=0.85`, which is typically\n *   appropriate for avatars. You can switch to `image/png` to preserve\n *   transparency.\n * - The output filename extension is adjusted to match the chosen MIME type by\n *   default (e.g., `.jpg` or `.png`). You can override naming via the `rename`\n *   option.\n *\n * Error handling\n * - Throws if canvas/context cannot be created or if canvas->blob conversion fails.\n * - Decoding failures (unsupported type) will throw; caller can try/catch and\n *   fall back to the original file.\n *\n * Performance tips\n * - Keep target sizes reasonable (e.g., 256–1024 px) to avoid long processing\n *   times on modest devices.\n * - JPEG with quality 0.8–0.9 often strikes a good balance between size and\n *   perceived quality for photos/avatars.\n *\n * Usage examples\n * --------------\n * Basic usage:\n * ```ts\n * import { resizeImage } from '@limetech/lime-elements/util/image-resize';\n *\n * const processed = await resizeImage(file, {\n *   width: 400,\n *   height: 400,\n *   fit: 'cover',         // default; center-crops\n *   type: 'image/jpeg',   // default\n *   quality: 0.85,        // default\n * });\n * // Upload `processed` instead of the original file\n * ```\n *\n * With custom naming:\n * ```ts\n * const processed = await resizeImage(file, {\n *   width: 800,\n *   height: 800,\n *   fit: 'contain',\n *   type: 'image/png',\n *   rename: (name) => name.replace(/\\.[^.]+$/, '') + '_resized.png',\n * });\n * ```\n *\n * In a Stencil component (simplified):\n * ```tsx\n * private async handleFilesSelected(file: File) {\n *   try {\n *     const resized = await resizeImage(file, { width: 400, height: 400 });\n *     // build your FileInfo and emit\n *   } catch {\n *     // fall back to original\n *   }\n * }\n * ```\n */\n/**\n * How the source image should fit into the target rectangle.\n * @public\n */\nexport type ResizeFit = 'cover' | 'contain';\n\n/**\n * Options for client-side image resizing.\n * @public\n */\nexport type ResizeOptions = {\n    /** Target width in CSS pixels. */\n    width: number;\n    /** Target height in CSS pixels. */\n    height: number;\n    /** Fit strategy; defaults to 'cover'. */\n    fit?: ResizeFit;\n    /** Output MIME type; 'image/jpeg' by default. */\n    type?: 'image/jpeg' | 'image/png';\n    /** JPEG quality (0..1); used only for 'image/jpeg'. Defaults to 0.85. */\n    quality?: number;\n    /** Optional renaming function. Defaults to changing extension to match MIME. */\n    rename?: (originalName: string) => string;\n};\n\ntype SourceLike = ImageBitmap | HTMLImageElement;\n\n/**\n * Resize an image file on the client using Canvas/OffscreenCanvas.\n * Returns a new File with the requested format and dimensions.\n *\n * Contract\n * - Input: image `File`\n * - Output: resized image as a new `File` with updated `type`, name, and size\n * - Errors: may throw on decode failure or canvas export failure\n *\n * @public\n * @param file - The image file to resize.\n * @param options - Configuration for the resize operation.\n */\nexport async function resizeImage(\n    file: File,\n    options: ResizeOptions\n): Promise<File> {\n    const {\n        width,\n        height,\n        fit = 'cover',\n        type = 'image/jpeg',\n        quality = 0.85,\n        rename = (name: string) => renameWithType(name, type),\n    } = options;\n\n    const source = await loadSource(file);\n    const { sx, sy, sw, sh, dx, dy, dw, dh } = computeRects(\n        source.width as number,\n        source.height as number,\n        width,\n        height,\n        fit\n    );\n\n    const canvas = createCanvas(width, height);\n    const ctx = get2dContext(canvas);\n    ctx.clearRect(0, 0, width, height);\n    ctx.drawImage(source, sx, sy, sw, sh, dx, dy, dw, dh);\n\n    const blob = await canvasToBlob(canvas, type, quality);\n    const name = rename(file.name);\n    return new File([blob], name, { type });\n}\n\n/** Whether OffscreenCanvas is available in the current environment. */\nfunction supportsOffscreen(): boolean {\n    try {\n        return typeof (globalThis as any).OffscreenCanvas === 'function';\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Create either an OffscreenCanvas or a regular canvas for drawing.\n * @param width - Target width\n * @param height - Target height\n */\nfunction createCanvas(\n    width: number,\n    height: number\n): HTMLCanvasElement | OffscreenCanvas {\n    if (supportsOffscreen()) {\n        return new (globalThis as any).OffscreenCanvas(width, height);\n    }\n\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n}\n\n/**\n * Get the 2D rendering context, throwing a descriptive error if unavailable.\n * @param canvas - The canvas to get context from\n */\nfunction get2dContext(canvas: HTMLCanvasElement | OffscreenCanvas) {\n    const ctx = (canvas as any).getContext('2d', { alpha: true });\n    if (!ctx) {\n        throw new Error('2D canvas context not available');\n    }\n\n    return ctx as CanvasRenderingContext2D;\n}\n\n/**\n * Convert the canvas content to a Blob, supporting both canvas types.\n * @param canvas - The source canvas\n * @param type - Output MIME type\n * @param quality - JPEG quality (0..1)\n */\nfunction canvasToBlob(\n    canvas: HTMLCanvasElement | OffscreenCanvas,\n    type: string,\n    quality: number\n): Promise<Blob> {\n    if ('convertToBlob' in canvas) {\n        return (canvas as OffscreenCanvas).convertToBlob({ type, quality });\n    }\n\n    return new Promise((resolve, reject) => {\n        (canvas as HTMLCanvasElement).toBlob(\n            (blob) => {\n                if (!blob) {\n                    reject(new Error('Failed to create blob from canvas'));\n                    return;\n                }\n                resolve(blob);\n            },\n            type,\n            quality\n        );\n    });\n}\n\n/**\n * Load the image into a decodable source (ImageBitmap preferred).\n * @param file - The input file to decode\n */\n\nasync function loadSource(file: File): Promise<SourceLike> {\n    if ('createImageBitmap' in globalThis) {\n        try {\n            const opts: unknown = { imageOrientation: 'from-image' };\n            return await createImageBitmap(file, opts as any);\n        } catch (error) {\n            // Log for debugging, but continue with fallback\n            console.debug(\n                'createImageBitmap failed, falling back to HTMLImageElement:',\n                error\n            );\n        }\n    }\n\n    return await loadImageElement(file);\n}\n\n/**\n * Decode an image file via HTMLImageElement when ImageBitmap is unavailable.\n * @param file - The input file to decode\n */\nasync function loadImageElement(file: File): Promise<HTMLImageElement> {\n    const url = URL.createObjectURL(file);\n    try {\n        const img = new Image();\n        img.decoding = 'sync';\n        img.src = url;\n        await img.decode?.().catch(() => undefined);\n        if (!img.complete) {\n            await new Promise<void>((resolve, reject) => {\n                const cleanup = () => {\n                    img.removeEventListener('load', onLoad);\n                    img.removeEventListener('error', onError);\n                };\n\n                const onLoad = () => {\n                    cleanup();\n                    resolve();\n                };\n                const onError = (e: Event) => {\n                    cleanup();\n                    reject(e);\n                };\n\n                img.addEventListener('load', onLoad);\n                img.addEventListener('error', onError);\n            });\n        }\n        return img;\n    } finally {\n        URL.revokeObjectURL(url);\n    }\n}\n\n/**\n * Compute source and destination rectangles for drawImage based on the fit mode.\n *\n * Returns sx, sy, sw, sh for the source crop/area and dx, dy, dw, dh for the\n * destination rectangle on the target canvas.\n *\n * @param sw - Source width\n * @param sh - Source height\n * @param tw - Target width\n * @param th - Target height\n * @param fit - Fit mode (cover/contain)\n */\nfunction computeRects(\n    sw: number,\n    sh: number,\n    tw: number,\n    th: number,\n    fit: ResizeFit\n) {\n    const sRatio = sw / sh;\n    const tRatio = tw / th;\n\n    if (fit === 'cover') {\n        // scale source to cover target, then center-crop\n        let cropW: number;\n        let cropH: number;\n        if (sRatio > tRatio) {\n            // source is wider than target: crop width\n            cropH = sh;\n            cropW = sh * tRatio;\n        } else {\n            // source is taller than target: crop height\n            cropW = sw;\n            cropH = sw / tRatio;\n        }\n        const sx = (sw - cropW) / 2;\n        const sy = (sh - cropH) / 2;\n        return { sx, sy, sw: cropW, sh: cropH, dx: 0, dy: 0, dw: tw, dh: th };\n    }\n\n    // contain: fit inside, letterbox if needed\n    let drawW: number;\n    let drawH: number;\n    if (sRatio > tRatio) {\n        drawW = tw;\n        drawH = tw / sRatio;\n    } else {\n        drawH = th;\n        drawW = th * sRatio;\n    }\n    const dx = (tw - drawW) / 2;\n    const dy = (th - drawH) / 2;\n\n    return { sx: 0, sy: 0, sw, sh, dx, dy, dw: drawW, dh: drawH };\n}\n\n/**\n * Update filename extension to match the desired MIME type.\n * @param name - Original filename\n * @param type - Output MIME type\n */\nfunction renameWithType(name: string, type: string): string {\n    const ext = type === 'image/png' ? 'png' : 'jpg';\n    const idx = name.lastIndexOf('.');\n    const base = idx > 0 ? name.slice(0, idx) : name;\n    return `${base}.${ext}`;\n}\n"],"mappings":"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"}