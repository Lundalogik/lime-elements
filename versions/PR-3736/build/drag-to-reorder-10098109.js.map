{"version":3,"names":["DEFAULT_DRAGGING_CLASS","DEFAULT_CONTAINER_CLASS","DEFAULT_DROP_ELEVATION_CLASS","DEFAULT_DROP_ELEVATION_DURATION","DEFAULT_ORIENTATION","dragToReorder","options","container","Error","itemSelector","dragHandleSelector","onPreview","onFinalize","draggingClass","containerActiveClass","containerDraggingClass","dropElevationClass","dropElevationDuration","_a","orientation","_b","getItemId","item","dataset","reorderId","undefined","activeDrag","previousUserSelect","previousCursor","dropElevationTimeout","dropElevationTarget","getItemElements","querySelectorAll","pointerDownListener","event","pointerType","button","target","handle","closest","HTMLElement","items","originalIndex","indexOf","stopPropagation","preventDefault","clearTimeout","classList","remove","pointerId","currentIndex","id","setPointerCapture","call","document","body","style","userSelect","cursor","add","onStart","index","addEventListener","pointerMoveListener","passive","pointerUpListener","pointerCancelListener","length","pointerPosition","clientY","clientX","targetIndex","element","rect","getBoundingClientRect","threshold","top","height","left","width","fromIndex","toIndex","finalizeDrag","cancelled","state","releasePointerCapture","removeEventListener","itemToReset","globalThis","setTimeout","destroy"],"sources":["./src/util/drag-to-reorder.ts"],"sourcesContent":["/**\n * Detail payload emitted when a drag reordering gesture starts.\n * `index` represents the position of the item among the filtered reorderable nodes.\n */\nexport interface DragToReorderStartDetail {\n    index: number;\n    item: HTMLElement;\n    id?: string;\n}\n\n/**\n * Detail payload representing a preview move while the pointer is still held.\n * Consumers should update their temporary DOM state to mirror the visual reorder.\n */\nexport interface DragToReorderPreviewDetail {\n    fromIndex: number;\n    toIndex: number;\n    item: HTMLElement;\n    id?: string;\n}\n\n/**\n * Detail payload describing the final outcome of a drag interaction.\n * `cancelled` indicates whether the gesture ended normally or aborted mid-way.\n */\nexport interface DragToReorderFinalizeDetail {\n    fromIndex: number;\n    toIndex: number;\n    item: HTMLElement;\n    id?: string;\n    cancelled: boolean;\n}\n\n/**\n * Configuration for the drag-to-reorder helper.\n * `itemSelector` and `dragHandleSelector` should both resolve inside `container`.\n */\nexport interface DragToReorderOptions {\n    container: HTMLElement;\n    itemSelector: string;\n    dragHandleSelector: string;\n    draggingClass?: string;\n    /** Class toggled on the container while a drag is active. */\n    containerDraggingClass?: string;\n    /** Class applied briefly when an item is dropped to highlight the new position. */\n    dropElevationClass?: string;\n    /** Duration in milliseconds before removing the drop elevation class (defaults to 1000ms). */\n    dropElevationDuration?: number;\n    /** Axis used to calculate the new drop position. Defaults to `vertical`. */\n    orientation?: 'vertical' | 'horizontal';\n    getItemId?: (item: HTMLElement) => string | undefined;\n    onStart?: (detail: DragToReorderStartDetail) => void;\n    onPreview: (detail: DragToReorderPreviewDetail) => void;\n    onFinalize: (detail: DragToReorderFinalizeDetail) => void;\n}\n\nexport interface DragToReorderController {\n    destroy(): void;\n}\n\ninterface ActiveDragState {\n    pointerId: number;\n    handle: HTMLElement;\n    item: HTMLElement;\n    originalIndex: number;\n    currentIndex: number;\n    id?: string;\n}\n\nconst DEFAULT_DRAGGING_CLASS = 'is-being-dragged';\nconst DEFAULT_CONTAINER_CLASS = 'has-an-item-which-is-being-dragged';\nconst DEFAULT_DROP_ELEVATION_CLASS = 'is-elevated';\nconst DEFAULT_DROP_ELEVATION_DURATION = 1000;\nconst DEFAULT_ORIENTATION: Required<DragToReorderOptions>['orientation'] =\n    'vertical';\n\n/**\n * Drag to reorder utility\n *\n * Lightweight pointer-driven drag helper for list-like layouts.\n * Keeps responsibilities split: this utility handles pointer + DOM bookkeeping,\n * while the caller owns rendering state updates through the supplied callbacks.\n *\n * ## Usage notes\n * - This helper uses low-level `pointer*` events instead of the native HTML Drag & Drop API,\n *   which makes behavior consistent across mouse, touch, and stylus input; and avoids\n *   many of the quirks and limitations of the native API.\n * - The helper relies on CSS selectors to identify both the draggable items and the\n *   drag handles within them. This allows consumers to define complex item structures\n *   with specific drag handles (e.g. an icon button) without requiring extra markup\n *   or event listeners.\n * - By default items are treated as a vertical list (drop target is derived from\n *   the pointer's Y position). Set `orientation: 'horizontal'` to track X\n *   positions instead when working with horizontally arranged items.\n * - A CSS class (defaults to `is-being-dragged`) is applied to the active item. Consumers\n *   should style this class inside their component Shadow DOM (e.g. add elevation) to\n *   communicate movement. The container simultaneously receives `has-an-item-which-is-being-dragged`\n *   (override via `containerDraggingClass`) in case you want to highlight the entire drop zone.\n * - While dragging the item also gets `is-elevated` (override via `dropElevationClass`). The class\n *   remains for one second after drop to give styles time to gracefully transition back.\n * - The helper temporarily sets `document.body.style.userSelect` and `.cursor` to prevent\n *   text selection and enforce a grabbing cursor during the interaction. Components do not need\n *   to manage these resets themselves — they are restored automatically when the drag ends.\n * - Call `dragToReorder({ ... })` in `componentDidLoad` (or equivalent) and keep a reference to\n *   the returned controller so you can invoke `destroy()` when your component unmounts.\n * - Use the `onPreview` callback to mirror the current visual ordering (e.g. reorder rows in state)\n *   and `onFinalize` to persist the change or revert when `cancelled` is true.\n */\n\n/**\n * Enable drag-and-drop style reordering for list-like DOM structures.\n *\n * @param options configuration for drag behavior and callbacks\n */\nexport function dragToReorder(\n    options: DragToReorderOptions\n): DragToReorderController {\n    if (!options?.container) {\n        throw new Error(\n            'Error in `dragToReorder`: Required option `container` is missing.'\n        );\n    }\n\n    if (!options.itemSelector) {\n        throw new Error(\n            'Error in `dragToReorder`: Required option `itemSelector` is missing.'\n        );\n    }\n\n    if (!options.dragHandleSelector) {\n        throw new Error(\n            'Error in `dragToReorder`: Required option `dragHandleSelector` is missing.'\n        );\n    }\n\n    if (!options.onPreview) {\n        throw new Error(\n            'Error in `dragToReorder`: Required option `onPreview` is missing.'\n        );\n    }\n\n    if (!options.onFinalize) {\n        throw new Error(\n            'Error in `dragToReorder`: Required option `onFinalize` is missing.'\n        );\n    }\n\n    const draggingClass = options.draggingClass || DEFAULT_DRAGGING_CLASS;\n    const containerActiveClass =\n        options.containerDraggingClass || DEFAULT_CONTAINER_CLASS;\n    const dropElevationClass =\n        options.dropElevationClass || DEFAULT_DROP_ELEVATION_CLASS;\n    const dropElevationDuration =\n        options.dropElevationDuration ?? DEFAULT_DROP_ELEVATION_DURATION;\n    const orientation = options.orientation ?? DEFAULT_ORIENTATION;\n    const getItemId =\n        options.getItemId ||\n        ((item: HTMLElement) => item.dataset.reorderId || undefined);\n\n    let activeDrag: ActiveDragState | undefined;\n    let previousUserSelect: string | undefined;\n    let previousCursor: string | undefined;\n    let dropElevationTimeout: ReturnType<typeof setTimeout> | undefined;\n    let dropElevationTarget: HTMLElement | undefined;\n\n    const getItemElements = () => {\n        return [\n            ...options.container.querySelectorAll(options.itemSelector),\n        ] as HTMLElement[];\n    };\n\n    // Activate dragging only when pressing a recognized handle inside the container\n    const pointerDownListener = (event: PointerEvent) => {\n        if (\n            event.pointerType === 'mouse' &&\n            'button' in event &&\n            event.button !== 0\n        ) {\n            return;\n        }\n\n        const target = event.target as HTMLElement;\n        if (!target) {\n            return;\n        }\n\n        const handle = target.closest(options.dragHandleSelector);\n        if (!(handle instanceof HTMLElement)) {\n            return;\n        }\n\n        const item = handle.closest(options.itemSelector);\n        if (!(item instanceof HTMLElement)) {\n            return;\n        }\n\n        const items = getItemElements();\n        const originalIndex = items.indexOf(item);\n        if (originalIndex === -1) {\n            return;\n        }\n\n        event.stopPropagation();\n        event.preventDefault();\n\n        if (dropElevationTimeout !== undefined) {\n            clearTimeout(dropElevationTimeout);\n            dropElevationTimeout = undefined;\n        }\n        if (dropElevationTarget) {\n            dropElevationTarget.classList.remove(dropElevationClass);\n            dropElevationTarget = undefined;\n        }\n\n        activeDrag = {\n            pointerId: event.pointerId,\n            handle,\n            item,\n            originalIndex,\n            currentIndex: originalIndex,\n            id: getItemId(item),\n        };\n\n        handle.setPointerCapture?.(event.pointerId);\n        previousUserSelect = document.body.style.userSelect;\n        document.body.style.userSelect = 'none';\n        previousCursor = document.body.style.cursor;\n        document.body.style.cursor = 'grabbing';\n        item.classList.add(dropElevationClass, draggingClass);\n        options.container.classList.add(containerActiveClass);\n\n        options.onStart?.({\n            index: originalIndex,\n            item,\n            id: activeDrag.id,\n        });\n\n        // Listen on the document to keep tracking even when the pointer leaves the list\n        document.addEventListener('pointermove', pointerMoveListener, {\n            passive: false,\n        });\n        document.addEventListener('pointerup', pointerUpListener);\n        document.addEventListener('pointercancel', pointerCancelListener);\n    };\n\n    // Calculate which item the pointer hovers over and inform the consumer\n    const pointerMoveListener = (event: PointerEvent) => {\n        if (!activeDrag) {\n            return;\n        }\n\n        event.preventDefault();\n\n        const items = getItemElements();\n        if (items.length === 0) {\n            return;\n        }\n\n        const pointerPosition =\n            orientation === 'vertical' ? event.clientY : event.clientX;\n        let targetIndex = items.length - 1;\n\n        let index = 0;\n        for (const element of items) {\n            const rect = element.getBoundingClientRect();\n            const threshold =\n                orientation === 'vertical'\n                    ? rect.top + rect.height / 2\n                    : rect.left + rect.width / 2;\n            if (pointerPosition < threshold) {\n                targetIndex = index;\n                break;\n            }\n            index += 1;\n        }\n\n        if (targetIndex < 0) {\n            targetIndex = 0;\n        }\n\n        if (targetIndex === activeDrag.currentIndex) {\n            return;\n        }\n\n        options.onPreview({\n            fromIndex: activeDrag.currentIndex,\n            toIndex: targetIndex,\n            item: activeDrag.item,\n            id: activeDrag.id,\n        });\n\n        activeDrag.currentIndex = targetIndex;\n    };\n\n    // Clean up listeners, restore styles, and let the consumer decide how to persist\n    const finalizeDrag = (cancelled: boolean) => {\n        if (!activeDrag) {\n            return;\n        }\n\n        const state = activeDrag;\n        activeDrag = undefined;\n\n        state.handle.releasePointerCapture?.(state.pointerId);\n        state.item.classList.remove(draggingClass);\n        options.container.classList.remove(containerActiveClass);\n\n        document.body.style.userSelect = previousUserSelect ?? '';\n        previousUserSelect = undefined;\n        document.body.style.cursor = previousCursor ?? '';\n        previousCursor = undefined;\n\n        document.removeEventListener('pointermove', pointerMoveListener);\n        document.removeEventListener('pointerup', pointerUpListener);\n        document.removeEventListener('pointercancel', pointerCancelListener);\n\n        options.onFinalize({\n            fromIndex: state.originalIndex,\n            toIndex: state.currentIndex,\n            item: state.item,\n            id: state.id,\n            cancelled,\n        });\n\n        if (dropElevationTimeout !== undefined) {\n            clearTimeout(dropElevationTimeout);\n            dropElevationTimeout = undefined;\n        }\n\n        if (cancelled || dropElevationDuration <= 0) {\n            state.item.classList.remove(dropElevationClass);\n            if (dropElevationTarget === state.item) {\n                dropElevationTarget = undefined;\n            }\n            return;\n        }\n\n        dropElevationTarget = state.item;\n        const itemToReset = state.item;\n        dropElevationTimeout = globalThis.setTimeout(() => {\n            itemToReset.classList.remove(dropElevationClass);\n            if (dropElevationTarget === itemToReset) {\n                dropElevationTarget = undefined;\n            }\n            dropElevationTimeout = undefined;\n        }, dropElevationDuration);\n    };\n\n    // Pointer released normally – treat as a completed reorder\n    const pointerUpListener = (event: PointerEvent) => {\n        if (!activeDrag || event.pointerId !== activeDrag.pointerId) {\n            return;\n        }\n\n        event.preventDefault();\n        finalizeDrag(false);\n    };\n\n    // Browser or OS cancelled the pointer sequence – revert to the snapshot state\n    const pointerCancelListener = (event: PointerEvent) => {\n        if (!activeDrag || event.pointerId !== activeDrag.pointerId) {\n            return;\n        }\n\n        finalizeDrag(true);\n    };\n\n    options.container.addEventListener('pointerdown', pointerDownListener);\n\n    // Allow the caller to tear down the helper, useful when the list unmounts\n    const destroy = () => {\n        options.container.removeEventListener(\n            'pointerdown',\n            pointerDownListener\n        );\n        if (activeDrag) {\n            finalizeDrag(true);\n        }\n\n        if (dropElevationTimeout !== undefined) {\n            clearTimeout(dropElevationTimeout);\n            dropElevationTimeout = undefined;\n        }\n\n        if (dropElevationTarget) {\n            dropElevationTarget.classList.remove(dropElevationClass);\n            dropElevationTarget = undefined;\n        }\n    };\n\n    return {\n        destroy,\n    };\n}\n"],"mappings":"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"}