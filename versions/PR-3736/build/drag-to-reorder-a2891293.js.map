{"version":3,"names":["DEFAULT_DRAGGING_CLASS","DEFAULT_CONTAINER_CLASS","DEFAULT_DROP_ELEVATION_CLASS","DEFAULT_DROP_ELEVATION_DURATION","DEFAULT_ORIENTATION","dragToReorder","options","container","Error","itemSelector","dragHandleSelector","onPreview","onFinalize","draggingClass","containerActiveClass","containerDraggingClass","dropElevationClass","dropElevationDuration","_a","orientation","_b","getItemId","item","dataset","reorderId","undefined","activeDrag","previousUserSelect","previousCursor","dropElevationTimeout","dropElevationTarget","getItemElements","querySelectorAll","pointerDownListener","event","pointerType","button","target","handle","closest","items","originalIndex","indexOf","preventDefault","clearTimeout","classList","remove","pointerId","currentIndex","id","setPointerCapture","call","document","body","style","userSelect","cursor","add","onStart","index","addEventListener","pointerMoveListener","passive","pointerUpListener","pointerCancelListener","length","pointerPosition","clientY","clientX","targetIndex","element","rect","getBoundingClientRect","threshold","top","height","left","width","fromIndex","toIndex","finalizeDrag","cancelled","state","releasePointerCapture","removeEventListener","itemToReset","window","setTimeout","destroy"],"sources":["./src/util/drag-to-reorder.ts"],"sourcesContent":["/**\n * Detail payload emitted when a drag reordering gesture starts.\n * `index` represents the position of the item among the filtered reorderable nodes.\n */\nexport interface DragToReorderStartDetail {\n    index: number;\n    item: HTMLElement;\n    id?: string;\n}\n\n/**\n * Detail payload representing a preview move while the pointer is still held.\n * Consumers should update their temporary DOM state to mirror the visual reorder.\n */\nexport interface DragToReorderPreviewDetail {\n    fromIndex: number;\n    toIndex: number;\n    item: HTMLElement;\n    id?: string;\n}\n\n/**\n * Detail payload describing the final outcome of a drag interaction.\n * `cancelled` indicates whether the gesture ended normally or aborted mid-way.\n */\nexport interface DragToReorderFinalizeDetail {\n    fromIndex: number;\n    toIndex: number;\n    item: HTMLElement;\n    id?: string;\n    cancelled: boolean;\n}\n\n/**\n * Configuration for the drag-to-reorder helper.\n * `itemSelector` and `dragHandleSelector` should both resolve inside `container`.\n */\nexport interface DragToReorderOptions {\n    container: HTMLElement;\n    itemSelector: string;\n    dragHandleSelector: string;\n    draggingClass?: string;\n    /** Class toggled on the container while a drag is active. */\n    containerDraggingClass?: string;\n    /** Class applied briefly when an item is dropped to highlight the new position. */\n    dropElevationClass?: string;\n    /** Duration in milliseconds before removing the drop elevation class (defaults to 1000ms). */\n    dropElevationDuration?: number;\n    /** Axis used to calculate the new drop position. Defaults to `vertical`. */\n    orientation?: 'vertical' | 'horizontal';\n    getItemId?: (item: HTMLElement) => string | undefined;\n    onStart?: (detail: DragToReorderStartDetail) => void;\n    onPreview: (detail: DragToReorderPreviewDetail) => void;\n    onFinalize: (detail: DragToReorderFinalizeDetail) => void;\n}\n\nexport interface DragToReorderController {\n    destroy(): void;\n}\n\ninterface ActiveDragState {\n    pointerId: number;\n    handle: HTMLElement;\n    item: HTMLElement;\n    originalIndex: number;\n    currentIndex: number;\n    id?: string;\n}\n\nconst DEFAULT_DRAGGING_CLASS = 'is-being-dragged';\nconst DEFAULT_CONTAINER_CLASS = 'has-an-item-which-is-being-dragged';\nconst DEFAULT_DROP_ELEVATION_CLASS = 'is-elevated';\nconst DEFAULT_DROP_ELEVATION_DURATION = 1000;\nconst DEFAULT_ORIENTATION: Required<DragToReorderOptions>['orientation'] =\n    'vertical';\n\n/**\n * Drag to reorder utility\n *\n * Lightweight pointer-driven drag helper for list-like layouts.\n * Keeps responsibilities split: this utility handles pointer + DOM bookkeeping,\n * while the caller owns rendering state updates through the supplied callbacks.\n *\n * ## Usage notes\n * - This helper uses low-level `pointer*` events instead of the native HTML Drag & Drop API,\n *   which makes behavior consistent across mouse, touch, and stylus input; and avoids\n *   many of the quirks and limitations of the native API.\n * - The helper relies on CSS selectors to identify both the draggable items and the\n *   drag handles within them. This allows consumers to define complex item structures\n *   with specific drag handles (e.g. an icon button) without requiring extra markup\n *   or event listeners.\n * - By default items are treated as a vertical list (drop target is derived from\n *   the pointer's Y position). Set `orientation: 'horizontal'` to track X\n *   positions instead when working with horizontally arranged items.\n * - A CSS class (defaults to `is-being-dragged`) is applied to the active item. Consumers\n *   should style this class inside their component Shadow DOM (e.g. add elevation) to\n *   communicate movement. The container simultaneously receives `has-an-item-which-is-being-dragged`\n *   (override via `containerDraggingClass`) in case you want to highlight the entire drop zone.\n * - While dragging the item also gets `is-elevated` (override via `dropElevationClass`). The class\n *   remains for one second after drop to give styles time to gracefully transition back.\n * - The helper temporarily sets `document.body.style.userSelect` and `.cursor` to prevent\n *   text selection and enforce a grabbing cursor during the interaction. Components do not need\n *   to manage these resets themselves — they are restored automatically when the drag ends.\n * - Call `dragToReorder({ ... })` in `componentDidLoad` (or equivalent) and keep a reference to\n *   the returned controller so you can invoke `destroy()` when your component unmounts.\n * - Use the `onPreview` callback to mirror the current visual ordering (e.g. reorder rows in state)\n *   and `onFinalize` to persist the change or revert when `cancelled` is true.\n */\n\n/**\n * Enable drag-and-drop style reordering for list-like DOM structures.\n *\n * @param options configuration for drag behavior and callbacks\n */\nexport function dragToReorder(\n    options: DragToReorderOptions\n): DragToReorderController {\n    if (!options?.container) {\n        throw new Error(\n            'Error in `dragToReorder`: Required option `container` is missing.'\n        );\n    }\n\n    if (!options.itemSelector) {\n        throw new Error(\n            'Error in `dragToReorder`: Required option `itemSelector` is missing.'\n        );\n    }\n\n    if (!options.dragHandleSelector) {\n        throw new Error(\n            'Error in `dragToReorder`: Required option `dragHandleSelector` is missing.'\n        );\n    }\n\n    if (!options.onPreview) {\n        throw new Error(\n            'Error in `dragToReorder`: Required option `onPreview` is missing.'\n        );\n    }\n\n    if (!options.onFinalize) {\n        throw new Error(\n            'Error in `dragToReorder`: Required option `onFinalize` is missing.'\n        );\n    }\n\n    const draggingClass = options.draggingClass || DEFAULT_DRAGGING_CLASS;\n    const containerActiveClass =\n        options.containerDraggingClass || DEFAULT_CONTAINER_CLASS;\n    const dropElevationClass =\n        options.dropElevationClass || DEFAULT_DROP_ELEVATION_CLASS;\n    const dropElevationDuration =\n        options.dropElevationDuration ?? DEFAULT_DROP_ELEVATION_DURATION;\n    const orientation = options.orientation ?? DEFAULT_ORIENTATION;\n    const getItemId =\n        options.getItemId ||\n        ((item: HTMLElement) => item.dataset.reorderId || undefined);\n\n    let activeDrag: ActiveDragState | undefined;\n    let previousUserSelect: string | undefined;\n    let previousCursor: string | undefined;\n    let dropElevationTimeout: number | undefined;\n    let dropElevationTarget: HTMLElement | undefined;\n\n    const getItemElements = () => {\n        return [\n            ...options.container.querySelectorAll(options.itemSelector),\n        ] as HTMLElement[];\n    };\n\n    // Activate dragging only when pressing a recognized handle inside the container\n    const pointerDownListener = (event: PointerEvent) => {\n        if (\n            event.pointerType === 'mouse' &&\n            'button' in event &&\n            event.button !== 0\n        ) {\n            return;\n        }\n\n        const target = event.target as HTMLElement;\n        if (!target) {\n            return;\n        }\n\n        const handle = target.closest(\n            options.dragHandleSelector\n        ) as HTMLElement;\n        if (!handle) {\n            return;\n        }\n\n        const item = handle.closest(options.itemSelector) as HTMLElement;\n        if (!item) {\n            return;\n        }\n\n        const items = getItemElements();\n        const originalIndex = items.indexOf(item);\n        if (originalIndex === -1) {\n            return;\n        }\n\n        event.preventDefault();\n\n        if (dropElevationTimeout !== undefined) {\n            clearTimeout(dropElevationTimeout);\n            dropElevationTimeout = undefined;\n        }\n        if (dropElevationTarget) {\n            dropElevationTarget.classList.remove(dropElevationClass);\n            dropElevationTarget = undefined;\n        }\n\n        activeDrag = {\n            pointerId: event.pointerId,\n            handle,\n            item,\n            originalIndex,\n            currentIndex: originalIndex,\n            id: getItemId(item),\n        };\n\n        handle.setPointerCapture?.(event.pointerId);\n        previousUserSelect = document.body.style.userSelect;\n        document.body.style.userSelect = 'none';\n        previousCursor = document.body.style.cursor;\n        document.body.style.cursor = 'grabbing';\n        item.classList.add(dropElevationClass, draggingClass);\n        options.container.classList.add(containerActiveClass);\n\n        options.onStart?.({\n            index: originalIndex,\n            item,\n            id: activeDrag.id,\n        });\n\n        // Listen on the document to keep tracking even when the pointer leaves the list\n        document.addEventListener('pointermove', pointerMoveListener, {\n            passive: false,\n        });\n        document.addEventListener('pointerup', pointerUpListener);\n        document.addEventListener('pointercancel', pointerCancelListener);\n    };\n\n    // Calculate which item the pointer hovers over and inform the consumer\n    const pointerMoveListener = (event: PointerEvent) => {\n        if (!activeDrag) {\n            return;\n        }\n\n        event.preventDefault();\n\n        const items = getItemElements();\n        if (items.length === 0) {\n            return;\n        }\n\n        const pointerPosition =\n            orientation === 'vertical' ? event.clientY : event.clientX;\n        let targetIndex = items.length - 1;\n\n        let index = 0;\n        for (const element of items) {\n            const rect = element.getBoundingClientRect();\n            const threshold =\n                orientation === 'vertical'\n                    ? rect.top + rect.height / 2\n                    : rect.left + rect.width / 2;\n            if (pointerPosition < threshold) {\n                targetIndex = index;\n                break;\n            }\n            index += 1;\n        }\n\n        if (targetIndex < 0) {\n            targetIndex = 0;\n        }\n\n        if (targetIndex === activeDrag.currentIndex) {\n            return;\n        }\n\n        options.onPreview({\n            fromIndex: activeDrag.currentIndex,\n            toIndex: targetIndex,\n            item: activeDrag.item,\n            id: activeDrag.id,\n        });\n\n        activeDrag.currentIndex = targetIndex;\n    };\n\n    // Clean up listeners, restore styles, and let the consumer decide how to persist\n    const finalizeDrag = (cancelled: boolean) => {\n        if (!activeDrag) {\n            return;\n        }\n\n        const state = activeDrag;\n        activeDrag = undefined;\n\n        state.handle.releasePointerCapture?.(state.pointerId);\n        state.item.classList.remove(draggingClass);\n        options.container.classList.remove(containerActiveClass);\n\n        document.body.style.userSelect = previousUserSelect ?? '';\n        previousUserSelect = undefined;\n        document.body.style.cursor = previousCursor ?? '';\n        previousCursor = undefined;\n\n        document.removeEventListener('pointermove', pointerMoveListener);\n        document.removeEventListener('pointerup', pointerUpListener);\n        document.removeEventListener('pointercancel', pointerCancelListener);\n\n        options.onFinalize({\n            fromIndex: state.originalIndex,\n            toIndex: state.currentIndex,\n            item: state.item,\n            id: state.id,\n            cancelled,\n        });\n\n        if (dropElevationTimeout !== undefined) {\n            clearTimeout(dropElevationTimeout);\n            dropElevationTimeout = undefined;\n        }\n\n        if (cancelled || dropElevationDuration <= 0) {\n            state.item.classList.remove(dropElevationClass);\n            if (dropElevationTarget === state.item) {\n                dropElevationTarget = undefined;\n            }\n            return;\n        }\n\n        dropElevationTarget = state.item;\n        const itemToReset = state.item;\n        dropElevationTimeout = window.setTimeout(() => {\n            itemToReset.classList.remove(dropElevationClass);\n            if (dropElevationTarget === itemToReset) {\n                dropElevationTarget = undefined;\n            }\n            dropElevationTimeout = undefined;\n        }, dropElevationDuration);\n    };\n\n    // Pointer released normally – treat as a completed reorder\n    const pointerUpListener = (event: PointerEvent) => {\n        if (!activeDrag || event.pointerId !== activeDrag.pointerId) {\n            return;\n        }\n\n        event.preventDefault();\n        finalizeDrag(false);\n    };\n\n    // Browser or OS cancelled the pointer sequence – revert to the snapshot state\n    const pointerCancelListener = (event: PointerEvent) => {\n        if (!activeDrag || event.pointerId !== activeDrag.pointerId) {\n            return;\n        }\n\n        finalizeDrag(true);\n    };\n\n    options.container.addEventListener('pointerdown', pointerDownListener);\n\n    // Allow the caller to tear down the helper, useful when the list unmounts\n    const destroy = () => {\n        options.container.removeEventListener(\n            'pointerdown',\n            pointerDownListener\n        );\n        if (activeDrag) {\n            finalizeDrag(true);\n        }\n\n        if (dropElevationTimeout !== undefined) {\n            clearTimeout(dropElevationTimeout);\n            dropElevationTimeout = undefined;\n        }\n\n        if (dropElevationTarget) {\n            dropElevationTarget.classList.remove(dropElevationClass);\n            dropElevationTarget = undefined;\n        }\n    };\n\n    return {\n        destroy,\n    };\n}\n"],"mappings":"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"}