{"version":3,"names":["DEFAULT_DRAGGING_CLASS","DEFAULT_CONTAINER_CLASS","DEFAULT_DROP_ELEVATION_CLASS","DEFAULT_DROP_ELEVATION_DURATION","DEFAULT_ORIENTATION","dragToReorder","options","container","Error","itemSelector","dragHandleSelector","onPreview","onFinalize","draggingClass","containerActiveClass","containerDraggingClass","dropElevationClass","dropElevationDuration","_a","orientation","_b","getItemId","item","dataset","reorderId","undefined","activeDrag","previousUserSelect","previousCursor","dropElevationTimeout","dropElevationTarget","getItemElements","querySelectorAll","pointerDownListener","event","pointerType","button","target","handle","closest","items","originalIndex","indexOf","stopPropagation","preventDefault","clearTimeout","classList","remove","pointerId","currentIndex","id","setPointerCapture","call","document","body","style","userSelect","cursor","add","onStart","index","addEventListener","pointerMoveListener","passive","pointerUpListener","pointerCancelListener","length","pointerPosition","clientY","clientX","targetIndex","element","rect","getBoundingClientRect","threshold","top","height","left","width","fromIndex","toIndex","finalizeDrag","cancelled","state","releasePointerCapture","removeEventListener","itemToReset","window","setTimeout","destroy"],"sources":["./src/util/drag-to-reorder.ts"],"sourcesContent":["/**\n * Detail payload emitted when a drag reordering gesture starts.\n * `index` represents the position of the item among the filtered reorderable nodes.\n */\nexport interface DragToReorderStartDetail {\n    index: number;\n    item: HTMLElement;\n    id?: string;\n}\n\n/**\n * Detail payload representing a preview move while the pointer is still held.\n * Consumers should update their temporary DOM state to mirror the visual reorder.\n */\nexport interface DragToReorderPreviewDetail {\n    fromIndex: number;\n    toIndex: number;\n    item: HTMLElement;\n    id?: string;\n}\n\n/**\n * Detail payload describing the final outcome of a drag interaction.\n * `cancelled` indicates whether the gesture ended normally or aborted mid-way.\n */\nexport interface DragToReorderFinalizeDetail {\n    fromIndex: number;\n    toIndex: number;\n    item: HTMLElement;\n    id?: string;\n    cancelled: boolean;\n}\n\n/**\n * Configuration for the drag-to-reorder helper.\n * `itemSelector` and `dragHandleSelector` should both resolve inside `container`.\n */\nexport interface DragToReorderOptions {\n    container: HTMLElement;\n    itemSelector: string;\n    dragHandleSelector: string;\n    draggingClass?: string;\n    /** Class toggled on the container while a drag is active. */\n    containerDraggingClass?: string;\n    /** Class applied briefly when an item is dropped to highlight the new position. */\n    dropElevationClass?: string;\n    /** Duration in milliseconds before removing the drop elevation class (defaults to 1000ms). */\n    dropElevationDuration?: number;\n    /** Axis used to calculate the new drop position. Defaults to `vertical`. */\n    orientation?: 'vertical' | 'horizontal';\n    getItemId?: (item: HTMLElement) => string | undefined;\n    onStart?: (detail: DragToReorderStartDetail) => void;\n    onPreview: (detail: DragToReorderPreviewDetail) => void;\n    onFinalize: (detail: DragToReorderFinalizeDetail) => void;\n}\n\nexport interface DragToReorderController {\n    destroy(): void;\n}\n\ninterface ActiveDragState {\n    pointerId: number;\n    handle: HTMLElement;\n    item: HTMLElement;\n    originalIndex: number;\n    currentIndex: number;\n    id?: string;\n}\n\nconst DEFAULT_DRAGGING_CLASS = 'is-being-dragged';\nconst DEFAULT_CONTAINER_CLASS = 'has-an-item-which-is-being-dragged';\nconst DEFAULT_DROP_ELEVATION_CLASS = 'is-elevated';\nconst DEFAULT_DROP_ELEVATION_DURATION = 1000;\nconst DEFAULT_ORIENTATION: Required<DragToReorderOptions>['orientation'] =\n    'vertical';\n\n/**\n * Drag to reorder utility\n *\n * Lightweight pointer-driven drag helper for list-like layouts.\n * Keeps responsibilities split: this utility handles pointer + DOM bookkeeping,\n * while the caller owns rendering state updates through the supplied callbacks.\n *\n * ## Usage notes\n * - This helper uses low-level `pointer*` events instead of the native HTML Drag & Drop API,\n *   which makes behavior consistent across mouse, touch, and stylus input; and avoids\n *   many of the quirks and limitations of the native API.\n * - The helper relies on CSS selectors to identify both the draggable items and the\n *   drag handles within them. This allows consumers to define complex item structures\n *   with specific drag handles (e.g. an icon button) without requiring extra markup\n *   or event listeners.\n * - By default items are treated as a vertical list (drop target is derived from\n *   the pointer's Y position). Set `orientation: 'horizontal'` to track X\n *   positions instead when working with horizontally arranged items.\n * - A CSS class (defaults to `is-being-dragged`) is applied to the active item. Consumers\n *   should style this class inside their component Shadow DOM (e.g. add elevation) to\n *   communicate movement. The container simultaneously receives `has-an-item-which-is-being-dragged`\n *   (override via `containerDraggingClass`) in case you want to highlight the entire drop zone.\n * - While dragging the item also gets `is-elevated` (override via `dropElevationClass`). The class\n *   remains for one second after drop to give styles time to gracefully transition back.\n * - The helper temporarily sets `document.body.style.userSelect` and `.cursor` to prevent\n *   text selection and enforce a grabbing cursor during the interaction. Components do not need\n *   to manage these resets themselves — they are restored automatically when the drag ends.\n * - Call `dragToReorder({ ... })` in `componentDidLoad` (or equivalent) and keep a reference to\n *   the returned controller so you can invoke `destroy()` when your component unmounts.\n * - Use the `onPreview` callback to mirror the current visual ordering (e.g. reorder rows in state)\n *   and `onFinalize` to persist the change or revert when `cancelled` is true.\n */\n\n/**\n * Enable drag-and-drop style reordering for list-like DOM structures.\n *\n * @param options configuration for drag behavior and callbacks\n */\nexport function dragToReorder(\n    options: DragToReorderOptions\n): DragToReorderController {\n    if (!options?.container) {\n        throw new Error(\n            'Error in `dragToReorder`: Required option `container` is missing.'\n        );\n    }\n\n    if (!options.itemSelector) {\n        throw new Error(\n            'Error in `dragToReorder`: Required option `itemSelector` is missing.'\n        );\n    }\n\n    if (!options.dragHandleSelector) {\n        throw new Error(\n            'Error in `dragToReorder`: Required option `dragHandleSelector` is missing.'\n        );\n    }\n\n    if (!options.onPreview) {\n        throw new Error(\n            'Error in `dragToReorder`: Required option `onPreview` is missing.'\n        );\n    }\n\n    if (!options.onFinalize) {\n        throw new Error(\n            'Error in `dragToReorder`: Required option `onFinalize` is missing.'\n        );\n    }\n\n    const draggingClass = options.draggingClass || DEFAULT_DRAGGING_CLASS;\n    const containerActiveClass =\n        options.containerDraggingClass || DEFAULT_CONTAINER_CLASS;\n    const dropElevationClass =\n        options.dropElevationClass || DEFAULT_DROP_ELEVATION_CLASS;\n    const dropElevationDuration =\n        options.dropElevationDuration ?? DEFAULT_DROP_ELEVATION_DURATION;\n    const orientation = options.orientation ?? DEFAULT_ORIENTATION;\n    const getItemId =\n        options.getItemId ||\n        ((item: HTMLElement) => item.dataset.reorderId || undefined);\n\n    let activeDrag: ActiveDragState | undefined;\n    let previousUserSelect: string | undefined;\n    let previousCursor: string | undefined;\n    let dropElevationTimeout: number | undefined;\n    let dropElevationTarget: HTMLElement | undefined;\n\n    const getItemElements = () => {\n        return [\n            ...options.container.querySelectorAll(options.itemSelector),\n        ] as HTMLElement[];\n    };\n\n    // Activate dragging only when pressing a recognized handle inside the container\n    const pointerDownListener = (event: PointerEvent) => {\n        if (\n            event.pointerType === 'mouse' &&\n            'button' in event &&\n            event.button !== 0\n        ) {\n            return;\n        }\n\n        const target = event.target as HTMLElement;\n        if (!target) {\n            return;\n        }\n\n        const handle = target.closest(\n            options.dragHandleSelector\n        ) as HTMLElement;\n        if (!handle) {\n            return;\n        }\n\n        const item = handle.closest(options.itemSelector) as HTMLElement;\n        if (!item) {\n            return;\n        }\n\n        const items = getItemElements();\n        const originalIndex = items.indexOf(item);\n        if (originalIndex === -1) {\n            return;\n        }\n\n        event.stopPropagation();\n        event.preventDefault();\n\n        if (dropElevationTimeout !== undefined) {\n            clearTimeout(dropElevationTimeout);\n            dropElevationTimeout = undefined;\n        }\n        if (dropElevationTarget) {\n            dropElevationTarget.classList.remove(dropElevationClass);\n            dropElevationTarget = undefined;\n        }\n\n        activeDrag = {\n            pointerId: event.pointerId,\n            handle,\n            item,\n            originalIndex,\n            currentIndex: originalIndex,\n            id: getItemId(item),\n        };\n\n        handle.setPointerCapture?.(event.pointerId);\n        previousUserSelect = document.body.style.userSelect;\n        document.body.style.userSelect = 'none';\n        previousCursor = document.body.style.cursor;\n        document.body.style.cursor = 'grabbing';\n        item.classList.add(dropElevationClass, draggingClass);\n        options.container.classList.add(containerActiveClass);\n\n        options.onStart?.({\n            index: originalIndex,\n            item,\n            id: activeDrag.id,\n        });\n\n        // Listen on the document to keep tracking even when the pointer leaves the list\n        document.addEventListener('pointermove', pointerMoveListener, {\n            passive: false,\n        });\n        document.addEventListener('pointerup', pointerUpListener);\n        document.addEventListener('pointercancel', pointerCancelListener);\n    };\n\n    // Calculate which item the pointer hovers over and inform the consumer\n    const pointerMoveListener = (event: PointerEvent) => {\n        if (!activeDrag) {\n            return;\n        }\n\n        event.preventDefault();\n\n        const items = getItemElements();\n        if (items.length === 0) {\n            return;\n        }\n\n        const pointerPosition =\n            orientation === 'vertical' ? event.clientY : event.clientX;\n        let targetIndex = items.length - 1;\n\n        let index = 0;\n        for (const element of items) {\n            const rect = element.getBoundingClientRect();\n            const threshold =\n                orientation === 'vertical'\n                    ? rect.top + rect.height / 2\n                    : rect.left + rect.width / 2;\n            if (pointerPosition < threshold) {\n                targetIndex = index;\n                break;\n            }\n            index += 1;\n        }\n\n        if (targetIndex < 0) {\n            targetIndex = 0;\n        }\n\n        if (targetIndex === activeDrag.currentIndex) {\n            return;\n        }\n\n        options.onPreview({\n            fromIndex: activeDrag.currentIndex,\n            toIndex: targetIndex,\n            item: activeDrag.item,\n            id: activeDrag.id,\n        });\n\n        activeDrag.currentIndex = targetIndex;\n    };\n\n    // Clean up listeners, restore styles, and let the consumer decide how to persist\n    const finalizeDrag = (cancelled: boolean) => {\n        if (!activeDrag) {\n            return;\n        }\n\n        const state = activeDrag;\n        activeDrag = undefined;\n\n        state.handle.releasePointerCapture?.(state.pointerId);\n        state.item.classList.remove(draggingClass);\n        options.container.classList.remove(containerActiveClass);\n\n        document.body.style.userSelect = previousUserSelect ?? '';\n        previousUserSelect = undefined;\n        document.body.style.cursor = previousCursor ?? '';\n        previousCursor = undefined;\n\n        document.removeEventListener('pointermove', pointerMoveListener);\n        document.removeEventListener('pointerup', pointerUpListener);\n        document.removeEventListener('pointercancel', pointerCancelListener);\n\n        options.onFinalize({\n            fromIndex: state.originalIndex,\n            toIndex: state.currentIndex,\n            item: state.item,\n            id: state.id,\n            cancelled,\n        });\n\n        if (dropElevationTimeout !== undefined) {\n            clearTimeout(dropElevationTimeout);\n            dropElevationTimeout = undefined;\n        }\n\n        if (cancelled || dropElevationDuration <= 0) {\n            state.item.classList.remove(dropElevationClass);\n            if (dropElevationTarget === state.item) {\n                dropElevationTarget = undefined;\n            }\n            return;\n        }\n\n        dropElevationTarget = state.item;\n        const itemToReset = state.item;\n        dropElevationTimeout = window.setTimeout(() => {\n            itemToReset.classList.remove(dropElevationClass);\n            if (dropElevationTarget === itemToReset) {\n                dropElevationTarget = undefined;\n            }\n            dropElevationTimeout = undefined;\n        }, dropElevationDuration);\n    };\n\n    // Pointer released normally – treat as a completed reorder\n    const pointerUpListener = (event: PointerEvent) => {\n        if (!activeDrag || event.pointerId !== activeDrag.pointerId) {\n            return;\n        }\n\n        event.preventDefault();\n        finalizeDrag(false);\n    };\n\n    // Browser or OS cancelled the pointer sequence – revert to the snapshot state\n    const pointerCancelListener = (event: PointerEvent) => {\n        if (!activeDrag || event.pointerId !== activeDrag.pointerId) {\n            return;\n        }\n\n        finalizeDrag(true);\n    };\n\n    options.container.addEventListener('pointerdown', pointerDownListener);\n\n    // Allow the caller to tear down the helper, useful when the list unmounts\n    const destroy = () => {\n        options.container.removeEventListener(\n            'pointerdown',\n            pointerDownListener\n        );\n        if (activeDrag) {\n            finalizeDrag(true);\n        }\n\n        if (dropElevationTimeout !== undefined) {\n            clearTimeout(dropElevationTimeout);\n            dropElevationTimeout = undefined;\n        }\n\n        if (dropElevationTarget) {\n            dropElevationTarget.classList.remove(dropElevationClass);\n            dropElevationTarget = undefined;\n        }\n    };\n\n    return {\n        destroy,\n    };\n}\n"],"mappings":"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"}