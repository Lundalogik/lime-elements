import { union, isEqual, isPlainObject } from 'lodash-es';
import { retrieveSchema } from 'react-jsonschema-form/lib/utils';

/**
 * Given two objects, get a list of keys for each value that is different between
 * the two objects. Compares using deep comparison
 *
 * @param {object} a first object
 * @param {object} b second object
 *
 * @returns {any[]} the array of keys
 */
const getDifferentKeys = (a: object = {}, b: object = {}): any[] => {
    const keys = union(Object.keys(a), Object.keys(b));

    return keys.filter((key) => {
        return !isEqual(b[key], a[key]);
    });
};

/**
 * Given the data for the current SchemaField, detect if the changed data
 * has any other fields that are dependent on it, and if so reset those dependent fields
 * (by deleting them from the data so that their defaults are populated on the next rerender).
 * Call onChange with the updated data
 *
 * @param {any} oldData The previous data before a data change event
 * @param {any} newData The form data from a change event
 * @param {object} schema The schema associated with the data
 * @param {object} definitions The root schema definitions
 *
 * @returns {void}
 */
export const resetDependentFields = (oldData, newData, schema, definitions) => {
    // Dependencies only exist on object types
    if (!isPlainObject(newData)) {
        return newData;
    }

    // Get the schema generated by the current data
    const currentSchema = retrieveSchema(schema, definitions, oldData);

    // Get the new schema that is calculated for the new data
    const newSchema = retrieveSchema(schema, definitions, newData);

    // Get property keys whose schema changed due to the new data.
    // These properties that have changed are the properties that are dependent on
    // data that has changed in the current onChange event
    const dependentPropertyKeys = getDifferentKeys(
        newSchema.properties,
        currentSchema.properties
    );

    // Reset keys that are dependent on the changed value.
    // The values for these dependent fields will be repopulated
    // with defaults during the next render
    for (const dependentPropertyKey of dependentPropertyKeys) {
        delete newData[dependentPropertyKey];
    }

    return newData;
};
